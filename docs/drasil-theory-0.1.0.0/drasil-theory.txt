-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Theory SubPackage
--   
--   Please see the README on GitHub at
--   <a>https://github.com/JacquesCarette/Drasil#readme</a>
@package drasil-theory
@version 0.1.0.0


-- | Re-export many things to simplify external use.
module Theory.Drasil

-- | Members of this class may have inputs.
class HasInputs c

-- | Provides a <tt>Lens</tt> that holds a <a>DefinedQuantityDict</a> and
--   maybe constraints.
inputs :: HasInputs c => Lens' c [(DefinedQuantityDict, Maybe (RealInterval Expr Expr))]

-- | Members of this class may have outputs.
class HasOutput c

-- | Provides a <a>Getter</a> that holds a <a>DefinedQuantityDict</a> for
--   output.
output :: HasOutput c => Getter c DefinedQuantityDict

-- | Provides a <a>Getter</a> that holds constraints on the output.
out_constraints :: HasOutput c => Getter c [RealInterval Expr Expr]

-- | <a>ConstraintSet</a>s are sets of invariants that always hold for
--   underlying domains.
data ConstraintSet e

-- | Smart constructor for building ConstraintSets
mkConstraintSet :: ConceptChunk -> NonEmpty e -> ConstraintSet e

-- | Derivations are an ordered list of sentences and expressions. They are
--   rendered in order as paragraphs and equation blocks to display the
--   derivation.
data Derivation
Derivation :: Sentence -> [Sentence] -> Derivation

-- | Smart constructor for creating a <a>Derivation</a>.
mkDeriv :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but prepends "Detailed derivation of" to
--   the header.
mkDerivName :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but without a header <a>Sentence</a>.
mkDerivNoHeader :: [Sentence] -> Derivation

-- | A class that might have a <a>Derivation</a>.
class MayHaveDerivation c

-- | Provides a <tt>Lens</tt> to a possible derivation.
derivations :: MayHaveDerivation c => Lens' c (Maybe Derivation)

-- | A data definition is a <a>QDefinition</a> that may have additional
--   notes: the scope, any references (as <a>DecRef</a>s), maybe a
--   derivation, a label (<a>ShortName</a>), a reference address, and other
--   notes (<a>Sentence</a>s).
data DataDefinition

-- | Smart constructor for data definitions.
ddE :: SimpleQDef -> [DecRef] -> Maybe Derivation -> String -> [Sentence] -> DataDefinition

-- | Smart constructor for data definitions with no references.
ddENoRefs :: SimpleQDef -> Maybe Derivation -> String -> [Sentence] -> DataDefinition

-- | Smart constructor for data definitions.
ddME :: ModelQDef -> [DecRef] -> Maybe Derivation -> String -> [Sentence] -> DataDefinition

-- | Smart constructor for data definitions with no references.
ddMENoRefs :: ModelQDef -> Maybe Derivation -> String -> [Sentence] -> DataDefinition

-- | Extracts the 'QDefinition e' from a <a>DataDefinition</a>.
qdFromDD :: DataDefinition -> Either SimpleQDef ModelQDef
qdEFromDD :: DataDefinition -> Maybe SimpleQDef

-- | A general definition is a <a>ModelKind</a> that may have units, a
--   derivation, references (as <a>DecRef</a>s), a shortname, a reference
--   address, and notes.
data GenDefn

-- | Smart constructor for general definitions.
gd :: IsUnit u => ModelKind ModelExpr -> Maybe u -> Maybe Derivation -> [DecRef] -> String -> [Sentence] -> GenDefn

-- | Smart constructor for general definitions with no references.
gdNoRefs :: IsUnit u => ModelKind ModelExpr -> Maybe u -> Maybe Derivation -> String -> [Sentence] -> GenDefn

-- | Grab all related <tt>QDefinitions</tt> from a list of general
--   definitions.
getEqModQdsFromGd :: [GenDefn] -> [ModelQDef]

-- | <a>MultiDefn</a>s are QDefinition factories, used for showing one or
--   more ways we can define a QDefinition.
data MultiDefn e

-- | <a>DefiningExpr</a> are the data that make up a (quantity) definition,
--   namely the description, the defining (rhs) expression and the context
--   domain(s). These are meant to be <tt>alternate</tt> but equivalent
--   definitions for a single concept.
data DefiningExpr e

-- | Smart constructor for MultiDefns, does nothing special at the moment.
--   First argument is the <a>Space</a> to become a <a>UID</a>.
mkMultiDefn :: String -> DefinedQuantityDict -> Sentence -> NonEmpty (DefiningExpr e) -> MultiDefn e

-- | Smart constructor for <a>MultiDefn</a>s defining <a>UID</a>s using
--   that of the <a>DefinedQuantityDict</a>.
mkMultiDefnForQuant :: DefinedQuantityDict -> Sentence -> NonEmpty (DefiningExpr e) -> MultiDefn e

-- | Smart constructor for <a>DefiningExpr</a>s.
mkDefiningExpr :: String -> [UID] -> Sentence -> e -> DefiningExpr e

-- | Convert <a>MultiDefn</a>s into <a>QDefinition</a>s via a specific
--   <a>DefiningExpr</a>.
multiDefnGenQD :: MultiDefn e -> DefiningExpr e -> QDefinition e

-- | Convert <a>MultiDefn</a>s into <a>QDefinition</a>s via a specific
--   <a>DefiningExpr</a> (by <a>UID</a>).
multiDefnGenQDByUID :: MultiDefn e -> UID -> QDefinition e

-- | <a>ModelKinds</a> carrier, used to carry commonly overwritten
--   information from the IMs<i>TMs</i>GDs.
data ModelKind e

-- | Smart constructor for <a>NewDEModel</a>s
newDEModel :: String -> NP -> DifferentialModel -> ModelKind e

-- | Smart constructor for <a>DEModel</a>s
deModel :: String -> NP -> RelationConcept -> ModelKind e

-- | Smart constructor for <a>EquationalConstraints</a>
equationalConstraints :: String -> NP -> ConstraintSet e -> ModelKind e

-- | Smart constructor for <a>EquationalModel</a>s
equationalModel :: String -> NP -> QDefinition e -> ModelKind e

-- | Smart constructor for <a>EquationalRealm</a>s
equationalRealm :: String -> NP -> MultiDefn e -> ModelKind e

-- | Smart constructor for <a>OthModel</a>s
othModel :: String -> NP -> RelationConcept -> ModelKind Expr

-- | Smart constructor for <a>NewDEModel</a>s, deriving UID+Term from the
--   <a>DifferentialModel</a>
newDEModel' :: DifferentialModel -> ModelKind e

-- | Smart constructor for <a>DEModel</a>s, deriving UID+Term from the
--   <a>RelationConcept</a>
deModel' :: RelationConcept -> ModelKind e

-- | Smart constructor for <a>EquationalConstraints</a>, deriving UID+Term
--   from the <a>ConstraintSet</a>
equationalConstraints' :: ConstraintSet e -> ModelKind e

-- | Smart constructor for <a>EquationalModel</a>s, deriving UID+Term from
--   the <a>QDefinition</a>
equationalModel' :: QDefinition e -> ModelKind e

-- | Smart constructor for <a>EquationalRealm</a>s, deriving UID+Term from
--   the <a>MultiDefn</a>
equationalRealm' :: MultiDefn e -> ModelKind e

-- | Smart constructor for <a>OthModel</a>s, deriving UID+Term from the
--   <a>RelationConcept</a>
othModel' :: RelationConcept -> ModelKind e

-- | Smart constructor for <a>EquationalModel</a>s, deriving Term from the
--   <a>QDefinition</a>
equationalModelU :: String -> QDefinition e -> ModelKind e

-- | Smart constructor for <a>EquationalModel</a>s, deriving UID from the
--   <a>QDefinition</a>
equationalModelN :: NP -> QDefinition e -> ModelKind e

-- | Smart constructor for <a>EquationalRealm</a>s
equationalRealmU :: String -> MultiDefn e -> ModelKind e

-- | Smart constructor for <a>EquationalRealm</a>s, deriving UID from the
--   <a>MultiDefn</a>
equationalRealmN :: NP -> MultiDefn e -> ModelKind e

-- | An instance model is a ModelKind that may have specific inputs,
--   outputs, and output constraints. It also has attributes like
--   references, derivation, labels (<a>ShortName</a>), reference address,
--   and notes.
data InstanceModel

-- | Smart constructor for instance models with everything defined.
im :: ModelKind Expr -> Inputs -> Output -> OutputConstraints -> [DecRef] -> Maybe Derivation -> String -> [Sentence] -> InstanceModel

-- | Smart constructor for instance models with a custom term, and no
--   derivation.
imNoDeriv :: ModelKind Expr -> Inputs -> Output -> OutputConstraints -> [DecRef] -> String -> [Sentence] -> InstanceModel

-- | Smart constructor for instance models with a custom term, and no
--   references.
imNoRefs :: ModelKind Expr -> Inputs -> Output -> OutputConstraints -> Maybe Derivation -> String -> [Sentence] -> InstanceModel

-- | Smart constructor for instance models with a custom term, and no
--   derivations or references.
imNoDerivNoRefs :: ModelKind Expr -> Inputs -> Output -> OutputConstraints -> String -> [Sentence] -> InstanceModel

-- | For building a quantity with no constraint.
qwUC :: (Quantity q, MayHaveUnit q, Concept q) => q -> Input

-- | For building a quantity with a constraint.
qwC :: (Quantity q, MayHaveUnit q, Concept q) => q -> RealInterval Expr Expr -> Input

-- | Grab all related <a>QDefinition</a>s from a list of instance models.
getEqModQdsFromIm :: [InstanceModel] -> [SimpleQDef]

-- | Theories are the basis for building models with context, spaces,
--   quantities, operations, invariants, etc.
class Theory t
valid_context :: Theory t => Lens' t [TheoryModel]
spaces :: Theory t => Lens' t [SpaceDefn]
quantities :: Theory t => Lens' t [DefinedQuantityDict]
operations :: Theory t => Lens' t [ConceptChunk]
defined_quant :: Theory t => Lens' t [ModelQDef]
invariants :: Theory t => Lens' t [ModelExpr]
defined_fun :: Theory t => Lens' t [ModelQDef]

-- | A TheoryModel is a collection of:
--   
--   <ul>
--   <li>tUid - a UID,</li>
--   <li>con - a ConceptChunk,</li>
--   <li>vctx - definition context (<a>TheoryModel</a>s),</li>
--   <li>spc - type definitions (<a>SpaceDefn</a>s),</li>
--   <li>quan - quantities (<a>DefinedQuantityDict</a>s),</li>
--   <li>ops - operations (<a>ConceptChunk</a>s),</li>
--   <li>defq - definitions (<a>QDefinition</a>s),</li>
--   <li>invs - invariants (<a>ModelExpr</a>s),</li>
--   <li>dfun - defined functions (<a>QDefinition</a>s),</li>
--   <li>ref - accompanying references (<a>DecRef</a>s),</li>
--   <li>lb - a label (<a>SpaceDefn</a>),</li>
--   <li>ra - reference address (<a>SpaceDefn</a>),</li>
--   <li>notes - additional notes (<a>Sentence</a>s).</li>
--   </ul>
--   
--   Right now, neither the definition context (vctx) nor the spaces (spc)
--   are ever defined.
data TheoryModel

-- | Constructor for theory models. Must have a source. Uses the shortname
--   of the reference address.
tm :: (Quantity q, MayHaveUnit q, Concept q, Concept c) => ModelKind ModelExpr -> [q] -> [c] -> [ModelQDef] -> [ModelExpr] -> [ModelQDef] -> [DecRef] -> String -> [Sentence] -> TheoryModel

-- | Constructor for theory models. Uses the shortname of the reference
--   address.
tmNoRefs :: (Quantity q, MayHaveUnit q, Concept q, Concept c) => ModelKind ModelExpr -> [q] -> [c] -> [ModelQDef] -> [ModelExpr] -> [ModelQDef] -> String -> [Sentence] -> TheoryModel

-- | Describe the structural content of a system of linear ODEs with six
--   necessary fields
data DifferentialModel
SystemOfLinearODEs :: UnitalChunk -> ConstrConcept -> [[Expr]] -> [Unknown] -> [Expr] -> ConceptChunk -> DifferentialModel

-- | independent variable, often time
[_indepVar] :: DifferentialModel -> UnitalChunk

-- | dependent variable
[_depVar] :: DifferentialModel -> ConstrConcept

-- | coefficients matrix
[_coefficients] :: DifferentialModel -> [[Expr]]

-- | unknowns column vector (orders)
[_unknowns] :: DifferentialModel -> [Unknown]

-- | constant column vector
[_dmConstants] :: DifferentialModel -> [Expr]

-- | meta data
[_dmconc] :: DifferentialModel -> ConceptChunk

-- | Acceptable format for ODE solvers, represent the structure of X' = AX
--   + B X' is a column vector of first-order unknowns
data ODESolverFormat
X' :: [[Expr]] -> [Integer] -> [Expr] -> ODESolverFormat

-- | represent A, the coefficient matrix with identity matrix
[coeffVects] :: ODESolverFormat -> [[Expr]]

-- | combing with the dependent variable. it represents X, the unknown
--   column vector after reduce the highest order.
[unknownVect] :: ODESolverFormat -> [Integer]

-- | represent B, the constant column vector with identity matrix
[constantVect] :: ODESolverFormat -> [Expr]

-- | Information for solving an initial value problem
data InitialValueProblem
IVP :: Expr -> Expr -> [Expr] -> InitialValueProblem

-- | initial time
[initTime] :: InitialValueProblem -> Expr

-- | end time
[finalTime] :: InitialValueProblem -> Expr

-- | initial values
[initValues] :: InitialValueProblem -> [Expr]

-- | Operation connect the dependent variable and the order
($^^) :: ConstrConcept -> Integer -> Unknown

-- | Operation represent multiple
($**) :: Expr -> Unknown -> Term

-- | Operation represent plus (collection Terms)
($++) :: [Term] -> Term -> LHS

-- | Construct an ODESolverFormat for solving the ODE.
makeAODESolverFormat :: DifferentialModel -> ODESolverFormat
makeAIVP :: Expr -> Expr -> [Expr] -> InitialValueProblem

-- | Create a <a>DifferentialModel</a> by giving a independent variable, a
--   dependent variable a canonical matrix form, and conceptChuck.
makeASystemDE :: UnitalChunk -> ConstrConcept -> [[Expr]] -> [Unknown] -> [Expr] -> String -> NP -> Sentence -> DifferentialModel

-- | Create a <a>DifferentialModel</a> by the input language
makeASingleDE :: UnitalChunk -> ConstrConcept -> LHS -> Expr -> String -> NP -> Sentence -> DifferentialModel

-- | Form well-formatted ODE equations which the ODE solvers can solve.
formEquations :: [[Expr]] -> [Unknown] -> [Expr] -> ConstrConcept -> [Expr]

module Drasil.Database.SearchTools
data TermAbbr
TermAbbr :: NP -> Maybe String -> TermAbbr
[longForm] :: TermAbbr -> NP
[shortForm] :: TermAbbr -> Maybe String

-- | Search for a chunk that is an instance of <a>Idea</a> and return its
--   "term" and abbreviation, erroring out if it doesn't exist.
termResolve :: (NP -> Maybe String -> c) -> ChunkDB -> UID -> c

-- | Find a chunk's "term" and abbreviation, erroring out if it doesn't
--   exist.
termResolve' :: ChunkDB -> UID -> TermAbbr
data DomDefn
DomDefn :: [UID] -> Sentence -> DomDefn
[domain] :: DomDefn -> [UID]
[definition] :: DomDefn -> Sentence

-- | Looks up a <a>UID</a> in all tables with concepts from the
--   <a>ChunkDB</a>. If nothing is found, an error is thrown.
defResolve :: ([UID] -> Sentence -> c) -> ChunkDB -> UID -> c
defResolve' :: ChunkDB -> UID -> DomDefn
findAllConcInsts :: ChunkDB -> [ConceptInstance]
findAllDefinedQuantities :: ChunkDB -> [DefinedQuantityDict]
findAllCitations :: ChunkDB -> [Citation]
findAllLabelledContent :: ChunkDB -> [LabelledContent]
