<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Data/ByteString/Builder/RealFloat/TableGenerator.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE ExplicitForAll #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE MultiParamTypeClasses #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE ScopedTypeVariables #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE BangPatterns, MagicHash, UnboxedTuples #-}</span>
<a name="line-5"></a><span class='hs-comment'>-- |</span>
<a name="line-6"></a><span class='hs-comment'>-- Module      : Data.ByteString.Builder.RealFloat.TableGenerator</span>
<a name="line-7"></a><span class='hs-comment'>-- Copyright   : (c) Lawrence Wu 2021</span>
<a name="line-8"></a><span class='hs-comment'>-- License     : BSD-style</span>
<a name="line-9"></a><span class='hs-comment'>-- Maintainer  : lawrencejwu@gmail.com</span>
<a name="line-10"></a><span class='hs-comment'>--</span>
<a name="line-11"></a><span class='hs-comment'>-- Constants and overview for compile-time table generation for Ryu internals</span>
<a name="line-12"></a><span class='hs-comment'>--</span>
<a name="line-13"></a><span class='hs-comment'>-- This module uses Haskell's arbitrary-precision `Integer` types to compute</span>
<a name="line-14"></a><span class='hs-comment'>-- the necessary multipliers for efficient conversion to a decimal power base.</span>
<a name="line-15"></a><span class='hs-comment'>--</span>
<a name="line-16"></a><span class='hs-comment'>-- It also exposes constants relevant to the 32- and 64-bit tables (e.g maximum</span>
<a name="line-17"></a><span class='hs-comment'>-- number of bits required to store the table values).</span>
<a name="line-18"></a>
<a name="line-19"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Data.ByteString.Builder.RealFloat.TableGenerator</span>
<a name="line-20"></a>  <span class='hs-layout'>(</span> <span class='hs-varid'>float_pow5_inv_bitcount</span>
<a name="line-21"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>float_pow5_bitcount</span>
<a name="line-22"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>double_pow5_bitcount</span>
<a name="line-23"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>double_pow5_inv_bitcount</span>
<a name="line-24"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>float_max_split</span>
<a name="line-25"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>float_max_inv_split</span>
<a name="line-26"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>double_max_split</span>
<a name="line-27"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>double_max_inv_split</span>
<a name="line-28"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-29"></a>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Float</span> <span class='hs-layout'>(</span><span class='hs-varid'>int2Double</span><span class='hs-layout'>)</span>
<a name="line-31"></a>
<a name="line-32"></a>
<a name="line-33"></a><span class='hs-comment'>-- The basic floating point conversion algorithm is as such:</span>
<a name="line-34"></a><span class='hs-comment'>--</span>
<a name="line-35"></a><span class='hs-comment'>-- Given floating point</span>
<a name="line-36"></a><span class='hs-comment'>--</span>
<a name="line-37"></a><span class='hs-comment'>--   f = (-1)^s * m_f * 2^e_f</span>
<a name="line-38"></a><span class='hs-comment'>--</span>
<a name="line-39"></a><span class='hs-comment'>-- which is IEEE encoded by `[s] [.. e ..] [.. m ..]`. `s` is the sign bit, `e`</span>
<a name="line-40"></a><span class='hs-comment'>-- is the biased exponent, and `m` is the mantissa, let</span>
<a name="line-41"></a><span class='hs-comment'>--</span>
<a name="line-42"></a><span class='hs-comment'>--       | e /= 0            | e == 0</span>
<a name="line-43"></a><span class='hs-comment'>--  -----+-------------------+-----------</span>
<a name="line-44"></a><span class='hs-comment'>--   m_f | 2^len(m) + m      | m</span>
<a name="line-45"></a><span class='hs-comment'>--   e_f | e - bias - len(m) | 1 - bias - len(m)</span>
<a name="line-46"></a><span class='hs-comment'>--</span>
<a name="line-47"></a><span class='hs-comment'>-- we compute the halfway points to the next smaller (`f-`) and larger (`f+`)</span>
<a name="line-48"></a><span class='hs-comment'>-- floating point numbers as</span>
<a name="line-49"></a><span class='hs-comment'>--</span>
<a name="line-50"></a><span class='hs-comment'>--  lower halfway point u * 2^e2, u = 4 * m_f - (if m == 0 then 1 else 2)</span>
<a name="line-51"></a><span class='hs-comment'>--                      v * 2^e2, v = 4 * m_f</span>
<a name="line-52"></a><span class='hs-comment'>--  upper halfway point w * 2^e2, u = 4 * m_f + 2</span>
<a name="line-53"></a><span class='hs-comment'>--  where e2 = ef - 2 (so u, v, w are integers)</span>
<a name="line-54"></a><span class='hs-comment'>--</span>
<a name="line-55"></a><span class='hs-comment'>--</span>
<a name="line-56"></a><span class='hs-comment'>-- Then we compute (a, b, c) * 10^e10 = (u, v, w) * 2^e2 which is split into</span>
<a name="line-57"></a><span class='hs-comment'>-- the case of</span>
<a name="line-58"></a><span class='hs-comment'>--</span>
<a name="line-59"></a><span class='hs-comment'>--   e2 &gt;= 0   ==&gt;    e10 = 0 , (a, b, c) = (u, v, w) * 2^e2</span>
<a name="line-60"></a><span class='hs-comment'>--   e2 &lt;  0   ==&gt;    e10 = e2, (a, b, c) = (u, v, w) * 5^-e2</span>
<a name="line-61"></a><span class='hs-comment'>--</span>
<a name="line-62"></a><span class='hs-comment'>-- And finally we find the shortest representation from integers d0 and e0 such</span>
<a name="line-63"></a><span class='hs-comment'>-- that</span>
<a name="line-64"></a><span class='hs-comment'>--</span>
<a name="line-65"></a><span class='hs-comment'>--  a * 10^e10 &lt; d0 * 10^(e0+e10) &lt; c * 10^e10</span>
<a name="line-66"></a><span class='hs-comment'>--</span>
<a name="line-67"></a><span class='hs-comment'>-- such that e0 is maximal (we allow equality to smaller or larger halfway</span>
<a name="line-68"></a><span class='hs-comment'>-- point depending on rounding mode). This is found through iteratively</span>
<a name="line-69"></a><span class='hs-comment'>-- dividing by 10 while a/10^j &lt; c/10^j and doing some bookkeeping around</span>
<a name="line-70"></a><span class='hs-comment'>-- zeros.</span>
<a name="line-71"></a><span class='hs-comment'>--</span>
<a name="line-72"></a><span class='hs-comment'>--</span>
<a name="line-73"></a><span class='hs-comment'>--</span>
<a name="line-74"></a><span class='hs-comment'>--</span>
<a name="line-75"></a><span class='hs-comment'>-- The ryu algorithm removes the requirement for arbitrary precision arithmetic</span>
<a name="line-76"></a><span class='hs-comment'>-- and improves the runtime significantly by skipping most of the iterative</span>
<a name="line-77"></a><span class='hs-comment'>-- division by carefully selecting a point where certain invariants hold and</span>
<a name="line-78"></a><span class='hs-comment'>-- precomputing a few tables.</span>
<a name="line-79"></a><span class='hs-comment'>--</span>
<a name="line-80"></a><span class='hs-comment'>-- Specifically, define `q` such that the correspondings values of a/10^q &lt;</span>
<a name="line-81"></a><span class='hs-comment'>-- c/10^q - 1. We can prove (not shown) that</span>
<a name="line-82"></a><span class='hs-comment'>--</span>
<a name="line-83"></a><span class='hs-comment'>--    if e2 &gt;= 0, q = e2 * log_10(2)</span>
<a name="line-84"></a><span class='hs-comment'>--    if e2 &lt;  0, q = -e2 * log_10(5)</span>
<a name="line-85"></a><span class='hs-comment'>--</span>
<a name="line-86"></a><span class='hs-comment'>-- Then we can compute (a, b, c) / 10^q. Starting from (u, v, w) we have</span>
<a name="line-87"></a><span class='hs-comment'>--</span>
<a name="line-88"></a><span class='hs-comment'>--      (a, b, c) / 10^q                  (a, b, c) / 10^q</span>
<a name="line-89"></a><span class='hs-comment'>--    = (u, v, w) * 2^e2 / 10^q    OR   = (u, v, w) * 5^-e2 / 10^q</span>
<a name="line-90"></a><span class='hs-comment'>--</span>
<a name="line-91"></a><span class='hs-comment'>-- And since q &lt; e2,</span>
<a name="line-92"></a><span class='hs-comment'>--</span>
<a name="line-93"></a><span class='hs-comment'>--    = (u, v, w) * 2^e2-q / 5^q   OR   = (u, v, w) * 5^-e2-q / 2^q</span>
<a name="line-94"></a><span class='hs-comment'>--</span>
<a name="line-95"></a><span class='hs-comment'>-- While (u, v, w) are n-bit numbers, 5^q and whatnot are significantly larger,</span>
<a name="line-96"></a><span class='hs-comment'>-- but we only need the top-most n bits of the result so we can choose `k` that</span>
<a name="line-97"></a><span class='hs-comment'>-- reduce the number of bits required to ~2n. We then multiply by either</span>
<a name="line-98"></a><span class='hs-comment'>--</span>
<a name="line-99"></a><span class='hs-comment'>--    2^k / 5^q                    OR   5^-e2-q / 2^k</span>
<a name="line-100"></a><span class='hs-comment'>--</span>
<a name="line-101"></a><span class='hs-comment'>-- The required `k` is roughly linear in the exponent (we need more of the</span>
<a name="line-102"></a><span class='hs-comment'>-- multiplication to be precise) but the number of bits to store the</span>
<a name="line-103"></a><span class='hs-comment'>-- multiplicands above stays fixed.</span>
<a name="line-104"></a><span class='hs-comment'>--</span>
<a name="line-105"></a><span class='hs-comment'>-- Since the number of bits needed is relatively small for IEEE 32- and 64-bit</span>
<a name="line-106"></a><span class='hs-comment'>-- floating types, we can compute appropriate values for `k` for the</span>
<a name="line-107"></a><span class='hs-comment'>-- floating-point-type-specific bounds instead of each e2.</span>
<a name="line-108"></a><span class='hs-comment'>--</span>
<a name="line-109"></a><span class='hs-comment'>-- Finally, we need to do some final manual iterations potentially to do a</span>
<a name="line-110"></a><span class='hs-comment'>-- final fixup of the skipped state</span>
<a name="line-111"></a>
<a name="line-112"></a>
<a name="line-113"></a><a name="float_pow5_inv_bitcount"></a><span class='hs-comment'>-- | Bound for bits of @2^k / 5^q@ for floats</span>
<a name="line-114"></a><span class='hs-definition'>float_pow5_inv_bitcount</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<a name="line-115"></a><span class='hs-definition'>float_pow5_inv_bitcount</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>59</span>
<a name="line-116"></a>
<a name="line-117"></a><a name="float_pow5_bitcount"></a><span class='hs-comment'>-- | Bound for bits of @5^-e2-q / 2^k@ for floats</span>
<a name="line-118"></a><span class='hs-definition'>float_pow5_bitcount</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<a name="line-119"></a><span class='hs-definition'>float_pow5_bitcount</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>61</span>
<a name="line-120"></a>
<a name="line-121"></a><a name="double_pow5_bitcount"></a><span class='hs-comment'>-- | Bound for bits of @5^-e2-q / 2^k@ for doubles</span>
<a name="line-122"></a><span class='hs-definition'>double_pow5_bitcount</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<a name="line-123"></a><span class='hs-definition'>double_pow5_bitcount</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>125</span>
<a name="line-124"></a>
<a name="line-125"></a><a name="double_pow5_inv_bitcount"></a><span class='hs-comment'>-- | Bound for bits of @2^k / 5^q@ for doubles</span>
<a name="line-126"></a><span class='hs-definition'>double_pow5_inv_bitcount</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<a name="line-127"></a><span class='hs-definition'>double_pow5_inv_bitcount</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>125</span>
<a name="line-128"></a>
<a name="line-129"></a><span class='hs-comment'>-- NB: these tables are encoded directly into the source code in F2S and D2S</span>
<a name="line-130"></a><span class='hs-comment'>--</span>
<a name="line-131"></a><span class='hs-comment'>-- -- | Number of bits in a positive integer</span>
<a name="line-132"></a><span class='hs-comment'>-- blen :: Integer -&gt; Int</span>
<a name="line-133"></a><span class='hs-comment'>-- blen 0 = 0</span>
<a name="line-134"></a><span class='hs-comment'>-- blen 1 = 1</span>
<a name="line-135"></a><span class='hs-comment'>-- blen n = 1 + blen (n `quot` 2)</span>
<a name="line-136"></a>
<a name="line-137"></a><span class='hs-comment'>-- -- | Used for table generation of 2^k / 5^q + 1</span>
<a name="line-138"></a><span class='hs-comment'>-- finv :: Int -&gt; Int -&gt; Integer</span>
<a name="line-139"></a><span class='hs-comment'>-- finv bitcount i =</span>
<a name="line-140"></a><span class='hs-comment'>--   let p = 5^i</span>
<a name="line-141"></a><span class='hs-comment'>--    in (1 `shiftL` (blen p - 1 + bitcount)) `div` p + 1</span>
<a name="line-142"></a>
<a name="line-143"></a><span class='hs-comment'>-- -- | Used for table generation of 5^-e2-q / 2^k</span>
<a name="line-144"></a><span class='hs-comment'>-- fnorm :: Int -&gt; Int -&gt; Integer</span>
<a name="line-145"></a><span class='hs-comment'>-- fnorm bitcount i =</span>
<a name="line-146"></a><span class='hs-comment'>--   let p = 5^i</span>
<a name="line-147"></a><span class='hs-comment'>--       s = blen p - bitcount</span>
<a name="line-148"></a><span class='hs-comment'>--    in if s &lt; 0 then p `shiftL` (-s) else p `shiftR` s</span>
<a name="line-149"></a>
<a name="line-150"></a><span class='hs-comment'>-- -- | Generates a compile-time lookup table for floats as Word64</span>
<a name="line-151"></a><span class='hs-comment'>-- gen_table_f :: Int -&gt; (Int -&gt; Integer) -&gt; Q Exp</span>
<a name="line-152"></a><span class='hs-comment'>-- gen_table_f n f = return $ ListE (fmap (LitE . IntegerL . f) [0..n])</span>
<a name="line-153"></a><span class='hs-comment'>--</span>
<a name="line-154"></a><span class='hs-comment'>-- -- | Generates a compile-time lookup table for doubles as Word128</span>
<a name="line-155"></a><span class='hs-comment'>-- gen_table_d :: Int -&gt; (Int -&gt; Integer) -&gt; Q Exp</span>
<a name="line-156"></a><span class='hs-comment'>-- gen_table_d n f = return $ ListE (fmap ff [0..n])</span>
<a name="line-157"></a><span class='hs-comment'>--   where</span>
<a name="line-158"></a><span class='hs-comment'>--     ff :: Int -&gt; Exp</span>
<a name="line-159"></a><span class='hs-comment'>--     ff c = let r = f c</span>
<a name="line-160"></a><span class='hs-comment'>--                hi = r `shiftR` 64</span>
<a name="line-161"></a><span class='hs-comment'>--                lo = r .&amp;. ((1 `shiftL` 64) - 1)</span>
<a name="line-162"></a><span class='hs-comment'>--             in AppE (AppE (ConE 'Word128) (LitE . IntegerL $ hi)) (LitE . IntegerL $ lo)</span>
<a name="line-163"></a>
<a name="line-164"></a><a name="get_range"></a><span class='hs-comment'>-- Given a specific floating-point type, determine the range of q for the &lt; 0</span>
<a name="line-165"></a><span class='hs-comment'>-- and &gt;= 0 cases</span>
<a name="line-166"></a><span class='hs-definition'>get_range</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>ff</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-conid'>RealFloat</span> <span class='hs-varid'>ff</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>ff</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<a name="line-167"></a><span class='hs-definition'>get_range</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span>
<a name="line-168"></a>  <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>emin</span><span class='hs-layout'>,</span> <span class='hs-varid'>emax</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>floatRange</span> <span class='hs-varid'>f</span>
<a name="line-169"></a>      <span class='hs-varid'>mantissaDigits</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>floatDigits</span> <span class='hs-varid'>f</span>
<a name="line-170"></a>      <span class='hs-varid'>emin'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emin</span> <span class='hs-comment'>-</span> <span class='hs-varid'>mantissaDigits</span> <span class='hs-comment'>-</span> <span class='hs-num'>2</span>
<a name="line-171"></a>      <span class='hs-varid'>emax'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emax</span> <span class='hs-comment'>-</span> <span class='hs-varid'>mantissaDigits</span> <span class='hs-comment'>-</span> <span class='hs-num'>2</span>
<a name="line-172"></a>   <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-varid'>emin'</span><span class='hs-layout'>)</span> <span class='hs-comment'>-</span> <span class='hs-varid'>floor</span> <span class='hs-layout'>(</span><span class='hs-varid'>int2Double</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-varid'>emin'</span><span class='hs-layout'>)</span> <span class='hs-varop'>*</span> <span class='hs-varid'>logBase</span> <span class='hs-num'>10</span> <span class='hs-num'>5</span><span class='hs-layout'>)</span>
<a name="line-173"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>floor</span> <span class='hs-layout'>(</span><span class='hs-varid'>int2Double</span> <span class='hs-varid'>emax'</span> <span class='hs-varop'>*</span> <span class='hs-varid'>logBase</span> <span class='hs-num'>10</span> <span class='hs-num'>2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-174"></a>
<a name="line-175"></a><a name="float_max_split"></a><span class='hs-definition'>float_max_split</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>     <span class='hs-comment'>-- = 46</span>
<a name="line-176"></a><a name="float_max_inv_split"></a><span class='hs-definition'>float_max_inv_split</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-comment'>-- = 30</span>
<a name="line-177"></a><span class='hs-layout'>(</span><span class='hs-varid'>float_max_split</span><span class='hs-layout'>,</span> <span class='hs-varid'>float_max_inv_split</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>get_range</span> <span class='hs-layout'>(</span><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Float</span><span class='hs-layout'>)</span>
<a name="line-178"></a>
<a name="line-179"></a><a name="double_max_split"></a><span class='hs-comment'>-- we take a slightly different codepath s.t we need one extra entry</span>
<a name="line-180"></a><span class='hs-definition'>double_max_split</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>     <span class='hs-comment'>-- = 325</span>
<a name="line-181"></a><a name="double_max_inv_split"></a><span class='hs-definition'>double_max_inv_split</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-comment'>-- = 291</span>
<a name="line-182"></a><span class='hs-layout'>(</span><span class='hs-varid'>double_max_split</span><span class='hs-layout'>,</span> <span class='hs-varid'>double_max_inv_split</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-183"></a>    <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-varid'>mi</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>get_range</span> <span class='hs-layout'>(</span><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Double</span><span class='hs-layout'>)</span>
<a name="line-184"></a>     <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-varid'>mi</span><span class='hs-layout'>)</span>
<a name="line-185"></a>
</pre></body>
</html>
