-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - GOOL SubPackage
--   
--   Please see the README on GitHub at
--   <a>https://github.com/JacquesCarette/Drasil#readme</a>
@package drasil-gool
@version 0.1.1.0


-- | re-export smart constructors for external code writing
module GOOL.Drasil
type Label = String
type GSProgram a = GS (a (Program a))
type SFile a = FS (a (File a))
type MSBody a = MS (a (Body a))
type MSBlock a = MS (a (Block a))
type VSType a = VS (a (Type a))
type SVariable a = VS (a (Variable a))
type SValue a = VS (a (Value a))
type VSFunction a = VS (a (Function a))
type MSStatement a = MS (a (Statement a))
type MSParameter a = MS (a (Parameter a))
type SMethod a = MS (a (Method a))
type CSStateVar a = CS (a (StateVar a))
type SClass a = CS (a (Class a))
type FSModule a = FS (a (Module a))
type NamedArgs r = [(SVariable r, SValue r)]
type Initializers r = [(SVariable r, SValue r)]
class (SharedProg r, ProgramSym r, OOVariableValue r, OODeclStatement r, OOFuncAppStatement r, OOValueExpression r, InternalValueExp r, GetSet r, ObserverPattern r, StrategyPattern r) => OOProg r
class (FileSym r) => ProgramSym r where {
    type Program r;
}
prog :: ProgramSym r => Label -> Label -> [SFile r] -> GSProgram r
class (ModuleSym r) => FileSym r where {
    type File r;
}
fileDoc :: FileSym r => FSModule r -> SFile r
docMod :: FileSym r => String -> [String] -> String -> SFile r -> SFile r
class PermanenceSym r where {
    type Permanence r;
}
static :: PermanenceSym r => r (Permanence r)
dynamic :: PermanenceSym r => r (Permanence r)
class (BlockSym r) => BodySym r where {
    type Body r;
}
body :: BodySym r => [MSBlock r] -> MSBody r
addComments :: BodySym r => Label -> MSBody r -> MSBody r
bodyStatements :: BodySym r => [MSStatement r] -> MSBody r
oneLiner :: BodySym r => MSStatement r -> MSBody r
class (StatementSym r) => BlockSym r where {
    type Block r;
}
block :: BlockSym r => [MSStatement r] -> MSBlock r
class TypeSym r where {
    type Type r;
}
bool :: TypeSym r => VSType r
int :: TypeSym r => VSType r
float :: TypeSym r => VSType r
double :: TypeSym r => VSType r
char :: TypeSym r => VSType r
string :: TypeSym r => VSType r
infile :: TypeSym r => VSType r
outfile :: TypeSym r => VSType r
listType :: TypeSym r => VSType r -> VSType r
arrayType :: TypeSym r => VSType r -> VSType r
listInnerType :: TypeSym r => VSType r -> VSType r
funcType :: TypeSym r => [VSType r] -> VSType r -> VSType r
void :: TypeSym r => VSType r
class (TypeSym r) => OOTypeSym r
obj :: OOTypeSym r => ClassName -> VSType r
class (TypeSym r) => TypeElim r
getType :: TypeElim r => r (Type r) -> CodeType
getTypeString :: TypeElim r => r (Type r) -> String
class ThunkSym r where {
    type Thunk (r :: Type -> Type);
}
class TypeSym r => VectorType r
vecType :: VectorType r => VSType r -> VSType r
class (VariableSym r, StatementSym r) => VectorDecl r
vecDec :: VectorDecl r => Integer -> SVariable r -> MSStatement r
vecDecDef :: VectorDecl r => SVariable r -> [SValue r] -> MSStatement r
class (VariableSym r, ThunkSym r) => VectorThunk r
vecThunk :: VectorThunk r => SVariable r -> VSThunk r
class (ThunkSym r, ValueSym r) => VectorExpression r
vecScale :: VectorExpression r => SValue r -> VSThunk r -> VSThunk r
vecAdd :: VectorExpression r => VSThunk r -> VSThunk r -> VSThunk r
vecIndex :: VectorExpression r => SValue r -> VSThunk r -> SValue r
vecDot :: VectorExpression r => VSThunk r -> VSThunk r -> VSThunk r
class (VariableSym r, ThunkSym r, StatementSym r) => ThunkAssign r
thunkAssign :: ThunkAssign r => SVariable r -> VSThunk r -> MSStatement r
class (ValueSym r) => StatementSym r where {
    type Statement r;
}
valStmt :: StatementSym r => SValue r -> MSStatement r
multi :: StatementSym r => [MSStatement r] -> MSStatement r
class (VariableSym r, StatementSym r) => AssignStatement r
(&-=) :: AssignStatement r => SVariable r -> SValue r -> MSStatement r
(&+=) :: AssignStatement r => SVariable r -> SValue r -> MSStatement r
(&++) :: AssignStatement r => SVariable r -> MSStatement r
(&--) :: AssignStatement r => SVariable r -> MSStatement r
assign :: AssignStatement r => SVariable r -> SValue r -> MSStatement r
infixl 8 &++
infixl 1 &+=
infixl 1 &-=
infixl 8 &--
(&=) :: AssignStatement r => SVariable r -> SValue r -> MSStatement r
infixr 1 &=
assignToListIndex :: (StatementSym r, VariableValue r, List r) => SVariable r -> SValue r -> SValue r -> MSStatement r
class (VariableSym r, StatementSym r) => DeclStatement r
varDec :: DeclStatement r => SVariable r -> MSStatement r
varDecDef :: DeclStatement r => SVariable r -> SValue r -> MSStatement r
listDec :: DeclStatement r => Integer -> SVariable r -> MSStatement r
listDecDef :: DeclStatement r => SVariable r -> [SValue r] -> MSStatement r
arrayDec :: DeclStatement r => Integer -> SVariable r -> MSStatement r
arrayDecDef :: DeclStatement r => SVariable r -> [SValue r] -> MSStatement r
constDecDef :: DeclStatement r => SVariable r -> SValue r -> MSStatement r
funcDecDef :: DeclStatement r => SVariable r -> [SVariable r] -> MSBody r -> MSStatement r
class (DeclStatement r, OOVariableSym r) => OODeclStatement r
objDecDef :: OODeclStatement r => SVariable r -> SValue r -> MSStatement r
objDecNew :: OODeclStatement r => SVariable r -> [SValue r] -> MSStatement r
extObjDecNew :: OODeclStatement r => Library -> SVariable r -> [SValue r] -> MSStatement r
objDecNewNoParams :: OODeclStatement r => SVariable r -> MSStatement r
extObjDecNewNoParams :: OODeclStatement r => Library -> SVariable r -> MSStatement r
class (VariableSym r, StatementSym r) => IOStatement r
print :: IOStatement r => SValue r -> MSStatement r
printLn :: IOStatement r => SValue r -> MSStatement r
printStr :: IOStatement r => String -> MSStatement r
printStrLn :: IOStatement r => String -> MSStatement r
printFile :: IOStatement r => SValue r -> SValue r -> MSStatement r
printFileLn :: IOStatement r => SValue r -> SValue r -> MSStatement r
printFileStr :: IOStatement r => SValue r -> String -> MSStatement r
printFileStrLn :: IOStatement r => SValue r -> String -> MSStatement r
getInput :: IOStatement r => SVariable r -> MSStatement r
discardInput :: IOStatement r => MSStatement r
getFileInput :: IOStatement r => SValue r -> SVariable r -> MSStatement r
discardFileInput :: IOStatement r => SValue r -> MSStatement r
openFileR :: IOStatement r => SVariable r -> SValue r -> MSStatement r
openFileW :: IOStatement r => SVariable r -> SValue r -> MSStatement r
openFileA :: IOStatement r => SVariable r -> SValue r -> MSStatement r
closeFile :: IOStatement r => SValue r -> MSStatement r
getFileInputLine :: IOStatement r => SValue r -> SVariable r -> MSStatement r
discardFileLine :: IOStatement r => SValue r -> MSStatement r
getFileInputAll :: IOStatement r => SValue r -> SVariable r -> MSStatement r
class (VariableSym r, StatementSym r) => StringStatement r
stringSplit :: StringStatement r => Char -> SVariable r -> SValue r -> MSStatement r
stringListVals :: StringStatement r => [SVariable r] -> SValue r -> MSStatement r
stringListLists :: StringStatement r => [SVariable r] -> SValue r -> MSStatement r
class (VariableSym r, StatementSym r) => FuncAppStatement r
inOutCall :: FuncAppStatement r => InOutCall r
extInOutCall :: FuncAppStatement r => Library -> InOutCall r
class (FuncAppStatement r, OOVariableSym r) => OOFuncAppStatement r
selfInOutCall :: OOFuncAppStatement r => InOutCall r
class (StatementSym r) => CommentStatement r
comment :: CommentStatement r => Comment -> MSStatement r
initObserverList :: DeclStatement r => VSType r -> [SValue r] -> MSStatement r
addObserver :: (StatementSym r, OOVariableValue r, List r) => SValue r -> MSStatement r
class (BodySym r, VariableSym r) => ControlStatement r
break :: ControlStatement r => MSStatement r
continue :: ControlStatement r => MSStatement r
returnStmt :: ControlStatement r => SValue r -> MSStatement r
throw :: ControlStatement r => Label -> MSStatement r

-- | String of if-else statements. Arguments: List of predicates and bodies
--   (if this then that), Body for else branch
ifCond :: ControlStatement r => [(SValue r, MSBody r)] -> MSBody r -> MSStatement r
switch :: ControlStatement r => SValue r -> [(SValue r, MSBody r)] -> MSBody r -> MSStatement r
ifExists :: ControlStatement r => SValue r -> MSBody r -> MSBody r -> MSStatement r
for :: ControlStatement r => MSStatement r -> SValue r -> MSStatement r -> MSBody r -> MSStatement r
forRange :: ControlStatement r => SVariable r -> SValue r -> SValue r -> SValue r -> MSBody r -> MSStatement r
forEach :: ControlStatement r => SVariable r -> SValue r -> MSBody r -> MSStatement r
while :: ControlStatement r => SValue r -> MSBody r -> MSStatement r
tryCatch :: ControlStatement r => MSBody r -> MSBody r -> MSStatement r
ifNoElse :: ControlStatement r => [(SValue r, MSBody r)] -> MSStatement r
switchAsIf :: (ControlStatement r, Comparison r) => SValue r -> [(SValue r, MSBody r)] -> MSBody r -> MSStatement r
class (TypeSym r) => VariableSym r where {
    type Variable r;
}
var :: VariableSym r => Label -> VSType r -> SVariable r
constant :: VariableSym r => Label -> VSType r -> SVariable r
extVar :: VariableSym r => Library -> Label -> VSType r -> SVariable r
arrayElem :: VariableSym r => Integer -> SVariable r -> SVariable r
class (VariableSym r, OOTypeSym r) => OOVariableSym r
staticVar :: OOVariableSym r => Label -> VSType r -> SVariable r
self :: OOVariableSym r => SVariable r
classVar :: OOVariableSym r => VSType r -> SVariable r -> SVariable r
extClassVar :: OOVariableSym r => VSType r -> SVariable r -> SVariable r
objVar :: OOVariableSym r => SVariable r -> SVariable r -> SVariable r
objVarSelf :: OOVariableSym r => SVariable r -> SVariable r
class (VariableSym r) => VariableElim r
variableName :: VariableElim r => r (Variable r) -> String
variableType :: VariableElim r => r (Variable r) -> r (Type r)
($->) :: OOVariableSym r => SVariable r -> SVariable r -> SVariable r
infixl 9 $->
listOf :: VariableSym r => Label -> VSType r -> SVariable r
listVar :: VariableSym r => Label -> VSType r -> SVariable r
class (TypeSym r) => ValueSym r where {
    type Value r;
}
valueType :: ValueSym r => r (Value r) -> r (Type r)
class (ValueSym r) => Argument r
pointerArg :: Argument r => SValue r -> SValue r
class (ValueSym r) => Literal r
litTrue :: Literal r => SValue r
litFalse :: Literal r => SValue r
litChar :: Literal r => Char -> SValue r
litDouble :: Literal r => Double -> SValue r
litFloat :: Literal r => Float -> SValue r
litInt :: Literal r => Integer -> SValue r
litString :: Literal r => String -> SValue r
litArray :: Literal r => VSType r -> [SValue r] -> SValue r
litList :: Literal r => VSType r -> [SValue r] -> SValue r
class (ValueSym r) => MathConstant r
pi :: MathConstant r => SValue r
class (VariableSym r, ValueSym r) => VariableValue r
valueOf :: VariableValue r => SVariable r -> SValue r
class (VariableValue r, OOVariableSym r) => OOVariableValue r
class (ValueSym r) => CommandLineArgs r
arg :: CommandLineArgs r => Integer -> SValue r
argsList :: CommandLineArgs r => SValue r
argExists :: CommandLineArgs r => Integer -> SValue r
class (ValueSym r) => NumericExpression r
(#~) :: NumericExpression r => SValue r -> SValue r
(#/^) :: NumericExpression r => SValue r -> SValue r
(#|) :: NumericExpression r => SValue r -> SValue r
(#+) :: NumericExpression r => SValue r -> SValue r -> SValue r
(#-) :: NumericExpression r => SValue r -> SValue r -> SValue r
(#*) :: NumericExpression r => SValue r -> SValue r -> SValue r
(#/) :: NumericExpression r => SValue r -> SValue r -> SValue r
(#%) :: NumericExpression r => SValue r -> SValue r -> SValue r
(#^) :: NumericExpression r => SValue r -> SValue r -> SValue r
log :: NumericExpression r => SValue r -> SValue r
ln :: NumericExpression r => SValue r -> SValue r
exp :: NumericExpression r => SValue r -> SValue r
sin :: NumericExpression r => SValue r -> SValue r
cos :: NumericExpression r => SValue r -> SValue r
tan :: NumericExpression r => SValue r -> SValue r
csc :: NumericExpression r => SValue r -> SValue r
sec :: NumericExpression r => SValue r -> SValue r
cot :: NumericExpression r => SValue r -> SValue r
arcsin :: NumericExpression r => SValue r -> SValue r
arccos :: NumericExpression r => SValue r -> SValue r
arctan :: NumericExpression r => SValue r -> SValue r
floor :: NumericExpression r => SValue r -> SValue r
ceil :: NumericExpression r => SValue r -> SValue r
infixl 5 #+
infixl 5 #-
infixl 6 #/
infixl 6 #*
infixl 8 #~
infixl 7 #/^
infixl 7 #|
infixl 6 #%
infixl 7 #^
class (ValueSym r) => BooleanExpression r
(?!) :: BooleanExpression r => SValue r -> SValue r
(?&&) :: BooleanExpression r => SValue r -> SValue r -> SValue r
(?||) :: BooleanExpression r => SValue r -> SValue r -> SValue r
infixl 2 ?&&
infixl 1 ?||
infixr 6 ?!
class (ValueSym r) => Comparison r
(?<) :: Comparison r => SValue r -> SValue r -> SValue r
(?<=) :: Comparison r => SValue r -> SValue r -> SValue r
(?>) :: Comparison r => SValue r -> SValue r -> SValue r
(?>=) :: Comparison r => SValue r -> SValue r -> SValue r
(?==) :: Comparison r => SValue r -> SValue r -> SValue r
(?!=) :: Comparison r => SValue r -> SValue r -> SValue r
infixl 4 ?<
infixl 4 ?<=
infixl 4 ?>
infixl 4 ?>=
infixl 3 ?==
infixl 3 ?!=
class (VariableSym r, ValueSym r) => ValueExpression r
inlineIf :: ValueExpression r => SValue r -> SValue r -> SValue r -> SValue r
funcAppMixedArgs :: ValueExpression r => MixedCall r
extFuncAppMixedArgs :: ValueExpression r => Library -> MixedCall r
libFuncAppMixedArgs :: ValueExpression r => Library -> MixedCall r
lambda :: ValueExpression r => [SVariable r] -> SValue r -> SValue r
notNull :: ValueExpression r => SValue r -> SValue r
class (ValueExpression r, OOVariableSym r, OOValueSym r) => OOValueExpression r
selfFuncAppMixedArgs :: OOValueExpression r => MixedCall r
newObjMixedArgs :: OOValueExpression r => MixedCtorCall r
extNewObjMixedArgs :: OOValueExpression r => Library -> MixedCtorCall r
libNewObjMixedArgs :: OOValueExpression r => Library -> MixedCtorCall r
funcApp :: ValueExpression r => PosCall r
funcAppNamedArgs :: ValueExpression r => Label -> VSType r -> NamedArgs r -> SValue r
selfFuncApp :: OOValueExpression r => PosCall r
extFuncApp :: ValueExpression r => Library -> PosCall r
libFuncApp :: ValueExpression r => Library -> PosCall r
newObj :: OOValueExpression r => PosCtorCall r
extNewObj :: OOValueExpression r => Library -> PosCtorCall r
libNewObj :: OOValueExpression r => Library -> PosCtorCall r
exists :: ValueExpression r => SValue r -> SValue r

-- | Calling a method. t is the return type of the method, o is the object,
--   f is the method name, and ps is a list of positional arguments.
objMethodCall :: InternalValueExp r => VSType r -> SValue r -> Label -> [SValue r] -> SValue r

-- | Calling a method with named arguments.
objMethodCallNamedArgs :: InternalValueExp r => VSType r -> SValue r -> Label -> NamedArgs r -> SValue r

-- | Calling a method with a mix of positional and named arguments.
objMethodCallMixedArgs :: InternalValueExp r => VSType r -> SValue r -> Label -> [SValue r] -> NamedArgs r -> SValue r

-- | Calling a method with no parameters.
objMethodCallNoParams :: InternalValueExp r => VSType r -> SValue r -> Label -> SValue r
class (ValueSym r) => FunctionSym r where {
    type Function r;
}
func :: FunctionSym r => Label -> VSType r -> [SValue r] -> VSFunction r
objAccess :: FunctionSym r => SValue r -> VSFunction r -> SValue r
($.) :: FunctionSym r => SValue r -> VSFunction r -> SValue r
infixl 9 $.
selfAccess :: (OOVariableValue r, FunctionSym r) => VSFunction r -> SValue r
class (ValueSym r, VariableSym r) => GetSet r
get :: GetSet r => SValue r -> SVariable r -> SValue r
set :: GetSet r => SValue r -> SVariable r -> SValue r -> SValue r
class (ValueSym r) => List r

-- | Does any necessary conversions from GOOL's zero-indexed assumptions to
--   the target language's assumptions
intToIndex :: List r => SValue r -> SValue r

-- | Does any necessary conversions from the target language's indexing
--   assumptions assumptions to GOOL's zero-indexed assumptions
indexToInt :: List r => SValue r -> SValue r

-- | Finds the size of a list. Arguments are: List
listSize :: List r => SValue r -> SValue r

-- | Inserts a value into a list. Arguments are: List, Index, Value
listAdd :: List r => SValue r -> SValue r -> SValue r -> SValue r

-- | Appens a value to a list. Arguments are: List, Value
listAppend :: List r => SValue r -> SValue r -> SValue r

-- | Gets the value of an index of a list. Arguments are: List, Index
listAccess :: List r => SValue r -> SValue r -> SValue r

-- | Sets the value of an index of a list. Arguments are: List, Index,
--   Value
listSet :: List r => SValue r -> SValue r -> SValue r -> SValue r

-- | Finds the index of the first occurrence of a value in a list.
--   Arguments are: List, Value
indexOf :: List r => SValue r -> SValue r -> SValue r

-- | Creates a slice of a list and assigns it to a variable. Arguments are:
--   Variable to assign List to read from [Start index] inclusive. (if
--   Nothing, then list start if step &gt; 0, list end if step &lt; 0) [End
--   index] exclusive. (if Nothing, then list end if step &gt; 0, list
--   start if step &gt; 0) [Step] (if Nothing, then defaults to 1)
listSlice :: InternalList r => SVariable r -> SValue r -> Maybe (SValue r) -> Maybe (SValue r) -> Maybe (SValue r) -> MSBlock r
listIndexExists :: (List r, Comparison r) => SValue r -> SValue r -> SValue r
at :: List r => SValue r -> SValue r -> SValue r
class (StatementSym r, FunctionSym r) => ObserverPattern r
notifyObservers :: ObserverPattern r => VSFunction r -> VSType r -> MSStatement r
class (BodySym r, VariableSym r) => StrategyPattern r
runStrategy :: StrategyPattern r => Label -> [(Label, MSBody r)] -> Maybe (SValue r) -> Maybe (SVariable r) -> MSBlock r
class ScopeSym r where {
    type Scope r;
}
private :: ScopeSym r => r (Scope r)
public :: ScopeSym r => r (Scope r)
class (VariableSym r) => ParameterSym r where {
    type Parameter r;
}
param :: ParameterSym r => SVariable r -> MSParameter r
pointerParam :: ParameterSym r => SVariable r -> MSParameter r
class (BodySym r, ParameterSym r, ScopeSym r) => MethodSym r where {
    type Method r;
}
docMain :: MethodSym r => MSBody r -> SMethod r
function :: MethodSym r => Label -> r (Scope r) -> VSType r -> [MSParameter r] -> MSBody r -> SMethod r
mainFunction :: MethodSym r => MSBody r -> SMethod r
docFunc :: MethodSym r => String -> [String] -> Maybe String -> SMethod r -> SMethod r
inOutFunc :: MethodSym r => Label -> r (Scope r) -> InOutFunc r
docInOutFunc :: MethodSym r => Label -> r (Scope r) -> DocInOutFunc r
class (MethodSym r, PermanenceSym r) => OOMethodSym r
method :: OOMethodSym r => Label -> r (Scope r) -> r (Permanence r) -> VSType r -> [MSParameter r] -> MSBody r -> SMethod r
getMethod :: OOMethodSym r => SVariable r -> SMethod r
setMethod :: OOMethodSym r => SVariable r -> SMethod r
constructor :: OOMethodSym r => [MSParameter r] -> Initializers r -> MSBody r -> SMethod r
inOutMethod :: OOMethodSym r => Label -> r (Scope r) -> r (Permanence r) -> InOutFunc r
docInOutMethod :: OOMethodSym r => Label -> r (Scope r) -> r (Permanence r) -> DocInOutFunc r
privMethod :: OOMethodSym r => Label -> VSType r -> [MSParameter r] -> MSBody r -> SMethod r
pubMethod :: OOMethodSym r => Label -> VSType r -> [MSParameter r] -> MSBody r -> SMethod r
initializer :: OOMethodSym r => [MSParameter r] -> Initializers r -> SMethod r
nonInitConstructor :: OOMethodSym r => [MSParameter r] -> MSBody r -> SMethod r
class (ScopeSym r, PermanenceSym r, VariableSym r) => StateVarSym r where {
    type StateVar r;
}
stateVar :: StateVarSym r => r (Scope r) -> r (Permanence r) -> SVariable r -> CSStateVar r
stateVarDef :: StateVarSym r => r (Scope r) -> r (Permanence r) -> SVariable r -> SValue r -> CSStateVar r
constVar :: StateVarSym r => r (Scope r) -> SVariable r -> SValue r -> CSStateVar r
privDVar :: StateVarSym r => SVariable r -> CSStateVar r
pubDVar :: StateVarSym r => SVariable r -> CSStateVar r
pubSVar :: StateVarSym r => SVariable r -> CSStateVar r
class (OOMethodSym r, StateVarSym r) => ClassSym r where {
    type Class r;
}

-- | Main external method for creating a class. Inputs: parent class,
--   variables, constructor(s), methods
buildClass :: ClassSym r => Maybe Label -> [CSStateVar r] -> [SMethod r] -> [SMethod r] -> SClass r

-- | Creates an extra class. Inputs: class name, the rest are the same as
--   buildClass.
extraClass :: ClassSym r => Label -> Maybe Label -> [CSStateVar r] -> [SMethod r] -> [SMethod r] -> SClass r

-- | Creates a class implementing interfaces. Inputs: class name, interface
--   names, variables, constructor(s), methods
implementingClass :: ClassSym r => Label -> [Label] -> [CSStateVar r] -> [SMethod r] -> [SMethod r] -> SClass r
docClass :: ClassSym r => String -> SClass r -> SClass r
class (ClassSym r) => ModuleSym r where {
    type Module r;
}
buildModule :: ModuleSym r => Label -> [Label] -> [SMethod r] -> [SClass r] -> FSModule r
convType :: TypeSym r => CodeType -> VSType r
convTypeOO :: OOTypeSym r => CodeType -> VSType r
data ProgData
data FileData
data ModData
data ScopeTag
Pub :: ScopeTag
Priv :: ScopeTag
data CodeType
Boolean :: CodeType
Integer :: CodeType
Float :: CodeType
Double :: CodeType
Char :: CodeType
String :: CodeType
InFile :: CodeType
OutFile :: CodeType
List :: CodeType -> CodeType
Array :: CodeType -> CodeType
Object :: ClassName -> CodeType
Func :: [CodeType] -> CodeType -> CodeType
Void :: CodeType
data GOOLState
GS :: [FilePath] -> [FilePath] -> Maybe FilePath -> Map String ClassName -> Map QualifiedName [ExceptionType] -> Map QualifiedName [QualifiedName] -> Bool -> Bool -> GOOLState
[_headers] :: GOOLState -> [FilePath]
[_sources] :: GOOLState -> [FilePath]
[_mainMod] :: GOOLState -> Maybe FilePath
[_classMap] :: GOOLState -> Map String ClassName
[_methodExceptionMap] :: GOOLState -> Map QualifiedName [ExceptionType]
[_callMap] :: GOOLState -> Map QualifiedName [QualifiedName]
[_throwUsed] :: GOOLState -> Bool
[_errorDefined] :: GOOLState -> Bool
lensMStoVS :: Lens' MethodState ValueState
headers :: Lens' GOOLState [FilePath]
sources :: Lens' GOOLState [FilePath]
mainMod :: Lens' GOOLState (Maybe FilePath)
initialState :: GOOLState
onStateValue :: (a -> b) -> State s a -> State s b
onCodeList :: Monad m => ([a] -> b) -> [m a] -> m b
unCI :: CodeInfo a -> a
unPC :: PythonCode a -> a
unJC :: JavaCode a -> a
unCSC :: CSharpCode a -> a
unCPPC :: CppCode CppSrcCode CppHdrCode a -> a
unSC :: SwiftCode a -> a
pyName :: String
pyVersion :: String
jName :: String
jVersion :: String
csName :: String
csVersion :: String
cppName :: String
cppVersion :: String
swiftName :: String
swiftVersion :: String
