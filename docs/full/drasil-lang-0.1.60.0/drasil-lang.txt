-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Language SubPackage
--   
--   Please see the README on GitHub at
--   <a>https://github.com/JacquesCarette/Drasil#readme</a>
@package drasil-lang
@version 0.1.60.0


-- | Unique Identifier used across Drasil.
module Drasil.Database.UID

-- | A <tt>UID</tt> is a 'unique identifier' for things that we will put
--   into our database of information. We use a newtype wrapper to make
--   sure we are only using <a>UID</a>s where desired.
data UID

-- | The most basic item: having a unique identifier key, here a UID.
class HasUID c

-- | Provides a <i>unique</i> id for internal Drasil use.
uid :: HasUID c => Getter c UID

-- | Smart constructor for <a>UID</a>s from raw <a>Value</a>s.
mkUid :: String -> UID

-- | Nest a <a>UID</a> under a namespace.
nsUid :: String -> UID -> UID

-- | Append a suffix to a thing with a <a>UID</a> and get the resulting
--   <a>UID</a>.
(+++) :: HasUID a => a -> String -> UID

-- | Append a suffix to a <a>UID</a>.
(+++.) :: UID -> String -> UID

-- | Merge the <a>UID</a>s of two chunks through simple concatenation.
(+++!) :: (HasUID a, HasUID b) => a -> b -> UID

-- | Get something's <a>UID</a> as a <a>Value</a>.
showUID :: HasUID a => a -> String
instance Data.Aeson.Types.ToJSON.ToJSON Drasil.Database.UID.UID
instance Data.Aeson.Types.ToJSON.ToJSONKey Drasil.Database.UID.UID
instance GHC.Show.Show Drasil.Database.UID.UID
instance GHC.Generics.Generic Drasil.Database.UID.UID
instance GHC.Classes.Ord Drasil.Database.UID.UID
instance GHC.Classes.Eq Drasil.Database.UID.UID


-- | Custom type for dates, in this case Month. This should, in time, be
--   switched out in favour of a proper package designed to handle all the
--   complexities of dates.
module Language.Drasil.Data.Date

-- | Custom type for months (abbreviated).
data Month
Jan :: Month
Feb :: Month
Mar :: Month
Apr :: Month
May :: Month
Jun :: Month
Jul :: Month
Aug :: Month
Sep :: Month
Oct :: Month
Nov :: Month
Dec :: Month
instance GHC.Classes.Ord Language.Drasil.Data.Date.Month
instance GHC.Classes.Eq Language.Drasil.Data.Date.Month
instance GHC.Show.Show Language.Drasil.Data.Date.Month


-- | Even though we do not have <tt>Label</tt>s per se, here we define the
--   different ways of construction ways to mark labels.
module Language.Drasil.Label.Type

-- | Applying different pieces of information for a reference. An RP is a
--   decorated internal reference. Citation is a citation. URI is for URLs
--   and other external links.
data LblType
RP :: IRefProg -> String -> LblType
Citation :: String -> LblType
URI :: String -> LblType

-- | Created for different forms of references. Used in <a>LblType</a>.
data IRefProg

-- | Deferred lookup; done later. Used for domains in a
--   <tt>ConceptInstance</tt>.
Deferred :: UID -> IRefProg

-- | Lifts a <a>String</a> into a <tt>RefProg</tt>.
RS :: String -> IRefProg

-- | Concatenates with two subprograms.
RConcat :: IRefProg -> IRefProg -> IRefProg

-- | The <tt>Symbol</tt> to insert the <tt>ShortName</tt> directly.
Name :: IRefProg

-- | Members must have a reference address.
class HasRefAddress b

-- | Provides the ability to hold a reference address.
getRefAdd :: HasRefAddress b => b -> LblType

-- | Members of this class have the ability to be referenced.
class (HasUID s, HasRefAddress s) => Referable s

-- | The referencing address (what we're linking to). Only visible in the
--   source (tex/html).
refAdd :: Referable s => s -> String

-- | Alternate form of reference.
renderRef :: Referable s => s -> LblType

-- | Retrieves the <a>String</a> contained in a <a>LblType</a>.
getAdd :: LblType -> String

-- | Constructor that gets the <a>Name</a> of an <a>IRefProg</a>.
name :: IRefProg

-- | Constructor that concatenates two subprograms.
(+::+) :: IRefProg -> IRefProg -> IRefProg

-- | Constructor for a <a>String</a> into an <a>IRefProg</a>.
raw :: String -> IRefProg

-- | Constructor to defer a <a>UID</a> lookup; done later.
defer :: UID -> IRefProg

-- | Prepends a <a>String</a> to an <a>IRefProg</a>.
prepend :: String -> IRefProg


-- | Defines types and functions to encode people, names, and naming
--   convention. Used for referencing and authorship of work.
module Language.Drasil.People

-- | Members of this class must have a name.
class HasName p

-- | A person can have a given name, middle name(s), and surname, as well
--   as the naming convention they use.
data Person

-- | People is a synonymn for many <a>Person</a>s.
type People = [Person]

-- | Naming conventions.
data Conv

-- | Western style conventions are given name followed by middle names,
--   followed by surname.
Western :: Conv

-- | Eastern style conventions are surname followed by middle names,
--   followed by given name.
Eastern :: Conv

-- | Mononyms are for those people who have only one name (ex. Madonna).
Mono :: Conv

-- | Constructor for a person using Western naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   given name, surname.
person :: String -> String -> Person

-- | Constructor for a person using Eastern naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   surname, given name.
person' :: String -> String -> Person

-- | Constructor for a person using Western naming conventions. Similar to
--   the <a>person</a> constructor, except the middle argument is a list of
--   middle names.
personWM :: String -> [String] -> String -> Person

-- | Constructor for a person using Eastern naming conventions. Similar to
--   the <a>person'</a> constructor, except the middle argument is a list
--   of middle names.
personWM' :: String -> [String] -> String -> Person

-- | Constructor for a person with a mononym (only one name).
mononym :: String -> Person

-- | Gets the name of a <a>Person</a>. Adds a dot after any initials.
name :: HasName n => n -> String

-- | Provides the ability to hold a name.
nameStr :: HasName p => p -> String

-- | Gets the last name of a <a>Person</a>.
lstName :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, First Middle.
rendPersLFM :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, F. M.
rendPersLFM' :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, First M.
rendPersLFM'' :: Person -> String

-- | Orderes different groups of <a>Person</a>s. If two lists are the same
--   up to a point, the citation with more <a>Person</a>s will go last.
comparePeople :: [Person] -> [Person] -> Ordering
instance GHC.Classes.Eq Language.Drasil.People.Conv
instance GHC.Classes.Eq Language.Drasil.People.Person
instance Language.Drasil.People.HasName Language.Drasil.People.Person


-- | Contains all necessary types and constructors for citing sources in
--   Drasil.
module Language.Drasil.Data.Citation

-- | Fields used in citations.
data CiteField
Address :: String -> CiteField
Author :: People -> CiteField

-- | Used for <a>InCollection</a> references only.
BookTitle :: String -> CiteField
Chapter :: Int -> CiteField
Edition :: Int -> CiteField
Editor :: People -> CiteField

-- | Can be published via URL or something else.
HowPublished :: HP -> CiteField
Institution :: String -> CiteField
Journal :: String -> CiteField
Month :: Month -> CiteField
Note :: String -> CiteField
Number :: Int -> CiteField
Organization :: String -> CiteField

-- | Range of pages (ex1. 1-32; ex2. 7,31,52-55).
Pages :: [Int] -> CiteField
Publisher :: String -> CiteField
School :: String -> CiteField
Series :: String -> CiteField
Title :: String -> CiteField

-- | BibTeX "type" field.
Type :: String -> CiteField
Volume :: Int -> CiteField
Year :: Int -> CiteField

-- | How something is published. Necessary for URLs to work properly.
data HP
URL :: String -> HP
Verb :: String -> HP

-- | External references come in many flavours. Articles, Books, etc. (we
--   are using the types available in Bibtex).
data CitationKind
Article :: CitationKind
Book :: CitationKind
Booklet :: CitationKind
InBook :: CitationKind
InCollection :: CitationKind
InProceedings :: CitationKind
Manual :: CitationKind
MThesis :: CitationKind
Misc :: CitationKind
PhDThesis :: CitationKind
Proceedings :: CitationKind
TechReport :: CitationKind
Unpublished :: CitationKind

-- | <tt>Citation</tt>s should have a fields (<a>CiteField</a>).
class HasFields c

-- | Provides a <tt>Lens</tt> to <a>CiteField</a>s.
getFields :: HasFields c => Lens' c [CiteField]

-- | Smart field constructor for a <a>CiteField</a>.
author :: People -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
editor :: People -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
address :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
bookTitle :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
howPublished :: String -> CiteField

-- | URL version of <a>howPublished</a>.
--   
--   Smart field constructor for a <a>CiteField</a>.
howPublishedU :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
institution :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
journal :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
note :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
organization :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
publisher :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
school :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
series :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
title :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
typeField :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
chapter :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
edition :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
number :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
volume :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
year :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
pages :: [Int] -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
month :: Month -> CiteField

-- | Orders two authors. If given two of the exact same authors, year, and
--   title, returns an error.
compareAuthYearTitle :: HasFields c => c -> c -> Ordering


-- | Stages of the development process.
module Language.Drasil.Stages

-- | Stages are what part of the development process we are in. There are
--   currently two: 1) The Equational stage (should be called
--   Specification) 2) The Implemenation stage
--   
--   The point is that information may be rendered differently depending at
--   what stage we're at. Being able to talk about stages lets us also
--   attach different display information.
data Stage
Equational :: Stage
Implementation :: Stage
instance GHC.Show.Show Language.Drasil.Stages.Stage


-- | Defines uncertainty types and functions.
module Language.Drasil.Uncertainty

-- | Something that may contain an uncertainty value and a precision value.
data Uncertainty

-- | HasUncertainty is just a chunk with some uncertainty associated to it.
--   This uncertainty is represented as a decimal value between 0 and 1
--   (percentage).
class HasUncertainty c

-- | Provides the <tt>Lens</tt> to an <a>Uncertainty</a>.
unc :: HasUncertainty c => Lens' c Uncertainty
uncert :: Lens' Uncertainty (Maybe Double)
prec :: Lens' Uncertainty (Maybe Int)

-- | Smart constructor for values with uncertainty.
uncty :: Double -> Maybe Int -> Uncertainty

-- | Smart constructor for exact values (no uncertainty).
exact :: Uncertainty

-- | The default uncertainty is set to 0.1.
defaultUncrt :: Uncertainty

-- | Accessor for uncertainty value from something that has an uncertainty.
uncVal :: HasUncertainty x => x -> Double

-- | Accessor for precision value from something that has an uncertainty.
uncPrec :: HasUncertainty x => x -> Maybe Int


-- | Special type for unicode characters.
module Language.Drasil.Unicode

-- | Special characters include partial derivatives and the degree circle.
data Special
Circle :: Special

-- | Class for rendering special characters.
class RenderSpecial r
special :: RenderSpecial r => Special -> r
instance GHC.Classes.Ord Language.Drasil.Unicode.Special
instance GHC.Classes.Eq Language.Drasil.Unicode.Special


-- | Drasil uses symbols in expressions and sentences.
module Language.Drasil.Symbol

-- | Decorations on symbols/characters such as hats or Vector
--   representations (determines bolding, italics, etc).
data Decoration

-- | Places a <tt>^</tt> on top of a symbol.
Hat :: Decoration

-- | Makes a symbol bold.
Vector :: Decoration

-- | Appends a <tt>'</tt> to a symbol.
Prime :: Decoration

-- | Prepends a <tt>Δ</tt> to a symbol.
Delta :: Decoration

-- | Places <tt>||</tt> before and after a symbol.
Magnitude :: Decoration

-- | A <a>Symbol</a> is actually going to be a graphical description of
--   what gets rendered as a (unique) symbol. This is actually NOT based on
--   semantics at all, but just a description of how things look.
--   
--   Symbols can be:
--   
--   <ul>
--   <li><tt><a>Variable</a></tt> (string such as "x" that represent a
--   value that can vary)</li>
--   <li><tt><a>Label</a></tt> (strings such as "max" or "target" that
--   represent a single idea)</li>
--   <li><tt><a>Symbol</a></tt> characters (ex. unicode)</li>
--   <li><tt>Decorated</tt> symbols using <a>Atop</a></li>
--   <li><tt>Concatenations</tt> of symbols, including subscripts and
--   superscripts</li>
--   <li><tt><a>Empty</a></tt>! (this is to give this a monoid-like
--   flavour)</li>
--   </ul>
data Symbol

-- | Basic variable name creation.
Variable :: String -> Symbol

-- | For when symbols need more context, but we don't want to add a new
--   variable name. For example, <tt>v_f</tt> may be encoded as <tt>Concat
--   [variable "v", label "f"]</tt>.
Label :: String -> Symbol

-- | For using numbers in Symbols.
Integ :: Int -> Symbol

-- | For now, special characters are the degree and partial differentiation
--   symbols. These should eventually move elsewhere and the <a>Symbol</a>
--   type removed.
Special :: Special -> Symbol

-- | Used to decorate symbols. For things like vectors (which need to be
--   bold), primes, magnitudes, etc. See <a>Decoration</a> for more
--   details.
Atop :: Decoration -> Symbol -> Symbol

-- | Order of Symbols: upleft lowleft upright lowright base. Ex:
--   
--   <pre>
--   Corners [1]   [2]   [3]   [4]   [5]
--   </pre>
--   
--   <pre>
--   Visually:  [1]   [3]
--   
--                 [5]
--   
--              [2]   [4]
--   </pre>
Corners :: [Symbol] -> [Symbol] -> [Symbol] -> [Symbol] -> Symbol -> Symbol

-- | Concatentation of two symbols: <tt>[s1, s2] -&gt; s1s2</tt>
Concat :: [Symbol] -> Symbol

-- | Placeholder for when a symbol is not needed.
Empty :: Symbol

-- | A HasSymbol is anything which has a <a>Symbol</a>.
class HasSymbol c

-- | Provides the <a>Symbol</a> for a particular stage of generation.
symbol :: HasSymbol c => c -> Stage -> Symbol

-- | The default compare function that sorts all the lower case symbols
--   after the upper case ones.
--   
--   Comparation is used twice for each <tt>Atomic</tt> case, once for
--   making sure they are the same letter, once for case sensitive. As far
--   as this comparison is considered, <tt>Δ</tt> is a "decoration" and
--   ignored unless the compared symbols are the exact same, in which case
--   it is ordered after the undecorated symbol.
--   
--   Superscripts and subscripts are ordered after the base symbols
--   (because they add additional context to a symbol). For example:
--   `v_f^{AB}` (expressed in LaTeX notation for clarity), where
--   <tt>v_f</tt> is a final velocity, and the `^{AB}` adds context that it
--   is the final velocity between points <tt>A</tt> and <tt>B</tt>. In
--   these cases, the sorting of `v_f^{AB}` should be following
--   <tt>v_f</tt> as it is logical to place it with its parent concept.
compsy :: Symbol -> Symbol -> Ordering
instance GHC.Classes.Ord Language.Drasil.Symbol.Decoration
instance GHC.Classes.Eq Language.Drasil.Symbol.Decoration
instance GHC.Classes.Eq Language.Drasil.Symbol.Symbol
instance GHC.Base.Semigroup Language.Drasil.Symbol.Symbol
instance GHC.Base.Monoid Language.Drasil.Symbol.Symbol


-- | Routines to help with Symbols and Stages.
module Language.Drasil.Symbol.Helpers

-- | Helper function for getting a symbol in the Equational Stage.
eqSymb :: HasSymbol q => q -> Symbol

-- | Helper function for getting a symbol in the Implementation Stage.
codeSymb :: HasSymbol q => q -> Symbol

-- | Finds if a <a>Stage</a> symbol is real or Empty. True if real.
hasStageSymbol :: HasSymbol q => q -> Stage -> Bool

-- | Helper for creating a symbol with Unicode in it.
autoStage :: Symbol -> Stage -> Symbol

-- | Helper for creating a symbol with a hat ("^") atop it.
hat :: Symbol -> Symbol

-- | Helper for creating a Vector symbol.
prime :: Symbol -> Symbol

-- | Helper for creating a symbol that depends on the stage.
staged :: Symbol -> Symbol -> Stage -> Symbol

-- | Helper for creating a symbol with a subscript to the right. Arguments:
--   Base symbol, then subscripted symbol.
sub :: Symbol -> Symbol -> Symbol

-- | Helper for a common case of subscript, with a string Arguments: Base
--   symbol, then subscript <a>String</a>.
subStr :: Symbol -> String -> Symbol

-- | Helper for creating a symbol with a superscript to the right.
--   Arguments: Base symbol, then superscripted symbol.
sup :: Symbol -> Symbol -> Symbol

-- | Helper for autoStage that applies unicodeString to all <a>Symbol</a>s
--   with <a>String</a>s.
unicodeConv :: Symbol -> Symbol

-- | Helper for creating a symbol with a superscript on the left side of
--   the symbol. Arguments: Base symbol, then superscripted symbol.
upperLeft :: Symbol -> Symbol -> Symbol

-- | Helper for creating a Vector symbol.
vec :: Symbol -> Symbol

-- | Label smart constructor, requires non-empty labels
label :: String -> Symbol

-- | Variable smart constructor, requires non-empty variables
variable :: String -> Symbol


-- | Number space types and functions.
module Language.Drasil.Space

-- | The difference kinds of spaces that may exist. This type holds
--   numerical spaces (such as the set of integers, rationals, etc.), a
--   space for booleans, a space for characters, dimensional spaces
--   (vectors, arrays, etc.), a space for Actors, discrete sets (both for
--   numbers and strings), and a void space.
data Space
Integer :: Space
Rational :: Space
Real :: Space
Natural :: Space
Boolean :: Space
Char :: Space
String :: Space
Vect :: Space -> Space
Set :: Space -> Space
Matrix :: Int -> Int -> Space -> Space
Array :: Space -> Space
Actor :: String -> Space
Function :: NonEmpty Primitive -> Primitive -> Space
Void :: Space
type Primitive = Space

-- | A RealInterval is a subset of <a>Space</a> (as a <a>Space</a>). These
--   come in different flavours. For now, we embed <tt>Expr</tt> for the
--   bounds, but that will change as well.
data RealInterval a b
[Bounded] :: (Inclusive, a) -> (Inclusive, b) -> RealInterval a b
[UpTo] :: (Inclusive, a) -> RealInterval a b
[UpFrom] :: (Inclusive, b) -> RealInterval a b

-- | Inclusive or exclusive bounds.
data Inclusive
Inc :: Inclusive
Exc :: Inclusive

-- | Describes the domain of a <a>Symbol</a> given a topology. Can be
--   bounded or encase all of the domain.
data DomainDesc (tplgy :: RTopology) a b
[BoundedDD] :: Symbol -> RTopology -> a -> b -> DomainDesc 'Discrete a b
[AllDD] :: Symbol -> RTopology -> DomainDesc 'Continuous a b

-- | Topology of a subset of reals.
data RTopology
Continuous :: RTopology
Discrete :: RTopology
type DiscreteDomainDesc a b = DomainDesc 'Discrete a b
type ContinuousDomainDesc a b = DomainDesc 'Continuous a b

-- | HasSpace is anything which has a <a>Space</a>.
class HasSpace c

-- | Provides a <a>Getter</a> to the <a>Space</a>.
typ :: HasSpace c => Getter c Space

-- | Gets the name of an <a>Actor</a>.
getActorName :: Space -> String

-- | Gets the inner <a>Space</a> of a vector or set.
getInnerSpace :: Space -> Space
mkFunction :: [Primitive] -> Primitive -> Space

-- | Is this Space a basic numeric space?
isBasicNumSpace :: Space -> Bool

-- | Assert that a <a>Space</a> is <a>Space</a> or return a formatted error
--   message.
assertReal :: Space -> (String -> String) -> Either String ()

-- | Assert that a <a>Space</a> is "numeric" or return a formatted error
--   message.
assertNumeric :: Space -> (String -> String) -> Either String ()

-- | Assert that a numeric <a>Space</a> is not <a>Natural</a> or return a
--   formatted error message.
assertNonNatNumeric :: Space -> (String -> String) -> Either String ()

-- | Assert that two numeric <a>Space</a>s are equivalent or return a
--   formatted error message.
assertEquivNumeric :: Space -> Space -> (String -> String -> String) -> Either String ()

-- | Assert that a <a>Space</a> is an index-like type (Integer or Natural)
--   or return a formatted error message.
assertIndexLike :: Space -> (String -> String) -> Either String ()

-- | Assert that a <a>Space</a> is a <a>Boolean</a> or return a formatted
--   error message.
assertBoolean :: Space -> (String -> String) -> Either String ()

-- | Assert that a <a>Space</a> is a <a>Set</a> and return either the
--   element type or a formatted error message.
assertSet :: Space -> (String -> String) -> Either String Space

-- | Assert that a <a>Space</a> is a <a>Vect</a> and return either the
--   element type or a formatted error message.
assertVector :: Space -> (String -> String) -> Either String Space

-- | Assert that a <a>Space</a> is a numeric vector (i.e., a vector of a
--   basic numeric type) and return either the numeric type or a formatted
--   error message.
assertNumericVector :: Space -> (String -> String) -> Either String Space

-- | Assert that a <a>Space</a> is a non-<a>Natural</a> numeric vector and
--   return either the numeric type or a formatted error message.
assertNonNatNumVector :: (String -> String) -> Space -> Either String Space

-- | Assert that a <a>Space</a> is a <a>Vect</a> of <a>Space</a>s or return
--   a formatted error message.
assertRealVector :: Space -> (String -> String) -> Either String ()

-- | Assert that a <a>Space</a> is a <a>Function</a>, returning either the
--   parameters and output type or a formatted error message.
assertFunction :: Space -> (String -> String) -> Either String (NonEmpty Primitive, Primitive)

-- | Assert that a <a>Space</a> is anything but a <a>Function</a> or return
--   a formatted error message.
assertNonFunction :: Space -> (String -> String) -> Either String ()
instance GHC.Show.Show Language.Drasil.Space.Space
instance GHC.Classes.Eq Language.Drasil.Space.Space


-- | Alphabet of capital/lowercase English letters as symbols.
module Language.Drasil.ShortHands

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cA :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cB :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cC :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cD :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cE :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cF :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cG :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cH :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cI :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cJ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cK :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cL :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cM :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cN :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cO :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cP :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cQ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cR :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cS :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cT :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cU :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cV :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cW :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cX :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cY :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cZ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lA :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lB :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lC :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lD :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lE :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lF :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lG :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lH :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lI :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lJ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lK :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lL :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lM :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lN :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lO :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lP :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lQ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lR :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lS :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lT :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lU :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lV :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lW :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lX :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lY :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lZ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lAlpha :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cAlpha :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lBeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cBeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lGamma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cGamma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lDelta :: Symbol

-- | <tt>Δ</tt> is often used as a decoration on top of a symbol. For
--   example, <tt>Δx</tt> and <tt>Δy</tt> represent the change in x and the
--   change in y. The variable defined here represents delta as its own
--   independent symbol and should not be used to represent "the change in"
--   something.
--   
--   Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cDelta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lEpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
vEpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cEpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lZeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cZeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lEta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cEta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lTheta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cTheta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lIota :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cIota :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lKappa :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cKappa :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lLambda :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cLambda :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lMu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cMu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lNu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cNu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lXi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cXi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lOmicron :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cOmicron :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cPi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lRho :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cRho :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lSigma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cSigma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lTau :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cTau :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lUpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cUpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPhi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
vPhi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cPhi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lChi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cChi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPsi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cPsi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lOmega :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cOmega :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lNabla :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lEll :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPosInf :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lNegInf :: Symbol


-- | Re-export display-related functions and types to simplify external
--   use.
module Language.Drasil.Display

-- | Decorations on symbols/characters such as hats or Vector
--   representations (determines bolding, italics, etc).
data Decoration

-- | Places a <tt>^</tt> on top of a symbol.
Hat :: Decoration

-- | Makes a symbol bold.
Vector :: Decoration

-- | Appends a <tt>'</tt> to a symbol.
Prime :: Decoration

-- | Prepends a <tt>Δ</tt> to a symbol.
Delta :: Decoration

-- | Places <tt>||</tt> before and after a symbol.
Magnitude :: Decoration

-- | A <a>Symbol</a> is actually going to be a graphical description of
--   what gets rendered as a (unique) symbol. This is actually NOT based on
--   semantics at all, but just a description of how things look.
--   
--   Symbols can be:
--   
--   <ul>
--   <li><tt><a>Variable</a></tt> (string such as "x" that represent a
--   value that can vary)</li>
--   <li><tt><a>Label</a></tt> (strings such as "max" or "target" that
--   represent a single idea)</li>
--   <li><tt><a>Symbol</a></tt> characters (ex. unicode)</li>
--   <li><tt>Decorated</tt> symbols using <a>Atop</a></li>
--   <li><tt>Concatenations</tt> of symbols, including subscripts and
--   superscripts</li>
--   <li><tt><a>Empty</a></tt>! (this is to give this a monoid-like
--   flavour)</li>
--   </ul>
data Symbol

-- | Basic variable name creation.
Variable :: String -> Symbol

-- | For when symbols need more context, but we don't want to add a new
--   variable name. For example, <tt>v_f</tt> may be encoded as <tt>Concat
--   [variable "v", label "f"]</tt>.
Label :: String -> Symbol

-- | For using numbers in Symbols.
Integ :: Int -> Symbol

-- | For now, special characters are the degree and partial differentiation
--   symbols. These should eventually move elsewhere and the <a>Symbol</a>
--   type removed.
Special :: Special -> Symbol

-- | Used to decorate symbols. For things like vectors (which need to be
--   bold), primes, magnitudes, etc. See <a>Decoration</a> for more
--   details.
Atop :: Decoration -> Symbol -> Symbol

-- | Order of Symbols: upleft lowleft upright lowright base. Ex:
--   
--   <pre>
--   Corners [1]   [2]   [3]   [4]   [5]
--   </pre>
--   
--   <pre>
--   Visually:  [1]   [3]
--   
--                 [5]
--   
--              [2]   [4]
--   </pre>
Corners :: [Symbol] -> [Symbol] -> [Symbol] -> [Symbol] -> Symbol -> Symbol

-- | Concatentation of two symbols: <tt>[s1, s2] -&gt; s1s2</tt>
Concat :: [Symbol] -> Symbol

-- | Placeholder for when a symbol is not needed.
Empty :: Symbol

-- | The default compare function that sorts all the lower case symbols
--   after the upper case ones.
--   
--   Comparation is used twice for each <tt>Atomic</tt> case, once for
--   making sure they are the same letter, once for case sensitive. As far
--   as this comparison is considered, <tt>Δ</tt> is a "decoration" and
--   ignored unless the compared symbols are the exact same, in which case
--   it is ordered after the undecorated symbol.
--   
--   Superscripts and subscripts are ordered after the base symbols
--   (because they add additional context to a symbol). For example:
--   `v_f^{AB}` (expressed in LaTeX notation for clarity), where
--   <tt>v_f</tt> is a final velocity, and the `^{AB}` adds context that it
--   is the final velocity between points <tt>A</tt> and <tt>B</tt>. In
--   these cases, the sorting of `v_f^{AB}` should be following
--   <tt>v_f</tt> as it is logical to place it with its parent concept.
compsy :: Symbol -> Symbol -> Ordering

module Drasil.Code.Classes

-- | Members must have a named argument.
class HasSymbol c => IsArgumentName c

-- | Some chunks can be called like functions.
class HasSymbol c => Callable c


-- | Language for defining and manipulating units.
module Language.Drasil.UnitLang

-- | Language of units (how to build them up into a unit symbol). Of the
--   form (<a>Symbol</a> ^ <a>Integer</a>). The <a>Integer</a> may be
--   negative, but should not be zero.
newtype USymb
US :: [(Symbol, Integer)] -> USymb

-- | Language of unit equations, to define a unit relative to another.
data UDefn

-- | to define straight synonyms.
USynonym :: USymb -> UDefn

-- | scale, i.e. *.
UScale :: Double -> USymb -> UDefn

-- | shift, i.e. +.
UShift :: Double -> USymb -> UDefn

-- | When we define units, they come in three flavours: SI (base) units,
--   derived SI units (aka synonyms), and defined units. The type below
--   captures that knowledge.
data UnitSymbol
BaseSI :: USymb -> UnitSymbol
DerivedSI :: USymb -> USymb -> UDefn -> UnitSymbol
Defined :: USymb -> UDefn -> UnitSymbol

-- | Generates a default unit symbol.
fromUDefn :: UDefn -> USymb

-- | Hand-rolled version of compare. Should assume <a>USymb</a> is
--   normalized, so that some redundant EQ cases can be removed.
compUSymb :: USymb -> USymb -> Ordering

-- | Generates a default unit symbol.
getUSymb :: UnitSymbol -> USymb

-- | Gets the unit definition of a unit symbol.
getDefn :: UnitSymbol -> Maybe UDefn
instance GHC.Classes.Eq Language.Drasil.UnitLang.USymb

module Language.Drasil.WellTyped
type TypeError = String

-- | We can only type check <a>UID</a>s within a type context relating
--   <a>UID</a>s to types since they don't carry any type information.
type TypingContext t = Map UID t

-- | Look for a known type of a specific <a>UID</a>.
inferFromContext :: TypingContext t -> UID -> Either TypeError t

-- | Build a bidirectional type checker for your expression language, e,
--   with respect to a specific type universe, t.
class (Eq t, Show t) => Typed e t

-- | Given a typing context and an expression, infer a unique type or
--   explain what went awry.
infer :: Typed e t => TypingContext t -> e -> Either TypeError t

-- | Given a typing context, an expression, and an expected type, check if
--   the expression can satisfy the expectation.
check :: Typed e t => TypingContext t -> e -> t -> Either TypeError t

-- | For all containers, c, which contain typed expressions, e, against a
--   specific type universe, t, expose all expressions and relations that
--   need to be type-checked.
class Typed e t => RequiresChecking c e t

-- | All things that need type checking.
requiredChecks :: RequiresChecking c e t => c -> [(e, t)]
assertEq :: (Show t, Eq t) => t -> t -> (String -> String -> TypeError) -> Either TypeError ()
(~==) :: (Show t, Eq t) => t -> t -> (String -> String -> TypeError) -> Either TypeError ()
infix 4 ~==

-- | `<tt>Check'</tt> an expressions type based by an inference.
typeCheckByInfer :: Typed e t => TypingContext t -> e -> t -> Either TypeError t
assertAllEq :: Typed e t => TypingContext t -> [e] -> t -> TypeError -> Either TypeError ()

-- | A temporary, hacky, indentation function. It should be removed when we
--   switch to using something else for error messages, which can be later
--   formatted nicely.
temporaryIndent :: String -> String -> String

module Language.Drasil.Literal.Lang
data Literal
[Int] :: Integer -> Literal
[Str] :: String -> Literal
[Dbl] :: Double -> Literal
[ExactDbl] :: Integer -> Literal
[Perc] :: Integer -> Integer -> Literal
instance GHC.Classes.Eq Language.Drasil.Literal.Lang.Literal
instance Language.Drasil.WellTyped.Typed Language.Drasil.Literal.Lang.Literal Language.Drasil.Space.Space

module Language.Drasil.Literal.Development
data Literal
[Int] :: Integer -> Literal
[Str] :: String -> Literal
[Dbl] :: Double -> Literal
[ExactDbl] :: Integer -> Literal
[Perc] :: Integer -> Integer -> Literal

module Language.Drasil.Literal.Class
class LiteralC r
int :: LiteralC r => Integer -> r
str :: LiteralC r => String -> r
dbl :: LiteralC r => Double -> r
exactDbl :: LiteralC r => Integer -> r
perc :: LiteralC r => Integer -> Integer -> r
instance Language.Drasil.Literal.Class.LiteralC Language.Drasil.Literal.Lang.Literal


-- | The Drasil Expression language
module Language.Drasil.Expr.Lang

-- | A relation is just an expression (<a>Expr</a>).
type Relation = Expr

-- | The variable type is just a renamed <a>String</a>.
type Variable = String

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Index operator. <a>Index</a> represents accessing an element at a
--   specific index, while <a>IndexOf</a> represents finding the index of a
--   specific element.
data LABinOp
Index :: LABinOp
IndexOf :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product, addition, subtraction).
data VVVBinOp
Cross :: VVVBinOp
VAdd :: VVVBinOp
VSub :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | <tt>Number x Vector -&gt; Vector</tt> binary operations (scaling).
data NVVBinOp
Scale :: NVVBinOp

-- | Element + Set -&gt; Set
data ESSBinOp
SAdd :: ESSBinOp
SRemove :: ESSBinOp

-- | Element + Set -&gt; Bool
data ESBBinOp
SContains :: ESBBinOp
data AssocConcatOper
SUnion :: AssocConcatOper

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
Add :: AssocArithOper
Mul :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | For case expressions (either complete or incomplete).
data Completeness
Complete :: Completeness
Incomplete :: Completeness

-- | Expression language where all terms are supposed to be 'well
--   understood' (i.e., have a definite meaning). Right now, this coincides
--   with "having a definite value", but should not be restricted to that.
data Expr

-- | Brings a literal into the expression language.
[Lit] :: Literal -> Expr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [Expr] -> Expr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [Expr] -> Expr
[AssocC] :: AssocConcatOper -> [Expr] -> Expr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> Expr

-- | Function applications.
[FCall] :: UID -> [Expr] -> Expr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(Expr, Relation)] -> Expr

-- | Represents a matrix of expressions.
[Matrix] :: [[Expr]] -> Expr

-- | Represents a set of expressions
[Set] :: Space -> [Expr] -> Expr

-- | used to refernce the (name + type = variable )
[Variable] :: String -> Expr -> Expr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> Expr -> Expr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> Expr -> Expr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> Expr -> Expr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> Expr -> Expr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> Expr -> Expr -> Expr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> Expr -> Expr -> Expr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> Expr -> Expr -> Expr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> Expr -> Expr -> Expr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Expr x Vector -&gt; Vector</tt> operations
--   (scaling).
[NVVBinaryOp] :: NVVBinOp -> Expr -> Expr -> Expr

-- | Set operator for Element + Set -&gt; Set
[ESSBinaryOp] :: ESSBinOp -> Expr -> Expr -> Expr

-- | Set operator for Element + Set -&gt; Bool
[ESBBinaryOp] :: ESBBinOp -> Expr -> Expr -> Expr

-- | Operators are generalized arithmetic operators over a
--   <tt>DomainDesc</tt> of an <a>Expr</a>. Could be called BigOp. ex:
--   Summation is represented via <a>Add</a> over a discrete domain.
[Operator] :: AssocArithOper -> DiscreteDomainDesc Expr Expr -> Expr -> Expr

-- | A different kind of <tt>IsIn</tt>. A <a>UID</a> is an element of an
--   interval.
[RealI] :: UID -> RealInterval Expr Expr -> Expr
class Pretty p
pretty :: Pretty p => p -> String
vvvInfer :: TypingContext Space -> VVVBinOp -> Expr -> Expr -> Either TypeError Space
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.ArithBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.EqBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.BoolBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.LABinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.OrdBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.VVVBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.VVNBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.NVVBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.ESSBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.ESBBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.AssocConcatOper
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.AssocArithOper
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.AssocBoolOper
instance GHC.Show.Show Language.Drasil.Expr.Lang.UFunc
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.UFunc
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.UFuncB
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.UFuncVV
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.UFuncVN
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.Completeness
instance Language.Drasil.Expr.Lang.Pretty Language.Drasil.Expr.Lang.VVVBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.Expr
instance Language.Drasil.Literal.Class.LiteralC Language.Drasil.Expr.Lang.Expr
instance Language.Drasil.WellTyped.Typed Language.Drasil.Expr.Lang.Expr Language.Drasil.Space.Space


-- | The Drasil Modelling Expression language
module Language.Drasil.ModelExpr.Lang

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp
IndexOf :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product, vector addition, subtraction).
data VVVBinOp
Cross :: VVVBinOp
VAdd :: VVVBinOp
VSub :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | <tt>Number x Vector -&gt; Vector</tt> binary operations (scaling).
data NVVBinOp
Scale :: NVVBinOp

-- | Element + Set -&gt; Set
data ESSBinOp
SAdd :: ESSBinOp
SRemove :: ESSBinOp

-- | Element + Set -&gt; Bool
data ESBBinOp
SContains :: ESBBinOp
data AssocConcatOper
SUnion :: AssocConcatOper

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
Add :: AssocArithOper
Mul :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper
Equivalence :: AssocBoolOper

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | Statements involving 2 arguments.
data StatBinOp
Defines :: StatBinOp

-- | <tt>Value -&gt; Space -&gt; Bool</tt> operators.
data SpaceBinOp
IsIn :: SpaceBinOp

-- | Determines the type of the derivative (either a partial derivative or
--   a total derivative).
data DerivType
Part :: DerivType
Total :: DerivType

-- | Expression language where all terms are supposed to have a meaning,
--   but that meaning may not be that of a definite value. For example,
--   specification expressions, especially with quantifiers, belong here.
data ModelExpr

-- | Brings a literal into the expression language.
[Lit] :: Literal -> ModelExpr

-- | Introduce Space values into the expression language.
[Spc] :: Space -> ModelExpr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [ModelExpr] -> ModelExpr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [ModelExpr] -> ModelExpr
[AssocC] :: AssocConcatOper -> [ModelExpr] -> ModelExpr

-- | Derivative syntax is: Type (<a>Part</a>ial or <a>Total</a>) -&gt;
--   principal part of change -&gt; with respect to For example: Deriv Part
--   y x1 would be (dy/dx1).
[Deriv] :: Integer -> DerivType -> ModelExpr -> UID -> ModelExpr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> ModelExpr

-- | Function applications.
[FCall] :: UID -> [ModelExpr] -> ModelExpr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(ModelExpr, ModelExpr)] -> ModelExpr

-- | Represents a matrix of expressions.
[Matrix] :: [[ModelExpr]] -> ModelExpr

-- | Represents a set of expressions
[Set] :: Space -> [ModelExpr] -> ModelExpr

-- | used to refernce the (name + type = variable )
[Variable] :: String -> ModelExpr -> ModelExpr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> ModelExpr -> ModelExpr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Space-related binary operations.
[SpaceBinaryOp] :: SpaceBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Statement-related binary operations.
[StatBinaryOp] :: StatBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for <tt>Number x Vector -&gt; Vector</tt> operations
--   (scaling).
[NVVBinaryOp] :: NVVBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Set operator for Element + Set -&gt; Set
[ESSBinaryOp] :: ESSBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Set operator for Element + Set -&gt; Bool
[ESBBinaryOp] :: ESBBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Operators are generalized arithmetic operators over a
--   <a>DomainDesc</a> of an <tt>Expr</tt>. Could be called BigOp. ex:
--   Summation is represented via <a>Add</a> over a discrete domain.
[Operator] :: AssocArithOper -> DomainDesc t ModelExpr ModelExpr -> ModelExpr -> ModelExpr

-- | A different kind of <a>IsIn</a>. A <a>UID</a> is an element of an
--   interval.
[RealI] :: UID -> RealInterval ModelExpr ModelExpr -> ModelExpr

-- | Universal quantification
[ForAll] :: UID -> Space -> ModelExpr -> ModelExpr

-- | The variable type is just a renamed <a>String</a>.
type Variable = String
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.ArithBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.EqBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.BoolBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.LABinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.OrdBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.VVVBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.VVNBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.NVVBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.ESSBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.ESBBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.AssocConcatOper
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.AssocArithOper
instance GHC.Show.Show Language.Drasil.ModelExpr.Lang.AssocBoolOper
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.AssocBoolOper
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.UFunc
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.UFuncB
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.UFuncVV
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.UFuncVN
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.StatBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.SpaceBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.DerivType
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.ModelExpr
instance Language.Drasil.Literal.Class.LiteralC Language.Drasil.ModelExpr.Lang.ModelExpr


-- | Defines operator precedence.
module Language.Drasil.ModelExpr.Precedence

-- | prec2Arith - precedence for arithmetic-related binary operations.
prec2Arith :: ArithBinOp -> Int

-- | prec2Bool - precedence for boolean-related binary operations.
prec2Bool :: BoolBinOp -> Int

-- | prec2Eq - precedence for equality-related binary operations.
prec2Eq :: EqBinOp -> Int

-- | prec2LA - precedence for access-related binary operations.
prec2LA :: LABinOp -> Int

-- | prec2Ord - precedence for order-related binary operations.
prec2Ord :: OrdBinOp -> Int
prec2Spc :: SpaceBinOp -> Int
prec2Stat :: StatBinOp -> Int

-- | prec2VVV - precedence for Vec-&gt;Vec-&gt;Vec-related binary
--   operations.
prec2VVV :: VVVBinOp -> Int

-- | prec2VVN - precedence for Vec-&gt;Vec-&gt;Num-related binary
--   operations.
prec2VVN :: VVNBinOp -> Int

-- | prec2NVV - precedence for Num-&gt;Vec-&gt;Vec-related binary
--   operations.
prec2NVV :: NVVBinOp -> Int
prec2ESS :: ESSBinOp -> Int
prec2ESB :: ESBBinOp -> Int

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int
precC :: AssocConcatOper -> Int

-- | prec1 - precedence of unary operators.
prec1 :: UFunc -> Int

-- | prec1B - precedence of boolean-related unary operators.
prec1B :: UFuncB -> Int

-- | prec1VV - precedence of vector-vector-related unary operators.
prec1VV :: UFuncVV -> Int

-- | prec1Vec - precedence of vector-number-related unary operators.
prec1VN :: UFuncVN -> Int

-- | eprec - <a>ModelExpr</a> precedence.
mePrec :: ModelExpr -> Int


-- | Defines functions to find Chunk UIDs within <a>ModelExpr</a>s.
module Language.Drasil.ModelExpr.Extract

-- | Generic traverse of all expressions that could lead to names.
meNames :: ModelExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>meNames</a>).
meNamesRI :: RealInterval ModelExpr ModelExpr -> [UID]

-- | Generic traverse of all positions that could lead to <a>meNames</a>
--   without functions. FIXME : this should really be done via post-facto
--   filtering, but right now the information needed to do this is not
--   available!
meNames' :: ModelExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names without functions (similar to <a>meNames'</a>).
meNamesRI' :: RealInterval ModelExpr ModelExpr -> [UID]

-- | Get dependencies from an equation.
meDep :: ModelExpr -> [UID]

module Language.Drasil.ModelExpr.Class

-- | Helper for creating new smart constructors for Associative Binary
--   operations that require at least 1 expression.
assocCreate :: AssocBoolOper -> [ModelExpr] -> ModelExpr

-- | Helper for associative operations, removes embedded variants of the
--   same kind
assocSanitize :: AssocBoolOper -> [ModelExpr] -> [ModelExpr]
class ModelExprC r

-- | Gets the derivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
deriv :: (ModelExprC r, HasUID c, HasSymbol c) => r -> c -> r

-- | Gets the derivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
pderiv :: (ModelExprC r, HasUID c, HasSymbol c) => r -> c -> r

-- | Gets the nthderivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
nthderiv :: (ModelExprC r, HasUID c, HasSymbol c) => Integer -> r -> c -> r

-- | Gets the nthderivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
nthpderiv :: (ModelExprC r, HasUID c, HasSymbol c) => Integer -> r -> c -> r

-- | One expression is "defined" by another.
defines :: ModelExprC r => r -> r -> r

-- | Space literals.
space :: ModelExprC r => Space -> r

-- | Check if a value belongs to a Space.
isIn :: ModelExprC r => r -> Space -> r

-- | Binary associative <a>Equivalence</a>.
equiv :: ModelExprC r => [r] -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
intAll :: ModelExprC r => Symbol -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
sumAll :: ModelExprC r => Symbol -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
prodAll :: ModelExprC r => Symbol -> r -> r
instance Language.Drasil.ModelExpr.Class.ModelExprC Language.Drasil.ModelExpr.Lang.ModelExpr


-- | Defines functions to convert from the base expression language to
--   <a>ModelExpr</a>s.
module Language.Drasil.ModelExpr.Convert
assocArithOper :: AssocArithOper -> AssocArithOper
assocBoolOper :: AssocBoolOper -> AssocBoolOper
assocConcatOper :: AssocConcatOper -> AssocConcatOper
uFunc :: UFunc -> UFunc
uFuncB :: UFuncB -> UFuncB
uFuncVV :: UFuncVV -> UFuncVV
uFuncVN :: UFuncVN -> UFuncVN
arithBinOp :: ArithBinOp -> ArithBinOp
boolBinOp :: BoolBinOp -> BoolBinOp
eqBinOp :: EqBinOp -> EqBinOp
laBinOp :: LABinOp -> LABinOp
ordBinOp :: OrdBinOp -> OrdBinOp
vvvBinOp :: VVVBinOp -> VVVBinOp
vvnBinOp :: VVNBinOp -> VVNBinOp
nvvBinOp :: NVVBinOp -> NVVBinOp
essBinOp :: ESSBinOp -> ESSBinOp
esbBinOp :: ESBBinOp -> ESBBinOp
expr :: Expr -> ModelExpr
realInterval :: RealInterval Expr Expr -> RealInterval ModelExpr ModelExpr
domainDesc :: DiscreteDomainDesc Expr Expr -> DiscreteDomainDesc ModelExpr ModelExpr


-- | Re-export functions and types related to <a>ModelExpr</a>
module Language.Drasil.ModelExpr.Development

-- | Expression language where all terms are supposed to have a meaning,
--   but that meaning may not be that of a definite value. For example,
--   specification expressions, especially with quantifiers, belong here.
data ModelExpr

-- | Brings a literal into the expression language.
[Lit] :: Literal -> ModelExpr

-- | Introduce Space values into the expression language.
[Spc] :: Space -> ModelExpr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [ModelExpr] -> ModelExpr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [ModelExpr] -> ModelExpr
[AssocC] :: AssocConcatOper -> [ModelExpr] -> ModelExpr

-- | Derivative syntax is: Type (<a>Part</a>ial or <a>Total</a>) -&gt;
--   principal part of change -&gt; with respect to For example: Deriv Part
--   y x1 would be (dy/dx1).
[Deriv] :: Integer -> DerivType -> ModelExpr -> UID -> ModelExpr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> ModelExpr

-- | Function applications.
[FCall] :: UID -> [ModelExpr] -> ModelExpr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(ModelExpr, ModelExpr)] -> ModelExpr

-- | Represents a matrix of expressions.
[Matrix] :: [[ModelExpr]] -> ModelExpr

-- | Represents a set of expressions
[Set] :: Space -> [ModelExpr] -> ModelExpr

-- | used to refernce the (name + type = variable )
[Variable] :: String -> ModelExpr -> ModelExpr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> ModelExpr -> ModelExpr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Space-related binary operations.
[SpaceBinaryOp] :: SpaceBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Statement-related binary operations.
[StatBinaryOp] :: StatBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for <tt>Number x Vector -&gt; Vector</tt> operations
--   (scaling).
[NVVBinaryOp] :: NVVBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Set operator for Element + Set -&gt; Set
[ESSBinaryOp] :: ESSBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Set operator for Element + Set -&gt; Bool
[ESBBinaryOp] :: ESBBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Operators are generalized arithmetic operators over a
--   <a>DomainDesc</a> of an <tt>Expr</tt>. Could be called BigOp. ex:
--   Summation is represented via <a>Add</a> over a discrete domain.
[Operator] :: AssocArithOper -> DomainDesc t ModelExpr ModelExpr -> ModelExpr -> ModelExpr

-- | A different kind of <a>IsIn</a>. A <a>UID</a> is an element of an
--   interval.
[RealI] :: UID -> RealInterval ModelExpr ModelExpr -> ModelExpr

-- | Universal quantification
[ForAll] :: UID -> Space -> ModelExpr -> ModelExpr

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp
IndexOf :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Value -&gt; Space -&gt; Bool</tt> operators.
data SpaceBinOp
IsIn :: SpaceBinOp

-- | Statements involving 2 arguments.
data StatBinOp
Defines :: StatBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product, vector addition, subtraction).
data VVVBinOp
Cross :: VVVBinOp
VAdd :: VVVBinOp
VSub :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | <tt>Number x Vector -&gt; Vector</tt> binary operations (scaling).
data NVVBinOp
Scale :: NVVBinOp

-- | Element + Set -&gt; Set
data ESSBinOp
SAdd :: ESSBinOp
SRemove :: ESSBinOp

-- | Element + Set -&gt; Bool
data ESBBinOp
SContains :: ESBBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
Add :: AssocArithOper
Mul :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper
Equivalence :: AssocBoolOper
data AssocConcatOper
SUnion :: AssocConcatOper

-- | Determines the type of the derivative (either a partial derivative or
--   a total derivative).
data DerivType
Part :: DerivType
Total :: DerivType

-- | For case expressions (either complete or incomplete).
data Completeness
Complete :: Completeness
Incomplete :: Completeness
expr :: Expr -> ModelExpr

-- | Get dependencies from an equation.
meDep :: ModelExpr -> [UID]

-- | eprec - <a>ModelExpr</a> precedence.
mePrec :: ModelExpr -> Int
precC :: AssocConcatOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int


-- | Defines classes for use with Drasil's expression language.
module Language.Drasil.ExprClasses

-- | Data that can be expressed using <a>ModelExpr</a>.
class Express c
express :: Express c => c -> ModelExpr
instance Language.Drasil.ExprClasses.Express Language.Drasil.Literal.Lang.Literal
instance Language.Drasil.ExprClasses.Express Language.Drasil.Expr.Lang.Expr
instance Language.Drasil.ExprClasses.Express Language.Drasil.ModelExpr.Lang.ModelExpr


-- | Contains Sentences and helpers functions.
module Language.Drasil.Sentence

-- | For writing <a>Sentence</a>s via combining smaller elements.
--   <a>Sentence</a>s are made up of some known vocabulary of things:
--   
--   <ul>
--   <li>units (their visual representation)</li>
--   <li>words (via <a>String</a>s)</li>
--   <li>special characters</li>
--   <li>accented letters</li>
--   <li>references to specific layout objects</li>
--   </ul>
data Sentence

-- | Ch looks up the term for a given <a>UID</a> and displays the term with
--   a given <a>SentenceStyle</a> and <tt>CapitalizationRule</tt>. This
--   allows Sentences to hold plural forms of <tt>NounPhrase</tt>s and
--   <tt>NamedIdea</tt>s.
[Ch] :: SentenceStyle -> TermCapitalization -> UID -> Sentence

-- | A branch of Ch dedicated to SymbolStyle only.
[SyCh] :: UID -> Sentence

-- | Converts a unit symbol into a usable Sentence form.
[Sy] :: USymb -> Sentence

-- | Constructor for <a>String</a>s, used often for descriptions in Chunks.
[S] :: String -> Sentence

-- | Converts the graphical representation of a symbol into a usable
--   Sentence form.
[P] :: Symbol -> Sentence

-- | Lifts an expression into a Sentence.
[E] :: ModelExpr -> Sentence

-- | Takes a <a>UID</a> to a reference, a display name (<a>Sentence</a>),
--   and any additional reference display information (<a>RefInfo</a>).
--   Resolves the reference later (similar to Ch).
[Ref] :: UID -> Sentence -> RefInfo -> Sentence

-- | Adds quotation marks around a Sentence.
[Quote] :: Sentence -> Sentence

-- | Used for a % symbol.
[Percent] :: Sentence

-- | Direct concatenation of two Sentences (no implicit spaces!).
[:+:] :: Sentence -> Sentence -> Sentence

-- | Empty Sentence.
[EmptyS] :: Sentence
infixr 5 :+:

-- | Used in <a>Ch</a> constructor to determine the state of a term (can
--   record whether something is in plural form, a singular term, or in
--   short form).
data SentenceStyle
PluralTerm :: SentenceStyle
TermStyle :: SentenceStyle
ShortStyle :: SentenceStyle

-- | Holds any extra information needed for a <tt>Reference</tt>, be it an
--   equation, pages, a note, or nothing.
data RefInfo
None :: RefInfo
Equation :: [Int] -> RefInfo
Page :: [Int] -> RefInfo
RefNote :: String -> RefInfo

-- | Used in <a>Ch</a> constructor to determine the capitalization of a
--   term. CapF is for capitalizing the first word from the <a>UID</a> of
--   the given term. CapW is for capitalizing all words from the <a>UID</a>
--   of the given term. Mirrors <tt>CapFirst</tt> and <tt>CapWords</tt>
--   from <tt>CapitalizationRule</tt>.
data TermCapitalization
CapF :: TermCapitalization
CapW :: TermCapitalization
NoCap :: TermCapitalization

-- | Helper for concatenating two <a>Sentence</a>s with a space between
--   them.
(+:+) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two <a>Sentence</a>s using <a>+:+</a> and
--   appends a period.
(+:+.) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two sentences using <a>+:+</a> and appends a
--   colon.
(+:) :: Sentence -> Sentence -> Sentence

-- | Helper which appends a period to the end of a <a>Sentence</a> (used
--   often as a post-fix operator).
(!.) :: Sentence -> Sentence

-- | Capitalizes a Sentence.
capSent :: Sentence -> Sentence

-- | Helper which creates a Header with size s of the <a>Sentence</a>.
headSent :: Int -> Sentence -> Sentence

-- | Gets a symbol and places it in a <a>Sentence</a>.
ch :: (HasUID c, HasSymbol c) => c -> Sentence
eS :: ModelExpr -> Sentence
eS' :: Express t => t -> Sentence

-- | Helper for concatenating two <a>Sentence</a>s with a comma and space
--   between them.
sC :: Sentence -> Sentence -> Sentence

-- | Helper for concatenating two <a>Sentence</a>s with a space-surrounded
--   dash between them.
sDash :: Sentence -> Sentence -> Sentence

-- | Helper for wrapping <a>Sentence</a>s in parentheses.
sParen :: Sentence -> Sentence

-- | Gets plural term of <a>UID</a>.
--   
--   Smart constructors for turning a <a>UID</a> into a <a>Sentence</a>.
sentencePlural :: UID -> Sentence

-- | Gets short form of <a>UID</a>.
--   
--   Smart constructors for turning a <a>UID</a> into a <a>Sentence</a>.
sentenceShort :: UID -> Sentence

-- | Gets symbol form of <a>UID</a>.
--   
--   Smart constructors for turning a <a>UID</a> into a <a>Sentence</a>.
sentenceSymb :: UID -> Sentence

-- | Gets singular form of <a>UID</a>.
--   
--   Smart constructors for turning a <a>UID</a> into a <a>Sentence</a>.
sentenceTerm :: UID -> Sentence
instance GHC.Base.Semigroup Language.Drasil.Sentence.Sentence
instance GHC.Base.Monoid Language.Drasil.Sentence.Sentence


-- | Short names are used for displaying references.
module Language.Drasil.ShortName

-- | Used for holding the short form of a name (as a <a>Sentence</a> with a
--   wrapper).
newtype ShortName
ShortNm :: Sentence -> ShortName

-- | A <a>ShortName</a> is the text to be displayed for a link.
--   
--   Used for referencing within a document that can include symbols and
--   whatnot if required. Visible in the typeset documents (pdf).
class HasShortName s
shortname :: HasShortName s => s -> ShortName

-- | Pulls the short form (as a <a>Sentence</a>) out of a <a>ShortName</a>.
getSentSN :: ShortName -> Sentence

-- | Smart constructor for making a <a>Sentence</a> into a
--   <a>ShortName</a>.
shortname' :: Sentence -> ShortName


-- | Extract various kinds of UIDs from a Sentence. Used in conjunction
--   with the chunk database in order to render terms, symbols, and
--   references properly.
module Language.Drasil.Sentence.Extract

-- | This is to collect <i>symbolic</i> <a>UID</a>s that are printed out as
--   a <tt>Symbol</tt>.
sdep :: Sentence -> [UID]
shortdep :: Sentence -> [UID]

-- | Generic traverse of all positions that could lead to <i>reference</i>
--   <a>UID</a>s from <a>Sentence</a>s.
lnames :: Sentence -> [UID]

-- | Get <i>reference</i> <a>UID</a>s from <a>Sentence</a>s.
lnames' :: [Sentence] -> [UID]


-- | Defines a type used to hold referencing information.
module Language.Drasil.Reference

-- | A Reference contains the identifier (<a>UID</a>), a reference address
--   (<a>LblType</a>), a human-readable shortname (<a>ShortName</a>), and
--   any extra information about the reference (<a>RefInfo</a>).
data Reference
Reference :: UID -> LblType -> ShortName -> Reference

-- | A class that contains a list of <a>Reference</a>s.
class HasReference c

-- | Provides a <tt>Lens</tt> to the <a>Reference</a>s.
getReferences :: HasReference c => Lens' c [Reference]

-- | Projector function that creates a <a>Reference</a> from something
--   <tt>Referable</tt>.
ref :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Reference

-- | Takes the reference <a>UID</a> and wraps it into a <a>Sentence</a>.
refS :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence

-- | Takes a <a>Reference</a> with a name to be displayed and wraps it into
--   a <a>Sentence</a>. Does not overwrite the shortname contained in the
--   reference, but will only display as the given <a>Sentence</a>.
namedRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence -> Sentence

-- | Takes a <a>Reference</a> with additional display info. Uses the
--   internal shortname for its display name.
complexRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> RefInfo -> Sentence

-- | Takes a <a>Reference</a> with a name to be displayed and any
--   additional information and wraps it into a <a>Sentence</a>. Does not
--   overwrite the shortname contained in the reference, but will only
--   display as the given <a>Sentence</a> along with the given
--   <a>RefInfo</a>.
namedComplexRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence -> RefInfo -> Sentence
instance GHC.Classes.Eq Language.Drasil.Reference.Reference
instance Drasil.Database.UID.HasUID Language.Drasil.Reference.Reference
instance Language.Drasil.Label.Type.HasRefAddress Language.Drasil.Reference.Reference
instance Language.Drasil.ShortName.HasShortName Language.Drasil.Reference.Reference


-- | Noun phrases are used to hold terms with knowledge of proper
--   capitalization and pluralization.
module Language.Drasil.NounPhrase.Core

-- | Capitalization rules.
data CapitalizationRule

-- | Capitalize the first letter of the first word only.
CapFirst :: CapitalizationRule

-- | Capitalize the first letter of each word.
CapWords :: CapitalizationRule

-- | Replace the noun phrase with the given <a>Sentence</a>. Used for
--   custom capitalization.
Replace :: Sentence -> CapitalizationRule

-- | For nouns and <tt>NounPhrase</tt>s. May be constructed from a proper
--   noun, common noun, or phrase (<a>Sentence</a>) and their respective
--   pluralization and capitalization rules.
data NP

-- | Stores a proper noun and its pluralization.
ProperNoun :: String -> PluralRule -> NP

-- | Stores a common noun and its pluralization.
CommonNoun :: String -> PluralRule -> CapitalizationRule -> NP

-- | Stores noun phrase and its pluralization. Phrase plurals can get very
--   odd, so it seems best (for now) to encode them directly. FIXME: If the
--   singular/plural phrase has special (replace) capitalization, one of
--   the two cannot be capitalized right now. The two capitalization rules
--   are for sentenceCase / titleCase respectively
Phrase :: Sentence -> PluralForm -> CapitalizationRule -> CapitalizationRule -> NP

-- | Synonym for <a>Sentence</a> typically used for plural forms.
type PluralForm = Sentence

-- | Pluralization rules.
data PluralRule

-- | Add "s" to the end of the noun phrase.
AddS :: PluralRule

-- | Add "e" to the end of the noun phrase.
AddE :: PluralRule

-- | Add "es" to the end of the noun phrase.
AddES :: PluralRule

-- | The noun phrase is already plural.
SelfPlur :: PluralRule

-- | Apply the given function to the noun phrase to get the plural.
IrregPlur :: (String -> String) -> PluralRule


-- | The lowest level of chunks in Drasil. It all starts with an identifier
--   and a term.
module Language.Drasil.Chunk.NamedIdea

-- | <a>IdeaDict</a> is the canonical dictionary associated to an
--   <a>Idea</a>. Contains a <a>UID</a> and a term that could have an
--   abbreviation (<a>Maybe</a> <a>String</a>).
--   
--   Ex. The project name "Double Pendulum" may have the abbreviation
--   <a>DblPend</a>.
data IdeaDict

-- | A NamedIdea is a <a>term</a> that we've identified (has a <a>UID</a>)
--   as being worthy of naming.
class HasUID c => NamedIdea c

-- | Lens to the term (a noun phrase).
term :: NamedIdea c => Lens' c NP

-- | An <a>Idea</a> is the combination of a <a>NamedIdea</a> and a
--   <tt>CommonIdea</tt>. In other words, it <i>may</i> have an
--   acronym/abbreviation.
class NamedIdea c => Idea c

-- | Gets the acronym/abbreviation.
getA :: Idea c => c -> Maybe String

-- | <a>IdeaDict</a> constructor, takes a <a>String</a> for its <a>UID</a>
--   and a term.
nc :: String -> NP -> IdeaDict

-- | Similar to <a>nc</a>, but takes in the <a>UID</a> in the form of a
--   <a>UID</a> rather than a <a>String</a>.
ncUID :: UID -> NP -> IdeaDict

-- | Historical name: nw comes from 'named wrapped' from when
--   <a>NamedIdea</a> exported <a>getA</a> (now in <a>Idea</a>). But there
--   are no more wrappers, instead we have explicit dictionaries. Unwraps
--   an <a>Idea</a> and places its <a>UID</a> and <a>NP</a> into an
--   <a>IdeaDict</a> with <a>Nothing</a> for an abbreviation.
nw :: Idea c => c -> IdeaDict

-- | <a>IdeaDict</a> constructor, takes a <a>UID</a>, <a>NP</a>, and an
--   abbreviation in the form of <a>Maybe</a> <a>String</a>.
mkIdea :: String -> NP -> Maybe String -> IdeaDict

-- | Same as <a>mkIdea</a> but takes a <a>UID</a> rather than a
--   <a>String</a>.
mkIdeaUID :: UID -> NP -> Maybe String -> IdeaDict
instance GHC.Classes.Eq Language.Drasil.Chunk.NamedIdea.IdeaDict
instance Drasil.Database.UID.HasUID Language.Drasil.Chunk.NamedIdea.IdeaDict
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.NamedIdea.IdeaDict
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.NamedIdea.IdeaDict

module Language.Drasil.NounPhrase
class NounPhrase n

-- | Retrieves singular form of term. Ex. "the quick brown fox".
phraseNP :: NounPhrase n => n -> Sentence

-- | Retrieves plural form of term. Ex. "the quick brown foxes".
pluralNP :: NounPhrase n => n -> PluralForm

-- | Retrieves the singular form and applies a captalization rule (usually
--   capitalizes the first word) to produce a <a>Sentence</a>. Ex. "The
--   quick brown fox".
sentenceCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization

-- | Retrieves the singular form and applies a captalization rule (usually
--   capitalizes all words) to produce a <a>Sentence</a>. Ex. "The Quick
--   Brown Fox".
titleCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization

-- | For nouns and <tt>NounPhrase</tt>s. May be constructed from a proper
--   noun, common noun, or phrase (<a>Sentence</a>) and their respective
--   pluralization and capitalization rules.
data NP

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
atStartNP :: NounPhrase n => n -> Capitalization

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
atStartNP' :: NounPhrase n => n -> Capitalization

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP :: NounPhrase n => n -> Capitalization

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP' :: NounPhrase n => n -> Capitalization

-- | Self plural.
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn :: String -> NP

-- | Plural form simply adds "s" (ex. dog -&gt; dogs).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn' :: String -> NP

-- | Plural form adds "e" (ex. formula -&gt; formulae).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn'' :: String -> NP

-- | Plural form adds "es" (ex. bush -&gt; bushes).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn''' :: String -> NP

-- | Construct a common noun that pluralizes by dropping the last two
--   letters and adding an "ices" ending (ex. matrix -&gt; matrices).
cnICES :: String -> NP

-- | Constructs a common noun that pluralizes by dropping the last letter
--   and adding an "ies" ending (ex. body -&gt; bodies).
cnIES :: String -> NP

-- | Constructs a common noun that allows you to specify the pluralization
--   rule (as in <a>pnIrr</a>).
cnIP :: String -> PluralRule -> NP

-- | Constructs a common noun that pluralizes by dropping the last two
--   letters and adding "es" (ex. analysis -&gt; analyses).
cnIS :: String -> NP

-- | Common noun that allows you to specify both the pluralization rule and
--   the capitalization rule for sentence case (if the noun is used at the
--   beginning of a sentence).
cnIrr :: String -> PluralRule -> CapitalizationRule -> NP

-- | Constructs a common noun that pluralizes by dropping the last two
--   letters and adding "a" (ex. datum -&gt; data).
cnUM :: String -> NP

-- | Self plural.
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn :: String -> NP

-- | Plural form simply adds "s" (ex. Henderson -&gt; Hendersons).
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn' :: String -> NP

-- | Plural form adds "e".
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn'' :: String -> NP

-- | Plural form adds "es" (ex. Bush -&gt; Bushes).
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn''' :: String -> NP

-- | Constructs a <a>ProperNoun</a> with a custom plural rule (using
--   <a>IrregPlur</a> from <a>PluralRule</a>). First argument is the String
--   representing the noun, second is the rule.
pnIrr :: String -> PluralRule -> NP

-- | Creates a <a>NP</a> with a given singular and plural form (as
--   <a>String</a>s) that capitalizes the first letter of the first word
--   for sentence case.
nounPhrase :: String -> PluralString -> NP

-- | Similar to <a>nounPhrase</a>, but takes a specified capitalization
--   rule for the sentence case.
nounPhrase' :: String -> PluralString -> CapitalizationRule -> NP

-- | Custom noun phrase constructor that takes a singular form
--   (<a>Sentence</a>), plural form (<a>Sentence</a>), sentence case
--   capitalization rule, and title case capitalization rule.
nounPhrase'' :: Sentence -> PluralForm -> CapitalizationRule -> CapitalizationRule -> NP

-- | For things that should not be pluralized (or are self-plural). Works
--   like <a>nounPhrase</a>, but with only the first argument.
nounPhraseSP :: String -> NP

-- | Similar to nounPhrase, except it only accepts one <a>Sentence</a>.
--   Used for Requirements, Assumptions, LikelyChanges, etc. to allow for
--   referencing. Plural case is just <a>AddS</a>.
nounPhraseSent :: Sentence -> NP

-- | Combine two noun phrases. The singular form becomes <tt>phrase</tt>
--   from t1 followed by <tt>phrase</tt> of t2. The plural becomes
--   <tt>phrase</tt> of t1 followed by <tt>plural</tt> of t2. Uses standard
--   <a>CapFirst</a> sentence case and <a>CapWords</a> title case. For
--   example: <tt>compoundPhrase system constraint</tt> will have singular
--   form "system constraint" and plural "system constraints".
compoundPhrase :: (NounPhrase a, NounPhrase b) => a -> b -> NP

-- | Similar to <a>compoundPhrase</a>, but the sentence case is the same as
--   the title case (<a>CapWords</a>).
compoundPhrase' :: NP -> NP -> NP

-- | Similar to <a>compoundPhrase'</a>, but accepts two functions that will
--   be used to construct the plural form. For example,
--   <tt>compoundPhrase'' plural phrase system constraint</tt> would have
--   the plural form "systems constraint".
compoundPhrase'' :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Similar to <a>compoundPhrase</a>, but used when you need a special
--   function applied to the first term of both singular and pluralcases
--   (eg. short or plural).
compoundPhrase''' :: (NP -> Sentence) -> NP -> NP -> NP

-- | Similar to <a>compoundPhrase</a>, but pluralizes the first <a>NP</a>
--   for both singular and plural cases.
compoundPhraseP1 :: NP -> NP -> NP

-- | Capitalization rules.
data CapitalizationRule

-- | Capitalize the first letter of the first word only.
CapFirst :: CapitalizationRule

-- | Capitalize the first letter of each word.
CapWords :: CapitalizationRule

-- | Replace the noun phrase with the given <a>Sentence</a>. Used for
--   custom capitalization.
Replace :: Sentence -> CapitalizationRule

-- | Pluralization rules.
data PluralRule

-- | Add "s" to the end of the noun phrase.
AddS :: PluralRule

-- | Add "e" to the end of the noun phrase.
AddE :: PluralRule

-- | Add "es" to the end of the noun phrase.
AddES :: PluralRule

-- | The noun phrase is already plural.
SelfPlur :: PluralRule

-- | Apply the given function to the noun phrase to get the plural.
IrregPlur :: (String -> String) -> PluralRule
instance Language.Drasil.NounPhrase.NounPhrase Language.Drasil.NounPhrase.Core.NP


-- | Developing the expression language in Drasil. Re-export many things to
--   simplify external use.
module Language.Drasil.Development
class NounPhrase n

-- | Retrieves singular form of term. Ex. "the quick brown fox".
phraseNP :: NounPhrase n => n -> Sentence

-- | Retrieves plural form of term. Ex. "the quick brown foxes".
pluralNP :: NounPhrase n => n -> PluralForm

-- | This is to collect <i>symbolic</i> <a>UID</a>s that are printed out as
--   a <tt>Symbol</tt>.
sdep :: Sentence -> [UID]
shortdep :: Sentence -> [UID]

-- | Generic traverse of all positions that could lead to <i>reference</i>
--   <a>UID</a>s from <a>Sentence</a>s.
lnames :: Sentence -> [UID]

-- | Get <i>reference</i> <a>UID</a>s from <a>Sentence</a>s.
lnames' :: [Sentence] -> [UID]

-- | Get something's <a>UID</a> as a <a>Value</a>.
showUID :: HasUID a => a -> String


-- | For deriving equations in examples.
module Language.Drasil.Derivation

-- | Derivations are an ordered list of sentences and expressions. They are
--   rendered in order as paragraphs and equation blocks to display the
--   derivation.
data Derivation
Derivation :: Sentence -> [Sentence] -> Derivation

-- | A class that might have a <a>Derivation</a>.
class MayHaveDerivation c

-- | Provides a <tt>Lens</tt> to a possible derivation.
derivations :: MayHaveDerivation c => Lens' c (Maybe Derivation)

-- | Smart constructor for creating a <a>Derivation</a>.
mkDeriv :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but prepends "Detailed derivation of" to
--   the header.
mkDerivName :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but without a header <a>Sentence</a>.
mkDerivNoHeader :: [Sentence] -> Derivation


-- | References that have extra information.
module Language.Drasil.DecoratedReference

-- | For holding a <a>Reference</a> that is decorated with extra
--   information (ex. page numbers, equation sources, etc.).
data DecRef
DR :: Reference -> RefInfo -> DecRef
[_rf] :: DecRef -> Reference
[refInfo] :: DecRef -> RefInfo

-- | A class that contains a list of decorated references (<a>DecRef</a>s).
class HasDecRef c

-- | Provides a <tt>Lens</tt> to the <a>DecRef</a>s.
getDecRefs :: HasDecRef c => Lens' c [DecRef]

-- | Same as <a>ref</a>, but for <a>DecRef</a> instead of <a>Reference</a>.
dRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> DecRef

-- | For creating a decorated reference (<a>DecRef</a>) with extra
--   reference information (<a>RefInfo</a>).
dRefInfo :: (HasUID r, HasRefAddress r, HasShortName r) => r -> RefInfo -> DecRef
instance GHC.Classes.Eq Language.Drasil.DecoratedReference.DecRef
instance Drasil.Database.UID.HasUID Language.Drasil.DecoratedReference.DecRef
instance Language.Drasil.Label.Type.HasRefAddress Language.Drasil.DecoratedReference.DecRef
instance Language.Drasil.ShortName.HasShortName Language.Drasil.DecoratedReference.DecRef


-- | Defines the chunk type to hold citations.
module Language.Drasil.Chunk.Citation

-- | All citations require a unique identifier used by the Drasil chunk. We
--   will re-use the <a>UID</a> part as an EntryID (<a>String</a>) used for
--   creating reference links. Finally we will have the reference
--   information (<a>CitationKind</a>, <a>CiteField</a>s, and a
--   <a>ShortName</a>).
--   
--   Ex. A reference to a thesis paper like Koothoor's "Document driven
--   approach to certifying scientific computing software" would include
--   the affiliated university, publishing year, and city.
data Citation

-- | A list of <a>Citation</a>s.
type BibRef = [Citation]

-- | A <a>String</a> that should contain no spaces.
type EntryID = String

-- | Some documents, as well as some pieces of knowledge, have citations.
class HasCitation c

-- | Provides a <tt>Lens</tt> to the citations.
getCitations :: HasCitation c => Lens' c [Citation]
citeID :: Lens' Citation UID
citeKind :: Lens' Citation CitationKind

-- | Article citation requires author(s), title, journal, year. Optional
--   fields can be: volume, number, pages, month, and note. Implicitly uses
--   the EntryID as the chunk id.
cArticle :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by author.
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk id.
cBookA :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by editor.
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk id.
cBookE :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Booklet citation requires title. Optional fields can be author, how
--   published, address, month, year, note. Implicitly uses the EntryID as
--   the chunk id.
cBooklet :: String -> [CiteField] -> String -> Citation

-- | InBook citation by author.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id. This smart constructor includes both chapter
--   and page numbers.
cInBookACP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InBook citation by editor.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id. This smart constructor includes both chapter
--   and page numbers.
cInBookECP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookACP</a>.
--   
--   InBook citation excluding page numbers.
cInBookAC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookECP</a>.
--   
--   InBook citation excluding page numbers.
cInBookEC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookACP</a>.
--   
--   InBook citation excluding chapter.
cInBookAP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookECP</a>.
--   
--   InBook citation excluding chapter.
cInBookEP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InCollection citation requires author, title, bookTitle, publisher,
--   year. Optional fields can be editor, volume or number, series, type,
--   chapter, pages, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id.
cInCollection :: People -> String -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | InProceedings citation requires author, title, bookTitle, year.
--   Optional fields can be editor, volume or number, series, pages,
--   address, month, organization, publisher, and note. Implicitly uses the
--   EntryID as the chunk id.
cInProceedings :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Manual (technical documentation) citation requires title. Optional
--   fields can be author, organization, address, edition, month, year, and
--   note. Implicitly uses the EntryID as the chunk id.
cManual :: String -> [CiteField] -> String -> Citation

-- | Master's Thesis citation requires author, title, school, and year.
--   Optional fields can be type, address, month, and note. Implicitly uses
--   the EntryID as the chunk id.
cMThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Misc citation requires nothing. Optional fields can be author, title,
--   howpublished, month, year, and note. Implicitly uses the EntryID as
--   the chunk id.
cMisc :: [CiteField] -> String -> Citation

-- | PhD Thesis citation requires author, title, school, and year. Optional
--   fields can be type, address, month, and note. Implicitly uses the
--   EntryID as the chunk id.
cPhDThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Proceedings citation requires title and year. Optional fields can be
--   editor, volume or number, series, address, publisher, note, month, and
--   organization. Implicitly uses the EntryID as the chunk id.
cProceedings :: String -> Int -> [CiteField] -> String -> Citation

-- | Technical Report citation requires author, title, institution, and
--   year. Optional fields can be type, number, address, month, and note.
--   Implicitly uses the EntryID as the chunk id.
cTechReport :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Unpublished citation requires author, title, and note. Optional fields
--   can be month and year. Implicitly uses the EntryID as the chunk id.
cUnpublished :: People -> String -> String -> [CiteField] -> String -> Citation
instance Drasil.Database.UID.HasUID Language.Drasil.Chunk.Citation.Citation
instance Language.Drasil.ShortName.HasShortName Language.Drasil.Chunk.Citation.Citation
instance Language.Drasil.Data.Citation.HasFields Language.Drasil.Chunk.Citation.Citation
instance Language.Drasil.Label.Type.Referable Language.Drasil.Chunk.Citation.Citation
instance Language.Drasil.Label.Type.HasRefAddress Language.Drasil.Chunk.Citation.Citation


-- | Defines operator precedence.
module Language.Drasil.Expr.Precedence

-- | prec2Arith - precedence for arithmetic-related binary operations.
prec2Arith :: ArithBinOp -> Int

-- | prec2Bool - precedence for boolean-related binary operations.
prec2Bool :: BoolBinOp -> Int

-- | prec2Eq - precedence for equality-related binary operations.
prec2Eq :: EqBinOp -> Int

-- | prec2LA - precedence for access-related binary operations.
prec2LA :: LABinOp -> Int

-- | prec2Ord - precedence for order-related binary operations.
prec2Ord :: OrdBinOp -> Int

-- | prec2VVV - precedence for Vec-&gt;Vec-&gt;Vec-related binary
--   operations.
prec2VVV :: VVVBinOp -> Int

-- | prec2VVN - precedence for Vec-&gt;Vec-&gt;Num-related binary
--   operations.
prec2VVN :: VVNBinOp -> Int

-- | prec2NVV - precedence for Num-&gt;Vec-&gt;Vec-related binary
--   operations.
prec2NVV :: NVVBinOp -> Int

-- | prec2ESS - precedence for Element-&gt;Set-&gt;Set-related binary
--   operations.
prec2ESS :: ESSBinOp -> Int

-- | prec2ESS - precedence for Element-&gt;Set-&gt;Bool-related binary
--   operations.
prec2ESB :: ESBBinOp -> Int

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int
precC :: AssocConcatOper -> Int

-- | prec1 - precedence of unary operators.
prec1 :: UFunc -> Int

-- | prec1B - precedence of boolean-related unary operators.
prec1B :: UFuncB -> Int

-- | prec1VV - precedence of vector-vector-related unary operators.
prec1VV :: UFuncVV -> Int

-- | prec1Vec - precedence of vector-number-related unary operators.
prec1VN :: UFuncVN -> Int

-- | eprec - <a>Expression</a> precedence.
eprec :: Expr -> Int


-- | Extract UIDs from an expression so that they can be looked up in the
--   chunk database and rendered.
module Language.Drasil.Expr.Extract

-- | Generic traverse of all expressions that could lead to names.
eNames :: Expr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>eNames</a>).
eNamesRI :: RealInterval Expr Expr -> [UID]

-- | Generic traverse of all positions that could lead to <a>eNames</a>
--   without functions. FIXME : this should really be done via post-facto
--   filtering, but right now the information needed to do this is not
--   available!
eNames' :: Expr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names without functions (similar to <a>eNames'</a>).
eNamesRI' :: RealInterval Expr Expr -> [UID]

-- | Get dependencies from an equation.
eDep :: Expr -> [UID]

module Language.Drasil.Expr.Development

-- | Expression language where all terms are supposed to be 'well
--   understood' (i.e., have a definite meaning). Right now, this coincides
--   with "having a definite value", but should not be restricted to that.
data Expr

-- | Brings a literal into the expression language.
[Lit] :: Literal -> Expr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [Expr] -> Expr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [Expr] -> Expr
[AssocC] :: AssocConcatOper -> [Expr] -> Expr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> Expr

-- | Function applications.
[FCall] :: UID -> [Expr] -> Expr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(Expr, Relation)] -> Expr

-- | Represents a matrix of expressions.
[Matrix] :: [[Expr]] -> Expr

-- | Represents a set of expressions
[Set] :: Space -> [Expr] -> Expr

-- | used to refernce the (name + type = variable )
[Variable] :: String -> Expr -> Expr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> Expr -> Expr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> Expr -> Expr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> Expr -> Expr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> Expr -> Expr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> Expr -> Expr -> Expr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> Expr -> Expr -> Expr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> Expr -> Expr -> Expr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> Expr -> Expr -> Expr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Expr x Vector -&gt; Vector</tt> operations
--   (scaling).
[NVVBinaryOp] :: NVVBinOp -> Expr -> Expr -> Expr

-- | Set operator for Element + Set -&gt; Set
[ESSBinaryOp] :: ESSBinOp -> Expr -> Expr -> Expr

-- | Set operator for Element + Set -&gt; Bool
[ESBBinaryOp] :: ESBBinOp -> Expr -> Expr -> Expr

-- | Operators are generalized arithmetic operators over a
--   <tt>DomainDesc</tt> of an <a>Expr</a>. Could be called BigOp. ex:
--   Summation is represented via <a>Add</a> over a discrete domain.
[Operator] :: AssocArithOper -> DiscreteDomainDesc Expr Expr -> Expr -> Expr

-- | A different kind of <tt>IsIn</tt>. A <a>UID</a> is an element of an
--   interval.
[RealI] :: UID -> RealInterval Expr Expr -> Expr

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Index operator. <a>Index</a> represents accessing an element at a
--   specific index, while <a>IndexOf</a> represents finding the index of a
--   specific element.
data LABinOp
Index :: LABinOp
IndexOf :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product, addition, subtraction).
data VVVBinOp
Cross :: VVVBinOp
VAdd :: VVVBinOp
VSub :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | <tt>Number x Vector -&gt; Vector</tt> binary operations (scaling).
data NVVBinOp
Scale :: NVVBinOp

-- | Element + Set -&gt; Set
data ESSBinOp
SAdd :: ESSBinOp
SRemove :: ESSBinOp

-- | Element + Set -&gt; Bool
data ESBBinOp
SContains :: ESBBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
Add :: AssocArithOper
Mul :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper
data AssocConcatOper
SUnion :: AssocConcatOper

-- | For case expressions (either complete or incomplete).
data Completeness
Complete :: Completeness
Incomplete :: Completeness

-- | A relation is just an expression (<a>Expr</a>).
type Relation = Expr

-- | Get dependencies from an equation.
eDep :: Expr -> [UID]

-- | Generic traverse of all expressions that could lead to names.
eNames :: Expr -> [UID]

-- | Generic traverse of all positions that could lead to <a>eNames</a>
--   without functions. FIXME : this should really be done via post-facto
--   filtering, but right now the information needed to do this is not
--   available!
eNames' :: Expr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>eNames</a>).
eNamesRI :: RealInterval Expr Expr -> [UID]

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int
precC :: AssocConcatOper -> Int

-- | eprec - <a>Expression</a> precedence.
eprec :: Expr -> Int


-- | Defines types and functions for constrained values.
module Language.Drasil.Constraint

-- | Holds constraints. May occur between an interval of <a>Expr</a>, a
--   list of <a>Double</a>s, or a list of <a>String</a>s.
data Constraint a

-- | By default, physical and software constraints are ranges.
[Range] :: ConstraintReason -> RealInterval a a -> Constraint a
[Elem] :: ConstraintReason -> a -> Constraint a

-- | Type synonym for <a>ConstraintE</a>
type ConstraintE = Constraint Expr

-- | The reason behind the constraint's existence.
data ConstraintReason
Physical :: ConstraintReason
Software :: ConstraintReason

-- | Smart constructor for range of <a>Physical</a> constraints between two
--   given expressions.
physRange :: RealInterval Expr Expr -> ConstraintE

-- | Smart constructor for range of <a>Software</a> constraints between two
--   given expressions.
sfwrRange :: RealInterval Expr Expr -> ConstraintE
physElem :: Expr -> ConstraintE
sfwrElem :: Expr -> ConstraintE

-- | Helpful for filtering for Physical constraints. True if constraint is
--   <a>Physical</a>.
isPhysC :: Constraint e -> Bool

-- | Helpful for filtering for Software constraints. True if constraint is
--   <a>Software</a>.
isSfwrC :: Constraint e -> Bool


-- | Defining all the classes which represent knowledge-about-knowledge.
module Language.Drasil.Classes

-- | A NamedIdea is a <a>term</a> that we've identified (has a <a>UID</a>)
--   as being worthy of naming.
class HasUID c => NamedIdea c

-- | Lens to the term (a noun phrase).
term :: NamedIdea c => Lens' c NP

-- | An <a>Idea</a> is the combination of a <a>NamedIdea</a> and a
--   <tt>CommonIdea</tt>. In other words, it <i>may</i> have an
--   acronym/abbreviation.
class NamedIdea c => Idea c

-- | Gets the acronym/abbreviation.
getA :: Idea c => c -> Maybe String

-- | CommonIdea is a <a>NamedIdea</a> with the additional constraint that
--   it <b>must</b> have an abbreviation. This is the main distinction
--   between getA and abrv, where getA may return Nothing, while abrv will
--   always return the abbreviation.
class NamedIdea c => CommonIdea c

-- | Introduces abrv which necessarily provides an abbreviation.
abrv :: CommonIdea c => c -> String

-- | Concepts are <a>Idea</a>s with definitions and domains.
type Concept c = (Idea c, Definition c, ConceptDomain c)

-- | Defines a chunk.
class Definition c

-- | Provides (a <tt>Lens</tt> to) the definition for a chunk.
defn :: Definition c => Lens' c Sentence

-- | Some concepts have a domain (related information encoded in
--   <a>UID</a>s to other chunks).
class ConceptDomain c

-- | Provides Getter for the concept domain tags for a chunk
--   
--   <i>cdom</i> should be exported for use by the Drasil framework, but
--   should not be exported beyond that.
cdom :: ConceptDomain c => c -> [UID]

-- | A Quantity is an <a>Idea</a> with a <tt>Space</tt> and a
--   <tt>Symbol</tt>. In theory, it should also restrict to being a part of
--   <tt>MayHaveUnit</tt>, but that causes all sorts of import cycles (or
--   lots of orphans).
class (Idea c, HasSpace c, HasSymbol c) => Quantity c

-- | Some chunks store a unit symbol.
class HasUnitSymbol u

-- | Provides the ability to hold a unit symbol (<a>USymb</a>).
usymb :: HasUnitSymbol u => u -> USymb

-- | A <a>Quantity</a> that could have a reasonable value.
class HasReasVal c

-- | Provides a <tt>Lens</tt> to the possible reasonable value.
reasVal :: HasReasVal c => Lens' c (Maybe Expr)

-- | The Constrained class is a <a>Quantity</a> that has value constraints.
--   It does not enforce <a>Quantity</a> at this point.
class Constrained c

-- | Provides a <tt>Lens</tt> to the <tt>Constraint</tt>s.
constraints :: Constrained c => Lens' c [ConstraintE]

-- | Records any additional notes needed to avoid losing information
class HasAdditionalNotes c

-- | Provides a <tt>Lens</tt> to the notes.
getNotes :: HasAdditionalNotes c => Lens' c [Sentence]

-- | Units are <a>Idea</a>s with a <a>Definition</a> which store a unit
--   symbol. They must also be explicitly declared to be instances of
--   IsUnit.
class (Idea u, Definition u, HasUnitSymbol u) => IsUnit u

-- | May have a unit definition.
udefn :: IsUnit u => u -> Maybe UDefn

-- | Holds units as a list of <a>UID</a>.
getUnits :: IsUnit u => u -> [UID]

-- | Contains a <a>UDefn</a>
class UnitEq u

-- | Provides the <tt>Lens</tt> to a unit definition.
uniteq :: UnitEq u => Lens' u UDefn

-- | Data that can be expressed using <a>ModelExpr</a>.
class Express c
express :: Express c => c -> ModelExpr
class DefiningExpr c

-- | Provides a <tt>Lens</tt> to the expression. TODO: Well, technically,
--   <tt>e</tt> doesn't need to be an "expression" of any sorts. It just
--   needs to be _something_, and it would have approximately have same
--   meaning.
defnExpr :: DefiningExpr c => Lens' (c e) e


-- | Various helpers for building Sentences from other bits. Really ought
--   to be moved out to (likely) docLang, but is here for now.
module Language.Drasil.Development.Sentence

-- | Helper for getting the phrase from a <a>NamedIdea</a> using it's UID.
phrase :: NamedIdea n => n -> Sentence

-- | Helper for getting the plural of a phrase from a <a>NamedIdea</a>.
plural :: NamedIdea n => n -> Sentence

-- | Singular possesive function
--   
--   Helper for getting the possesive cases from the term of a
--   <a>NamedIdea</a>.
phrasePoss :: NamedIdea n => n -> Sentence

-- | Plural possesive function
--   
--   Helper for getting the possesive cases from the term of a
--   <a>NamedIdea</a>.
pluralPoss :: NamedIdea n => n -> Sentence

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   <a>NamedIdea</a>.
atStart :: NamedIdea n => n -> Sentence

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   <a>NamedIdea</a>.
atStart' :: NamedIdea n => n -> Sentence

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   <a>NamedIdea</a>.
titleize :: NamedIdea n => n -> Sentence

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   <a>NamedIdea</a>.
titleize' :: NamedIdea n => n -> Sentence

-- | Get short form (if it exists), else get term of an <a>Idea</a>. Uses
--   the UID of the <a>Idea</a> in a <tt>Ch</tt> Sentence constructor to
--   get the short form using getA. getA may return Nothing, in which case
--   lookupS uses the term, where lookupS is the main helper for looking up
--   the short form of a <tt>Ch</tt> Sentence.
short :: Idea c => c -> Sentence

-- | Helper for common pattern of introducing the title-case version of a
--   noun phrase (from an Idea) followed by its abbreviation in
--   parentheses.
introduceAbb :: Idea n => n -> Sentence


-- | Defines various sentence level combinators that may be based in
--   English and not necessarily have a conceptual link. See the
--   <a>Wiki</a> for more information. There are also <tt>C</tt> variants
--   to each combinator to denote those meant for use at the start of a
--   sentence (capitalizes the first word). This module should be used as a
--   qualified import (usually as <tt>S</tt>), as many function names clash
--   with those in Concepts.hs and NounPhrase.hs.
module Language.Drasil.Sentence.Combinators

-- | Inserts the word "and" between two Sentences.
and_ :: Sentence -> Sentence -> Sentence

-- | Inserts the words "and its" between two Sentences.
andIts :: Sentence -> Sentence -> Sentence

-- | Inserts the words "and the" between two Sentences.
andThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "from the" between two Sentences.
fromThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "in the" between two Sentences.
inThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "on the" between two Sentences.
onThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "to the" between two Sentences.
toThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "is the" between two Sentences.
isThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "of the" between two Sentences.
ofThe :: Sentence -> Sentence -> Sentence

-- | Same as <a>ofThe</a>, but inserts "the" at the beginning of the
--   Sentence.
the_ofThe :: Sentence -> Sentence -> Sentence

-- | Same as <a>the_ofThe</a>, except first "the" is capitalized.
the_ofTheC :: Sentence -> Sentence -> Sentence

-- | Prepends "the" and inserts "of a given" between two Sentences.
the_ofGiv :: Sentence -> Sentence -> Sentence

-- | Same as <tt>ofGiv</tt>, except first "the" is capitalized.
the_ofGivC :: Sentence -> Sentence -> Sentence

-- | Prepends "The" and inserts "is expected to have" between two
--   Sentences.
the_isExpctdToHvC :: Sentence -> Sentence -> Sentence

-- | Similar to <a>for</a>, but used for titles and first <a>NamedIdea</a>
--   is pluralized.
forTPS :: (NamedIdea c, NamedIdea d) => c -> d -> Sentence

-- | Similar to <tt>forTTPS</tt>, but both <a>NamedIdea</a>s are
--   pluralized.
forTPP :: (NamedIdea c, NamedIdea d) => c -> d -> Sentence

-- | Inserts the word "for" between two Sentences.
for :: Sentence -> Sentence -> Sentence

-- | Similar to <a>for</a>, but both terms are <a>titleize</a>d.
forT :: (NamedIdea c, NamedIdea d) => c -> d -> Sentence

-- | Similar to <tt>forTT</tt>, but takes two arguments (for capitalization
--   or pluralization) to apply to the two terms respectively.
forGen :: (c -> Sentence) -> (d -> Sentence) -> c -> d -> Sentence

-- | Inserts the word "of" between two Sentences.
of_ :: Sentence -> Sentence -> Sentence

-- | Inserts the words "of a" between two Sentences.
ofA :: Sentence -> Sentence -> Sentence

-- | Inserts the word "or" between two Sentences.
or_ :: Sentence -> Sentence -> Sentence

-- | Inserts the word "are" between two Sentences.
are :: Sentence -> Sentence -> Sentence

-- | Inserts the word "in" between two Sentences.
in_ :: Sentence -> Sentence -> Sentence

-- | Inserts the word "is" between two Sentences.
is :: Sentence -> Sentence -> Sentence

-- | Inserts the words "defined as" between two Sentences.
defnAs :: Sentence -> Sentence -> Sentence

-- | Inserts the words "denotes the" between two Sentences.
denotes :: Sentence -> Sentence -> Sentence

-- | Inserts the word "versus" between two Sentences.
versus :: Sentence -> Sentence -> Sentence

-- | Inserts the words "with respect to" between two Sentences.
wrt :: Sentence -> Sentence -> Sentence


-- | Defines various NounPhrase-level combinators. These hold more
--   information than those of the Sentence level but may not necessarily
--   have a conceptual link. See the <a>Wiki</a> for more information and
--   details about the naming process for combinators. A summary of the
--   function naming scheme is as follows:
--   
--   <ul>
--   <li>Combinators that conflict with haskell-native functions have an
--   underscore appended.</li>
--   <li>Default plural case for combinators will be first term singular,
--   second term plural.</li>
--   <li><tt>P</tt> and <tt>S</tt> denote the plural case of the combinator
--   when it does not follow the above default.</li>
--   <li><tt>Gen</tt> denotes the general function case.</li>
--   </ul>
--   
--   This module should be used as a qualified import (usually as
--   <tt>NP</tt>), as many function names clash with those in Concepts.hs
--   and Sentence.hs.
module Language.Drasil.NounPhrase.Combinators

-- | Helper function that places a <a>String</a> in between two <a>NP</a>s.
--   Plural case is <tt>(phraseNP t1) +:+ S s +:+ (pluralNP t2)</tt>.
insertString :: String -> NP -> NP -> NP

-- | Helper function that prepends a <a>String</a> to a <a>NP</a>.
prependString :: String -> NP -> NP

-- | Helper function that places a <a>Sentence</a> in between two
--   <a>NP</a>s. Plural case is <tt>(phraseNP t1) +:+ s +:+ (pluralNP
--   t2)</tt>.
insertSent :: Sentence -> NP -> NP -> NP

-- | Helper function that prepends a <a>Sentence</a> to a <a>NP</a>.
prependSent :: Sentence -> NP -> NP

-- | Prepends "the" to a <a>NP</a>.
the :: NP -> NP

-- | Similar to <a>the</a>, but accepts a function that determines the
--   plural case.
theGen :: (NP -> Sentence) -> NP -> NP

-- | Prepends "a" to a <a>NP</a>.
a_ :: NP -> NP

-- | Similar to <tt>a</tt>, but accepts a function that determines the
--   plural case.
a_Gen :: (NP -> Sentence) -> NP -> NP

-- | Inserts "and" between two <a>NP</a>s. Plural case is <tt>(phraseNP t1)
--   +:+ "and" +:+ (pluralNP t2)</tt>.
and_ :: NP -> NP -> NP

-- | Same as <a>and_</a>, but plural case is now <tt>(pluralNP t1)
--   <a>and_</a> (phraseNP t2)</tt>.
and_PS :: NP -> NP -> NP

-- | Same as <a>and_</a>, but takes two functions for the plural case.
and_Gen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Same as <a>and_</a>, but takes two functions for the singular case and
--   two for the plural case.
and_GenGen :: (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "and the" between two <a>NP</a>s. Plural case is <tt>(phraseNP
--   t1) +:+ "and the" +:+ (pluralNP t2)</tt>.
andThe :: NP -> NP -> NP

-- | Inserts "of the" between two <a>NP</a>s. Plural case is <tt>(phraseNP
--   t1) +:+ "of the" +:+ (pluralNP t2)</tt>.
ofThe :: NP -> NP -> NP

-- | Similar to <a>ofThe</a>, but the plural case is now <tt>(pluralNP t1)
--   <a>ofThe</a> (phraseNP t2)</tt>.
ofThePS :: NP -> NP -> NP

-- | Similar to <a>ofThe</a>, but accepts two functions for the plural
--   case.
ofTheGen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "in the" between two <a>NP</a>s. Plural case is <tt>(phraseNP
--   t1) +:+ "in the" +:+ (pluralNP t2)</tt>.
inThe :: NP -> NP -> NP

-- | Similar to <a>ofThe</a>, but the plural case is now <tt>(pluralNP t1)
--   <a>inThe</a> (phraseNP t2)</tt>.
inThePS :: NP -> NP -> NP

-- | Similar to <a>ofThe</a>, but accepts two functions for the plural
--   case.
inTheGen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Prepends "the" and inserts "of the". Plural case is <tt>"the" +:+
--   (phraseNP t1) +:+ "of the" +:+ (pluralNP t2)</tt>.
the_ofThe :: NP -> NP -> NP

-- | Similar to <a>the_ofThe</a>, but the plural case is now <tt> S "the"
--   +:+ (pluralNP t1) <a>ofThe</a> (phraseNP t2)</tt>.
the_ofThePS :: NP -> NP -> NP

-- | Similar to <tt>the_ofThe'</tt>, but takes two functions for the plural
--   case.
the_ofTheGen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "for" between two <a>NP</a>s. Plural case is <tt>(phraseNP t1)
--   +:+ "for" +:+ (pluralNP t2)</tt>.
for :: NP -> NP -> NP

-- | Same as <a>for</a>, but plural case is now <tt>(pluralNP t1)
--   <a>for</a> (phraseNP t2)</tt>.
forPS :: NP -> NP -> NP

-- | Same as <tt>for'</tt>, but takes two functions for the plural case.
forGen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "of" between two <a>NP</a>s. Plural case is <tt>(phraseNP t1)
--   +:+ "of" +:+ (pluralNP t2)</tt>.
of_ :: NP -> NP -> NP

-- | Same as <a>of_</a>, but plural case is now <tt>(pluralNP t1)
--   <a>of_</a> (phraseNP t2)</tt>.
of_PS :: NP -> NP -> NP

-- | Same as <a>of_</a>, but takes two functions for the plural case.
of_Gen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Same as <a>of_</a>, but takes two functions for the singular case and
--   two for the plural case.
of_GenGen :: (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "with" between two <a>NP</a>s. Plural case is <tt>(phraseNP
--   t1) +:+ "with" +:+ (pluralNP t2)</tt>.
with :: NP -> NP -> NP


-- | Defines various chunk combinators. The full naming scheme can be found
--   in the <a>Wiki</a>. For convenience, here is a summary:
--   
--   <ul>
--   <li>Combinators that conflict with haskell-native functions have an
--   underscore appended.</li>
--   <li>Default plural case for combinators will be first term singular,
--   second term plural.</li>
--   <li><tt>P</tt> and <tt>S</tt> denote the plural case of the combinator
--   when it does not follow the above default.</li>
--   <li><tt>Gen</tt> denotes the general function case.</li>
--   <li>Although this should eventually be phased out, <tt>T</tt> denotes
--   a combinator meant for use with titles.</li>
--   <li><tt>NI</tt> and <tt>NP</tt> denote whether something must be a
--   part of the <a>NamedIdea</a> or <a>NounPhrase</a> class.</li>
--   </ul>
module Language.Drasil.Chunk.Concept.NamedCombinators

-- | Prepends "the" to a <a>NamedIdea</a>.
the :: NamedIdea t => t -> NP

-- | A customizable version of <a>the</a>. The given function is applied to
--   both singular and plural cases.
theGen :: (t -> Sentence) -> t -> NP

-- | Prepends "a" to a <a>NamedIdea</a> (similar to <a>the</a>).
a_ :: NamedIdea c => c -> NP

-- | Customizable version of <tt>a</tt>.
a_Gen :: (c -> Sentence) -> c -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "and" between their terms. Plural case is <tt>(phrase t1) "and"
--   (plural t2)</tt>.
and_ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "and" between their terms. Plural case is <tt>(plural t1) "and"
--   (phrase t2)</tt>.
and_PS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "and" between their terms. Plural case is <tt>(plural t1) "and"
--   (plural t2)</tt>.
and_PP :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Customizable <a>and_</a> combinator (takes two title case
--   capitalization rules and two <tt>NamedIdeas</tt>).
and_TGen :: (NamedIdea c, NamedIdea d) => (c -> Sentence) -> (d -> Sentence) -> c -> d -> NP

-- | Customizable <a>and_</a> combinator. Both plural and singular cases
--   are dermined by the two given functions
and_Gen :: (c -> Sentence) -> (d -> Sentence) -> c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "and its" between their terms. Plural case is <tt>(phrase t1) "and
--   its" (plural t2)</tt>.
andIts :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "and the" between their terms. Plural case is <tt>(phrase t1) "and
--   the" (plural t2)</tt>.
andThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "of" between their terms. Plural case is <tt>(phrase t1) "of" (plural
--   t2)</tt>.
of_ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a> but second argument is a <a>NounPhrase</a>.
of_NINP :: (NamedIdea c, NounPhrase d) => c -> d -> NP

-- | Same as <a>of_</a> but first argument is a <a>NounPhrase</a> and
--   plural case is <tt>(plural t1) "of" (phrase t2)</tt>.
of_PSNPNI :: (NounPhrase c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a>, except plural case is <tt>(plural t1) "of" (phrase
--   t2)</tt>.
of_PS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_PS</a>, except combining <a>Sentence</a> piece is "of
--   a".
ofA :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>ofA</a>, except phrase case is <tt>(plural t1) "of a"
--   (phrase t2)</tt>.
ofAPS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a>, except combining <a>Sentence</a> piece is "of
--   the". Plural case is <tt>(phrase t1) <a>ofThe</a> (plural t2)</tt>.
ofThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>ofThe</a>, except plural case is <tt>(plural t1)
--   <a>ofThe</a> (phrase t2)</tt>.
ofThePS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>ofThe</a>, except prepends "the".
the_ofThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>the_ofThe</a>, except plural case is <tt>(plural t1)
--   <a>the_ofThe</a> (phrase t2)</tt>
the_ofThePS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a>, except combining Sentence piece is "on the".
onThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>onThe</a>, except plural case is (plural t1) S.onThe
--   (phrase t2)
onThePS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>onThe</a>, except plural case is (plural t1) S.onThe
--   (plural t2)
onThePP :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "in the" between their terms. Plural case is <tt>(phrase t1) "in the"
--   (plural t2)</tt>.
inThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "in the" between their terms. Plural case is <tt>(plural t1) "in the"
--   (phrase t2)</tt>.
inThePS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "in the" between their terms. Plural case is <tt>(plural t1) "in the"
--   (plural t2)</tt>.
inThePP :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "is the" between their terms. Plural case is <tt>(phrase t1) "is the"
--   (plural t2)</tt>.
isThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "to the" between their terms. Plural case is <tt>(phrase t1) "to the"
--   (plural t2)</tt>.
toThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "for" between their terms. Plural case is <tt>(phrase t1) "for"
--   (plural t2)</tt>.
for :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Similar to <a>for</a>, but takes two functions that determine the
--   <tt>titleCase</tt>.
forTGen :: (NamedIdea c, Idea d) => (c -> Sentence) -> (d -> Sentence) -> c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "in" between their terms. Plural case is <tt>(phrase t1) "in" (plural
--   t2)</tt>.
in_ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>in_</a>, except plural case is <tt>(plural t1) "in" (phrase
--   t2)</tt>.
in_PS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "in a" between their terms. Plural case is <tt>(phrase t1) "in a"
--   (plural t2)</tt>.
inA :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "is" between their terms. Plural case is <tt>(phrase t1) "is" (plural
--   t2)</tt>.
is :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Case with "T1s with T2", as opposed to "T1 with T2", i.e. singular
--   case is <tt>(plural t1) "with" (phrase t2)</tt> while the plural case
--   pluralizes the first.
with :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Combinator for combining two <tt>NamedIdeas</tt>s into a
--   <a>IdeaDict</a>. Plural case only makes second term plural. See
--   <a>compoundPhrase</a> for more on plural behaviour. <i>Does not
--   preserve abbreviations</i>.
compoundNC :: (NamedIdea a, NamedIdea b) => a -> b -> IdeaDict

-- | Similar to <a>compoundNC</a> but both terms are pluralized for plural
--   case.
compoundNCPP :: (NamedIdea a, NamedIdea b) => a -> b -> IdeaDict

-- | Similar to <a>compoundNC</a>, except plural cases are customizable.
compoundNCGen :: (NamedIdea a, NamedIdea b) => (NP -> Sentence) -> (NP -> Sentence) -> a -> b -> IdeaDict

-- | Similar to <a>compoundNC</a>, except for plural case, where first
--   parameter gets pluralized while second one stays singular.
compoundNCPS :: IdeaDict -> IdeaDict -> IdeaDict

-- | Similar to <a>compoundNCGenP</a> but sets first parameter function to
--   plural.
compoundNCPSPP :: IdeaDict -> IdeaDict -> IdeaDict

-- | Similar to <a>compoundNC</a>, but takes a function that is applied to
--   the first term (eg. <tt>short</tt> or <a>plural</a>).
compoundNCGenP :: (NamedIdea a, NamedIdea b) => (NP -> Sentence) -> a -> b -> IdeaDict

-- | Helper function that combines a <a>NamedIdea</a> and a <a>NP</a>
--   without any words in between. Plural case is <tt>(phrase t1) +:+
--   (pluralNP t2)</tt>.
combineNINP :: NamedIdea c => c -> NP -> NP

-- | Similar to <a>combineNINP</a> but takes in a <a>NP</a> first and a
--   <a>NamedIdea</a> second.
combineNPNI :: NamedIdea c => NP -> c -> NP

-- | Similar to <a>combineNINP</a> but takes two <a>NamedIdea</a>s.
combineNINI :: (NamedIdea c, NamedIdea d) => c -> d -> NP


-- | Define concept-related chunks. A concept is usually something that has
--   a term, definition, and comes from some domain of knowledge.
module Language.Drasil.Chunk.Concept.Core

-- | The ConceptChunk datatype records a concept that contains an idea
--   (<a>IdeaDict</a>), a definition (<a>Sentence</a>), and an associated
--   domain of knowledge ([<a>UID</a>]).
--   
--   Ex. The concept of <a>Accuracy</a> may be defined as the quality or
--   state of being correct or precise.
data ConceptChunk
ConDict :: IdeaDict -> Sentence -> [UID] -> ConceptChunk

-- | Contains a <a>ConceptChunk</a>, reference address, and a
--   <a>ShortName</a>. It is a concept that can be referred to, or rather,
--   a instance of where a concept is applied. Often used in Goal
--   Statements, Assumptions, Requirements, etc.
--   
--   Ex. Something like the assumption that gravity is 9.81 m/s. When we
--   write our equations, we can then link this assumption so that we do
--   not have to explicitly define that assumption when needed to verify
--   our work.
data ConceptInstance
ConInst :: UID -> ConceptChunk -> String -> ShortName -> ConceptInstance

-- | Check if something has one domain. Throws an error if there is more
--   than one.
sDom :: [UID] -> UID
instance GHC.Classes.Eq Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Drasil.Database.UID.HasUID Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.ShortName.HasShortName Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Label.Type.HasRefAddress Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Label.Type.Referable Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance GHC.Classes.Eq Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Drasil.Database.UID.HasUID Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Concept.Core.ConceptChunk


-- | Contains functions to create the concept related chunk types found in
--   <a>Language.Drasil.Chunk.Concept.Core</a>.
module Language.Drasil.Chunk.Concept

-- | The ConceptChunk datatype records a concept that contains an idea
--   (<a>IdeaDict</a>), a definition (<a>Sentence</a>), and an associated
--   domain of knowledge ([<a>UID</a>]).
--   
--   Ex. The concept of <a>Accuracy</a> may be defined as the quality or
--   state of being correct or precise.
data ConceptChunk

-- | Smart constructor for creating concept chunks given a <tt>UID</tt>,
--   <tt>NounPhrase</tt> (<a>NP</a>) and definition (as a <a>String</a>).
--   
--   Concept domain tagging is not yet implemented in this constructor.
dcc :: String -> NP -> String -> ConceptChunk

-- | Smart constructor for creating a concept chunks with an abbreviation
--   Takes a UID (String), a term (NounPhrase), a definition (String), and
--   an abbreviation (Maybe String).
dccA :: String -> NP -> String -> Maybe String -> ConceptChunk
dccAWDS :: String -> NP -> Sentence -> Maybe String -> ConceptChunk

-- | Similar to <a>dcc</a>, except the definition takes a <a>Sentence</a>.
dccWDS :: String -> NP -> Sentence -> ConceptChunk

-- | Constructor for projecting an idea into a <a>ConceptChunk</a>. Takes
--   the definition of the <a>ConceptChunk</a> as a <a>String</a>. Does not
--   allow concept domain tagging.
cc :: Idea c => c -> String -> ConceptChunk

-- | Same as <a>cc</a>, except definition is a <a>Sentence</a>.
cc' :: Idea c => c -> Sentence -> ConceptChunk

-- | Similar to <a>cc'</a>, but allows explicit domain tagging.
ccs :: (Idea c, Concept d) => c -> Sentence -> [d] -> ConceptChunk

-- | For projecting out to the <a>ConceptChunk</a> data-type.
cw :: Concept c => c -> ConceptChunk

-- | Contains a <a>ConceptChunk</a>, reference address, and a
--   <a>ShortName</a>. It is a concept that can be referred to, or rather,
--   a instance of where a concept is applied. Often used in Goal
--   Statements, Assumptions, Requirements, etc.
--   
--   Ex. Something like the assumption that gravity is 9.81 m/s. When we
--   write our equations, we can then link this assumption so that we do
--   not have to explicitly define that assumption when needed to verify
--   our work.
data ConceptInstance

-- | Constructor for a <a>ConceptInstance</a>. Takes in the Reference
--   Address (<a>String</a>), a definition (<a>Sentence</a>), a short name
--   (<a>String</a>), and a domain (for explicit tagging).
cic :: Concept c => String -> Sentence -> String -> c -> ConceptInstance


-- | For defining units built from a concept.
module Language.Drasil.Chunk.UnitDefn

-- | Types may contain a unit (<a>UnitDefn</a>).
class MayHaveUnit u
getUnit :: MayHaveUnit u => u -> Maybe UnitDefn

-- | Units are <a>Idea</a>s with a <a>Definition</a> which store a unit
--   symbol. They must also be explicitly declared to be instances of
--   IsUnit.
class (Idea u, Definition u, HasUnitSymbol u) => IsUnit u

-- | Holds units as a list of <a>UID</a>.
getUnits :: IsUnit u => u -> [UID]

-- | Temporary class to make sure chunks have a unit (in order to
--   eventually get rid of <a>MayHaveUnit</a>).
class TempHasUnit u
findUnit :: TempHasUnit u => u -> UnitDefn

-- | For defining units. It has a <a>ConceptChunk</a> (that defines what
--   kind of unit it is), a unit symbol, maybe another (when it is a
--   synonym), perhaps a definition, and a list of <a>UID</a> of the units
--   that make up the definition.
--   
--   Ex. Meter is a unit of length defined by the symbol (m).
data UnitDefn
UD :: ConceptChunk -> UnitSymbol -> [UID] -> UnitDefn
[_vc] :: UnitDefn -> ConceptChunk
[_cas] :: UnitDefn -> UnitSymbol
[_cu] :: UnitDefn -> [UID]

-- | Create a derived unit chunk from a concept and a unit equation.
makeDerU :: ConceptChunk -> UnitEquation -> UnitDefn

-- | Smart constructor for new derived units from existing units.
newUnit :: String -> UnitEquation -> UnitDefn

-- | Uses self-plural term.
--   
--   Create a derived unit chunk from a <a>UID</a>, term (<a>String</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Uses term that pluralizes by adding "s" to the end.
--   
--   Create a derived unit chunk from a <a>UID</a>, term (<a>String</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC' :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Create a derived unit chunk from a <a>UID</a>, term (<a>NP</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC'' :: String -> NP -> String -> Symbol -> UDefn -> UnitDefn

-- | Smart constructor for a "fundamental" unit.
fund :: String -> String -> String -> UnitDefn

-- | Variant of the <a>fund</a>, useful for degree.
fund' :: String -> String -> Symbol -> UnitDefn

-- | Create a <tt>SI_Unit</tt> with two <a>Symbol</a> representations. The
--   created <a>NP</a> is self-plural.
derCUC :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Similar to <a>derCUC</a>, but the created <a>NP</a> has the
--   <tt>AddS</tt> plural rule.
derCUC' :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Create a derived unit chunk from a <a>UID</a>, term (<a>NP</a>),
--   definition, <a>Symbol</a>, and unit equation.
derCUC'' :: String -> NP -> String -> Symbol -> UnitEquation -> UnitDefn

-- | For allowing lists to mix together chunks that are units by projecting
--   them into a <a>UnitDefn</a>. For now, this only works on
--   <a>UnitDefn</a>s.
unitWrapper :: IsUnit u => u -> UnitDefn

-- | Combinator for raising a unit to a power.
(^:) :: UnitDefn -> Integer -> UnitEquation

-- | Combinator for dividing one unit by another.
(/:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying two units together.
(*:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying a unit and a symbol.
(*$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for dividing a unit and a symbol.
(/$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for mulitiplying two unit equations.
(^$) :: UnitEquation -> UnitEquation -> UnitEquation

-- | Combinator for scaling one unit by some number.
scale :: IsUnit s => Double -> s -> UDefn

-- | Combinator for shifting one unit by some number.
shift :: IsUnit s => Double -> s -> UDefn

-- | Generates a default unit symbol.
fromUDefn :: UDefn -> USymb

-- | Helper for fundamental unit concept chunk creation. Uses the same
--   <a>String</a> for the identifier, term, and definition.
unitCon :: String -> ConceptChunk

-- | Get a list of <a>UID</a> of the units that make up the
--   <a>UnitEquation</a>.
getCu :: UnitEquation -> [UID]

-- | We don't want an Ord on units, but this still allows us to compare
--   them.
compUnitDefn :: UnitDefn -> UnitDefn -> Ordering
instance Language.Drasil.Classes.HasUnitSymbol Language.Drasil.Chunk.UnitDefn.UnitEquation
instance Drasil.Database.UID.HasUID Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.UnitDefn.UnitDefn
instance GHC.Classes.Eq Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.HasUnitSymbol Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.IsUnit Language.Drasil.Chunk.UnitDefn.UnitDefn


-- | Defines chunks to add units to a quantity. Similar to
--   <tt>UnitalChunk</tt>.
module Language.Drasil.Chunk.Unitary

-- | A Unitary is a <a>Quantity</a> that <b>must</b> have a unit.
class (Quantity c) => Unitary c
unit :: Unitary c => c -> UnitDefn

-- | Helper for getting the unit's <tt>Symbol</tt> from a chunk, as opposed
--   to the symbols of the chunk itself.
unit_symb :: Unitary c => c -> USymb


-- | For adding a relation (expression) to a concept.
module Language.Drasil.Chunk.Relation

-- | For a concept (<a>ConceptChunk</a>) that also has a <tt>Relation</tt>
--   (<a>ModelExpr</a>) attached.
--   
--   Ex. We can describe a pendulum arm and then apply an associated
--   equation so that we know its behaviour.
data RelationConcept

-- | Create a <a>RelationConcept</a> from a given <tt>UID</tt>, term
--   (<a>NP</a>), definition (<a>Sentence</a>), and <tt>Relation</tt>.
makeRC :: Express e => String -> NP -> Sentence -> e -> RelationConcept
instance Drasil.Database.UID.HasUID Language.Drasil.Chunk.Relation.RelationConcept
instance GHC.Classes.Eq Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.ExprClasses.Express Language.Drasil.Chunk.Relation.RelationConcept


-- | Contains the common idea type and respective constructors.
module Language.Drasil.Chunk.CommonIdea

-- | The common idea (with <tt>NounPhrase</tt>) data type. It must have a
--   <a>UID</a>, <tt>NounPhrase</tt> for its term, an abbreviation
--   (<a>String</a>), and a domain ([<a>UID</a>]). It is similar to
--   <a>IdeaDict</a> and <a>IdeaDict</a> in the sense that these are for
--   things worth naming, but this type also carries an abbreviation and
--   related domains of knowledge.
--   
--   Ex. The term "Operating System" has the abbreviation <a>OS</a> and
--   comes from the domain of computer science.
data CI

-- | The commonIdea smart constructor requires a chunk id (<a>String</a>),
--   a term (<a>NP</a>), an abbreviation (<a>String</a>), and a domain
--   ([<a>UID</a>]).
commonIdea :: String -> NP -> String -> [UID] -> CI

-- | Similar to <a>commonIdea</a>, but takes a list of <a>IdeaDict</a>
--   (often a domain).
commonIdeaWithDict :: String -> NP -> String -> [IdeaDict] -> CI

-- | Prepends the abbreviation from a <a>CommonIdea</a> to a <a>String</a>.
prependAbrv :: CommonIdea c => c -> String -> String
instance Drasil.Database.UID.HasUID Language.Drasil.Chunk.CommonIdea.CI
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.CommonIdea.CI
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.CommonIdea.CI
instance Language.Drasil.Classes.CommonIdea Language.Drasil.Chunk.CommonIdea.CI
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.CommonIdea.CI

module Drasil.Code.CodeExpr.Lang

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp
IndexOf :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product, vector addition, vector sub).
data VVVBinOp
Cross :: VVVBinOp
VAdd :: VVVBinOp
VSub :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | <tt>Number x Vector -&gt; Vector</tt> binary operations (scaling).
data NVVBinOp
Scale :: NVVBinOp

-- | Element + Set -&gt; Set
data ESSBinOp
SAdd :: ESSBinOp
SRemove :: ESSBinOp

-- | Element + Set -&gt; Bool
data ESBBinOp
SContains :: ESBBinOp
data AssocConcatOper
SUnion :: AssocConcatOper

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
Add :: AssocArithOper
Mul :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | Expression language where all terms also denote a term in GOOL (i.e.
--   translation is total and meaning preserving).
data CodeExpr

-- | Brings literals into the expression language.
[Lit] :: Literal -> CodeExpr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [CodeExpr] -> CodeExpr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [CodeExpr] -> CodeExpr
[AssocC] :: AssocConcatOper -> [CodeExpr] -> CodeExpr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> CodeExpr

-- | A function call accepts a list of parameters and a list of named
--   parameters. For example
--   
--   <ul>
--   <li>F(x) is (FCall F [x] []).</li>
--   <li>F(x,y) would be (FCall F [x,y]).</li>
--   <li>F(x,n=y) would be (FCall F [x] [(n,y)]).</li>
--   </ul>
[FCall] :: UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Actor creation given <a>UID</a>, parameters, and named parameters.
[New] :: UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Message an actor:
--   
--   <ul>
--   <li>1st <a>UID</a> is the actor,</li>
--   <li>2nd <a>UID</a> is the method.</li>
--   </ul>
[Message] :: UID -> UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Access a field of an actor:
--   
--   <ul>
--   <li>1st <a>UID</a> is the actor,</li>
--   <li>2nd <a>UID</a> is the field.</li>
--   </ul>
[Field] :: UID -> UID -> CodeExpr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(CodeExpr, CodeExpr)] -> CodeExpr

-- | Represents a matrix of expressions.
[Matrix] :: [[CodeExpr]] -> CodeExpr

-- | Represents a set of expressions
[Set] :: Space -> [CodeExpr] -> CodeExpr

-- | used to refernce the (name + type = variable )
[Variable] :: String -> CodeExpr -> CodeExpr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> CodeExpr -> CodeExpr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Number x Vector -&gt; Vector</tt> operations
--   (scaling).
[NVVBinaryOp] :: NVVBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Set operator for Set + Set -&gt; Set
[ESSBinaryOp] :: ESSBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Set operator for Element + Set -&gt; Bool
[ESBBinaryOp] :: ESBBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Operators are generalized arithmetic operators over a
--   <tt>DomainDesc</tt> of an <tt>Expr</tt>. Could be called BigOp. ex:
--   Summation is represented via <a>Add</a> over a discrete domain.
[Operator] :: AssocArithOper -> DiscreteDomainDesc CodeExpr CodeExpr -> CodeExpr -> CodeExpr

-- | The expression is an element of a space. IsIn :: Expr -&gt; Space
--   -&gt; Expr | A different kind of <tt>IsIn</tt>. A <a>UID</a> is an
--   element of an interval.
[RealI] :: UID -> RealInterval CodeExpr CodeExpr -> CodeExpr
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.ArithBinOp
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.EqBinOp
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.BoolBinOp
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.LABinOp
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.OrdBinOp
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.VVVBinOp
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.VVNBinOp
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.NVVBinOp
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.ESSBinOp
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.ESBBinOp
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.AssocConcatOper
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.AssocArithOper
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.AssocBoolOper
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.UFunc
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.UFuncB
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.UFuncVV
instance GHC.Classes.Eq Drasil.Code.CodeExpr.Lang.UFuncVN
instance Language.Drasil.Literal.Class.LiteralC Drasil.Code.CodeExpr.Lang.CodeExpr

module Language.Drasil.Expr.Class
class ExprC r
lit :: ExprC r => Literal -> r
($=) :: ExprC r => r -> r -> r
($!=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>=) :: ExprC r => r -> r -> r

-- | Smart constructor for the dot product of two equations.
($.) :: ExprC r => r -> r -> r

-- | Add two expressions.
($+) :: ExprC r => r -> r -> r

-- | Multiply two expressions.
($*) :: ExprC r => r -> r -> r
($-) :: ExprC r => r -> r -> r
($/) :: ExprC r => r -> r -> r
($^) :: ExprC r => r -> r -> r
($=>) :: ExprC r => r -> r -> r
($<=>) :: ExprC r => r -> r -> r
($&&) :: ExprC r => r -> r -> r
($||) :: ExprC r => r -> r -> r

-- | Smart constructor for set-theoretic membership relation. Added ' to
--   avoid conflict.
in' :: ExprC r => r -> r -> r

-- | Smart constructor for taking the absolute value of an expression.
abs_ :: ExprC r => r -> r

-- | Smart constructor for negating an expression.
neg :: ExprC r => r -> r

-- | Smart constructor to take the log of an expression.
log :: ExprC r => r -> r

-- | Smart constructor to take the ln of an expression.
ln :: ExprC r => r -> r

-- | Smart constructor to take the square root of an expression.
sqrt :: ExprC r => r -> r

-- | Smart constructor to apply sin to an expression.
sin :: ExprC r => r -> r

-- | Smart constructor to apply cos to an expression.
cos :: ExprC r => r -> r

-- | Smart constructor to apply tan to an expression.
tan :: ExprC r => r -> r

-- | Smart constructor to apply sec to an expression.
sec :: ExprC r => r -> r

-- | Smart constructor to apply csc to an expression.
csc :: ExprC r => r -> r

-- | Smart constructor to apply cot to an expression.
cot :: ExprC r => r -> r

-- | Smart constructor to apply arcsin to an expression.
arcsin :: ExprC r => r -> r

-- | Smart constructor to apply arccos to an expression.
arccos :: ExprC r => r -> r

-- | Smart constructor to apply arctan to an expression.
arctan :: ExprC r => r -> r

-- | Smart constructor for the exponential (base e) function.
exp :: ExprC r => r -> r

-- | Smart constructor for calculating the dimension of a vector.
dim :: ExprC r => r -> r

-- | Smart constructor for calculating the normal form of a vector.
norm :: ExprC r => r -> r

-- | Smart constructor for negating vectors.
negVec :: ExprC r => r -> r

-- | Smart constructor for applying logical negation to an expression.
not_ :: ExprC r => r -> r

-- | Smart constructor for indexing.
idx :: ExprC r => r -> r -> r

-- | Smart constructor for indexOf. Finds the index of the first occurrence
--   of a value in a list.
idxOf :: ExprC r => r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defint :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defsum :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defprod :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for 'real interval' membership.
realInterval :: (ExprC r, HasUID c) => c -> RealInterval r r -> r

-- | Euclidean function : takes a vector and returns the sqrt of the
--   sum-of-squares.
euclidean :: ExprC r => [r] -> r

-- | Smart constructor to cross product two expressions.
cross :: ExprC r => r -> r -> r

-- | Smart constructor for vector scaling
vScale :: ExprC r => r -> r -> r

-- | Vector Addition
vAdd :: ExprC r => r -> r -> r

-- | Vector Subtraction
vSub :: ExprC r => r -> r -> r

-- | Smart constructor for case statements with a complete set of cases.
completeCase :: ExprC r => [(r, r)] -> r

-- | Smart constructor for case statements with an incomplete set of cases.
incompleteCase :: ExprC r => [(r, r)] -> r

-- | Create a matrix.
matrix :: ExprC r => [[r]] -> r

-- | Create a Set.
set' :: ExprC r => Space -> [r] -> r

-- | Applies a given function with a list of parameters.
apply :: (ExprC r, HasUID f, HasSymbol f) => f -> [r] -> r

-- | Create an <a>Expr</a> from a <a>Symbol</a>ic Chunk.
sy :: (ExprC r, HasUID c, HasSymbol c) => c -> r
infixr 4 $=
infixl 7 $/
infixr 8 $^
infixr 9 $&&
infixr 9 $||

-- | Smart constructor for fractions.
frac :: (ExprC r, LiteralC r) => Integer -> Integer -> r

-- | Smart constructor for rational expressions (only in 1/x form).
recip_ :: (ExprC r, LiteralC r) => r -> r

-- | Smart constructor to square a function.
square :: (ExprC r, LiteralC r) => r -> r

-- | Smart constructor to half a function exactly.
half :: (ExprC r, LiteralC r) => r -> r

-- | 1/2, as an expression.
oneHalf :: (ExprC r, LiteralC r) => r

-- | 1/3rd, as an expression.
oneThird :: (ExprC r, LiteralC r) => r

-- | Similar to <a>apply</a>, but converts second argument into
--   <a>Symbol</a>s.
apply1 :: (ExprC r, HasUID f, HasSymbol f, HasUID a, HasSymbol a) => f -> a -> r

-- | Similar to <a>apply</a>, but the applied function takes two parameters
--   (which are both <a>Symbol</a>s).
apply2 :: (ExprC r, HasUID f, HasSymbol f, HasUID a, HasSymbol a, HasUID b, HasSymbol b) => f -> a -> b -> r

-- | Create a two-by-two matrix from four given values. For example:
--   
--   <pre>
--   &gt;&gt;&gt; m2x2 1 2 3 4
--   [ [1,2],
--     [3,4] ]
--   </pre>
m2x2 :: ExprC r => r -> r -> r -> r -> r

-- | Create a 2D vector (a matrix with two rows, one column). First
--   argument is placed above the second.
vec2D :: ExprC r => r -> r -> r

-- | Creates a diagonal two-by-two matrix. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dgnl2x2 1 2
--   [ [1, 0],
--     [0, 2] ]
--   </pre>
dgnl2x2 :: (ExprC r, LiteralC r) => r -> r -> r

-- | Create a row vector
rowVec :: ExprC r => [r] -> r

-- | Create a column vector
columnVec :: ExprC r => [r] -> r
mkSet :: ExprC r => Space -> [r] -> r
instance Language.Drasil.Expr.Class.ExprC Language.Drasil.Expr.Lang.Expr
instance Language.Drasil.Expr.Class.ExprC Language.Drasil.ModelExpr.Lang.ModelExpr
instance Language.Drasil.Expr.Class.ExprC Drasil.Code.CodeExpr.Lang.CodeExpr


-- | Contains types that define quantities from concepts.
module Language.Drasil.Chunk.DefinedQuantity

-- | DefinedQuantityDict is the combination of a <a>Concept</a> and a
--   <a>Quantity</a>. Contains a <a>ConceptChunk</a>, a <a>Symbol</a>
--   dependent on <a>Stage</a>, a <a>Space</a>, and maybe a
--   <a>UnitDefn</a>. Used when we want to assign a quantity to a concept.
--   Includes the space, symbol, and units for that quantity.
--   
--   Ex. A pendulum arm can be defined as a concept with a symbol (l),
--   space (Real numbers), and units (cm, m, etc.).
data DefinedQuantityDict
class DefinesQuantity d
defLhs :: DefinesQuantity d => Getter d DefinedQuantityDict

-- | Smart constructor that creates a DefinedQuantityDict with a
--   <a>ConceptChunk</a>, a <a>Symbol</a> independent of <a>Stage</a>, a
--   <a>Space</a>, and a unit.
dqd :: IsUnit u => ConceptChunk -> Symbol -> Space -> u -> DefinedQuantityDict

-- | Similar to <a>dqd</a>, but without any units.
dqdNoUnit :: ConceptChunk -> Symbol -> Space -> DefinedQuantityDict
dqdNoUnit' :: ConceptChunk -> (Stage -> Symbol) -> Space -> DefinedQuantityDict

-- | Similar to <a>dqd</a>, but the <a>Symbol</a> is now dependent on the
--   <a>Stage</a>.
dqd' :: ConceptChunk -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> DefinedQuantityDict

-- | When we want to merge a quantity and a concept. This is suspicious.
dqdQd :: (Quantity c, MayHaveUnit c) => c -> Sentence -> DefinedQuantityDict

-- | When the input already has all the necessary information. A
--   <tt>projection</tt> operator from some a type with instances of listed
--   classes to a <a>DefinedQuantityDict</a>.
dqdWr :: (Quantity c, Concept c, MayHaveUnit c) => c -> DefinedQuantityDict

-- | Makes a variable that is implementation-only.
implVar :: String -> NP -> String -> Space -> Symbol -> DefinedQuantityDict

-- | Similar to <a>implVar</a>, but takes in a <a>Sentence</a> for the
--   description rather than a <a>String</a>.
implVar' :: String -> NP -> Sentence -> Space -> Symbol -> DefinedQuantityDict

-- | Similar to <a>implVar</a> but allows specification of abbreviation and
--   unit.
implVarAU :: String -> NP -> String -> Maybe String -> Space -> Symbol -> Maybe UnitDefn -> DefinedQuantityDict

-- | Similar to <a>implVarAU</a> but takes a Sentence for the description
--   rather than a String.
implVarAU' :: String -> NP -> Sentence -> Maybe String -> Space -> Symbol -> Maybe UnitDefn -> DefinedQuantityDict
instance Drasil.Database.UID.HasUID Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance GHC.Classes.Eq Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Space.HasSpace Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Symbol.HasSymbol Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.ExprClasses.Express Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict


-- | Defines chunks to add units to a quantity. Similar to
--   <tt>UnitaryChunk</tt>.
module Language.Drasil.Chunk.Unital

-- | Similar to a <a>DefinedQuantityDict</a>, UnitalChunks are concepts
--   with quantities that must have a unit definition. Contains
--   <a>DefinedQuantityDict</a>s and a <a>UnitDefn</a>.
--   
--   Ex. A pendulum arm is a tangible object with a symbol (l) and units
--   (cm, m, etc.).
data UnitalChunk
UC :: DefinedQuantityDict -> UnitDefn -> UnitalChunk
[_defq'] :: UnitalChunk -> DefinedQuantityDict
[_uni] :: UnitalChunk -> UnitDefn

-- | Used to create a <a>UnitalChunk</a> from a <a>Concept</a>,
--   <a>Symbol</a>, and <tt>Unit</tt>.
uc :: (Concept c, IsUnit u) => c -> Symbol -> Space -> u -> UnitalChunk

-- | Similar to <a>uc</a>, except it builds the <a>Concept</a> portion of
--   the <a>UnitalChunk</a> from a given <tt>UID</tt>, term, and definition
--   (as a <a>Sentence</a>) which are its first three arguments.
uc' :: IsUnit u => String -> NP -> Sentence -> Symbol -> Space -> u -> UnitalChunk

-- | Similar to <a>uc</a>, but <a>Symbol</a> is dependent on the
--   <a>Stage</a>.
ucStaged :: (Concept c, IsUnit u) => c -> (Stage -> Symbol) -> Space -> u -> UnitalChunk

-- | Similar to <a>uc'</a>, but <a>Symbol</a> is dependent on the
--   <a>Stage</a>.
ucStaged' :: IsUnit u => String -> NP -> Sentence -> (Stage -> Symbol) -> Space -> u -> UnitalChunk

-- | Attach units to a chunk that has a symbol and definition.
ucuc :: (Quantity c, Concept c, MayHaveUnit c) => c -> UnitDefn -> UnitalChunk

-- | Constructs a UnitalChunk from a <a>Concept</a> with <tt>Units</tt>.
ucw :: (Unitary c, Concept c, MayHaveUnit c) => c -> UnitalChunk
instance Drasil.Database.UID.HasUID Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Space.HasSpace Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Symbol.HasSymbol Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Chunk.Unitary.Unitary Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Chunk.UnitDefn.TempHasUnit Language.Drasil.Chunk.Unital.UnitalChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.ExprClasses.Express Language.Drasil.Chunk.Unital.UnitalChunk


-- | Add constraints and a reasonable value to chunks that are quantities.
module Language.Drasil.Chunk.Constrained

-- | ConstrConcepts are conceptual symbolic quantities
--   (<a>DefinedQuantityDict</a>) with <tt>Constraint</tt>s and maybe a
--   reasonable value (no units!). Similar to <tt>ConstrainedChunk</tt> but
--   includes a definition and domain.
--   
--   Ex. Measuring the length of a pendulum arm could be a concept that has
--   some reasonable value (between 1 cm and 2 m) and the constraint that
--   the length cannot be a negative value.
data ConstrConcept
ConstrConcept :: DefinedQuantityDict -> [ConstraintE] -> Maybe Expr -> ConstrConcept
[_defq] :: ConstrConcept -> DefinedQuantityDict
[_constr'] :: ConstrConcept -> [ConstraintE]
[_reasV'] :: ConstrConcept -> Maybe Expr

-- | Similar to <tt>cnstrw</tt>, but types must also have a <a>Concept</a>.
cnstrw' :: (Quantity c, Concept c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> ConstrConcept

-- | Creates a <a>ConstrConcept</a> with a quantitative concept, a list of
--   <tt>Constraint</tt>s and an <a>Expr</a>.
constrained' :: (Concept c, MayHaveUnit c, Quantity c) => c -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to <a>constrained'</a>, but defaults <a>Maybe</a> <a>Expr</a>
--   to <a>Nothing</a>.
constrainedNRV' :: (Concept c, MayHaveUnit c, Quantity c) => c -> [ConstraintE] -> ConstrConcept

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), description (<a>String</a>), <a>Symbol</a>, unit,
--   <a>Space</a>, <tt>Constraint</tt>s, and an <a>Expr</a>.
cuc' :: IsUnit u => String -> NP -> String -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to <a>cuc'</a>, but <a>Symbol</a> is dependent on
--   <a>Stage</a>.
cuc'' :: IsUnit u => String -> NP -> String -> (Stage -> Symbol) -> u -> Space -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to cuc', but does not include a unit.
cucNoUnit' :: String -> NP -> String -> Symbol -> Space -> [ConstraintE] -> Expr -> ConstrConcept
instance Drasil.Database.UID.HasUID Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Space.HasSpace Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Symbol.HasSymbol Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Constrained Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.HasReasVal Language.Drasil.Chunk.Constrained.ConstrConcept
instance GHC.Classes.Eq Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.ExprClasses.Express Language.Drasil.Chunk.Constrained.ConstrConcept


-- | For adding an uncertainty value to quantities with constraints.
module Language.Drasil.Chunk.UncertainQuantity

-- | UncertQs are conceptual symbolic quantities with constraints and an
--   <a>Uncertainty</a>. Contains a <a>ConstrConcept</a> and an
--   <a>Uncertainty</a>.
--   
--   Ex. Measuring the length of a pendulum arm may be recorded with an
--   uncertainty value.
data UncertQ

-- | Smart constructor that requires a <a>Quantity</a>, a percentage, and a
--   typical value with an <a>Uncertainty</a>.
uq :: (Quantity c, Constrained c, Concept c, HasReasVal c, MayHaveUnit c) => c -> Uncertainty -> UncertQ

-- | Uncertainty quantity (<a>uq</a>) but with a constraint.
uqc :: IsUnit u => String -> NP -> String -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertQ

-- | Uncertainty quantity constraint (<a>uqc</a>) without a description.
uqcND :: IsUnit u => String -> NP -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertQ
instance GHC.Classes.Eq Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Drasil.Database.UID.HasUID Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Space.HasSpace Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Symbol.HasSymbol Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Uncertainty.HasUncertainty Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Constrained Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.HasReasVal Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.ExprClasses.Express Language.Drasil.Chunk.UncertainQuantity.UncertQ


-- | Contains types and functions common to aspects of generating
--   documents.
module Language.Drasil.Document.Core

-- | Denotes the different possible types that can be used as a list.
data ListType

-- | Bulleted list.
Bullet :: [(ItemType, Maybe String)] -> ListType

-- | Enumerated list.
Numeric :: [(ItemType, Maybe String)] -> ListType

-- | Simple list with items denoted by <tt>:</tt>. Renders as "Title: Item"
Simple :: [ListTuple] -> ListType

-- | Descriptive list, renders as "<b>Title</b>: Item" (see
--   <a>ListTuple</a>).
Desc :: [ListTuple] -> ListType

-- | Renders a list of "<tt><a>Title</a></tt> is the <tt>Item</tt>".
Definitions :: [ListTuple] -> ListType

-- | Denotes how something should behave in a list (<a>ListType</a>).
data ItemType

-- | Standard singular item.
Flat :: Sentence -> ItemType

-- | Nest a list (<a>ListType</a>) as an item.
Nested :: Header -> ListType -> ItemType

-- | MaxWidthPercent should be kept in the range 1-100. Values outside this
--   range may have unexpected results. Used for specifying max figure
--   width as <tt>pagewidth*MaxWidthPercent/100</tt>.
type MaxWidthPercent = Float
type Title = Sentence
type Author = Sentence
type Header = -- | Used when creating sublists. Sentence
type Depth = Int
type Width = Float
type Height = Float
type ListTuple = -- | Formats as Title: Item. For use in lists. (Title, ItemType, Maybe String)
type Filepath = String
type Lbl = -- | Label. Sentence

-- | Contents may be labelled or unlabelled.
data Contents
UlC :: UnlabelledContent -> Contents
LlC :: LabelledContent -> Contents

-- | Types of definitions (general, instance, theory, or data).
data DType
General :: DType
Instance :: DType
Theory :: DType
Data :: DType

-- | Indicates whether a figure has a caption or not.
data HasCaption
NoCaption :: HasCaption
WithCaption :: HasCaption

-- | Types of layout objects we deal with explicitly.
data RawContent

-- | table has: header-row, data(rows), label/caption, and a bool that
--   determines whether or not to show label.
Table :: [Sentence] -> [[Sentence]] -> Title -> Bool -> RawContent

-- | Paragraphs are just sentences.
Paragraph :: Sentence -> RawContent

-- | Block of Equations holds an expression.
EqnBlock :: ModelExpr -> RawContent

-- | Grants the ability to label a group of <a>RawContent</a>.
DerivBlock :: Sentence -> [RawContent] -> RawContent

-- | For enumerated lists.
Enumeration :: ListType -> RawContent

-- | Defines something with a type, identifier, and <a>Contents</a>.
Defini :: DType -> [(Identifier, [Contents])] -> RawContent

-- | For creating figures in a document includes whether the figure has a
--   caption.
Figure :: Lbl -> Filepath -> MaxWidthPercent -> HasCaption -> RawContent

-- | Grants the ability to reference something.
Bib :: BibRef -> RawContent

-- | Contain a graph with coordinates (<a>Sentence</a>s), maybe a width and
--   height, and a label (<a>Sentence</a>).
Graph :: [(Sentence, Sentence)] -> Maybe Width -> Maybe Height -> Lbl -> RawContent

-- | Block for codes TODO: Fill this one in.
CodeBlock :: CodeExpr -> RawContent

-- | An identifier is just a <a>String</a>.
type Identifier = String

-- | Contains a <a>Reference</a> and <a>RawContent</a>.
data LabelledContent
LblC :: Reference -> RawContent -> LabelledContent
[_ref] :: LabelledContent -> Reference
[_ctype] :: LabelledContent -> RawContent

-- | Only contains <a>RawContent</a>.
newtype UnlabelledContent
UnlblC :: RawContent -> UnlabelledContent
[_cntnts] :: UnlabelledContent -> RawContent
ref :: Lens' LabelledContent Reference
ctype :: Lens' LabelledContent RawContent
cntnts :: Iso' UnlabelledContent RawContent

-- | Members of this class must have <a>RawContent</a>.
class HasContents c

-- | Provides a <tt>Lens</tt> to the <a>RawContent</a>.
accessContents :: HasContents c => Lens' c RawContent

-- | Helper to prepend labels to <a>LabelledContent</a> when referencing.
prependLabel :: RawContent -> IRefProg
instance Language.Drasil.Document.Core.HasContents Language.Drasil.Document.Core.LabelledContent
instance Language.Drasil.Document.Core.HasContents Language.Drasil.Document.Core.UnlabelledContent
instance Language.Drasil.Document.Core.HasContents Language.Drasil.Document.Core.Contents
instance Drasil.Database.UID.HasUID Language.Drasil.Document.Core.LabelledContent
instance GHC.Classes.Eq Language.Drasil.Document.Core.LabelledContent
instance Language.Drasil.Label.Type.HasRefAddress Language.Drasil.Document.Core.LabelledContent
instance Language.Drasil.ShortName.HasShortName Language.Drasil.Document.Core.LabelledContent
instance Language.Drasil.Label.Type.Referable Language.Drasil.Document.Core.LabelledContent
instance GHC.Classes.Eq Language.Drasil.Document.Core.HasCaption


-- | Document Description Language.
module Language.Drasil.Document

-- | Section Contents are split into subsections or contents, where
--   contents are standard layout objects (see <a>Contents</a>).
data SecCons
Sub :: Section -> SecCons
Con :: Contents -> SecCons
data Partition
Sections :: Partition
Part :: Partition
Chapter :: Partition

-- | Sections have a title (<a>Sentence</a>), a list of contents
--   (<a>SecCons</a>) and a shortname (<a>Reference</a>).
data Section
Section :: Title -> [SecCons] -> Reference -> Section
[tle] :: Section -> Title
[cons] :: Section -> [SecCons]
[_lab] :: Section -> Reference
lab :: Lens' Section Reference

-- | A Document has a Title (<a>Sentence</a>), Author(s) (<a>Sentence</a>),
--   and <a>Section</a>s which hold the contents of the document.
data Document
Document :: Title -> Author -> ShowTableOfContents -> [Section] -> Document
Notebook :: Title -> Author -> [Section] -> Document

-- | Determines whether or not the table of contents appears on the
--   generated artifacts.
data ShowTableOfContents
ToC :: ShowTableOfContents
NoToC :: ShowTableOfContents

-- | Manually removes the first section of a document (table of contents
--   section). temp fix for Notebook (see if we need this in notebook
--   later)
checkToC :: Document -> Document

-- | Smart constructor for labelled content chunks.
llcc :: Reference -> RawContent -> LabelledContent

-- | Smart constructor for unlabelled content chunks (no <a>Reference</a>).
ulcc :: RawContent -> UnlabelledContent

-- | Smart constructor that wraps <a>UnlabelledContent</a> into
--   <a>Contents</a>.
mkParagraph :: Sentence -> Contents

-- | Smart constructor that wraps <a>LabelledContent</a> into
--   <a>Contents</a>.
mkFig :: Reference -> RawContent -> Contents

-- | Smart constructor similar to <a>llcc</a>, but takes in
--   <a>RawContent</a> first.
mkRawLC :: RawContent -> Reference -> LabelledContent

-- | Smart constructor for creating <a>Section</a>s with a title
--   (<a>Sentence</a>), introductory contents (ie. paragraphs, tables,
--   etc.), a list of subsections, and a shortname (<a>Reference</a>).
section :: Sentence -> [Contents] -> [Section] -> Reference -> Section

-- | <a>Figure</a> smart constructor with a <a>Lbl</a> and a
--   <a>Filepath</a>. Assumes 100% of page width as max width. Defaults to
--   <a>WithCaption</a>.
fig :: Lbl -> Filepath -> RawContent

-- | <a>Figure</a> smart constructor without a caption.
figNoCap :: Lbl -> Filepath -> RawContent

-- | <a>Figure</a> smart constructor that allows for customized max widths.
--   Defaults to <a>WithCaption</a>.
figWithWidth :: Lbl -> Filepath -> MaxWidthPercent -> RawContent

-- | <a>Figure</a> smart constructor with customized max widths and no
--   caption.
figNoCapWithWidth :: Lbl -> Filepath -> MaxWidthPercent -> RawContent
docNs :: UID -> UID
docUid :: String -> UID

-- | Create a reference for a table. Takes in the name of a table (which
--   will also be used for its shortname).
makeTabRef :: String -> Reference

-- | Create a reference for a figure. Takes in the name of a figure (which
--   will also be used for its shortname).
makeFigRef :: String -> Reference

-- | Create a reference for a section. Takes in the name of a section and a
--   shortname for the section.
makeSecRef :: String -> Sentence -> Reference

-- | Create a reference for a equation. Takes in the name of the equation
--   (which will also be used for its shortname).
makeEqnRef :: String -> Reference

-- | Create a reference for a <a>URI</a>. Takes in a <a>UID</a> (as a
--   <a>String</a>), a reference address, and a shortname.
makeURI :: String -> String -> ShortName -> Reference

-- | Variants of <a>makeTabRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeTabRef' :: UID -> Reference

-- | Variants of <a>makeFigRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeFigRef' :: UID -> Reference

-- | Variants of <a>makeSecRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeSecRef' :: UID -> Sentence -> Reference

-- | Variants of <a>makeEqnRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeEqnRef' :: UID -> Reference

-- | Variants of <a>makeURI</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeURI' :: UID -> String -> ShortName -> Reference
instance Drasil.Database.UID.HasUID Language.Drasil.Document.Section
instance GHC.Classes.Eq Language.Drasil.Document.Section
instance Language.Drasil.ShortName.HasShortName Language.Drasil.Document.Section
instance Language.Drasil.Label.Type.Referable Language.Drasil.Document.Section
instance Language.Drasil.Label.Type.HasRefAddress Language.Drasil.Document.Section


-- | Folding-related functions and types.
module Language.Drasil.Sentence.Fold

-- | Type that helps determine enumeration method. Can use either numbers,
--   uppercase letters, or lowercase letters.
data EnumType
Numb :: EnumType
Upper :: EnumType
Lower :: EnumType

-- | Type to help wrap a sentence with parenthesis or to add a period at
--   the end.
data WrapType
Parens :: WrapType
Period :: WrapType

-- | Type to help separate words with commas or semicolons.
data SepType
Comma :: SepType
SemiCol :: SepType

-- | Type to help fold differently between listed items, or if there are
--   options (ex. using "and" or "or" at the end of a list of words).
data FoldType
List :: FoldType
Options :: FoldType

-- | Helper for formatting a list of constraints.
foldConstraints :: Quantity c => c -> [ConstraintE] -> Sentence

-- | Creates a list of elements with "enumerators" in "wrappers" using
--   foldlList.
foldlEnumList :: EnumType -> WrapType -> SepType -> FoldType -> [Sentence] -> Sentence

-- | Creates a list of elements separated by a "separator", ending with
--   "and" or "or".
foldlList :: SepType -> FoldType -> [Sentence] -> Sentence

-- | Fold sentences then turns into content using <a>foldlSent</a>.
foldlSP :: [Sentence] -> Contents

-- | Same as <a>foldlSP</a> but uses <a>foldlSent_</a>.
foldlSP_ :: [Sentence] -> Contents

-- | Same as <a>foldlSP</a> but uses <a>foldlSentCol</a>.
foldlSPCol :: [Sentence] -> Contents

-- | Partial function application of <a>foldle</a> for sentences
--   specifically. Folds with spaces and adds a period (".") at the end.
foldlSent :: [Sentence] -> Sentence

-- | <a>foldlSent</a> but does not add a period.
foldlSent_ :: [Sentence] -> Sentence

-- | <a>foldlSent</a> but ends with colon.
foldlSentCol :: [Sentence] -> Sentence

-- | Folds a list of elements separated by commas, including the last
--   element.
foldlsC :: [Sentence] -> Sentence

-- | Parses a list of integers into a nice sentence (ie. S "1, 4-7, and
--   13").
foldNums :: String -> [Int] -> Sentence

-- | Parses a list of integers into a list of strings (ie. ["1", "4-7",
--   "13"]).
numList :: String -> [Int] -> [String]


-- | Miscellaneous utility functions for use throughout Drasil.
module Language.Drasil.Document.Combinators

-- | Output is of the form "<tt>reference - sentence</tt>".
chgsStart :: (HasShortName x, Referable x) => x -> Sentence -> Sentence

-- | Takes a <a>HasSymbol</a> that is also <a>Referable</a> and outputs as
--   a <a>Sentence</a>: "<tt>symbol</tt> is defined in <tt>reference</tt>."
definedIn :: (Referable r, HasShortName r, DefinesQuantity r) => r -> Sentence

-- | Same as <a>definedIn</a>, but allows for additional information to be
--   appended to the <a>Sentence</a>.
definedIn' :: (Referable r, HasShortName r, DefinesQuantity r) => r -> Sentence -> Sentence

-- | Takes a <a>Referable</a> and outputs as a <a>Sentence</a> "defined in
--   <tt>reference</tt>" (no <a>HasSymbol</a>).
definedIn'' :: (Referable r, HasShortName r) => r -> Sentence

-- | Takes a <a>Symbol</a> and its <tt>Reference</tt> (does not append a
--   period at the end!). Outputs as "<tt>symbol</tt> is defined in
--   <tt>source</tt>".
definedIn''' :: (HasSymbol q, HasUID q, Referable r, HasShortName r) => q -> r -> Sentence

-- | Takes an expression and a <a>Referable</a> and outputs as a Sentence
--   "expression (source)".
eqnWSource :: (Referable r, HasShortName r) => ModelExpr -> r -> Sentence

-- | Takes a <a>Referable</a> source and a <a>UnitalChunk</a> and outputs
--   as a <a>Sentence</a>: "From <tt>source</tt> we can replace
--   <tt>symbol</tt>:".
fromReplace :: (Referable r, HasShortName r) => r -> UnitalChunk -> Sentence

-- | Wraps "from <tt>reference</tt>" in parentheses.
fromSource :: (Referable r, HasShortName r) => r -> Sentence

-- | Similar to <a>fromSource</a> but takes a list of references instead of
--   one.
fromSources :: (Referable r, HasShortName r) => [r] -> Sentence

-- | Takes an amount as a <a>Sentence</a> and appends a unit to it.
fmtU :: MayHaveUnit a => Sentence -> a -> Sentence

-- | Appends "following <tt>reference</tt>" to the end of a
--   <a>Sentence</a>.
follows :: (Referable r, HasShortName r) => Sentence -> r -> Sentence

-- | Takes a list and a <a>Section</a>, then generates a list of that
--   section's reference to match the length of the list.
makeListRef :: [a] -> Section -> [Sentence]

-- | Converts input to a <a>Sentence</a> and appends %.
addPercent :: Show a => a -> Sentence

-- | Prepends the word <a>Equation</a> to an <a>Int</a>.
eqN :: Int -> Sentence

-- | Uses an <a>Either</a> type to check if a <a>String</a> is valid -
--   <a>Left</a> with error message if there is an invalid <a>Char</a> in
--   <a>String</a>, else <a>Right</a> with <a>String</a>.
checkValidStr :: String -> String -> Either String String

-- | Used when you want to say a term followed by its symbol. ex. "...using
--   the Force F in...".
getTandS :: Quantity a => a -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeChanged :: Sentence -> Sentence -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeExpanded :: Sentence -> Sentence -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeWOVerb :: Sentence -> Sentence -> Sentence

-- | Returns the <a>Sentence</a> "<tt>(<a>titleize</a> aNamedIdea)</tt>
--   Showing the Connections Between <tt>contents</tt>".
showingCxnBw :: NamedIdea c => c -> Sentence -> Sentence

-- | Takes a list of <a>Referable</a>s and <a>Symbol</a>s and outputs as a
--   Sentence "By substituting <tt>symbols</tt>, this can be written as:".
substitute :: (Referable r, HasShortName r, DefinesQuantity r) => [r] -> Sentence

-- | Extracts the typical uncertainty to be displayed from something that
--   has an uncertainty.
typUncr :: HasUncertainty c => c -> Sentence

-- | Returns the <a>Sentence</a> "The <tt>chunk</tt> under consideration is
--   <tt>chunkDefinition</tt>".
underConsidertn :: ConceptChunk -> Sentence

-- | Get a unit symbol if there is one.
unwrap :: Maybe UnitDefn -> Sentence

-- | Apply a binary function to the terms of two named ideas, instead of to
--   the named ideas themselves. Ex. <tt>fterms compoundPhrase t1 t2</tt>
--   instead of <tt>compoundPhrase (t1 ^. term) (t2 ^. term)</tt>.
fterms :: (NamedIdea c, NamedIdea d) => (NP -> NP -> t) -> c -> d -> t

-- | Applies <a>Bullet</a> and <a>Flat</a> to a list.
bulletFlat :: [Sentence] -> ListType

-- | Applies <a>Bullet</a>s and headers to a <a>Nested</a> <a>ListType</a>.
--   The first argument is the headers of the <a>Nested</a> lists.
bulletNested :: [Sentence] -> [ListType] -> ListType

-- | Makes <a>Sentence</a>s from an item and its reference. Takes the title
--   of reference as a <a>String</a> and a <a>Sentence</a> containing the
--   full reference. Wraps the full reference in parenthesis.
itemRefToSent :: String -> Sentence -> Sentence

-- | Makes a traceability matrix from a list of row titles, a list of rows
--   of "checked" columns, and a list of columns.
makeTMatrix :: Eq a => [Sentence] -> [[a]] -> [a] -> [[Sentence]]

-- | Zip helper function enumerates abbreviations and zips it with list of
--   <a>ItemType</a>:
--   
--   <ul>
--   <li>s - the number from which the enumeration should start from
--   (<a>Integer</a>),</li>
--   <li>t - the title of the list (<a>Sentence</a>),</li>
--   <li>l - the list to be enumerated ([<a>Sentence</a>]).</li>
--   </ul>
mkEnumAbbrevList :: Integer -> Sentence -> [Sentence] -> [(Sentence, ItemType)]

-- | Helper for making a table from a columns.
mkTableFromColumns :: [(Sentence, [Sentence])] -> ([Sentence], [[Sentence]])

-- | Converts lists of simple <a>ItemType</a>s into a list which may be
--   used in <tt>Contents</tt> but is not directly referable.
noRefs :: [ItemType] -> [(ItemType, Maybe String)]

-- | Create a list in the pattern of "The __ are refined to the __". Note:
--   Order matters!
refineChain :: NamedIdea c => [(c, Section)] -> Sentence

-- | Sorts a list of <tt>HasSymbols</tt> by <a>Symbol</a>.
sortBySymbol :: HasSymbol a => [a] -> [a]

-- | Sorts a tuple list of <tt>HasSymbols</tt> by first Symbol in the
--   tuple.
sortBySymbolTuple :: HasSymbol a => [(a, b)] -> [(a, b)]

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term -
--   termDefinition</tt>".
tAndDOnly :: Concept s => s -> ItemType

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term (abbreviation) -
--   termDefinition</tt>".
tAndDWAcc :: Concept s => s -> ItemType

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term (symbol) -
--   termDefinition</tt>".
tAndDWSym :: (Concept s, Quantity a) => s -> a -> ItemType

-- | Distributes a list of Sentences by prepending individual Sentences
--   once to an existing list of Sentences.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; zipSentList [S "Hi", S "Hey", S "Hi"] [[S "Hello"], [S "World"], [S "Hello", S "World"]]
--   [[S "Hi", S "Hello"], [S "Hey", S "World"], [S "Hi", S "Hello", S "World"]]
--   </pre>
zipSentList :: [[Sentence]] -> [Sentence] -> [[Sentence]] -> [[Sentence]]


-- | General functions that are useful in manipulating some Drasil types
--   into printable <a>Contents</a>.
module Language.Drasil.Document.Contents

-- | Creates a bulleted list.
enumBullet :: Reference -> [Sentence] -> LabelledContent

-- | Same as <a>enumBullet</a> but unlabelled.
enumBulletU :: [Sentence] -> Contents

-- | Currently Unused. Creates a simple bulleted list that labels things
--   with a title and number:
--   
--   <ul>
--   <li>lb - Reference,</li>
--   <li>s - start index for the enumeration,</li>
--   <li>t - title of the list,</li>
--   <li>l - list to be enumerated.</li>
--   </ul>
--   
--   For example, if we want to create a list of data definitions, we could
--   call the function as follows:
--   
--   <pre>
--   enumSimple _ 2 (S "DD") [def1, def2, ...]
--   </pre>
--   
--   And the resulting <a>LabelledContent</a> would be rendered as:
--   
--   <ul>
--   <li>DD2: def1</li>
--   <li>DD3: def2</li>
--   <li>DD4: def3 ...</li>
--   </ul>
enumSimple :: Reference -> Integer -> Sentence -> [Sentence] -> LabelledContent

-- | Same as <a>enumSimple</a> but unlabelled.
enumSimpleU :: Integer -> Sentence -> [Sentence] -> Contents

-- | Convenience function for transforming referable concepts into a
--   bulleted list. Used in drasil-docLang in making the assumptions,
--   goals, and requirements sections. Output is of the kind <tt>Concept
--   Name: definition of concept</tt>.
mkEnumSimpleD :: (Referable c, HasShortName c, Definition c) => [c] -> [Contents]

-- | Displays a given expression and attaches a <a>Reference</a> to it.
lbldExpr :: ModelExpr -> Reference -> LabelledContent

-- | Same as <tt>eqUnR</tt> except content is unlabelled (does not attach a
--   <a>Reference</a>).
unlbldExpr :: ModelExpr -> Contents

-- | Unlabelled code expression
unlbldCode :: CodeExpr -> Contents


-- | Defines chunk types for use in code generation.
module Drasil.Code.CodeVar

-- | A <a>CodeIdea</a> must include some code and its name.
class CodeIdea c

-- | Name of the idea.
codeName :: CodeIdea c => c -> String

-- | Code chunk associated with the idea.
codeChunk :: CodeIdea c => c -> CodeChunk

-- | A <a>DefiningCodeExpr</a> must have it's underlying chunk defined in
--   the CodeExpr language.
class CodeIdea c => DefiningCodeExpr c
codeExpr :: DefiningCodeExpr c => Lens' c CodeExpr

-- | Convert an abbreviation into one deemed 'code-friendly', removing
--   spaces, and replacing special characters with underscores.
--   
--   FIXME: This should NOT be treated as a <tt>getter</tt>, but something
--   we cache local to something that has a 'program name'.
programName :: CommonIdea c => c -> String

-- | Used when a function name needs to be distinguishable from a variable
--   name.
funcPrefix :: String

-- | Details if a piece of code is meant to be a variable or a function.
data VarOrFunc
Var :: VarOrFunc
Func :: VarOrFunc

-- | Basic chunk representation in the code generation context. Contains a
--   DefinedQuantityDict and the kind of code (variable or function).
data CodeChunk
CodeC :: DefinedQuantityDict -> VarOrFunc -> CodeChunk
[_qc] :: CodeChunk -> DefinedQuantityDict
[kind] :: CodeChunk -> VarOrFunc
qc :: Lens' CodeChunk DefinedQuantityDict

-- | Chunk representing a variable. The <tt>obv</tt> field represents the
--   object containing this variable, if it is an object field.
data CodeVarChunk
CodeVC :: CodeChunk -> Maybe CodeChunk -> CodeVarChunk
[_ccv] :: CodeVarChunk -> CodeChunk
[_obv] :: CodeVarChunk -> Maybe CodeChunk
obv :: Lens' CodeVarChunk (Maybe CodeChunk)
ccv :: Lens' CodeVarChunk CodeChunk

-- | Chunk representing a function.
newtype CodeFuncChunk
CodeFC :: CodeChunk -> CodeFuncChunk
[_ccf] :: CodeFuncChunk -> CodeChunk
ccf :: Iso' CodeFuncChunk CodeChunk
listToArray :: CodeVarChunk -> CodeVarChunk
instance Drasil.Database.UID.HasUID Drasil.Code.CodeVar.CodeFuncChunk
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Drasil.Code.CodeVar.CodeFuncChunk
instance Language.Drasil.Chunk.NamedIdea.Idea Drasil.Code.CodeVar.CodeFuncChunk
instance Language.Drasil.Classes.Definition Drasil.Code.CodeVar.CodeFuncChunk
instance Language.Drasil.Classes.ConceptDomain Drasil.Code.CodeVar.CodeFuncChunk
instance Language.Drasil.Space.HasSpace Drasil.Code.CodeVar.CodeFuncChunk
instance Language.Drasil.Symbol.HasSymbol Drasil.Code.CodeVar.CodeFuncChunk
instance Language.Drasil.Classes.Quantity Drasil.Code.CodeVar.CodeFuncChunk
instance Drasil.Code.Classes.Callable Drasil.Code.CodeVar.CodeFuncChunk
instance GHC.Classes.Eq Drasil.Code.CodeVar.CodeFuncChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Drasil.Code.CodeVar.CodeFuncChunk
instance Drasil.Database.UID.HasUID Drasil.Code.CodeVar.CodeVarChunk
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Drasil.Code.CodeVar.CodeVarChunk
instance Language.Drasil.Chunk.NamedIdea.Idea Drasil.Code.CodeVar.CodeVarChunk
instance Language.Drasil.Classes.Definition Drasil.Code.CodeVar.CodeVarChunk
instance Language.Drasil.Classes.ConceptDomain Drasil.Code.CodeVar.CodeVarChunk
instance Language.Drasil.Space.HasSpace Drasil.Code.CodeVar.CodeVarChunk
instance Language.Drasil.Symbol.HasSymbol Drasil.Code.CodeVar.CodeVarChunk
instance Language.Drasil.Classes.Quantity Drasil.Code.CodeVar.CodeVarChunk
instance GHC.Classes.Eq Drasil.Code.CodeVar.CodeVarChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Drasil.Code.CodeVar.CodeVarChunk
instance Drasil.Database.UID.HasUID Drasil.Code.CodeVar.CodeChunk
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Drasil.Code.CodeVar.CodeChunk
instance Language.Drasil.Chunk.NamedIdea.Idea Drasil.Code.CodeVar.CodeChunk
instance Language.Drasil.Classes.Definition Drasil.Code.CodeVar.CodeChunk
instance Language.Drasil.Classes.ConceptDomain Drasil.Code.CodeVar.CodeChunk
instance Language.Drasil.Space.HasSpace Drasil.Code.CodeVar.CodeChunk
instance Language.Drasil.Symbol.HasSymbol Drasil.Code.CodeVar.CodeChunk
instance Language.Drasil.Classes.Quantity Drasil.Code.CodeVar.CodeChunk
instance GHC.Classes.Eq Drasil.Code.CodeVar.CodeChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Drasil.Code.CodeVar.CodeChunk

module Drasil.Code.CodeExpr.Precedence

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | eprec - <a>Expression</a> precedence.
eprec :: CodeExpr -> Int

module Drasil.Code.CodeExpr.Extract

-- | Get dependencies from an equation.
eDep :: CodeExpr -> [UID]

-- | Get dependencies from an equation, without functions.
eDep' :: CodeExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>eNames</a>).
eNamesRI :: RealInterval CodeExpr CodeExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names without functions (similar to <a>eNames'</a>).
eNamesRI' :: RealInterval CodeExpr CodeExpr -> [UID]

module Drasil.Code.CodeExpr.Class
class CodeExprC r

-- | Constructs a CodeExpr for actor creation (constructor call)
new :: (CodeExprC r, Callable f, HasUID f, CodeIdea f) => f -> [r] -> r

-- | Constructs a CodeExpr for actor creation (constructor call) that uses
--   named arguments
newWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr for actor messaging (method call)
msg :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c) => c -> f -> [r] -> r

-- | Constructs a CodeExpr for actor messaging (method call) that uses
--   named arguments
msgWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c, HasUID a, IsArgumentName a) => c -> f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr representing the field of an actor
field :: CodeExprC r => CodeVarChunk -> CodeVarChunk -> r

-- | Similar to <a>apply</a>, but takes a relation to apply to
--   <a>FCall</a>.
applyWithNamedArgs :: (CodeExprC r, HasUID f, HasSymbol f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r
instance Drasil.Code.CodeExpr.Class.CodeExprC Drasil.Code.CodeExpr.Lang.CodeExpr

module Drasil.Code.CodeExpr.Convert

-- | Render an algebraic expression into our code expression language.
expr :: Expr -> CodeExpr

-- | Convert <a>RealInterval</a> <tt>Expr</tt> <tt>Expr</tt>s into
--   <a>RealInterval</a> <a>CodeExpr</a> <a>CodeExpr</a>s.
realInterval :: RealInterval Expr Expr -> RealInterval CodeExpr CodeExpr

-- | Convert constrained expressions (<a>ConstraintE</a>) into
--   <tt>Constraint''CodeExpr</tt>s.
constraint :: ConstraintE -> Constraint CodeExpr
class CanGenCode e
toCodeExpr :: CanGenCode e => e -> CodeExpr
instance Drasil.Code.CodeExpr.Convert.CanGenCode Language.Drasil.Literal.Lang.Literal
instance Drasil.Code.CodeExpr.Convert.CanGenCode Language.Drasil.Expr.Lang.Expr


-- | Re-exporting modules
module Drasil.Code.CodeExpr.Development

-- | Expression language where all terms also denote a term in GOOL (i.e.
--   translation is total and meaning preserving).
data CodeExpr

-- | Brings literals into the expression language.
[Lit] :: Literal -> CodeExpr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [CodeExpr] -> CodeExpr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [CodeExpr] -> CodeExpr
[AssocC] :: AssocConcatOper -> [CodeExpr] -> CodeExpr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> CodeExpr

-- | A function call accepts a list of parameters and a list of named
--   parameters. For example
--   
--   <ul>
--   <li>F(x) is (FCall F [x] []).</li>
--   <li>F(x,y) would be (FCall F [x,y]).</li>
--   <li>F(x,n=y) would be (FCall F [x] [(n,y)]).</li>
--   </ul>
[FCall] :: UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Actor creation given <a>UID</a>, parameters, and named parameters.
[New] :: UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Message an actor:
--   
--   <ul>
--   <li>1st <a>UID</a> is the actor,</li>
--   <li>2nd <a>UID</a> is the method.</li>
--   </ul>
[Message] :: UID -> UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Access a field of an actor:
--   
--   <ul>
--   <li>1st <a>UID</a> is the actor,</li>
--   <li>2nd <a>UID</a> is the field.</li>
--   </ul>
[Field] :: UID -> UID -> CodeExpr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(CodeExpr, CodeExpr)] -> CodeExpr

-- | Represents a matrix of expressions.
[Matrix] :: [[CodeExpr]] -> CodeExpr

-- | Represents a set of expressions
[Set] :: Space -> [CodeExpr] -> CodeExpr

-- | used to refernce the (name + type = variable )
[Variable] :: String -> CodeExpr -> CodeExpr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> CodeExpr -> CodeExpr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Number x Vector -&gt; Vector</tt> operations
--   (scaling).
[NVVBinaryOp] :: NVVBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Set operator for Set + Set -&gt; Set
[ESSBinaryOp] :: ESSBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Set operator for Element + Set -&gt; Bool
[ESBBinaryOp] :: ESBBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Operators are generalized arithmetic operators over a
--   <tt>DomainDesc</tt> of an <tt>Expr</tt>. Could be called BigOp. ex:
--   Summation is represented via <a>Add</a> over a discrete domain.
[Operator] :: AssocArithOper -> DiscreteDomainDesc CodeExpr CodeExpr -> CodeExpr -> CodeExpr

-- | The expression is an element of a space. IsIn :: Expr -&gt; Space
--   -&gt; Expr | A different kind of <tt>IsIn</tt>. A <a>UID</a> is an
--   element of an interval.
[RealI] :: UID -> RealInterval CodeExpr CodeExpr -> CodeExpr

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp
IndexOf :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product, vector addition, vector sub).
data VVVBinOp
Cross :: VVVBinOp
VAdd :: VVVBinOp
VSub :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | <tt>Number x Vector -&gt; Vector</tt> binary operations (scaling).
data NVVBinOp
Scale :: NVVBinOp

-- | Element + Set -&gt; Set
data ESSBinOp
SAdd :: ESSBinOp
SRemove :: ESSBinOp

-- | Element + Set -&gt; Bool
data ESBBinOp
SContains :: ESBBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
Add :: AssocArithOper
Mul :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper
data AssocConcatOper
SUnion :: AssocConcatOper

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN
class CodeExprC r

-- | Constructs a CodeExpr for actor creation (constructor call)
new :: (CodeExprC r, Callable f, HasUID f, CodeIdea f) => f -> [r] -> r

-- | Constructs a CodeExpr for actor creation (constructor call) that uses
--   named arguments
newWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr for actor messaging (method call)
msg :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c) => c -> f -> [r] -> r

-- | Constructs a CodeExpr for actor messaging (method call) that uses
--   named arguments
msgWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c, HasUID a, IsArgumentName a) => c -> f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr representing the field of an actor
field :: CodeExprC r => CodeVarChunk -> CodeVarChunk -> r

-- | Similar to <a>apply</a>, but takes a relation to apply to
--   <a>FCall</a>.
applyWithNamedArgs :: (CodeExprC r, HasUID f, HasSymbol f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Get dependencies from an equation.
eDep :: CodeExpr -> [UID]

-- | Get dependencies from an equation, without functions.
eDep' :: CodeExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>eNames</a>).
eNamesRI :: RealInterval CodeExpr CodeExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names without functions (similar to <a>eNames'</a>).
eNamesRI' :: RealInterval CodeExpr CodeExpr -> [UID]

-- | eprec - <a>Expression</a> precedence.
eprec :: CodeExpr -> Int

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | Render an algebraic expression into our code expression language.
expr :: Expr -> CodeExpr

-- | Convert <a>RealInterval</a> <tt>Expr</tt> <tt>Expr</tt>s into
--   <a>RealInterval</a> <a>CodeExpr</a> <a>CodeExpr</a>s.
realInterval :: RealInterval Expr Expr -> RealInterval CodeExpr CodeExpr

-- | Convert constrained expressions (<a>ConstraintE</a>) into
--   <tt>Constraint''CodeExpr</tt>s.
constraint :: ConstraintE -> Constraint CodeExpr
class CanGenCode e
toCodeExpr :: CanGenCode e => e -> CodeExpr


-- | Re-export CodeExpr constructors.
module Drasil.Code.CodeExpr

-- | Expression language where all terms also denote a term in GOOL (i.e.
--   translation is total and meaning preserving).
data CodeExpr
class CodeExprC r

-- | Constructs a CodeExpr for actor creation (constructor call)
new :: (CodeExprC r, Callable f, HasUID f, CodeIdea f) => f -> [r] -> r

-- | Constructs a CodeExpr for actor creation (constructor call) that uses
--   named arguments
newWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr for actor messaging (method call)
msg :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c) => c -> f -> [r] -> r

-- | Constructs a CodeExpr for actor messaging (method call) that uses
--   named arguments
msgWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c, HasUID a, IsArgumentName a) => c -> f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr representing the field of an actor
field :: CodeExprC r => CodeVarChunk -> CodeVarChunk -> r

-- | Similar to <a>apply</a>, but takes a relation to apply to
--   <a>FCall</a>.
applyWithNamedArgs :: (CodeExprC r, HasUID f, HasSymbol f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r
class ExprC r
lit :: ExprC r => Literal -> r
($=) :: ExprC r => r -> r -> r
($!=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>=) :: ExprC r => r -> r -> r

-- | Smart constructor for the dot product of two equations.
($.) :: ExprC r => r -> r -> r

-- | Add two expressions.
($+) :: ExprC r => r -> r -> r

-- | Multiply two expressions.
($*) :: ExprC r => r -> r -> r
($-) :: ExprC r => r -> r -> r
($/) :: ExprC r => r -> r -> r
($^) :: ExprC r => r -> r -> r
($=>) :: ExprC r => r -> r -> r
($<=>) :: ExprC r => r -> r -> r
($&&) :: ExprC r => r -> r -> r
($||) :: ExprC r => r -> r -> r

-- | Smart constructor for set-theoretic membership relation. Added ' to
--   avoid conflict.
in' :: ExprC r => r -> r -> r

-- | Smart constructor for taking the absolute value of an expression.
abs_ :: ExprC r => r -> r

-- | Smart constructor for negating an expression.
neg :: ExprC r => r -> r

-- | Smart constructor to take the log of an expression.
log :: ExprC r => r -> r

-- | Smart constructor to take the ln of an expression.
ln :: ExprC r => r -> r

-- | Smart constructor to take the square root of an expression.
sqrt :: ExprC r => r -> r

-- | Smart constructor to apply sin to an expression.
sin :: ExprC r => r -> r

-- | Smart constructor to apply cos to an expression.
cos :: ExprC r => r -> r

-- | Smart constructor to apply tan to an expression.
tan :: ExprC r => r -> r

-- | Smart constructor to apply sec to an expression.
sec :: ExprC r => r -> r

-- | Smart constructor to apply csc to an expression.
csc :: ExprC r => r -> r

-- | Smart constructor to apply cot to an expression.
cot :: ExprC r => r -> r

-- | Smart constructor to apply arcsin to an expression.
arcsin :: ExprC r => r -> r

-- | Smart constructor to apply arccos to an expression.
arccos :: ExprC r => r -> r

-- | Smart constructor to apply arctan to an expression.
arctan :: ExprC r => r -> r

-- | Smart constructor for the exponential (base e) function.
exp :: ExprC r => r -> r

-- | Smart constructor for calculating the dimension of a vector.
dim :: ExprC r => r -> r

-- | Smart constructor for calculating the normal form of a vector.
norm :: ExprC r => r -> r

-- | Smart constructor for negating vectors.
negVec :: ExprC r => r -> r

-- | Smart constructor for applying logical negation to an expression.
not_ :: ExprC r => r -> r

-- | Smart constructor for indexing.
idx :: ExprC r => r -> r -> r

-- | Smart constructor for indexOf. Finds the index of the first occurrence
--   of a value in a list.
idxOf :: ExprC r => r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defint :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defsum :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defprod :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for 'real interval' membership.
realInterval :: (ExprC r, HasUID c) => c -> RealInterval r r -> r

-- | Euclidean function : takes a vector and returns the sqrt of the
--   sum-of-squares.
euclidean :: ExprC r => [r] -> r

-- | Smart constructor to cross product two expressions.
cross :: ExprC r => r -> r -> r

-- | Smart constructor for vector scaling
vScale :: ExprC r => r -> r -> r

-- | Vector Addition
vAdd :: ExprC r => r -> r -> r

-- | Vector Subtraction
vSub :: ExprC r => r -> r -> r

-- | Smart constructor for case statements with a complete set of cases.
completeCase :: ExprC r => [(r, r)] -> r

-- | Smart constructor for case statements with an incomplete set of cases.
incompleteCase :: ExprC r => [(r, r)] -> r

-- | Create a matrix.
matrix :: ExprC r => [[r]] -> r

-- | Create a Set.
set' :: ExprC r => Space -> [r] -> r

-- | Applies a given function with a list of parameters.
apply :: (ExprC r, HasUID f, HasSymbol f) => f -> [r] -> r

-- | Create an <a>Expr</a> from a <a>Symbol</a>ic Chunk.
sy :: (ExprC r, HasUID c, HasSymbol c) => c -> r
infixr 4 $=
infixl 7 $/
infixr 8 $^
infixr 9 $&&
infixr 9 $||
class LiteralC r
int :: LiteralC r => Integer -> r
str :: LiteralC r => String -> r
dbl :: LiteralC r => Double -> r
exactDbl :: LiteralC r => Integer -> r
perc :: LiteralC r => Integer -> Integer -> r

-- | Render an algebraic expression into our code expression language.
expr :: Expr -> CodeExpr


-- | Contains chunks related to adding an expression to a quantitative
--   concept.
module Language.Drasil.Chunk.Eq
data QDefinition e

-- | Create a <a>QDefinition</a> with a <a>UID</a> (as a <a>Space</a>),
--   term (<a>NP</a>), definition (<a>Sentence</a>), <a>Symbol</a>,
--   <a>Space</a>, unit, and defining expression.
fromEqn :: IsUnit u => String -> NP -> Sentence -> Symbol -> Space -> u -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but has no units.
fromEqn' :: String -> NP -> Sentence -> Symbol -> Space -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but symbol depends on stage.
fromEqnSt :: IsUnit u => UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> u -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but symbol depends on stage and has no units.
fromEqnSt' :: UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> e -> QDefinition e

-- | Same as <a>fromEqnSt'</a>, but takes a <a>Space</a> instead of a
--   <a>UID</a>.
fromEqnSt'' :: String -> NP -> Sentence -> (Stage -> Symbol) -> Space -> e -> QDefinition e

-- | Wrapper for fromEqnSt and fromEqnSt'
mkQDefSt :: UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> e -> QDefinition e

-- | Used to help make <a>QDefinition</a>s when <a>UID</a>, term, and
--   <a>Symbol</a> come from the same source.
mkQuantDef :: (Quantity c, MayHaveUnit c, Concept c) => c -> e -> QDefinition e

-- | Used to help make <a>QDefinition</a>s when <a>UID</a> and
--   <a>Symbol</a> come from the same source, with the term separate.
mkQuantDef' :: (Quantity c, MayHaveUnit c) => c -> NP -> e -> QDefinition e

-- | Smart constructor for QDefinitions. Requires a quantity and its
--   defining equation.
ec :: (Quantity c, MayHaveUnit c) => c -> e -> QDefinition e

-- | Create a <a>QDefinition</a> function with a symbol, name, term, list
--   of inputs, resultant units, and a defining Expr
mkFuncDef :: (HasUID f, HasSymbol f, HasSpace f, HasUID i, HasSymbol i, HasSpace i, IsUnit u) => f -> NP -> Sentence -> u -> [i] -> e -> QDefinition e

-- | Create a <a>QDefinition</a> function with a symbol, name, term, list
--   of inputs, and a defining Expr
mkFuncDef' :: (HasUID f, HasSymbol f, HasSpace f, HasUID i, HasSymbol i, HasSpace i) => f -> NP -> Sentence -> [i] -> e -> QDefinition e

-- | Create a <a>QDefinition</a> functions using a symbol, list of inputs,
--   and a defining Expr
mkFuncDefByQ :: (Quantity c, MayHaveUnit c, HasSpace c, Quantity i, HasSpace i) => c -> [i] -> e -> QDefinition e
instance Drasil.Database.UID.HasUID (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.Chunk.NamedIdea.NamedIdea (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.Chunk.NamedIdea.Idea (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.Chunk.DefinedQuantity.DefinesQuantity (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.Space.HasSpace (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.Symbol.HasSymbol (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.Classes.Definition (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.Classes.Quantity (Language.Drasil.Chunk.Eq.QDefinition e)
instance GHC.Classes.Eq (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.Classes.DefiningExpr Language.Drasil.Chunk.Eq.QDefinition
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.ExprClasses.Express (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.Classes.ConceptDomain (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.WellTyped.RequiresChecking (Language.Drasil.Chunk.Eq.QDefinition Language.Drasil.Expr.Lang.Expr) Language.Drasil.Expr.Lang.Expr Language.Drasil.Space.Space


-- | Parameterized types, at times, deserve their own names.
module Language.Drasil.Synonyms

-- | Commonly used type for QDefinitions containing Literals.
type ConstQDef = QDefinition Literal

-- | Commonly used type for QDefinitions containing Exprs.
type SimpleQDef = QDefinition Expr

-- | Commonly used type for QDefinitions containing ModelExprs.
type ModelQDef = QDefinition ModelExpr

-- | Commonly used type for polymorphic Exprs.
type PExpr = forall r. (ExprC r, LiteralC r) => r

module Language.Drasil.Chunk.DifferentialModel

-- | Describe the structural content of a system of linear ODEs with six
--   necessary fields
data DifferentialModel
SystemOfLinearODEs :: UnitalChunk -> ConstrConcept -> [[Expr]] -> [Unknown] -> [Expr] -> ConceptChunk -> DifferentialModel

-- | independent variable, often time
[_indepVar] :: DifferentialModel -> UnitalChunk

-- | dependent variable
[_depVar] :: DifferentialModel -> ConstrConcept

-- | coefficients matrix
[_coefficients] :: DifferentialModel -> [[Expr]]

-- | unknowns column vector (orders)
[_unknowns] :: DifferentialModel -> [Unknown]

-- | constant column vector
[_dmConstants] :: DifferentialModel -> [Expr]

-- | meta data
[_dmconc] :: DifferentialModel -> ConceptChunk

-- | Acceptable format for ODE solvers, represent the structure of X' = AX
--   + B X' is a column vector of first-order unknowns
data ODESolverFormat
X' :: [[Expr]] -> [Integer] -> [Expr] -> ODESolverFormat

-- | represent A, the coefficient matrix with identity matrix
[coeffVects] :: ODESolverFormat -> [[Expr]]

-- | combing with the dependent variable. it represents X, the unknown
--   column vector after reduce the highest order.
[unknownVect] :: ODESolverFormat -> [Integer]

-- | represent B, the constant column vector with identity matrix
[constantVect] :: ODESolverFormat -> [Expr]

-- | Information for solving an initial value problem
data InitialValueProblem
IVP :: Expr -> Expr -> [Expr] -> InitialValueProblem

-- | initial time
[initTime] :: InitialValueProblem -> Expr

-- | end time
[finalTime] :: InitialValueProblem -> Expr

-- | initial values
[initValues] :: InitialValueProblem -> [Expr]

-- | Operation connect the dependent variable and the order
($^^) :: ConstrConcept -> Integer -> Unknown

-- | Operation represent multiple
($**) :: Expr -> Unknown -> Term

-- | Operation represent plus (collection Terms)
($++) :: [Term] -> Term -> LHS

-- | Construct an ODESolverFormat for solving the ODE.
makeAODESolverFormat :: DifferentialModel -> ODESolverFormat
makeAIVP :: Expr -> Expr -> [Expr] -> InitialValueProblem

-- | Create a <a>DifferentialModel</a> by giving a independent variable, a
--   dependent variable a canonical matrix form, and conceptChuck.
makeASystemDE :: UnitalChunk -> ConstrConcept -> [[Expr]] -> [Unknown] -> [Expr] -> String -> NP -> Sentence -> DifferentialModel

-- | Create a <a>DifferentialModel</a> by the input language
makeASingleDE :: UnitalChunk -> ConstrConcept -> LHS -> Expr -> String -> NP -> Sentence -> DifferentialModel

-- | Form well-formatted ODE equations which the ODE solvers can solve.
formEquations :: [[Expr]] -> [Unknown] -> [Expr] -> ConstrConcept -> [Expr]
instance Language.Drasil.WellTyped.RequiresChecking Language.Drasil.Chunk.DifferentialModel.DifferentialModel Language.Drasil.Expr.Lang.Expr Language.Drasil.Space.Space
instance Drasil.Database.UID.HasUID Language.Drasil.Chunk.DifferentialModel.DifferentialModel
instance GHC.Classes.Eq Language.Drasil.Chunk.DifferentialModel.DifferentialModel
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.DifferentialModel.DifferentialModel
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.DifferentialModel.DifferentialModel
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.DifferentialModel.DifferentialModel
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.DifferentialModel.DifferentialModel
instance Language.Drasil.ExprClasses.Express Language.Drasil.Chunk.DifferentialModel.DifferentialModel


-- | The Drasil language, including expressions, chunks, sentences,
--   references, classes, datatypes, and generally useful functions.
--   Re-exports modules to simplify external use.
module Language.Drasil

-- | Expression language where all terms are supposed to be 'well
--   understood' (i.e., have a definite meaning). Right now, this coincides
--   with "having a definite value", but should not be restricted to that.
data Expr
class ExprC r
lit :: ExprC r => Literal -> r
($=) :: ExprC r => r -> r -> r
($!=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>=) :: ExprC r => r -> r -> r

-- | Smart constructor for the dot product of two equations.
($.) :: ExprC r => r -> r -> r

-- | Add two expressions.
($+) :: ExprC r => r -> r -> r

-- | Multiply two expressions.
($*) :: ExprC r => r -> r -> r
($-) :: ExprC r => r -> r -> r
($/) :: ExprC r => r -> r -> r
($^) :: ExprC r => r -> r -> r
($=>) :: ExprC r => r -> r -> r
($<=>) :: ExprC r => r -> r -> r
($&&) :: ExprC r => r -> r -> r
($||) :: ExprC r => r -> r -> r

-- | Smart constructor for set-theoretic membership relation. Added ' to
--   avoid conflict.
in' :: ExprC r => r -> r -> r

-- | Smart constructor for taking the absolute value of an expression.
abs_ :: ExprC r => r -> r

-- | Smart constructor for negating an expression.
neg :: ExprC r => r -> r

-- | Smart constructor to take the log of an expression.
log :: ExprC r => r -> r

-- | Smart constructor to take the ln of an expression.
ln :: ExprC r => r -> r

-- | Smart constructor to take the square root of an expression.
sqrt :: ExprC r => r -> r

-- | Smart constructor to apply sin to an expression.
sin :: ExprC r => r -> r

-- | Smart constructor to apply cos to an expression.
cos :: ExprC r => r -> r

-- | Smart constructor to apply tan to an expression.
tan :: ExprC r => r -> r

-- | Smart constructor to apply sec to an expression.
sec :: ExprC r => r -> r

-- | Smart constructor to apply csc to an expression.
csc :: ExprC r => r -> r

-- | Smart constructor to apply cot to an expression.
cot :: ExprC r => r -> r

-- | Smart constructor to apply arcsin to an expression.
arcsin :: ExprC r => r -> r

-- | Smart constructor to apply arccos to an expression.
arccos :: ExprC r => r -> r

-- | Smart constructor to apply arctan to an expression.
arctan :: ExprC r => r -> r

-- | Smart constructor for the exponential (base e) function.
exp :: ExprC r => r -> r

-- | Smart constructor for calculating the dimension of a vector.
dim :: ExprC r => r -> r

-- | Smart constructor for calculating the normal form of a vector.
norm :: ExprC r => r -> r

-- | Smart constructor for negating vectors.
negVec :: ExprC r => r -> r

-- | Smart constructor for applying logical negation to an expression.
not_ :: ExprC r => r -> r

-- | Smart constructor for indexing.
idx :: ExprC r => r -> r -> r

-- | Smart constructor for indexOf. Finds the index of the first occurrence
--   of a value in a list.
idxOf :: ExprC r => r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defint :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defsum :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defprod :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for 'real interval' membership.
realInterval :: (ExprC r, HasUID c) => c -> RealInterval r r -> r

-- | Euclidean function : takes a vector and returns the sqrt of the
--   sum-of-squares.
euclidean :: ExprC r => [r] -> r

-- | Smart constructor to cross product two expressions.
cross :: ExprC r => r -> r -> r

-- | Smart constructor for vector scaling
vScale :: ExprC r => r -> r -> r

-- | Vector Addition
vAdd :: ExprC r => r -> r -> r

-- | Vector Subtraction
vSub :: ExprC r => r -> r -> r

-- | Smart constructor for case statements with a complete set of cases.
completeCase :: ExprC r => [(r, r)] -> r

-- | Smart constructor for case statements with an incomplete set of cases.
incompleteCase :: ExprC r => [(r, r)] -> r

-- | Create a matrix.
matrix :: ExprC r => [[r]] -> r

-- | Create a Set.
set' :: ExprC r => Space -> [r] -> r

-- | Applies a given function with a list of parameters.
apply :: (ExprC r, HasUID f, HasSymbol f) => f -> [r] -> r

-- | Create an <a>Expr</a> from a <a>Symbol</a>ic Chunk.
sy :: (ExprC r, HasUID c, HasSymbol c) => c -> r
infixr 4 $=
infixl 7 $/
infixr 8 $^
infixr 9 $&&
infixr 9 $||

-- | Smart constructor for fractions.
frac :: (ExprC r, LiteralC r) => Integer -> Integer -> r

-- | Smart constructor for rational expressions (only in 1/x form).
recip_ :: (ExprC r, LiteralC r) => r -> r

-- | Smart constructor to square a function.
square :: (ExprC r, LiteralC r) => r -> r

-- | Smart constructor to half a function exactly.
half :: (ExprC r, LiteralC r) => r -> r

-- | 1/2, as an expression.
oneHalf :: (ExprC r, LiteralC r) => r

-- | 1/3rd, as an expression.
oneThird :: (ExprC r, LiteralC r) => r

-- | Similar to <a>apply</a>, but converts second argument into
--   <a>Symbol</a>s.
apply1 :: (ExprC r, HasUID f, HasSymbol f, HasUID a, HasSymbol a) => f -> a -> r

-- | Similar to <a>apply</a>, but the applied function takes two parameters
--   (which are both <a>Symbol</a>s).
apply2 :: (ExprC r, HasUID f, HasSymbol f, HasUID a, HasSymbol a, HasUID b, HasSymbol b) => f -> a -> b -> r

-- | Create a two-by-two matrix from four given values. For example:
--   
--   <pre>
--   &gt;&gt;&gt; m2x2 1 2 3 4
--   [ [1,2],
--     [3,4] ]
--   </pre>
m2x2 :: ExprC r => r -> r -> r -> r -> r

-- | Create a 2D vector (a matrix with two rows, one column). First
--   argument is placed above the second.
vec2D :: ExprC r => r -> r -> r

-- | Creates a diagonal two-by-two matrix. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dgnl2x2 1 2
--   [ [1, 0],
--     [0, 2] ]
--   </pre>
dgnl2x2 :: (ExprC r, LiteralC r) => r -> r -> r

-- | Create a row vector
rowVec :: ExprC r => [r] -> r

-- | Create a column vector
columnVec :: ExprC r => [r] -> r
mkSet :: ExprC r => Space -> [r] -> r

-- | For case expressions (either complete or incomplete).
data Completeness

-- | A relation is just an expression (<a>Expr</a>).
type Relation = Expr
data Literal
class LiteralC r
int :: LiteralC r => Integer -> r
str :: LiteralC r => String -> r
dbl :: LiteralC r => Double -> r
exactDbl :: LiteralC r => Integer -> r
perc :: LiteralC r => Integer -> Integer -> r

-- | Expression language where all terms are supposed to have a meaning,
--   but that meaning may not be that of a definite value. For example,
--   specification expressions, especially with quantifiers, belong here.
data ModelExpr

-- | Introduce Space values into the expression language.
[Spc] :: Space -> ModelExpr

-- | Determines the type of the derivative (either a partial derivative or
--   a total derivative).
data DerivType
class ModelExprC r

-- | Gets the derivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
deriv :: (ModelExprC r, HasUID c, HasSymbol c) => r -> c -> r

-- | Gets the derivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
pderiv :: (ModelExprC r, HasUID c, HasSymbol c) => r -> c -> r

-- | Gets the nthderivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
nthderiv :: (ModelExprC r, HasUID c, HasSymbol c) => Integer -> r -> c -> r

-- | Gets the nthderivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
nthpderiv :: (ModelExprC r, HasUID c, HasSymbol c) => Integer -> r -> c -> r

-- | One expression is "defined" by another.
defines :: ModelExprC r => r -> r -> r

-- | Space literals.
space :: ModelExprC r => Space -> r

-- | Check if a value belongs to a Space.
isIn :: ModelExprC r => r -> Space -> r

-- | Binary associative <a>Equivalence</a>.
equiv :: ModelExprC r => [r] -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
intAll :: ModelExprC r => Symbol -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
sumAll :: ModelExprC r => Symbol -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
prodAll :: ModelExprC r => Symbol -> r -> r

-- | Expression language where all terms also denote a term in GOOL (i.e.
--   translation is total and meaning preserving).
data CodeExpr
class CodeExprC r

-- | Constructs a CodeExpr for actor creation (constructor call)
new :: (CodeExprC r, Callable f, HasUID f, CodeIdea f) => f -> [r] -> r

-- | Constructs a CodeExpr for actor creation (constructor call) that uses
--   named arguments
newWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr for actor messaging (method call)
msg :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c) => c -> f -> [r] -> r

-- | Constructs a CodeExpr for actor messaging (method call) that uses
--   named arguments
msgWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c, HasUID a, IsArgumentName a) => c -> f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr representing the field of an actor
field :: CodeExprC r => CodeVarChunk -> CodeVarChunk -> r

-- | Similar to <a>apply</a>, but takes a relation to apply to
--   <a>FCall</a>.
applyWithNamedArgs :: (CodeExprC r, HasUID f, HasSymbol f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Special characters include partial derivatives and the degree circle.
data Special
Circle :: Special

-- | Class for rendering special characters.
class RenderSpecial r
special :: RenderSpecial r => Special -> r

-- | The most basic item: having a unique identifier key, here a UID.
class HasUID c

-- | Provides a <i>unique</i> id for internal Drasil use.
uid :: HasUID c => Getter c UID

-- | A HasSymbol is anything which has a <a>Symbol</a>.
class HasSymbol c

-- | Provides the <a>Symbol</a> for a particular stage of generation.
symbol :: HasSymbol c => c -> Stage -> Symbol

-- | A NamedIdea is a <a>term</a> that we've identified (has a <a>UID</a>)
--   as being worthy of naming.
class HasUID c => NamedIdea c

-- | Lens to the term (a noun phrase).
term :: NamedIdea c => Lens' c NP

-- | An <a>Idea</a> is the combination of a <a>NamedIdea</a> and a
--   <tt>CommonIdea</tt>. In other words, it <i>may</i> have an
--   acronym/abbreviation.
class NamedIdea c => Idea c

-- | Gets the acronym/abbreviation.
getA :: Idea c => c -> Maybe String

-- | CommonIdea is a <a>NamedIdea</a> with the additional constraint that
--   it <b>must</b> have an abbreviation. This is the main distinction
--   between getA and abrv, where getA may return Nothing, while abrv will
--   always return the abbreviation.
class NamedIdea c => CommonIdea c

-- | Introduces abrv which necessarily provides an abbreviation.
abrv :: CommonIdea c => c -> String

-- | Defines a chunk.
class Definition c

-- | Provides (a <tt>Lens</tt> to) the definition for a chunk.
defn :: Definition c => Lens' c Sentence

-- | Some concepts have a domain (related information encoded in
--   <a>UID</a>s to other chunks).
class ConceptDomain c

-- | Provides Getter for the concept domain tags for a chunk
--   
--   <i>cdom</i> should be exported for use by the Drasil framework, but
--   should not be exported beyond that.
cdom :: ConceptDomain c => c -> [UID]

-- | Concepts are <a>Idea</a>s with definitions and domains.
type Concept c = (Idea c, Definition c, ConceptDomain c)

-- | HasSpace is anything which has a <a>Space</a>.
class HasSpace c

-- | Provides a <a>Getter</a> to the <a>Space</a>.
typ :: HasSpace c => Getter c Space

-- | Some chunks store a unit symbol.
class HasUnitSymbol u

-- | Provides the ability to hold a unit symbol (<a>USymb</a>).
usymb :: HasUnitSymbol u => u -> USymb

-- | A Quantity is an <a>Idea</a> with a <tt>Space</tt> and a
--   <tt>Symbol</tt>. In theory, it should also restrict to being a part of
--   <tt>MayHaveUnit</tt>, but that causes all sorts of import cycles (or
--   lots of orphans).
class (Idea c, HasSpace c, HasSymbol c) => Quantity c

-- | A <a>Quantity</a> that could have a reasonable value.
class HasReasVal c

-- | Provides a <tt>Lens</tt> to the possible reasonable value.
reasVal :: HasReasVal c => Lens' c (Maybe Expr)

-- | The Constrained class is a <a>Quantity</a> that has value constraints.
--   It does not enforce <a>Quantity</a> at this point.
class Constrained c

-- | Provides a <tt>Lens</tt> to the <tt>Constraint</tt>s.
constraints :: Constrained c => Lens' c [ConstraintE]

-- | Records any additional notes needed to avoid losing information
class HasAdditionalNotes c

-- | Provides a <tt>Lens</tt> to the notes.
getNotes :: HasAdditionalNotes c => Lens' c [Sentence]

-- | A class that might have a <a>Derivation</a>.
class MayHaveDerivation c

-- | Provides a <tt>Lens</tt> to a possible derivation.
derivations :: MayHaveDerivation c => Lens' c (Maybe Derivation)

-- | Units are <a>Idea</a>s with a <a>Definition</a> which store a unit
--   symbol. They must also be explicitly declared to be instances of
--   IsUnit.
class (Idea u, Definition u, HasUnitSymbol u) => IsUnit u

-- | Holds units as a list of <a>UID</a>.
getUnits :: IsUnit u => u -> [UID]
class DefiningExpr c

-- | Provides a <tt>Lens</tt> to the expression. TODO: Well, technically,
--   <tt>e</tt> doesn't need to be an "expression" of any sorts. It just
--   needs to be _something_, and it would have approximately have same
--   meaning.
defnExpr :: DefiningExpr c => Lens' (c e) e

-- | Data that can be expressed using <a>ModelExpr</a>.
class Express c
express :: Express c => c -> ModelExpr

-- | Members must have a reference address.
class HasRefAddress b

-- | Provides the ability to hold a reference address.
getRefAdd :: HasRefAddress b => b -> LblType

-- | Members of this class have the ability to be referenced.
class (HasUID s, HasRefAddress s) => Referable s

-- | The referencing address (what we're linking to). Only visible in the
--   source (tex/html).
refAdd :: Referable s => s -> String

-- | Alternate form of reference.
renderRef :: Referable s => s -> LblType

-- | A class that contains a list of <a>Reference</a>s.
class HasReference c

-- | Provides a <tt>Lens</tt> to the <a>Reference</a>s.
getReferences :: HasReference c => Lens' c [Reference]

-- | Some chunks can be called like functions.
class HasSymbol c => Callable c

-- | Members must have a named argument.
class HasSymbol c => IsArgumentName c

-- | A <tt>UID</tt> is a 'unique identifier' for things that we will put
--   into our database of information. We use a newtype wrapper to make
--   sure we are only using <a>UID</a>s where desired.
data UID

-- | Smart constructor for <a>UID</a>s from raw <a>Value</a>s.
mkUid :: String -> UID

-- | Nest a <a>UID</a> under a namespace.
nsUid :: String -> UID -> UID

-- | Get something's <a>UID</a> as a <a>Value</a>.
showUID :: HasUID a => a -> String

-- | Append a suffix to a thing with a <a>UID</a> and get the resulting
--   <a>UID</a>.
(+++) :: HasUID a => a -> String -> UID

-- | Append a suffix to a <a>UID</a>.
(+++.) :: UID -> String -> UID

-- | Merge the <a>UID</a>s of two chunks through simple concatenation.
(+++!) :: (HasUID a, HasUID b) => a -> b -> UID

-- | <a>IdeaDict</a> constructor, takes a <a>String</a> for its <a>UID</a>
--   and a term.
nc :: String -> NP -> IdeaDict

-- | Similar to <a>nc</a>, but takes in the <a>UID</a> in the form of a
--   <a>UID</a> rather than a <a>String</a>.
ncUID :: UID -> NP -> IdeaDict

-- | <a>IdeaDict</a> is the canonical dictionary associated to an
--   <a>Idea</a>. Contains a <a>UID</a> and a term that could have an
--   abbreviation (<a>Maybe</a> <a>String</a>).
--   
--   Ex. The project name "Double Pendulum" may have the abbreviation
--   <a>DblPend</a>.
data IdeaDict

-- | <a>IdeaDict</a> constructor, takes a <a>UID</a>, <a>NP</a>, and an
--   abbreviation in the form of <a>Maybe</a> <a>String</a>.
mkIdea :: String -> NP -> Maybe String -> IdeaDict

-- | Historical name: nw comes from 'named wrapped' from when
--   <a>NamedIdea</a> exported <a>getA</a> (now in <a>Idea</a>). But there
--   are no more wrappers, instead we have explicit dictionaries. Unwraps
--   an <a>Idea</a> and places its <a>UID</a> and <a>NP</a> into an
--   <a>IdeaDict</a> with <a>Nothing</a> for an abbreviation.
nw :: Idea c => c -> IdeaDict

-- | A <a>CodeIdea</a> must include some code and its name.
class CodeIdea c

-- | Name of the idea.
codeName :: CodeIdea c => c -> String

-- | Code chunk associated with the idea.
codeChunk :: CodeIdea c => c -> CodeChunk

-- | Basic chunk representation in the code generation context. Contains a
--   DefinedQuantityDict and the kind of code (variable or function).
data CodeChunk
CodeC :: DefinedQuantityDict -> VarOrFunc -> CodeChunk
[_qc] :: CodeChunk -> DefinedQuantityDict
[kind] :: CodeChunk -> VarOrFunc

-- | Chunk representing a variable. The <tt>obv</tt> field represents the
--   object containing this variable, if it is an object field.
data CodeVarChunk
CodeVC :: CodeChunk -> Maybe CodeChunk -> CodeVarChunk
[_ccv] :: CodeVarChunk -> CodeChunk
[_obv] :: CodeVarChunk -> Maybe CodeChunk

-- | Chunk representing a function.
newtype CodeFuncChunk
CodeFC :: CodeChunk -> CodeFuncChunk
[_ccf] :: CodeFuncChunk -> CodeChunk

-- | Details if a piece of code is meant to be a variable or a function.
data VarOrFunc
Var :: VarOrFunc
Func :: VarOrFunc
obv :: Lens' CodeVarChunk (Maybe CodeChunk)
qc :: Lens' CodeChunk DefinedQuantityDict
ccf :: Iso' CodeFuncChunk CodeChunk
ccv :: Lens' CodeVarChunk CodeChunk
listToArray :: CodeVarChunk -> CodeVarChunk

-- | Convert an abbreviation into one deemed 'code-friendly', removing
--   spaces, and replacing special characters with underscores.
--   
--   FIXME: This should NOT be treated as a <tt>getter</tt>, but something
--   we cache local to something that has a 'program name'.
programName :: CommonIdea c => c -> String

-- | Used when a function name needs to be distinguishable from a variable
--   name.
funcPrefix :: String

-- | A <a>DefiningCodeExpr</a> must have it's underlying chunk defined in
--   the CodeExpr language.
class CodeIdea c => DefiningCodeExpr c
codeExpr :: DefiningCodeExpr c => Lens' c CodeExpr

-- | The common idea (with <tt>NounPhrase</tt>) data type. It must have a
--   <a>UID</a>, <tt>NounPhrase</tt> for its term, an abbreviation
--   (<a>String</a>), and a domain ([<a>UID</a>]). It is similar to
--   <a>IdeaDict</a> and <a>IdeaDict</a> in the sense that these are for
--   things worth naming, but this type also carries an abbreviation and
--   related domains of knowledge.
--   
--   Ex. The term "Operating System" has the abbreviation <a>OS</a> and
--   comes from the domain of computer science.
data CI

-- | The commonIdea smart constructor requires a chunk id (<a>String</a>),
--   a term (<a>NP</a>), an abbreviation (<a>String</a>), and a domain
--   ([<a>UID</a>]).
commonIdea :: String -> NP -> String -> [UID] -> CI

-- | Similar to <a>commonIdea</a>, but takes a list of <a>IdeaDict</a>
--   (often a domain).
commonIdeaWithDict :: String -> NP -> String -> [IdeaDict] -> CI

-- | Prepends the abbreviation from a <a>CommonIdea</a> to a <a>String</a>.
prependAbrv :: CommonIdea c => c -> String -> String

-- | The ConceptChunk datatype records a concept that contains an idea
--   (<a>IdeaDict</a>), a definition (<a>Sentence</a>), and an associated
--   domain of knowledge ([<a>UID</a>]).
--   
--   Ex. The concept of <a>Accuracy</a> may be defined as the quality or
--   state of being correct or precise.
data ConceptChunk

-- | Contains a <a>ConceptChunk</a>, reference address, and a
--   <a>ShortName</a>. It is a concept that can be referred to, or rather,
--   a instance of where a concept is applied. Often used in Goal
--   Statements, Assumptions, Requirements, etc.
--   
--   Ex. Something like the assumption that gravity is 9.81 m/s. When we
--   write our equations, we can then link this assumption so that we do
--   not have to explicitly define that assumption when needed to verify
--   our work.
data ConceptInstance

-- | Check if something has one domain. Throws an error if there is more
--   than one.
sDom :: [UID] -> UID

-- | Smart constructor for creating concept chunks given a <tt>UID</tt>,
--   <tt>NounPhrase</tt> (<a>NP</a>) and definition (as a <a>String</a>).
--   
--   Concept domain tagging is not yet implemented in this constructor.
dcc :: String -> NP -> String -> ConceptChunk
dccAWDS :: String -> NP -> Sentence -> Maybe String -> ConceptChunk

-- | Smart constructor for creating a concept chunks with an abbreviation
--   Takes a UID (String), a term (NounPhrase), a definition (String), and
--   an abbreviation (Maybe String).
dccA :: String -> NP -> String -> Maybe String -> ConceptChunk

-- | Similar to <a>dcc</a>, except the definition takes a <a>Sentence</a>.
dccWDS :: String -> NP -> Sentence -> ConceptChunk

-- | Constructor for projecting an idea into a <a>ConceptChunk</a>. Takes
--   the definition of the <a>ConceptChunk</a> as a <a>String</a>. Does not
--   allow concept domain tagging.
cc :: Idea c => c -> String -> ConceptChunk

-- | Same as <a>cc</a>, except definition is a <a>Sentence</a>.
cc' :: Idea c => c -> Sentence -> ConceptChunk

-- | Similar to <a>cc'</a>, but allows explicit domain tagging.
ccs :: (Idea c, Concept d) => c -> Sentence -> [d] -> ConceptChunk

-- | For projecting out to the <a>ConceptChunk</a> data-type.
cw :: Concept c => c -> ConceptChunk

-- | Constructor for a <a>ConceptInstance</a>. Takes in the Reference
--   Address (<a>String</a>), a definition (<a>Sentence</a>), a short name
--   (<a>String</a>), and a domain (for explicit tagging).
cic :: Concept c => String -> Sentence -> String -> c -> ConceptInstance

-- | For a concept (<a>ConceptChunk</a>) that also has a <tt>Relation</tt>
--   (<a>ModelExpr</a>) attached.
--   
--   Ex. We can describe a pendulum arm and then apply an associated
--   equation so that we know its behaviour.
data RelationConcept

-- | Create a <a>RelationConcept</a> from a given <tt>UID</tt>, term
--   (<a>NP</a>), definition (<a>Sentence</a>), and <tt>Relation</tt>.
makeRC :: Express e => String -> NP -> Sentence -> e -> RelationConcept

-- | Describe the structural content of a system of linear ODEs with six
--   necessary fields
data DifferentialModel
SystemOfLinearODEs :: UnitalChunk -> ConstrConcept -> [[Expr]] -> [Unknown] -> [Expr] -> ConceptChunk -> DifferentialModel

-- | independent variable, often time
[_indepVar] :: DifferentialModel -> UnitalChunk

-- | dependent variable
[_depVar] :: DifferentialModel -> ConstrConcept

-- | coefficients matrix
[_coefficients] :: DifferentialModel -> [[Expr]]

-- | unknowns column vector (orders)
[_unknowns] :: DifferentialModel -> [Unknown]

-- | constant column vector
[_dmConstants] :: DifferentialModel -> [Expr]

-- | meta data
[_dmconc] :: DifferentialModel -> ConceptChunk

-- | Acceptable format for ODE solvers, represent the structure of X' = AX
--   + B X' is a column vector of first-order unknowns
data ODESolverFormat
X' :: [[Expr]] -> [Integer] -> [Expr] -> ODESolverFormat

-- | represent A, the coefficient matrix with identity matrix
[coeffVects] :: ODESolverFormat -> [[Expr]]

-- | combing with the dependent variable. it represents X, the unknown
--   column vector after reduce the highest order.
[unknownVect] :: ODESolverFormat -> [Integer]

-- | represent B, the constant column vector with identity matrix
[constantVect] :: ODESolverFormat -> [Expr]

-- | Information for solving an initial value problem
data InitialValueProblem
IVP :: Expr -> Expr -> [Expr] -> InitialValueProblem

-- | initial time
[initTime] :: InitialValueProblem -> Expr

-- | end time
[finalTime] :: InitialValueProblem -> Expr

-- | initial values
[initValues] :: InitialValueProblem -> [Expr]

-- | Operation connect the dependent variable and the order
($^^) :: ConstrConcept -> Integer -> Unknown

-- | Operation represent multiple
($**) :: Expr -> Unknown -> Term

-- | Operation represent plus (collection Terms)
($++) :: [Term] -> Term -> LHS

-- | Construct an ODESolverFormat for solving the ODE.
makeAODESolverFormat :: DifferentialModel -> ODESolverFormat
makeAIVP :: Expr -> Expr -> [Expr] -> InitialValueProblem

-- | Form well-formatted ODE equations which the ODE solvers can solve.
formEquations :: [[Expr]] -> [Unknown] -> [Expr] -> ConstrConcept -> [Expr]

-- | Create a <a>DifferentialModel</a> by giving a independent variable, a
--   dependent variable a canonical matrix form, and conceptChuck.
makeASystemDE :: UnitalChunk -> ConstrConcept -> [[Expr]] -> [Unknown] -> [Expr] -> String -> NP -> Sentence -> DifferentialModel

-- | Create a <a>DifferentialModel</a> by the input language
makeASingleDE :: UnitalChunk -> ConstrConcept -> LHS -> Expr -> String -> NP -> Sentence -> DifferentialModel
data QDefinition e

-- | Create a <a>QDefinition</a> with a <a>UID</a> (as a <a>Space</a>),
--   term (<a>NP</a>), definition (<a>Sentence</a>), <a>Symbol</a>,
--   <a>Space</a>, unit, and defining expression.
fromEqn :: IsUnit u => String -> NP -> Sentence -> Symbol -> Space -> u -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but has no units.
fromEqn' :: String -> NP -> Sentence -> Symbol -> Space -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but symbol depends on stage.
fromEqnSt :: IsUnit u => UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> u -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but symbol depends on stage and has no units.
fromEqnSt' :: UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> e -> QDefinition e

-- | Same as <a>fromEqnSt'</a>, but takes a <a>Space</a> instead of a
--   <a>UID</a>.
fromEqnSt'' :: String -> NP -> Sentence -> (Stage -> Symbol) -> Space -> e -> QDefinition e

-- | Wrapper for fromEqnSt and fromEqnSt'
mkQDefSt :: UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> e -> QDefinition e

-- | Used to help make <a>QDefinition</a>s when <a>UID</a>, term, and
--   <a>Symbol</a> come from the same source.
mkQuantDef :: (Quantity c, MayHaveUnit c, Concept c) => c -> e -> QDefinition e

-- | Used to help make <a>QDefinition</a>s when <a>UID</a> and
--   <a>Symbol</a> come from the same source, with the term separate.
mkQuantDef' :: (Quantity c, MayHaveUnit c) => c -> NP -> e -> QDefinition e

-- | Smart constructor for QDefinitions. Requires a quantity and its
--   defining equation.
ec :: (Quantity c, MayHaveUnit c) => c -> e -> QDefinition e

-- | Create a <a>QDefinition</a> function with a symbol, name, term, list
--   of inputs, resultant units, and a defining Expr
mkFuncDef :: (HasUID f, HasSymbol f, HasSpace f, HasUID i, HasSymbol i, HasSpace i, IsUnit u) => f -> NP -> Sentence -> u -> [i] -> e -> QDefinition e

-- | Create a <a>QDefinition</a> function with a symbol, name, term, list
--   of inputs, and a defining Expr
mkFuncDef' :: (HasUID f, HasSymbol f, HasSpace f, HasUID i, HasSymbol i, HasSpace i) => f -> NP -> Sentence -> [i] -> e -> QDefinition e

-- | Create a <a>QDefinition</a> functions using a symbol, list of inputs,
--   and a defining Expr
mkFuncDefByQ :: (Quantity c, MayHaveUnit c, HasSpace c, Quantity i, HasSpace i) => c -> [i] -> e -> QDefinition e

-- | Helper for getting the unit's <tt>Symbol</tt> from a chunk, as opposed
--   to the symbols of the chunk itself.
unit_symb :: Unitary c => c -> USymb

-- | DefinedQuantityDict is the combination of a <a>Concept</a> and a
--   <a>Quantity</a>. Contains a <a>ConceptChunk</a>, a <a>Symbol</a>
--   dependent on <a>Stage</a>, a <a>Space</a>, and maybe a
--   <a>UnitDefn</a>. Used when we want to assign a quantity to a concept.
--   Includes the space, symbol, and units for that quantity.
--   
--   Ex. A pendulum arm can be defined as a concept with a symbol (l),
--   space (Real numbers), and units (cm, m, etc.).
data DefinedQuantityDict

-- | Smart constructor that creates a DefinedQuantityDict with a
--   <a>ConceptChunk</a>, a <a>Symbol</a> independent of <a>Stage</a>, a
--   <a>Space</a>, and a unit.
dqd :: IsUnit u => ConceptChunk -> Symbol -> Space -> u -> DefinedQuantityDict

-- | Similar to <a>dqd</a>, but the <a>Symbol</a> is now dependent on the
--   <a>Stage</a>.
dqd' :: ConceptChunk -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> DefinedQuantityDict

-- | Similar to <a>dqd</a>, but without any units.
dqdNoUnit :: ConceptChunk -> Symbol -> Space -> DefinedQuantityDict
dqdNoUnit' :: ConceptChunk -> (Stage -> Symbol) -> Space -> DefinedQuantityDict

-- | When we want to merge a quantity and a concept. This is suspicious.
dqdQd :: (Quantity c, MayHaveUnit c) => c -> Sentence -> DefinedQuantityDict

-- | When the input already has all the necessary information. A
--   <tt>projection</tt> operator from some a type with instances of listed
--   classes to a <a>DefinedQuantityDict</a>.
dqdWr :: (Quantity c, Concept c, MayHaveUnit c) => c -> DefinedQuantityDict
class DefinesQuantity d
defLhs :: DefinesQuantity d => Getter d DefinedQuantityDict

-- | Makes a variable that is implementation-only.
implVar :: String -> NP -> String -> Space -> Symbol -> DefinedQuantityDict

-- | Similar to <a>implVar</a>, but takes in a <a>Sentence</a> for the
--   description rather than a <a>String</a>.
implVar' :: String -> NP -> Sentence -> Space -> Symbol -> DefinedQuantityDict

-- | Similar to <a>implVarAU</a> but takes a Sentence for the description
--   rather than a String.
implVarAU' :: String -> NP -> Sentence -> Maybe String -> Space -> Symbol -> Maybe UnitDefn -> DefinedQuantityDict

-- | Similar to a <a>DefinedQuantityDict</a>, UnitalChunks are concepts
--   with quantities that must have a unit definition. Contains
--   <a>DefinedQuantityDict</a>s and a <a>UnitDefn</a>.
--   
--   Ex. A pendulum arm is a tangible object with a symbol (l) and units
--   (cm, m, etc.).
data UnitalChunk
UC :: DefinedQuantityDict -> UnitDefn -> UnitalChunk
[_defq'] :: UnitalChunk -> DefinedQuantityDict
[_uni] :: UnitalChunk -> UnitDefn

-- | Used to create a <a>UnitalChunk</a> from a <a>Concept</a>,
--   <a>Symbol</a>, and <tt>Unit</tt>.
uc :: (Concept c, IsUnit u) => c -> Symbol -> Space -> u -> UnitalChunk

-- | Similar to <a>uc</a>, except it builds the <a>Concept</a> portion of
--   the <a>UnitalChunk</a> from a given <tt>UID</tt>, term, and definition
--   (as a <a>Sentence</a>) which are its first three arguments.
uc' :: IsUnit u => String -> NP -> Sentence -> Symbol -> Space -> u -> UnitalChunk

-- | Similar to <a>uc</a>, but <a>Symbol</a> is dependent on the
--   <a>Stage</a>.
ucStaged :: (Concept c, IsUnit u) => c -> (Stage -> Symbol) -> Space -> u -> UnitalChunk

-- | Similar to <a>uc'</a>, but <a>Symbol</a> is dependent on the
--   <a>Stage</a>.
ucStaged' :: IsUnit u => String -> NP -> Sentence -> (Stage -> Symbol) -> Space -> u -> UnitalChunk

-- | Attach units to a chunk that has a symbol and definition.
ucuc :: (Quantity c, Concept c, MayHaveUnit c) => c -> UnitDefn -> UnitalChunk

-- | Constructs a UnitalChunk from a <a>Concept</a> with <tt>Units</tt>.
ucw :: (Unitary c, Concept c, MayHaveUnit c) => c -> UnitalChunk

-- | For defining units. It has a <a>ConceptChunk</a> (that defines what
--   kind of unit it is), a unit symbol, maybe another (when it is a
--   synonym), perhaps a definition, and a list of <a>UID</a> of the units
--   that make up the definition.
--   
--   Ex. Meter is a unit of length defined by the symbol (m).
data UnitDefn
UD :: ConceptChunk -> UnitSymbol -> [UID] -> UnitDefn
[_vc] :: UnitDefn -> ConceptChunk
[_cas] :: UnitDefn -> UnitSymbol
[_cu] :: UnitDefn -> [UID]

-- | Generates a default unit symbol.
fromUDefn :: UDefn -> USymb

-- | Helper for fundamental unit concept chunk creation. Uses the same
--   <a>String</a> for the identifier, term, and definition.
unitCon :: String -> ConceptChunk

-- | Create a derived unit chunk from a concept and a unit equation.
makeDerU :: ConceptChunk -> UnitEquation -> UnitDefn

-- | Combinator for raising a unit to a power.
(^:) :: UnitDefn -> Integer -> UnitEquation

-- | Combinator for dividing one unit by another.
(/:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying two units together.
(*:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying a unit and a symbol.
(*$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for dividing a unit and a symbol.
(/$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for mulitiplying two unit equations.
(^$) :: UnitEquation -> UnitEquation -> UnitEquation

-- | Smart constructor for new derived units from existing units.
newUnit :: String -> UnitEquation -> UnitDefn

-- | Combinator for scaling one unit by some number.
scale :: IsUnit s => Double -> s -> UDefn

-- | Combinator for shifting one unit by some number.
shift :: IsUnit s => Double -> s -> UDefn

-- | Uses self-plural term.
--   
--   Create a derived unit chunk from a <a>UID</a>, term (<a>String</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Uses term that pluralizes by adding "s" to the end.
--   
--   Create a derived unit chunk from a <a>UID</a>, term (<a>String</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC' :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Create a derived unit chunk from a <a>UID</a>, term (<a>NP</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC'' :: String -> NP -> String -> Symbol -> UDefn -> UnitDefn

-- | Smart constructor for a "fundamental" unit.
fund :: String -> String -> String -> UnitDefn

-- | Variant of the <a>fund</a>, useful for degree.
fund' :: String -> String -> Symbol -> UnitDefn

-- | We don't want an Ord on units, but this still allows us to compare
--   them.
compUnitDefn :: UnitDefn -> UnitDefn -> Ordering

-- | Create a <tt>SI_Unit</tt> with two <a>Symbol</a> representations. The
--   created <a>NP</a> is self-plural.
derCUC :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Similar to <a>derCUC</a>, but the created <a>NP</a> has the
--   <tt>AddS</tt> plural rule.
derCUC' :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Create a derived unit chunk from a <a>UID</a>, term (<a>NP</a>),
--   definition, <a>Symbol</a>, and unit equation.
derCUC'' :: String -> NP -> String -> Symbol -> UnitEquation -> UnitDefn

-- | For allowing lists to mix together chunks that are units by projecting
--   them into a <a>UnitDefn</a>. For now, this only works on
--   <a>UnitDefn</a>s.
unitWrapper :: IsUnit u => u -> UnitDefn

-- | Get a list of <a>UID</a> of the units that make up the
--   <a>UnitEquation</a>.
getCu :: UnitEquation -> [UID]

-- | Types may contain a unit (<a>UnitDefn</a>).
class MayHaveUnit u
getUnit :: MayHaveUnit u => u -> Maybe UnitDefn

-- | The reason behind the constraint's existence.
data ConstraintReason
Physical :: ConstraintReason
Software :: ConstraintReason

-- | Holds constraints. May occur between an interval of <a>Expr</a>, a
--   list of <a>Double</a>s, or a list of <a>String</a>s.
data Constraint a

-- | By default, physical and software constraints are ranges.
[Range] :: ConstraintReason -> RealInterval a a -> Constraint a
[Elem] :: ConstraintReason -> a -> Constraint a

-- | Type synonym for <a>ConstraintE</a>
type ConstraintE = Constraint Expr

-- | Smart constructor for range of <a>Physical</a> constraints between two
--   given expressions.
physRange :: RealInterval Expr Expr -> ConstraintE

-- | Smart constructor for range of <a>Software</a> constraints between two
--   given expressions.
sfwrRange :: RealInterval Expr Expr -> ConstraintE
physElem :: Expr -> ConstraintE
sfwrElem :: Expr -> ConstraintE

-- | Helpful for filtering for Physical constraints. True if constraint is
--   <a>Physical</a>.
isPhysC :: Constraint e -> Bool

-- | Helpful for filtering for Software constraints. True if constraint is
--   <a>Software</a>.
isSfwrC :: Constraint e -> Bool

-- | ConstrConcepts are conceptual symbolic quantities
--   (<a>DefinedQuantityDict</a>) with <tt>Constraint</tt>s and maybe a
--   reasonable value (no units!). Similar to <tt>ConstrainedChunk</tt> but
--   includes a definition and domain.
--   
--   Ex. Measuring the length of a pendulum arm could be a concept that has
--   some reasonable value (between 1 cm and 2 m) and the constraint that
--   the length cannot be a negative value.
data ConstrConcept
ConstrConcept :: DefinedQuantityDict -> [ConstraintE] -> Maybe Expr -> ConstrConcept
[_defq] :: ConstrConcept -> DefinedQuantityDict
[_constr'] :: ConstrConcept -> [ConstraintE]
[_reasV'] :: ConstrConcept -> Maybe Expr

-- | Creates a <a>ConstrConcept</a> with a quantitative concept, a list of
--   <tt>Constraint</tt>s and an <a>Expr</a>.
constrained' :: (Concept c, MayHaveUnit c, Quantity c) => c -> [ConstraintE] -> Expr -> ConstrConcept

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), description (<a>String</a>), <a>Symbol</a>, unit,
--   <a>Space</a>, <tt>Constraint</tt>s, and an <a>Expr</a>.
cuc' :: IsUnit u => String -> NP -> String -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to <a>cuc'</a>, but <a>Symbol</a> is dependent on
--   <a>Stage</a>.
cuc'' :: IsUnit u => String -> NP -> String -> (Stage -> Symbol) -> u -> Space -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to cuc', but does not include a unit.
cucNoUnit' :: String -> NP -> String -> Symbol -> Space -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to <a>constrained'</a>, but defaults <a>Maybe</a> <a>Expr</a>
--   to <a>Nothing</a>.
constrainedNRV' :: (Concept c, MayHaveUnit c, Quantity c) => c -> [ConstraintE] -> ConstrConcept

-- | Similar to <tt>cnstrw</tt>, but types must also have a <a>Concept</a>.
cnstrw' :: (Quantity c, Concept c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> ConstrConcept

-- | UncertQs are conceptual symbolic quantities with constraints and an
--   <a>Uncertainty</a>. Contains a <a>ConstrConcept</a> and an
--   <a>Uncertainty</a>.
--   
--   Ex. Measuring the length of a pendulum arm may be recorded with an
--   uncertainty value.
data UncertQ

-- | Smart constructor that requires a <a>Quantity</a>, a percentage, and a
--   typical value with an <a>Uncertainty</a>.
uq :: (Quantity c, Constrained c, Concept c, HasReasVal c, MayHaveUnit c) => c -> Uncertainty -> UncertQ

-- | Uncertainty quantity (<a>uq</a>) but with a constraint.
uqc :: IsUnit u => String -> NP -> String -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertQ

-- | Uncertainty quantity constraint (<a>uqc</a>) without a description.
uqcND :: IsUnit u => String -> NP -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertQ

-- | Something that may contain an uncertainty value and a precision value.
data Uncertainty

-- | Smart constructor for values with uncertainty.
uncty :: Double -> Maybe Int -> Uncertainty

-- | HasUncertainty is just a chunk with some uncertainty associated to it.
--   This uncertainty is represented as a decimal value between 0 and 1
--   (percentage).
class HasUncertainty c

-- | Provides the <tt>Lens</tt> to an <a>Uncertainty</a>.
unc :: HasUncertainty c => Lens' c Uncertainty

-- | The default uncertainty is set to 0.1.
defaultUncrt :: Uncertainty

-- | Accessor for uncertainty value from something that has an uncertainty.
uncVal :: HasUncertainty x => x -> Double

-- | Accessor for precision value from something that has an uncertainty.
uncPrec :: HasUncertainty x => x -> Maybe Int

-- | Smart constructor for exact values (no uncertainty).
exact :: Uncertainty

-- | Retrieves the <a>String</a> contained in a <a>LblType</a>.
getAdd :: LblType -> String

-- | Prepends a <a>String</a> to an <a>IRefProg</a>.
prepend :: String -> IRefProg

-- | Applying different pieces of information for a reference. An RP is a
--   decorated internal reference. Citation is a citation. URI is for URLs
--   and other external links.
data LblType
RP :: IRefProg -> String -> LblType
Citation :: String -> LblType
URI :: String -> LblType

-- | Created for different forms of references. Used in <a>LblType</a>.
data IRefProg

-- | Deferred lookup; done later. Used for domains in a
--   <tt>ConceptInstance</tt>.
Deferred :: UID -> IRefProg

-- | Lifts a <a>String</a> into a <tt>RefProg</tt>.
RS :: String -> IRefProg

-- | Concatenates with two subprograms.
RConcat :: IRefProg -> IRefProg -> IRefProg

-- | The <tt>Symbol</tt> to insert the <tt>ShortName</tt> directly.
Name :: IRefProg

-- | A Reference contains the identifier (<a>UID</a>), a reference address
--   (<a>LblType</a>), a human-readable shortname (<a>ShortName</a>), and
--   any extra information about the reference (<a>RefInfo</a>).
data Reference
Reference :: UID -> LblType -> ShortName -> Reference

-- | Projector function that creates a <a>Reference</a> from something
--   <tt>Referable</tt>.
ref :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Reference

-- | Takes the reference <a>UID</a> and wraps it into a <a>Sentence</a>.
refS :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence

-- | Takes a <a>Reference</a> with a name to be displayed and wraps it into
--   a <a>Sentence</a>. Does not overwrite the shortname contained in the
--   reference, but will only display as the given <a>Sentence</a>.
namedRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence -> Sentence

-- | Takes a <a>Reference</a> with additional display info. Uses the
--   internal shortname for its display name.
complexRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> RefInfo -> Sentence

-- | Takes a <a>Reference</a> with a name to be displayed and any
--   additional information and wraps it into a <a>Sentence</a>. Does not
--   overwrite the shortname contained in the reference, but will only
--   display as the given <a>Sentence</a> along with the given
--   <a>RefInfo</a>.
namedComplexRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence -> RefInfo -> Sentence

-- | For holding a <a>Reference</a> that is decorated with extra
--   information (ex. page numbers, equation sources, etc.).
data DecRef

-- | For creating a decorated reference (<a>DecRef</a>) with extra
--   reference information (<a>RefInfo</a>).
dRefInfo :: (HasUID r, HasRefAddress r, HasShortName r) => r -> RefInfo -> DecRef

-- | Same as <a>ref</a>, but for <a>DecRef</a> instead of <a>Reference</a>.
dRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> DecRef

-- | A class that contains a list of decorated references (<a>DecRef</a>s).
class HasDecRef c

-- | Provides a <tt>Lens</tt> to the <a>DecRef</a>s.
getDecRefs :: HasDecRef c => Lens' c [DecRef]

-- | A <a>String</a> that should contain no spaces.
type EntryID = String

-- | All citations require a unique identifier used by the Drasil chunk. We
--   will re-use the <a>UID</a> part as an EntryID (<a>String</a>) used for
--   creating reference links. Finally we will have the reference
--   information (<a>CitationKind</a>, <a>CiteField</a>s, and a
--   <a>ShortName</a>).
--   
--   Ex. A reference to a thesis paper like Koothoor's "Document driven
--   approach to certifying scientific computing software" would include
--   the affiliated university, publishing year, and city.
data Citation

-- | A list of <a>Citation</a>s.
type BibRef = [Citation]

-- | Some documents, as well as some pieces of knowledge, have citations.
class HasCitation c

-- | Provides a <tt>Lens</tt> to the citations.
getCitations :: HasCitation c => Lens' c [Citation]

-- | <tt>Citation</tt>s should have a fields (<a>CiteField</a>).
class HasFields c

-- | Provides a <tt>Lens</tt> to <a>CiteField</a>s.
getFields :: HasFields c => Lens' c [CiteField]
citeID :: Lens' Citation UID
citeKind :: Lens' Citation CitationKind

-- | Article citation requires author(s), title, journal, year. Optional
--   fields can be: volume, number, pages, month, and note. Implicitly uses
--   the EntryID as the chunk id.
cArticle :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by author.
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk id.
cBookA :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by editor.
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk id.
cBookE :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Booklet citation requires title. Optional fields can be author, how
--   published, address, month, year, note. Implicitly uses the EntryID as
--   the chunk id.
cBooklet :: String -> [CiteField] -> String -> Citation

-- | InBook citation by author.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id. This smart constructor includes both chapter
--   and page numbers.
cInBookACP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InBook citation by editor.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id. This smart constructor includes both chapter
--   and page numbers.
cInBookECP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookACP</a>.
--   
--   InBook citation excluding page numbers.
cInBookAC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookECP</a>.
--   
--   InBook citation excluding page numbers.
cInBookEC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookACP</a>.
--   
--   InBook citation excluding chapter.
cInBookAP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookECP</a>.
--   
--   InBook citation excluding chapter.
cInBookEP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InCollection citation requires author, title, bookTitle, publisher,
--   year. Optional fields can be editor, volume or number, series, type,
--   chapter, pages, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id.
cInCollection :: People -> String -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | InProceedings citation requires author, title, bookTitle, year.
--   Optional fields can be editor, volume or number, series, pages,
--   address, month, organization, publisher, and note. Implicitly uses the
--   EntryID as the chunk id.
cInProceedings :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Manual (technical documentation) citation requires title. Optional
--   fields can be author, organization, address, edition, month, year, and
--   note. Implicitly uses the EntryID as the chunk id.
cManual :: String -> [CiteField] -> String -> Citation

-- | Master's Thesis citation requires author, title, school, and year.
--   Optional fields can be type, address, month, and note. Implicitly uses
--   the EntryID as the chunk id.
cMThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Misc citation requires nothing. Optional fields can be author, title,
--   howpublished, month, year, and note. Implicitly uses the EntryID as
--   the chunk id.
cMisc :: [CiteField] -> String -> Citation

-- | PhD Thesis citation requires author, title, school, and year. Optional
--   fields can be type, address, month, and note. Implicitly uses the
--   EntryID as the chunk id.
cPhDThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Proceedings citation requires title and year. Optional fields can be
--   editor, volume or number, series, address, publisher, note, month, and
--   organization. Implicitly uses the EntryID as the chunk id.
cProceedings :: String -> Int -> [CiteField] -> String -> Citation

-- | Technical Report citation requires author, title, institution, and
--   year. Optional fields can be type, number, address, month, and note.
--   Implicitly uses the EntryID as the chunk id.
cTechReport :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Unpublished citation requires author, title, and note. Optional fields
--   can be month and year. Implicitly uses the EntryID as the chunk id.
cUnpublished :: People -> String -> String -> [CiteField] -> String -> Citation

-- | Custom type for months (abbreviated).
data Month
Jan :: Month
Feb :: Month
Mar :: Month
Apr :: Month
May :: Month
Jun :: Month
Jul :: Month
Aug :: Month
Sep :: Month
Oct :: Month
Nov :: Month
Dec :: Month

-- | Fields used in citations.
data CiteField
Address :: String -> CiteField
Author :: People -> CiteField

-- | Used for <a>InCollection</a> references only.
BookTitle :: String -> CiteField
Chapter :: Int -> CiteField
Edition :: Int -> CiteField
Editor :: People -> CiteField

-- | Can be published via URL or something else.
HowPublished :: HP -> CiteField
Institution :: String -> CiteField
Journal :: String -> CiteField
Month :: Month -> CiteField
Note :: String -> CiteField
Number :: Int -> CiteField
Organization :: String -> CiteField

-- | Range of pages (ex1. 1-32; ex2. 7,31,52-55).
Pages :: [Int] -> CiteField
Publisher :: String -> CiteField
School :: String -> CiteField
Series :: String -> CiteField
Title :: String -> CiteField

-- | BibTeX "type" field.
Type :: String -> CiteField
Volume :: Int -> CiteField
Year :: Int -> CiteField

-- | How something is published. Necessary for URLs to work properly.
data HP
URL :: String -> HP
Verb :: String -> HP

-- | External references come in many flavours. Articles, Books, etc. (we
--   are using the types available in Bibtex).
data CitationKind
Article :: CitationKind
Book :: CitationKind
Booklet :: CitationKind
InBook :: CitationKind
InCollection :: CitationKind
InProceedings :: CitationKind
Manual :: CitationKind
MThesis :: CitationKind
Misc :: CitationKind
PhDThesis :: CitationKind
Proceedings :: CitationKind
TechReport :: CitationKind
Unpublished :: CitationKind

-- | Orders two authors. If given two of the exact same authors, year, and
--   title, returns an error.
compareAuthYearTitle :: HasFields c => c -> c -> Ordering

-- | Smart field constructor for a <a>CiteField</a>.
author :: People -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
editor :: People -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
address :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
bookTitle :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
howPublished :: String -> CiteField

-- | URL version of <a>howPublished</a>.
--   
--   Smart field constructor for a <a>CiteField</a>.
howPublishedU :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
institution :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
journal :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
note :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
organization :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
publisher :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
school :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
series :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
title :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
typeField :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
chapter :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
edition :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
number :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
volume :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
year :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
pages :: [Int] -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
month :: Month -> CiteField

-- | People is a synonymn for many <a>Person</a>s.
type People = [Person]

-- | A person can have a given name, middle name(s), and surname, as well
--   as the naming convention they use.
data Person

-- | Constructor for a person using Western naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   given name, surname.
person :: String -> String -> Person

-- | Members of this class must have a name.
class HasName p

-- | Gets the name of a <a>Person</a>. Adds a dot after any initials.
name :: HasName n => n -> String

-- | Constructor for a person using Eastern naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   surname, given name.
person' :: String -> String -> Person

-- | Constructor for a person using Western naming conventions. Similar to
--   the <a>person</a> constructor, except the middle argument is a list of
--   middle names.
personWM :: String -> [String] -> String -> Person

-- | Constructor for a person using Eastern naming conventions. Similar to
--   the <a>person'</a> constructor, except the middle argument is a list
--   of middle names.
personWM' :: String -> [String] -> String -> Person

-- | Constructor for a person with a mononym (only one name).
mononym :: String -> Person

-- | Provides the ability to hold a name.
nameStr :: HasName p => p -> String

-- | Gets a <a>Person</a>'s name in the form: Last, First Middle.
rendPersLFM :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, F. M.
rendPersLFM' :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, First M.
rendPersLFM'' :: Person -> String

-- | Orderes different groups of <a>Person</a>s. If two lists are the same
--   up to a point, the citation with more <a>Person</a>s will go last.
comparePeople :: [Person] -> [Person] -> Ordering

-- | For writing <a>Sentence</a>s via combining smaller elements.
--   <a>Sentence</a>s are made up of some known vocabulary of things:
--   
--   <ul>
--   <li>units (their visual representation)</li>
--   <li>words (via <a>String</a>s)</li>
--   <li>special characters</li>
--   <li>accented letters</li>
--   <li>references to specific layout objects</li>
--   </ul>
data Sentence

-- | Ch looks up the term for a given <a>UID</a> and displays the term with
--   a given <a>SentenceStyle</a> and <tt>CapitalizationRule</tt>. This
--   allows Sentences to hold plural forms of <tt>NounPhrase</tt>s and
--   <tt>NamedIdea</tt>s.
[Ch] :: SentenceStyle -> TermCapitalization -> UID -> Sentence

-- | A branch of Ch dedicated to SymbolStyle only.
[SyCh] :: UID -> Sentence

-- | Converts a unit symbol into a usable Sentence form.
[Sy] :: USymb -> Sentence

-- | Constructor for <a>String</a>s, used often for descriptions in Chunks.
[S] :: String -> Sentence

-- | Converts the graphical representation of a symbol into a usable
--   Sentence form.
[P] :: Symbol -> Sentence

-- | Lifts an expression into a Sentence.
[E] :: ModelExpr -> Sentence

-- | Takes a <a>UID</a> to a reference, a display name (<a>Sentence</a>),
--   and any additional reference display information (<a>RefInfo</a>).
--   Resolves the reference later (similar to Ch).
[Ref] :: UID -> Sentence -> RefInfo -> Sentence

-- | Adds quotation marks around a Sentence.
[Quote] :: Sentence -> Sentence

-- | Used for a % symbol.
[Percent] :: Sentence

-- | Direct concatenation of two Sentences (no implicit spaces!).
[:+:] :: Sentence -> Sentence -> Sentence

-- | Empty Sentence.
[EmptyS] :: Sentence
infixr 5 :+:

-- | Used in <a>Ch</a> constructor to determine the state of a term (can
--   record whether something is in plural form, a singular term, or in
--   short form).
data SentenceStyle
PluralTerm :: SentenceStyle
TermStyle :: SentenceStyle
ShortStyle :: SentenceStyle

-- | Used in <a>Ch</a> constructor to determine the capitalization of a
--   term. CapF is for capitalizing the first word from the <a>UID</a> of
--   the given term. CapW is for capitalizing all words from the <a>UID</a>
--   of the given term. Mirrors <tt>CapFirst</tt> and <tt>CapWords</tt>
--   from <tt>CapitalizationRule</tt>.
data TermCapitalization
CapF :: TermCapitalization
CapW :: TermCapitalization
NoCap :: TermCapitalization

-- | Holds any extra information needed for a <tt>Reference</tt>, be it an
--   equation, pages, a note, or nothing.
data RefInfo
None :: RefInfo
Equation :: [Int] -> RefInfo
Page :: [Int] -> RefInfo
RefNote :: String -> RefInfo

-- | Helper for concatenating two <a>Sentence</a>s with a space between
--   them.
(+:+) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two <a>Sentence</a>s using <a>+:+</a> and
--   appends a period.
(+:+.) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two sentences using <a>+:+</a> and appends a
--   colon.
(+:) :: Sentence -> Sentence -> Sentence

-- | Helper which appends a period to the end of a <a>Sentence</a> (used
--   often as a post-fix operator).
(!.) :: Sentence -> Sentence

-- | Capitalizes a Sentence.
capSent :: Sentence -> Sentence

-- | Helper which creates a Header with size s of the <a>Sentence</a>.
headSent :: Int -> Sentence -> Sentence

-- | Gets a symbol and places it in a <a>Sentence</a>.
ch :: (HasUID c, HasSymbol c) => c -> Sentence
eS :: ModelExpr -> Sentence
eS' :: Express t => t -> Sentence

-- | Helper for concatenating two <a>Sentence</a>s with a comma and space
--   between them.
sC :: Sentence -> Sentence -> Sentence

-- | Helper for concatenating two <a>Sentence</a>s with a space-surrounded
--   dash between them.
sDash :: Sentence -> Sentence -> Sentence

-- | Helper for wrapping <a>Sentence</a>s in parentheses.
sParen :: Sentence -> Sentence
class NounPhrase n

-- | Retrieves singular form of term. Ex. "the quick brown fox".
phraseNP :: NounPhrase n => n -> Sentence

-- | Retrieves plural form of term. Ex. "the quick brown foxes".
pluralNP :: NounPhrase n => n -> PluralForm

-- | Retrieves the singular form and applies a captalization rule (usually
--   capitalizes the first word) to produce a <a>Sentence</a>. Ex. "The
--   quick brown fox".
sentenceCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization

-- | Retrieves the singular form and applies a captalization rule (usually
--   capitalizes all words) to produce a <a>Sentence</a>. Ex. "The Quick
--   Brown Fox".
titleCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization

-- | For nouns and <tt>NounPhrase</tt>s. May be constructed from a proper
--   noun, common noun, or phrase (<a>Sentence</a>) and their respective
--   pluralization and capitalization rules.
data NP

-- | Self plural.
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn :: String -> NP

-- | Plural form simply adds "s" (ex. Henderson -&gt; Hendersons).
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn' :: String -> NP

-- | Plural form adds "e".
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn'' :: String -> NP

-- | Plural form adds "es" (ex. Bush -&gt; Bushes).
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn''' :: String -> NP

-- | Constructs a <a>ProperNoun</a> with a custom plural rule (using
--   <a>IrregPlur</a> from <a>PluralRule</a>). First argument is the String
--   representing the noun, second is the rule.
pnIrr :: String -> PluralRule -> NP

-- | Self plural.
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn :: String -> NP

-- | Plural form simply adds "s" (ex. dog -&gt; dogs).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn' :: String -> NP

-- | Plural form adds "e" (ex. formula -&gt; formulae).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn'' :: String -> NP

-- | Plural form adds "es" (ex. bush -&gt; bushes).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn''' :: String -> NP

-- | Constructs a common noun that allows you to specify the pluralization
--   rule (as in <a>pnIrr</a>).
cnIP :: String -> PluralRule -> NP

-- | Common noun that allows you to specify both the pluralization rule and
--   the capitalization rule for sentence case (if the noun is used at the
--   beginning of a sentence).
cnIrr :: String -> PluralRule -> CapitalizationRule -> NP

-- | Constructs a common noun that pluralizes by dropping the last letter
--   and adding an "ies" ending (ex. body -&gt; bodies).
cnIES :: String -> NP

-- | Construct a common noun that pluralizes by dropping the last two
--   letters and adding an "ices" ending (ex. matrix -&gt; matrices).
cnICES :: String -> NP

-- | Constructs a common noun that pluralizes by dropping the last two
--   letters and adding "es" (ex. analysis -&gt; analyses).
cnIS :: String -> NP

-- | Constructs a common noun that pluralizes by dropping the last two
--   letters and adding "a" (ex. datum -&gt; data).
cnUM :: String -> NP

-- | Creates a <a>NP</a> with a given singular and plural form (as
--   <a>String</a>s) that capitalizes the first letter of the first word
--   for sentence case.
nounPhrase :: String -> PluralString -> NP

-- | Similar to <a>nounPhrase</a>, but takes a specified capitalization
--   rule for the sentence case.
nounPhrase' :: String -> PluralString -> CapitalizationRule -> NP

-- | Capitalization rules.
data CapitalizationRule

-- | Capitalize the first letter of the first word only.
CapFirst :: CapitalizationRule

-- | Capitalize the first letter of each word.
CapWords :: CapitalizationRule

-- | Replace the noun phrase with the given <a>Sentence</a>. Used for
--   custom capitalization.
Replace :: Sentence -> CapitalizationRule

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
atStartNP :: NounPhrase n => n -> Capitalization

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
atStartNP' :: NounPhrase n => n -> Capitalization

-- | Pluralization rules.
data PluralRule

-- | Add "s" to the end of the noun phrase.
AddS :: PluralRule

-- | Add "e" to the end of the noun phrase.
AddE :: PluralRule

-- | Add "es" to the end of the noun phrase.
AddES :: PluralRule

-- | The noun phrase is already plural.
SelfPlur :: PluralRule

-- | Apply the given function to the noun phrase to get the plural.
IrregPlur :: (String -> String) -> PluralRule

-- | Combine two noun phrases. The singular form becomes <tt>phrase</tt>
--   from t1 followed by <tt>phrase</tt> of t2. The plural becomes
--   <tt>phrase</tt> of t1 followed by <tt>plural</tt> of t2. Uses standard
--   <a>CapFirst</a> sentence case and <a>CapWords</a> title case. For
--   example: <tt>compoundPhrase system constraint</tt> will have singular
--   form "system constraint" and plural "system constraints".
compoundPhrase :: (NounPhrase a, NounPhrase b) => a -> b -> NP

-- | Similar to <a>compoundPhrase</a>, but the sentence case is the same as
--   the title case (<a>CapWords</a>).
compoundPhrase' :: NP -> NP -> NP

-- | Similar to <a>compoundPhrase'</a>, but accepts two functions that will
--   be used to construct the plural form. For example,
--   <tt>compoundPhrase'' plural phrase system constraint</tt> would have
--   the plural form "systems constraint".
compoundPhrase'' :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Similar to <a>compoundPhrase</a>, but used when you need a special
--   function applied to the first term of both singular and pluralcases
--   (eg. short or plural).
compoundPhrase''' :: (NP -> Sentence) -> NP -> NP -> NP

-- | Similar to <a>compoundPhrase</a>, but pluralizes the first <a>NP</a>
--   for both singular and plural cases.
compoundPhraseP1 :: NP -> NP -> NP

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP :: NounPhrase n => n -> Capitalization

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP' :: NounPhrase n => n -> Capitalization

-- | Custom noun phrase constructor that takes a singular form
--   (<a>Sentence</a>), plural form (<a>Sentence</a>), sentence case
--   capitalization rule, and title case capitalization rule.
nounPhrase'' :: Sentence -> PluralForm -> CapitalizationRule -> CapitalizationRule -> NP

-- | For things that should not be pluralized (or are self-plural). Works
--   like <a>nounPhrase</a>, but with only the first argument.
nounPhraseSP :: String -> NP

-- | Similar to nounPhrase, except it only accepts one <a>Sentence</a>.
--   Used for Requirements, Assumptions, LikelyChanges, etc. to allow for
--   referencing. Plural case is just <a>AddS</a>.
nounPhraseSent :: Sentence -> NP

-- | Helper for common pattern of introducing the title-case version of a
--   noun phrase (from an Idea) followed by its abbreviation in
--   parentheses.
introduceAbb :: Idea n => n -> Sentence

-- | Helper for getting the phrase from a <a>NamedIdea</a> using it's UID.
phrase :: NamedIdea n => n -> Sentence

-- | Helper for getting the plural of a phrase from a <a>NamedIdea</a>.
plural :: NamedIdea n => n -> Sentence

-- | Singular possesive function
--   
--   Helper for getting the possesive cases from the term of a
--   <a>NamedIdea</a>.
phrasePoss :: NamedIdea n => n -> Sentence

-- | Plural possesive function
--   
--   Helper for getting the possesive cases from the term of a
--   <a>NamedIdea</a>.
pluralPoss :: NamedIdea n => n -> Sentence

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   <a>NamedIdea</a>.
atStart :: NamedIdea n => n -> Sentence

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   <a>NamedIdea</a>.
atStart' :: NamedIdea n => n -> Sentence

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   <a>NamedIdea</a>.
titleize :: NamedIdea n => n -> Sentence

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   <a>NamedIdea</a>.
titleize' :: NamedIdea n => n -> Sentence

-- | Get short form (if it exists), else get term of an <a>Idea</a>. Uses
--   the UID of the <a>Idea</a> in a <tt>Ch</tt> Sentence constructor to
--   get the short form using getA. getA may return Nothing, in which case
--   lookupS uses the term, where lookupS is the main helper for looking up
--   the short form of a <tt>Ch</tt> Sentence.
short :: Idea c => c -> Sentence

-- | Used for holding the short form of a name (as a <a>Sentence</a> with a
--   wrapper).
data ShortName

-- | Smart constructor for making a <a>Sentence</a> into a
--   <a>ShortName</a>.
shortname' :: Sentence -> ShortName

-- | Pulls the short form (as a <a>Sentence</a>) out of a <a>ShortName</a>.
getSentSN :: ShortName -> Sentence

-- | A <a>ShortName</a> is the text to be displayed for a link.
--   
--   Used for referencing within a document that can include symbols and
--   whatnot if required. Visible in the typeset documents (pdf).
class HasShortName s
shortname :: HasShortName s => s -> ShortName

-- | Derivations are an ordered list of sentences and expressions. They are
--   rendered in order as paragraphs and equation blocks to display the
--   derivation.
data Derivation
Derivation :: Sentence -> [Sentence] -> Derivation

-- | Smart constructor for creating a <a>Derivation</a>.
mkDeriv :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but prepends "Detailed derivation of" to
--   the header.
mkDerivName :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but without a header <a>Sentence</a>.
mkDerivNoHeader :: [Sentence] -> Derivation

-- | Type that helps determine enumeration method. Can use either numbers,
--   uppercase letters, or lowercase letters.
data EnumType
Numb :: EnumType
Upper :: EnumType
Lower :: EnumType

-- | Type to help wrap a sentence with parenthesis or to add a period at
--   the end.
data WrapType
Parens :: WrapType
Period :: WrapType

-- | Type to help separate words with commas or semicolons.
data SepType
Comma :: SepType
SemiCol :: SepType

-- | Type to help fold differently between listed items, or if there are
--   options (ex. using "and" or "or" at the end of a list of words).
data FoldType
List :: FoldType
Options :: FoldType

-- | Helper for formatting a list of constraints.
foldConstraints :: Quantity c => c -> [ConstraintE] -> Sentence

-- | Creates a list of elements with "enumerators" in "wrappers" using
--   foldlList.
foldlEnumList :: EnumType -> WrapType -> SepType -> FoldType -> [Sentence] -> Sentence

-- | Creates a list of elements separated by a "separator", ending with
--   "and" or "or".
foldlList :: SepType -> FoldType -> [Sentence] -> Sentence

-- | Fold sentences then turns into content using <a>foldlSent</a>.
foldlSP :: [Sentence] -> Contents

-- | Same as <a>foldlSP</a> but uses <a>foldlSent_</a>.
foldlSP_ :: [Sentence] -> Contents

-- | Same as <a>foldlSP</a> but uses <a>foldlSentCol</a>.
foldlSPCol :: [Sentence] -> Contents

-- | Partial function application of <a>foldle</a> for sentences
--   specifically. Folds with spaces and adds a period (".") at the end.
foldlSent :: [Sentence] -> Sentence

-- | <a>foldlSent</a> but does not add a period.
foldlSent_ :: [Sentence] -> Sentence

-- | <a>foldlSent</a> but ends with colon.
foldlSentCol :: [Sentence] -> Sentence

-- | Folds a list of elements separated by commas, including the last
--   element.
foldlsC :: [Sentence] -> Sentence

-- | Parses a list of integers into a nice sentence (ie. S "1, 4-7, and
--   13").
foldNums :: String -> [Int] -> Sentence

-- | Parses a list of integers into a list of strings (ie. ["1", "4-7",
--   "13"]).
numList :: String -> [Int] -> [String]

-- | A Document has a Title (<a>Sentence</a>), Author(s) (<a>Sentence</a>),
--   and <a>Section</a>s which hold the contents of the document.
data Document
Document :: Title -> Author -> ShowTableOfContents -> [Section] -> Document
Notebook :: Title -> Author -> [Section] -> Document

-- | Determines whether or not the table of contents appears on the
--   generated artifacts.
data ShowTableOfContents
ToC :: ShowTableOfContents
NoToC :: ShowTableOfContents

-- | Types of definitions (general, instance, theory, or data).
data DType
General :: DType
Instance :: DType
Theory :: DType
Data :: DType

-- | Sections have a title (<a>Sentence</a>), a list of contents
--   (<a>SecCons</a>) and a shortname (<a>Reference</a>).
data Section
Section :: Title -> [SecCons] -> Reference -> Section
[tle] :: Section -> Title
[cons] :: Section -> [SecCons]
[_lab] :: Section -> Reference

-- | Contents may be labelled or unlabelled.
data Contents
UlC :: UnlabelledContent -> Contents
LlC :: LabelledContent -> Contents

-- | Section Contents are split into subsections or contents, where
--   contents are standard layout objects (see <a>Contents</a>).
data SecCons
Sub :: Section -> SecCons
Con :: Contents -> SecCons

-- | Denotes the different possible types that can be used as a list.
data ListType

-- | Bulleted list.
Bullet :: [(ItemType, Maybe String)] -> ListType

-- | Enumerated list.
Numeric :: [(ItemType, Maybe String)] -> ListType

-- | Simple list with items denoted by <tt>:</tt>. Renders as "Title: Item"
Simple :: [ListTuple] -> ListType

-- | Descriptive list, renders as "<b>Title</b>: Item" (see
--   <a>ListTuple</a>).
Desc :: [ListTuple] -> ListType

-- | Renders a list of "<tt><a>Title</a></tt> is the <tt>Item</tt>".
Definitions :: [ListTuple] -> ListType

-- | Denotes how something should behave in a list (<a>ListType</a>).
data ItemType

-- | Standard singular item.
Flat :: Sentence -> ItemType

-- | Nest a list (<a>ListType</a>) as an item.
Nested :: Header -> ListType -> ItemType
type ListTuple = -- | Formats as Title: Item. For use in lists. (Title, ItemType, Maybe String)

-- | Contains a <a>Reference</a> and <a>RawContent</a>.
data LabelledContent
LblC :: Reference -> RawContent -> LabelledContent
[_ref] :: LabelledContent -> Reference
[_ctype] :: LabelledContent -> RawContent

-- | Only contains <a>RawContent</a>.
newtype UnlabelledContent
UnlblC :: RawContent -> UnlabelledContent
[_cntnts] :: UnlabelledContent -> RawContent

-- | Indicates whether a figure has a caption or not.
data HasCaption
NoCaption :: HasCaption
WithCaption :: HasCaption

-- | Smart constructor that wraps <a>UnlabelledContent</a> into
--   <a>Contents</a>.
mkParagraph :: Sentence -> Contents

-- | Smart constructor similar to <a>llcc</a>, but takes in
--   <a>RawContent</a> first.
mkRawLC :: RawContent -> Reference -> LabelledContent

-- | Manually removes the first section of a document (table of contents
--   section). temp fix for Notebook (see if we need this in notebook
--   later)
checkToC :: Document -> Document

-- | Smart constructor for labelled content chunks.
llcc :: Reference -> RawContent -> LabelledContent

-- | Smart constructor for unlabelled content chunks (no <a>Reference</a>).
ulcc :: RawContent -> UnlabelledContent

-- | Smart constructor for creating <a>Section</a>s with a title
--   (<a>Sentence</a>), introductory contents (ie. paragraphs, tables,
--   etc.), a list of subsections, and a shortname (<a>Reference</a>).
section :: Sentence -> [Contents] -> [Section] -> Reference -> Section

-- | <a>Figure</a> smart constructor with a <a>Lbl</a> and a
--   <a>Filepath</a>. Assumes 100% of page width as max width. Defaults to
--   <a>WithCaption</a>.
fig :: Lbl -> Filepath -> RawContent

-- | <a>Figure</a> smart constructor without a caption.
figNoCap :: Lbl -> Filepath -> RawContent

-- | <a>Figure</a> smart constructor that allows for customized max widths.
--   Defaults to <a>WithCaption</a>.
figWithWidth :: Lbl -> Filepath -> MaxWidthPercent -> RawContent

-- | <a>Figure</a> smart constructor with customized max widths and no
--   caption.
figNoCapWithWidth :: Lbl -> Filepath -> MaxWidthPercent -> RawContent

-- | MaxWidthPercent should be kept in the range 1-100. Values outside this
--   range may have unexpected results. Used for specifying max figure
--   width as <tt>pagewidth*MaxWidthPercent/100</tt>.
type MaxWidthPercent = Float

-- | Members of this class must have <a>RawContent</a>.
class HasContents c

-- | Provides a <tt>Lens</tt> to the <a>RawContent</a>.
accessContents :: HasContents c => Lens' c RawContent

-- | Types of layout objects we deal with explicitly.
data RawContent

-- | table has: header-row, data(rows), label/caption, and a bool that
--   determines whether or not to show label.
Table :: [Sentence] -> [[Sentence]] -> Title -> Bool -> RawContent

-- | Paragraphs are just sentences.
Paragraph :: Sentence -> RawContent

-- | Block of Equations holds an expression.
EqnBlock :: ModelExpr -> RawContent

-- | Grants the ability to label a group of <a>RawContent</a>.
DerivBlock :: Sentence -> [RawContent] -> RawContent

-- | For enumerated lists.
Enumeration :: ListType -> RawContent

-- | Defines something with a type, identifier, and <a>Contents</a>.
Defini :: DType -> [(Identifier, [Contents])] -> RawContent

-- | For creating figures in a document includes whether the figure has a
--   caption.
Figure :: Lbl -> Filepath -> MaxWidthPercent -> HasCaption -> RawContent

-- | Grants the ability to reference something.
Bib :: BibRef -> RawContent

-- | Contain a graph with coordinates (<a>Sentence</a>s), maybe a width and
--   height, and a label (<a>Sentence</a>).
Graph :: [(Sentence, Sentence)] -> Maybe Width -> Maybe Height -> Lbl -> RawContent

-- | Block for codes TODO: Fill this one in.
CodeBlock :: CodeExpr -> RawContent

-- | Smart constructor that wraps <a>LabelledContent</a> into
--   <a>Contents</a>.
mkFig :: Reference -> RawContent -> Contents

-- | Create a reference for a table. Takes in the name of a table (which
--   will also be used for its shortname).
makeTabRef :: String -> Reference

-- | Create a reference for a figure. Takes in the name of a figure (which
--   will also be used for its shortname).
makeFigRef :: String -> Reference

-- | Create a reference for a section. Takes in the name of a section and a
--   shortname for the section.
makeSecRef :: String -> Sentence -> Reference

-- | Create a reference for a equation. Takes in the name of the equation
--   (which will also be used for its shortname).
makeEqnRef :: String -> Reference

-- | Create a reference for a <a>URI</a>. Takes in a <a>UID</a> (as a
--   <a>String</a>), a reference address, and a shortname.
makeURI :: String -> String -> ShortName -> Reference

-- | Variants of <a>makeTabRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeTabRef' :: UID -> Reference

-- | Variants of <a>makeFigRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeFigRef' :: UID -> Reference

-- | Variants of <a>makeSecRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeSecRef' :: UID -> Sentence -> Reference

-- | Variants of <a>makeEqnRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeEqnRef' :: UID -> Reference

-- | Variants of <a>makeURI</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeURI' :: UID -> String -> ShortName -> Reference

-- | Creates a bulleted list.
enumBullet :: Reference -> [Sentence] -> LabelledContent

-- | Same as <a>enumBullet</a> but unlabelled.
enumBulletU :: [Sentence] -> Contents

-- | Currently Unused. Creates a simple bulleted list that labels things
--   with a title and number:
--   
--   <ul>
--   <li>lb - Reference,</li>
--   <li>s - start index for the enumeration,</li>
--   <li>t - title of the list,</li>
--   <li>l - list to be enumerated.</li>
--   </ul>
--   
--   For example, if we want to create a list of data definitions, we could
--   call the function as follows:
--   
--   <pre>
--   enumSimple _ 2 (S "DD") [def1, def2, ...]
--   </pre>
--   
--   And the resulting <a>LabelledContent</a> would be rendered as:
--   
--   <ul>
--   <li>DD2: def1</li>
--   <li>DD3: def2</li>
--   <li>DD4: def3 ...</li>
--   </ul>
enumSimple :: Reference -> Integer -> Sentence -> [Sentence] -> LabelledContent

-- | Same as <a>enumSimple</a> but unlabelled.
enumSimpleU :: Integer -> Sentence -> [Sentence] -> Contents

-- | Convenience function for transforming referable concepts into a
--   bulleted list. Used in drasil-docLang in making the assumptions,
--   goals, and requirements sections. Output is of the kind <tt>Concept
--   Name: definition of concept</tt>.
mkEnumSimpleD :: (Referable c, HasShortName c, Definition c) => [c] -> [Contents]

-- | Displays a given expression and attaches a <a>Reference</a> to it.
lbldExpr :: ModelExpr -> Reference -> LabelledContent

-- | Same as <tt>eqUnR</tt> except content is unlabelled (does not attach a
--   <a>Reference</a>).
unlbldExpr :: ModelExpr -> Contents

-- | Unlabelled code expression
unlbldCode :: CodeExpr -> Contents

-- | Output is of the form "<tt>reference - sentence</tt>".
chgsStart :: (HasShortName x, Referable x) => x -> Sentence -> Sentence

-- | Takes a <a>HasSymbol</a> that is also <a>Referable</a> and outputs as
--   a <a>Sentence</a>: "<tt>symbol</tt> is defined in <tt>reference</tt>."
definedIn :: (Referable r, HasShortName r, DefinesQuantity r) => r -> Sentence

-- | Same as <a>definedIn</a>, but allows for additional information to be
--   appended to the <a>Sentence</a>.
definedIn' :: (Referable r, HasShortName r, DefinesQuantity r) => r -> Sentence -> Sentence

-- | Takes a <a>Referable</a> and outputs as a <a>Sentence</a> "defined in
--   <tt>reference</tt>" (no <a>HasSymbol</a>).
definedIn'' :: (Referable r, HasShortName r) => r -> Sentence

-- | Takes a <a>Symbol</a> and its <tt>Reference</tt> (does not append a
--   period at the end!). Outputs as "<tt>symbol</tt> is defined in
--   <tt>source</tt>".
definedIn''' :: (HasSymbol q, HasUID q, Referable r, HasShortName r) => q -> r -> Sentence

-- | Takes an expression and a <a>Referable</a> and outputs as a Sentence
--   "expression (source)".
eqnWSource :: (Referable r, HasShortName r) => ModelExpr -> r -> Sentence

-- | Takes a <a>Referable</a> source and a <a>UnitalChunk</a> and outputs
--   as a <a>Sentence</a>: "From <tt>source</tt> we can replace
--   <tt>symbol</tt>:".
fromReplace :: (Referable r, HasShortName r) => r -> UnitalChunk -> Sentence

-- | Wraps "from <tt>reference</tt>" in parentheses.
fromSource :: (Referable r, HasShortName r) => r -> Sentence

-- | Similar to <a>fromSource</a> but takes a list of references instead of
--   one.
fromSources :: (Referable r, HasShortName r) => [r] -> Sentence

-- | Takes an amount as a <a>Sentence</a> and appends a unit to it.
fmtU :: MayHaveUnit a => Sentence -> a -> Sentence

-- | Appends "following <tt>reference</tt>" to the end of a
--   <a>Sentence</a>.
follows :: (Referable r, HasShortName r) => Sentence -> r -> Sentence

-- | Takes a list and a <a>Section</a>, then generates a list of that
--   section's reference to match the length of the list.
makeListRef :: [a] -> Section -> [Sentence]

-- | Converts input to a <a>Sentence</a> and appends %.
addPercent :: Show a => a -> Sentence

-- | Prepends the word <a>Equation</a> to an <a>Int</a>.
eqN :: Int -> Sentence

-- | Uses an <a>Either</a> type to check if a <a>String</a> is valid -
--   <a>Left</a> with error message if there is an invalid <a>Char</a> in
--   <a>String</a>, else <a>Right</a> with <a>String</a>.
checkValidStr :: String -> String -> Either String String

-- | Used when you want to say a term followed by its symbol. ex. "...using
--   the Force F in...".
getTandS :: Quantity a => a -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeChanged :: Sentence -> Sentence -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeExpanded :: Sentence -> Sentence -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeWOVerb :: Sentence -> Sentence -> Sentence

-- | Returns the <a>Sentence</a> "<tt>(<a>titleize</a> aNamedIdea)</tt>
--   Showing the Connections Between <tt>contents</tt>".
showingCxnBw :: NamedIdea c => c -> Sentence -> Sentence

-- | Takes a list of <a>Referable</a>s and <a>Symbol</a>s and outputs as a
--   Sentence "By substituting <tt>symbols</tt>, this can be written as:".
substitute :: (Referable r, HasShortName r, DefinesQuantity r) => [r] -> Sentence

-- | Extracts the typical uncertainty to be displayed from something that
--   has an uncertainty.
typUncr :: HasUncertainty c => c -> Sentence

-- | Returns the <a>Sentence</a> "The <tt>chunk</tt> under consideration is
--   <tt>chunkDefinition</tt>".
underConsidertn :: ConceptChunk -> Sentence

-- | Get a unit symbol if there is one.
unwrap :: Maybe UnitDefn -> Sentence

-- | Apply a binary function to the terms of two named ideas, instead of to
--   the named ideas themselves. Ex. <tt>fterms compoundPhrase t1 t2</tt>
--   instead of <tt>compoundPhrase (t1 ^. term) (t2 ^. term)</tt>.
fterms :: (NamedIdea c, NamedIdea d) => (NP -> NP -> t) -> c -> d -> t

-- | Applies <a>Bullet</a> and <a>Flat</a> to a list.
bulletFlat :: [Sentence] -> ListType

-- | Applies <a>Bullet</a>s and headers to a <a>Nested</a> <a>ListType</a>.
--   The first argument is the headers of the <a>Nested</a> lists.
bulletNested :: [Sentence] -> [ListType] -> ListType

-- | Makes <a>Sentence</a>s from an item and its reference. Takes the title
--   of reference as a <a>String</a> and a <a>Sentence</a> containing the
--   full reference. Wraps the full reference in parenthesis.
itemRefToSent :: String -> Sentence -> Sentence

-- | Makes a traceability matrix from a list of row titles, a list of rows
--   of "checked" columns, and a list of columns.
makeTMatrix :: Eq a => [Sentence] -> [[a]] -> [a] -> [[Sentence]]

-- | Zip helper function enumerates abbreviations and zips it with list of
--   <a>ItemType</a>:
--   
--   <ul>
--   <li>s - the number from which the enumeration should start from
--   (<a>Integer</a>),</li>
--   <li>t - the title of the list (<a>Sentence</a>),</li>
--   <li>l - the list to be enumerated ([<a>Sentence</a>]).</li>
--   </ul>
mkEnumAbbrevList :: Integer -> Sentence -> [Sentence] -> [(Sentence, ItemType)]

-- | Helper for making a table from a columns.
mkTableFromColumns :: [(Sentence, [Sentence])] -> ([Sentence], [[Sentence]])

-- | Converts lists of simple <a>ItemType</a>s into a list which may be
--   used in <tt>Contents</tt> but is not directly referable.
noRefs :: [ItemType] -> [(ItemType, Maybe String)]

-- | Create a list in the pattern of "The __ are refined to the __". Note:
--   Order matters!
refineChain :: NamedIdea c => [(c, Section)] -> Sentence

-- | Sorts a list of <tt>HasSymbols</tt> by <a>Symbol</a>.
sortBySymbol :: HasSymbol a => [a] -> [a]

-- | Sorts a tuple list of <tt>HasSymbols</tt> by first Symbol in the
--   tuple.
sortBySymbolTuple :: HasSymbol a => [(a, b)] -> [(a, b)]

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term -
--   termDefinition</tt>".
tAndDOnly :: Concept s => s -> ItemType

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term (abbreviation) -
--   termDefinition</tt>".
tAndDWAcc :: Concept s => s -> ItemType

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term (symbol) -
--   termDefinition</tt>".
tAndDWSym :: (Concept s, Quantity a) => s -> a -> ItemType

-- | Distributes a list of Sentences by prepending individual Sentences
--   once to an existing list of Sentences.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; zipSentList [S "Hi", S "Hey", S "Hi"] [[S "Hello"], [S "World"], [S "Hello", S "World"]]
--   [[S "Hi", S "Hello"], [S "Hey", S "World"], [S "Hi", S "Hello", S "World"]]
--   </pre>
zipSentList :: [[Sentence]] -> [Sentence] -> [[Sentence]] -> [[Sentence]]

-- | The difference kinds of spaces that may exist. This type holds
--   numerical spaces (such as the set of integers, rationals, etc.), a
--   space for booleans, a space for characters, dimensional spaces
--   (vectors, arrays, etc.), a space for Actors, discrete sets (both for
--   numbers and strings), and a void space.
data Space
Integer :: Space
Rational :: Space
Real :: Space
Natural :: Space
Boolean :: Space
Char :: Space
String :: Space
Vect :: Space -> Space
Set :: Space -> Space
Matrix :: Int -> Int -> Space -> Space
Array :: Space -> Space
Actor :: String -> Space
Function :: NonEmpty Primitive -> Primitive -> Space
Void :: Space

-- | A RealInterval is a subset of <a>Space</a> (as a <a>Space</a>). These
--   come in different flavours. For now, we embed <tt>Expr</tt> for the
--   bounds, but that will change as well.
data RealInterval a b
[Bounded] :: (Inclusive, a) -> (Inclusive, b) -> RealInterval a b
[UpTo] :: (Inclusive, a) -> RealInterval a b
[UpFrom] :: (Inclusive, b) -> RealInterval a b

-- | Inclusive or exclusive bounds.
data Inclusive
Inc :: Inclusive
Exc :: Inclusive

-- | Describes the domain of a <a>Symbol</a> given a topology. Can be
--   bounded or encase all of the domain.
data DomainDesc (tplgy :: RTopology) a b
[BoundedDD] :: Symbol -> RTopology -> a -> b -> DomainDesc 'Discrete a b
[AllDD] :: Symbol -> RTopology -> DomainDesc 'Continuous a b

-- | Topology of a subset of reals.
data RTopology
Continuous :: RTopology
Discrete :: RTopology
type ContinuousDomainDesc a b = DomainDesc 'Continuous a b
type DiscreteDomainDesc a b = DomainDesc 'Discrete a b

-- | Gets the name of an <a>Actor</a>.
getActorName :: Space -> String

-- | Gets the inner <a>Space</a> of a vector or set.
getInnerSpace :: Space -> Space
mkFunction :: [Primitive] -> Primitive -> Space
type Primitive = Space

-- | Decorations on symbols/characters such as hats or Vector
--   representations (determines bolding, italics, etc).
data Decoration

-- | A <a>Symbol</a> is actually going to be a graphical description of
--   what gets rendered as a (unique) symbol. This is actually NOT based on
--   semantics at all, but just a description of how things look.
--   
--   Symbols can be:
--   
--   <ul>
--   <li><tt><a>Variable</a></tt> (string such as "x" that represent a
--   value that can vary)</li>
--   <li><tt><a>Label</a></tt> (strings such as "max" or "target" that
--   represent a single idea)</li>
--   <li><tt><a>Symbol</a></tt> characters (ex. unicode)</li>
--   <li><tt>Decorated</tt> symbols using <a>Atop</a></li>
--   <li><tt>Concatenations</tt> of symbols, including subscripts and
--   superscripts</li>
--   <li><tt><a>Empty</a></tt>! (this is to give this a monoid-like
--   flavour)</li>
--   </ul>
data Symbol

-- | Language of units (how to build them up into a unit symbol). Of the
--   form (<a>Symbol</a> ^ <a>Integer</a>). The <a>Integer</a> may be
--   negative, but should not be zero.
newtype USymb
US :: [(Symbol, Integer)] -> USymb

-- | Stages are what part of the development process we are in. There are
--   currently two: 1) The Equational stage (should be called
--   Specification) 2) The Implemenation stage
--   
--   The point is that information may be rendered differently depending at
--   what stage we're at. Being able to talk about stages lets us also
--   attach different display information.
data Stage
Equational :: Stage
Implementation :: Stage

-- | Helper function for getting a symbol in the Equational Stage.
eqSymb :: HasSymbol q => q -> Symbol

-- | Helper function for getting a symbol in the Implementation Stage.
codeSymb :: HasSymbol q => q -> Symbol

-- | Finds if a <a>Stage</a> symbol is real or Empty. True if real.
hasStageSymbol :: HasSymbol q => q -> Stage -> Bool

-- | Helper for creating a symbol with Unicode in it.
autoStage :: Symbol -> Stage -> Symbol

-- | Helper for creating a symbol with a hat ("^") atop it.
hat :: Symbol -> Symbol

-- | Helper for creating a Vector symbol.
prime :: Symbol -> Symbol

-- | Helper for creating a symbol that depends on the stage.
staged :: Symbol -> Symbol -> Stage -> Symbol

-- | Helper for creating a symbol with a subscript to the right. Arguments:
--   Base symbol, then subscripted symbol.
sub :: Symbol -> Symbol -> Symbol

-- | Helper for a common case of subscript, with a string Arguments: Base
--   symbol, then subscript <a>String</a>.
subStr :: Symbol -> String -> Symbol

-- | Helper for creating a symbol with a superscript to the right.
--   Arguments: Base symbol, then superscripted symbol.
sup :: Symbol -> Symbol -> Symbol

-- | Helper for autoStage that applies unicodeString to all <a>Symbol</a>s
--   with <a>String</a>s.
unicodeConv :: Symbol -> Symbol

-- | Helper for creating a symbol with a superscript on the left side of
--   the symbol. Arguments: Base symbol, then superscripted symbol.
upperLeft :: Symbol -> Symbol -> Symbol

-- | Helper for creating a Vector symbol.
vec :: Symbol -> Symbol

-- | Label smart constructor, requires non-empty labels
label :: String -> Symbol

-- | Variable smart constructor, requires non-empty variables
variable :: String -> Symbol

-- | Commonly used type for QDefinitions containing Literals.
type ConstQDef = QDefinition Literal

-- | Commonly used type for QDefinitions containing Exprs.
type SimpleQDef = QDefinition Expr

-- | Commonly used type for QDefinitions containing ModelExprs.
type ModelQDef = QDefinition ModelExpr

-- | Commonly used type for polymorphic Exprs.
type PExpr = forall r. (ExprC r, LiteralC r) => r

-- | We can only type check <a>UID</a>s within a type context relating
--   <a>UID</a>s to types since they don't carry any type information.
type TypingContext t = Map UID t
type TypeError = String

-- | Look for a known type of a specific <a>UID</a>.
inferFromContext :: TypingContext t -> UID -> Either TypeError t

-- | Build a bidirectional type checker for your expression language, e,
--   with respect to a specific type universe, t.
class (Eq t, Show t) => Typed e t

-- | Given a typing context and an expression, infer a unique type or
--   explain what went awry.
infer :: Typed e t => TypingContext t -> e -> Either TypeError t

-- | Given a typing context, an expression, and an expected type, check if
--   the expression can satisfy the expectation.
check :: Typed e t => TypingContext t -> e -> t -> Either TypeError t

-- | For all containers, c, which contain typed expressions, e, against a
--   specific type universe, t, expose all expressions and relations that
--   need to be type-checked.
class Typed e t => RequiresChecking c e t

-- | All things that need type checking.
requiredChecks :: RequiresChecking c e t => c -> [(e, t)]

-- | A temporary, hacky, indentation function. It should be removed when we
--   switch to using something else for error messages, which can be later
--   formatted nicely.
temporaryIndent :: String -> String -> String
