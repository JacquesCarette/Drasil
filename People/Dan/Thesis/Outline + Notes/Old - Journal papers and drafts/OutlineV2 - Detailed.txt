JC: I will put my comments inline below, but with all lines prefixed with JC.
DS: Responses to comments/questions will be prefixed with DS.

Title: 
"Automate your problems away with Drasil - Developing software without CTRL-C/CTRL-V"
variant - "Automate your problems away with Drasil - Developing software without copy/paste"
JC: I'm not so keen on either of those titles. But that's fine, we can adjust that later.
JC: Though it does communicate your spin on the story, and I'm less comfortable with that.

Main idea Notes (outline after):
  - Software dev has problems including
    - duplication + inconsistency + unnecessary re-development
      - duplication
        - We really only care about manual duplication, automated duplication
            is not common enough(?) and (when done properly) not an issue.
        - Manual duplication begets problems with:
          - inconsistency - common enough, we want to fix that
          - traceability - inter- and intra-artifact issues are common
JC: So that was DEFINITELY our story for ~4 years. But your 'forced reality' comments below are
JC: very apt, and do reflect our newer story. In other words, I think the deeper reality is about
JC: *development of all artifacts by hand*. Duplication is indeed 'forced', because different
JC: artifacts are different views on the same thing.
JC: Hand-development is error prone, and does indeed lead to inconsistency and traceability problems.
      - inconsistency
        - really big problem in certified software (inconsistency costs money and time)
          - Why shouldn't we hold all software projects to the same standard?
            - Obviously, costs.
        - common enough in many software projects
        - makes maintenance/expansion efforts much more difficult
JC: I continue to be wary of talking about 'certified software' too earlier / too prominently.
JC: Otherwise agree.
DS: Completely agree - I want to include cert. software as an example, but am trying
DS: not to focus on it too heavily.
      - re-development
        - We want to see more software re-use, but the reality is its often
          faster (or cheaper) to re-develop a particular tool, algorithm, etc.
          rather than find an existing project to adapt 
            (re-word previous, it's not quite what I want to say)
JC: Good point. Leads to justification for 'knowledge capture' via current artifacts of SE
JC: perhaps not being the 'right' ones. Some libraries (and frameworks) have had huge success
JC: regarding re-use, while others have flopped completely. No obvious trend.
        - Significant efforts can be made to develop a software variant that is very 
          similar to an existing project
          - These variants are members of the same software family, typically with
            minor changes
JC: need to be more concrete. The linux kernel here is an interesting example - it is a huge
JC: software family. No one really knows which of the variants actually work!
DS: That's a great example.
            - Can happen when it seems easier to create a new variant as a stand-alone
              rather than attempt to update old code and docs
            - Also influenced by lack of documentation around existing software,
              confusing APIs, lack of subject-matter-experts, etc.
JC: Do you have citations to back that up? Proper science needs its citations.
DS: Yes, just need to re-find them.

  - A look at why duplication is a 'forced reality'
    - Software artifacts are views of the same information
JC: Right. The telling of the story, in my mind, needs to show this concretely.
    - Views that don't replicate (or reference) the core knowledge to some extent
      imply inconsistency between artifacts
JC: That's a Drasil-centric view of things (naturally). But this represents looking at things
JC: 'backwards' [this is a new realization, that came with the forced reality]. The very existence
JC: of the shared information is the source of the 'core knowledge' that we want to dig out.
    - Traceability only matters when there is lots of duplication
JC: strongly agreed.
      - Low duplication = loose threads of knowledge
        - We expect a tightly woven pattern with neat ends
    - Manually maintaining consistency across knowledge duplication is complex
      and tedious
JC: right!
  
  - Drasil is a framework we've developed to tackle these problems through a 
    knowledge-capture (KC) focused approach to software development
    - What is it? A framework for generating *ALL* software artifacts (in their
    desired format) from a single source using transformations and projections.
      - Core knowledge (not system-specific) is reusable inter- and intra-project
      - No manual duplication
      - Consistent by construction
      - Fully traceable for certification, maintenance, or upgrades
JC: I would remove that last point, or at least tone it down.
DS: Will tone it down
JC: I agree that that is one very plausible description of "What is it?". Is it the one we want?
DS: I think it's the one that best suits my narrative for the time being.

    - Leveraged our understanding of generative software & software development
    principles and practices in dev
    - Development of Drasil has been practical and example-driven
    - Guiding principle: If software artifacts are views of the same information,
    we should be able to abstract out the core knowledge, then generate the views 
    as necessary
      - Remove the need for manual duplication
      - Use transformations to format knowledge appropriately
        - Ex. Code-views vs. document-views of calculations
        look very different, even across similar languages, but say the same thing
          - Figure: A calculation in C# code, python code, LaTeX, and HTML
      - Ensure consistency & traceability
JC: agreed on all points above (leveraged ... here).

    - "Recipes" used to create our views, can be thought of as "little programs"
    that assemble our artifacts.
      - Based off of document templates, and similar to code templating, but 
      much broader configuration scope(or something?)
    - Includes KC mechanisms for creating a 'living database' of common information 
JC: not sure about mentioning KC *here*. Agree that it is part of our ideas.
DS: KC was just being used as a descriptor, doesn't need to be here.
      - Currently hand-curated
      - Expands as needed, all projects share it
      - Very low-level, system-specific information stored elsewhere to avoid pollution
        - Easy to move around if determined to be 'general-enough' for the common
        knowledge base (KB)
    - Captured knowledge acts as a uniform source for artifact generation
    - Structure of a project in Drasil can be broken down (generally) as:
      [Core knowledge], [Specific knowledge], & [Recipes]
JC: on Recipes and 'living database': this is all true, and important. But I am not quite
JC: "feeling it" as far as how/when to say this.
DS: This is where I'm explaining the key parts of our design/impl.
DS: It's as good a place as any to introduce the concepts. We can get into more
DS: detail later on.
  
  - What Drasil isn't
    - Not the be-all, end-all of software development
    - Only useful (and useable) in well-understood domains
      - We need to know how to capture and structure knowledge effectively
        - Ex. Science/math
    - One tool with a specific set of possible outputs and limited scope
    - Will not replace human developers, only help remove some of the tedium of
      following good software development practices
    - Not complete - Dev is still in progress
JC: Right. We don't want to over-emphasize, but do want to say.
  
  - Our examples - SWHS, GlassBR, SSP, Gamephys, Tiny, and NoPCM
    - Drove our practical approach
    - All re-developed to follow the SmithEtAl artifact templates using modern SE approaches
      - Gives us consistent views
        - Knowledge is easier to extract
        - We know what we want the generator to create from our Recipes
        - Gives a base structure to our recipes
JC: Right.
    - SWHS and NoPCM are software family members
      - Model solar water heating system with and without phase change material (PCM)
    - GlassBR
      - Models whether glass panes will break due to force of explosions
    - SSP
      - Models slope stability
    - Gamephys
      - Reduced-scope section of the Chipmunk2D game physics engine
      - Simulates rigid-body physics
    - Tiny
      - Toy example taken from a model of a fuel-pin in a nuclear reactor
      - Used for proof of concept mainly, and as a test case to ensure 
      updates to Drasil don't create any unwanted behaviours
    - Examples share common baseline math/science knowledge
      - Gives us a starting point for the common KB
JC: Right.

  - Analyzing artifacts and extracting commonalities
    - Part of our practical approach
    - Introduce exercise we did way back on finding out what each section of 
    each artifact is really saying
      - Each section has its own purpose and we need to identify it
      - What is boilerplate text (common to all artifacts of a given type), 
      what is contextual text, and what is knowledge we really care about?
      - Can we extract the knowledge and abstract the rest?
JC: Yes, but this kind of feels like it should be part of the n^th round of exercise to pull
JC: out knowledge from the artifacts. Various things already mentioned above were parts of
JC: previous rounds.  Since this 'knowledge extraction' is so important to us, we need to work
JC: hard at organizing how we extracted it. We should be honest and describe it as a rational
JC: reconstruction of the actual process.
    - Using the SmithEtAl SRS as our example for each of the case studies
    mentioned above, what do we find?
      - SRS is separated into distinct sections with related subsections within
      - Each section and subsection has a specific purpose
        - Table: SRS Sections & subsections and their purposes
      - The exact text differs, but the core idea being conveyed is the same
        - System-specific knowledge will obviously differ.
        - Other text may look different, but is either saying the same thing or 
        adding something that is not relevant to the other examples
          - Example: Pick one section from two of the SRS (SWHS and GlassBR?) and explain
JC: Good.

          
---------------------
OUTLINE
---------------------

-- The 'Main Idea Notes' above could really be a huge part of the introduction

JC: And I'm really not hapy with the outline. I think a lot of the notes above are great, and
JC: capture lots of good things about Drasil.  The outline below doesn't strike me as telling
JC: any kind of story!
DS: Understandable, it was by no means ready for review.

JC: I think you should focus on first figuring out
JC: 1. what are the take home points?
DS:   - All artifacts important, even though they say a lot of the same things.
        - Core knowledge is most important to capture
        - Everything else is derived from there as a view for a specific audience
      - Change dev practice 
        - stop reinventing the wheel (manual duplication/re-dev)
        - start using/modifying wheel manufacturing lines (generate all the things)

JC: 2. what is the problem we are solving?
DS:   - Inconsistency in software artifacts
      - Unnecessary re-development 
      - Difficulty in creating new software family members

JC: 3. why does our solution make sense?
DS:   - Keeps artifacts consistent
      - Promotes re-use of whole projects and/or core components where applicable
      - Simplifies software family member generation

JC: 4. how to lead the reader from what they know, to the problem, to our solution.
DS: This is the general "flow" of ideas from reader -> problem -> intro of our solution, essentially 
  - What has the reader experienced?
  - Why did they experience that?
  - Where can improvements be made?
  - How do we make those improvements?
DS: After we've introduced the key ideas, then the rest of the paper will just be
DS: explaining in more depth, in likely the same order as originally introduced.
  
DS: Attempt at explaining how to structure it is below, but this needs tuning as well.
-- Begin --
- Common experiences in Sfwr dev. (What we've observed and/or know to be common)
  - Not always easy to find a good solution to the problem you're tackling
  - Can be easier (and faster) to roll-your-own even if one exists
    - Could be software exists, but is un- or badly-documented
      - [Discuss inconsistency and lack of traceability particularly w/ respect to code and APIs]
    - OR Locked-down software lacking a req'd feature
      - Wasn't in scope for the devs at the time
    - OR Simple problem that's quick to solve
      - Not worth investing time in finding an existing solution
- Why is the above common?
  - Short answer - costs.
  - Longer answer:
    - Documentation
      - Not often incentivized, except in specific areas (ie. cert sfwr)
      - Tedious or complex to maintain, lots of requisite hand-duplication between artifacts
      - Sometimes all you get is comments in source code (open-source) or the API,
        or a user guide (not necessarily targeted to devs)
    - Software families are not developed from the get-go
      - Costly and out of scope
      - Develop the required software at the time, add features when deemed worthwhile
        - Over time other family members will be developed as needs change
        - Not always the same devs/teams working on it.
        - Want to upgrade existing software when possible
          - Easiest to occur with open-source projects, but can lead to many branched projects w/ different feature sets
            - Linux as an example
        - When impossible to upgrade, need to roll new software family member with similar features
- What can we do about it?
  - Make maintaining documentation easier
  - Emphasize re-use in development
  - Make creating software family members easier
- How?
  - Let's be practical
  - Need to understand more about artifacts first.
    - Look at case studies (See "Our examples - SWHS, GlassBR, SSP, Gamephys, Tiny, and NoPCM" above)
    - Analyze & generalize (see "Analyzing artifacts and extracting commonalities" above)
  - Don't sweat the small stuff
    - Generating boilerplate
  - Figure out what's relevant
    - Capture the core knowledge
    - Generate the context-sensitive stuff
      - Core transformations/projections for views
      - Context-sensitive recipe pieces
  - Put it all together
    - Drasil
-- END --  

Section-by-Section (roadmap + breakdown) to follow.  
