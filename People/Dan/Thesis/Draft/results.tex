\chapter{Results}
\label{c:results}

In this chapter we discuss our observations following the reimplementation 
of our case studies using Drasil. Content here is primarily illustrative: 
concrete examples, issue identifiers, and sample artifacts that document how the
single-source approach affected consistency, traceability, and
reimplementation effort. Formal, controlled experiments are future work
(see Chapter~\ref{c:future}). For interpretation and implications of these
observations, see Chapter~\ref{c:discussion}.

\section{Value in the Mundane}

This section highlights routine, practical benefits that emerged from the
reimplementations. Each subsection focuses on a specific, often-overlooked
advantage \textemdash{} consistency, traceability, and reproducibility 
\textemdash{} and shows how these ``mundane" improvements materially reduce
maintenance effort and increase confidence in generated artifacts.

\subsection{Consistency by Construction}
\label{sec:res_cons}
Drasil's single-source knowledge representation produced artifacts that are
consistent by construction. Small, localized edits to domain knowledge or
recipes propagated deterministically to all generated outputs (documentation
and code). During reimplementations, this property reduced the number of
manual synchronization tasks normally required when maintaining separate
artifacts. In practice, consistency by construction meant that corrections
made in the knowledge base appeared immediately and uniformly across the SRS,
reference tables, and generated code after regeneration. 

Additionally, all domain knowledge must be explicitly encoded, which prevents
dangling references or undefined symbols as observed in a number of 
early passes over the original case study documentation (for example, issue 
\#348 in the issue tracker which will be discussed in more detail in 
Section~\ref{sec:quality} and Section~\ref{sec:dis_reproducibility}).

\subsection{Traceability and Maintainability}
Every generated element (formulae, symbols, tables, code identifiers) can be
traced back to a named knowledge chunk or recipe. The generation pipeline
produces traceability matrices and reference-material tables as part of normal
output, enabling explicit provenance for items that are typically
undocumented. This traceability materially reduced the cognitive effort
required to locate the origin of a definition or relation during maintenance
tasks and refactoring: it was trivial to identify the source to edit rather than
hunting through multiple artifacts.

For example, in the GlassBR case study (see issue~\#349), a unit conversion
was embedded implicitly in the original documentation. With Drasil, it was
straightforward to trace the generated formula back to its originating chunk,
facilitating a single-point correction to change the implicit conversion into 
an explicit one that propagated to all artifacts after regeneration, 
demonstrating the practical benefits of strong traceability and reducing the 
burden of maintenance.

\subsection{Reproducibility and Determinism}
Artifact generation in Drasil was fully deterministic: repeated generation runs
from the same knowledge base and recipe set produced byte-for-byte equivalent
outputs for generated softifacts as compared to the then-current stable 
versions. These outputs were confirmed using a diff tool that ran as part of an 
automated regression test suite.

Furthermore, repeatability checks executed during the case study 
reimplementations confirmed that regenerating artifacts after 
environment-consistent builds did not introduce nondeterministic differences, 
supporting reproducibility guarantees that are important for scientific 
software.

\section{Observations: Case Studies and Reimplementations}
We reimplemented each of our case studies using Drasil and recorded
measurable outcomes for generated artifacts and the knowledge source that
produced them.

For the GlassBR case study, the Drasil implementation generated a multi-
page SRS (44 pages in the final PDF) and produced working implementations
in multiple target languages. The complete SRS recipe for GlassBR is
contained in a single source file of under 370 lines of Haskell
(including comments and imports). This line count refers only to the
GlassBR-specific recipe and does not include the shared base knowledge
(units, symbols, common chunks, and generic recipes) that are stored
separately in the global knowledge base and are reused across case studies. 

\begin{table}[h]
\centering
\caption{Summary statistics for Drasil case study SRS reimplementations}
\label{tab:case_study_stats}
\begin{tabular}{|l|c|c|}
\hline
\textbf{\rule{0pt}{3ex}Case Study} & \textbf{SRS Pages} & 
\textbf{Recipe LOC$^1$} \\
\hline
\rule{0pt}{3ex}GlassBR & 44 & 370 \\
SWHS    & 50 & 560$^2$ \\
NoPCM   & 32 & 316 \\
SSP     & 84 & 380 \\
Projectile & 31 & 209 \\
GamePhysics & 46 & 424 \\
\hline
\end{tabular}
\begin{flushleft}
% I couldn't get regular footnotes working in a tabular env, so this is a 
% workaround
\footnotesize
$^1$ Including comments and import statements

$^2$ This is an outlier due to excessive use of comments. Without comments it 
would be 386 lines.
\end{flushleft}
\end{table}

Comparable results were observed for other reimplemented case studies:
each system produced a multi-page SRS and a modest-sized recipe or set of
recipes (tens to a few hundred lines) that captured the system-specific
knowledge. See Table~\ref{tab:case_study_stats} for a summary. Generated
code for each system followed the same pattern: language-agnostic knowledge
encoded as chunks and recipes was emitted to multiple target languages with
consistent identifiers and traceability annotations.

Generated code and documentation remained consistent after edits to the
knowledge base, with regeneration producing updated artifacts across all
targets.

\subsection{Quality and Bug Detectability}
\label{sec:quality}
Because all artifacts are derived from the same knowledge, a defect in the
knowledge base manifested consistently across every generated artifact. This
property made defects more visible (``pervasive bugs"), which in turn aided
discovery and correction. During reimplementations, categories of problems
that were revealed included inconsistent symbol naming, implicit numeric
constants, and unstated domain assumptions. Fixing those issues at the
knowledge level eliminated their occurrences across documentation and code
simultaneously.

An instructive, concrete example is issue~\#348 from the issue tracker.
In the original \sp{} artifacts several closely related symbols (for shear
stress and associated forces) were used inconsistently across sections and
tables. When the \sp{} content was encoded as Drasil chunks these 
inconsistencies became immediately visible: the same semantic item was 
projected with conflicting identifiers, and cross-references did not align. 
Correcting the underlying chunk in the knowledge base removed the 
inconsistencies from all generated artifacts (SRS and code) after regeneration. 
During the investigation of the same issue, it was also discovered that one of 
the terms had an implicit unit vector ``into the page'' that was not documented 
in the original artifacts. Encoding the unit vector explicitly in Drasil made 
that assumption visible, allowing it to be documented properly in the generated 
SRS and ensuring that the generated code reflected the correct physical 
interpretation.

A similar example arose in the GlassBR case study (see issue \#349), where an 
implicit division by 1000 for unit conversion was embedded in the original 
documentation. Drasil's explicit chunk encoding surfaced this hidden 
assumption, enabling a single-point correction that propagated to all generated 
artifacts. Other similar issues surfaced during reimplementation, each 
illustrating how centralized knowledge capture increases error visibility and 
simplifies maintenance.

\subsection{Design for Change and Software Families}
\label{sec:design_change}
The single-source approach enabled rapid generation of software-family
variants. Where artifacts differed only by parameterization or small domain
choices (for example, \sw{} with PCM vs \np{} variants), encoding those choices 
in the knowledge base allowed whole-family updates by editing a small set of 
chunks. This capability materially reduced the effort to produce consistent 
variants of the same artifact family.

\begin{table}[h]
\centering
\caption{Key differences between SWHS and NoPCM Drasil implementations}
\label{tab:swhs_nopcm}
\begin{tabular}{|p{3.5cm}|c|c|p{6cm}|}
\hline
\textbf{\rule{0pt}{3ex}Chunk/Concept} & \textbf{SWHS} & \textbf{NoPCM} & 
\textbf{Notes} \\
\hline
\rule{0pt}{3ex}PCM properties         & Yes           & No             & Only 
in SWHS \\
Latent heat            & Yes           & No             & Only in SWHS \\
Sensible heat          & Yes           & Yes            & Present in both \\
Energy balance         & Yes           & Yes            & PCM terms omitted in 
NoPCM \\
PCM input parameters   & Yes           & No             & Only in SWHS \\
PCM assumptions        & Yes           & No             & Only in SWHS \\
Tank/water properties  & Yes           & Yes            & Shared \\
\rule{0pt}{3ex}Recipes                 & Modified       & Modified           & 
NoPCM 
recipe omits PCM-related content \\
\hline
\end{tabular}
\end{table}

For example, producing the NoPCM variant from SWHS required removing all 
reference to PCM by excluding the PCM-related chunks. The majority of the 
knowledge base and recipes were reused without change, demonstrating the 
efficiency of the single-source approach for software families. Table~\ref{tab:swhs_nopcm} summarizes the key differences between the SWHS and NoPCM Drasil
implementations, highlighting which chunks and concepts were unique to each
variant and which were shared.

\section{Usability and Adoption}
From the reimplementation work it became clear that Drasil's expressiveness
comes with an onboarding cost. Contributors familiar with the codebase could
encode and modify domain knowledge effectively; new users required a
nontrivial ramp-up period of up to two weeks of mentoring to understand the 
chunk combinators and recipe patterns. Common challenges
included understanding the how to build new chunks, particularly while 
referencing other chunks, and how to find existing chunks of the 
appropriate type in the knowledge base. 

Feedback collected during onboarding, along with the observations listed above, 
indicated that improved search tools and documentation would significantly 
reduce ramp-up time. Nevertheless, undergraduate contributors and short-term 
students were able to make meaningful contributions after initial mentoring.


\section{Summary and Takeaways}
The combined results from the case studies show that the primary benefits of
the Drasil approach are increased consistency, strong provenance for
generated artifacts, and deterministic reproducibility. These benefits
manifested in lower ongoing synchronization effort, higher visibility of
domain assumptions and defects, and faster family-wide changes when those
domain choices were encoded explicitly. The observations collected
during the reimplementations supports these claims while also documenting the
practical cost of initial knowledge capture and onboarding.

