\chapter{External libraries}
\label{cha_extlib}
External libraries are from an outside source; they do not originate from the source project. Our current interest is for libraries that are used to support solving scientific problems. Most external libraries are language-dependent, and the Drasil framework can generate five different languages: Python, Java, C\texttt{++}, C\#, and Swift. Among those five languages, four programming languages have ODE libraries for solving ODEs and we did not find a suitable library for Swift. In Python, the Scipy library~\citep{scipy} is a well-known scientific library for solving scientific problems, including support for solving ODEs. In Java, a library called Apache Commons Maths (ACM)~\citep{apache} provides a supplementary library for solving mathematical and statistical problems not available in the Java programming language. ACM includes support to solve ODEs. Two less known libraries to solve ODEs are ODEINT Library~\citep{odeint} in C\texttt{++} and the OSLO Library~\citep{oslo} in C\#. There could be multiple external libraries to solve the ODE in one language, but we only find one external library for each selected library. 

We believe it is beneficial to conduct a commonalty analysis for all four selected libraries because the Drasil framework wants to generate a program family. A Program families~\citep{dp1976} is a sets of programs whose common properties are so extensive that it is advantageous to study the common properties of the programs before analyzing individual members. In this case, we may want to instruct the Code Generator to create programs that solve ODEs in multiple algorithms or allow other output types to interact with other modules. Those programs vary in application demand and different algorithms, so we can take advantage of developing them as a family~\citep{ss2004}.

The four selected libraries have some commonalities and variabilities. Firstly, they all provide a numerical solution for a system of first-order ODEs. Each library can output a value of the dependent variable at a specific time, and we can collect those values in a time range. Secondly, they all provide different algorithms for solving ODEs numerically, and we will conduct a rough commonality analysis of available algorithms. A completed commonality analysis would be too time-consuming and out of the scope of our study. Lastly, Scipy and OSLO libraries have the potential to output an ODE in different types. This discovery will provide options for the Drasil framework to solve an ODE by generating a library rather than a standalone executable program. 

% Besides commonalities and variabilities, the Drasil team has to learn how to manage external libraries in general. The four selected external libraries are just examples, and there are many useful external libraries out there. The team will likely encounter difficulties of handling external libraries, such as how to handle dependencies in this Drasil framework. This research will start surface some related challenges.

This chapter will discuss topics related to the commonalities and variabilities of four libraries, including numerical solutions, algorithms options and outputting an ODE in different types. 

% Lastly, we will discuss how we handle dependencies in the framework.

\section{Numerical Solutions}
We use algorithms to make approximations for mathematical equations and create numerical solutions. All numerical solutions are approximations, and some numerical solutions that utilize better algorithms can produce a better result than others. All selected libraries provide numerical solutions for a system of first-order ODE as an IVP (initial value problem). The IVP requires an initial condition that specifies the function's value at the start point, contrasting with BVP (boundary value problem). In a BVP, we apply boundary conditions instead of initial condition. In this research, we will solve each scientific problem as an IVP. Let's see how to solve a system of first-order ODE with an example. 

The following example is derived from the Example~\ref{eq_odeexmaple}. We transform the second-order ODE into a system of first-order ODE. We replaced $y(t)$ with $x_{1}(t)$, and $y'(t)$ with $x_{2}(t)$. The details on how to convert a higher-order linear ODE to a system of first-order ODE shows in Section~\ref{se_hightofirst}. In here, we want to show an example on how we encode a system of first-order ODE in Drasil.

\begin{flalign} \label{ex_firstorderode}
& x_{1}'(t) = x_{2}(t) \\ \nonumber
& x_{2}'(t) = -(1 + K_{d}) \cdot x_{2}(t) - (20 + K_{p}) \cdot x_{1}(t) + r_{t} \cdot K_{p} 
\end{flalign}

In Example~\ref{ex_firstorderode}, there are two dependent variables: $x_1$ and $x_2$. Both $x_1(t)$ and $x_2(t)$ are functions of the independent variable, in this case time. The $x_1$ is the process variable, and the $x_2$ is the rate of change of $x_1$. The $x_1'$(t) is the first directive of the function $x_1(t)$ respect time, and the $x_2'$(t) is the first derivative of the function $x_2$(t) respect time. The $K_d$ , $K_p$, and $r_t$ are constant variables, and they remain the same meaning in Example~\ref{eq_odeexmaple} and example~\ref{ex_firstorderode}. We can encode the Example~\ref{ex_firstorderode} in all four libraries.

In Python Scipy library, we can write the example as the following code:
\begin{python1}
def f(t, y_t):
    return [y_t[1], -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p]
\end{python1}
In this example, the y\_t is a list of dependent variables. The index 0 of y\_t is the dependent variable $x_1$, and the index 1 of y\_t is the dependent variable $x_2$. The y\_t[1] represent the first equation $x_{1}'(t) = x_{2}(t)$ in Example~\ref{ex_firstorderode}. The -(1.0 + K\_d) * y\_t[1] + -(20.0 + K\_p) * y\_t[0] + r\_t * K\_p represents the second equation, $x_{2}'(t) = -(1 + K_{d}) \cdot x_{2}(t) - (20 + K_{p}) \cdot x_{1}(t) + r_{t} \cdot K_{p}$, in Example~\ref{ex_firstorderode}. 

In Java ACM library, we can write the example as the following code:
\begin{java1}
public void computeDeriv(double t, double[] y_t, double[] dy_t) {
    dy_t[0] = y_t[1];
    dy_t[1] = -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p;
}
\end{java1}

In C\texttt{++} ODEINT library, we can write the example as the following code:
\begin{cplusplus1}
void ODE::operator()(vector<double> y_t, vector<double> &dy_t, double t) {
    dy_t.at(0) = y_t.at(1);
    dy_t.at(1) = -(1.0 + K_d) * y_t.at(1) + -(20.0 + K_p) * y_t.at(0) + r_t * K_p;
}	
\end{cplusplus1}

In C\# OSLO library, we can write the example as the following code:
\begin{csharp1}
Func<double, Vector, Vector> f = (t, y_t_vec) => {
    return new Vector(y_t_vec[1], -(1.0 + K_d) * y_t_vec[1] + -(20.0 + K_p) * y_t_vec[0] + r_t * K_p);
};
\end{csharp1}

Once we capture the information of the system of ODE, we have to give an initial condition for solving an ODE as an IVP. To solve the Example~\ref{ex_firstorderode}, we must provide the initial value for both $x_1$ and $x_2$. Overall, an ODE is a simulation, and it simulates a function of time. Before we start the simulation, other configurations need to be specified, including the start time, end time, and time step between each iteration. We can also provide values for each library's absolute and relative tolerance. Those two tolerances control the accuracy of the solution. As we mentioned before, all numerical solutions are approximations. High tolerances produces less accurate solutions, and smaller tolerances produce more accurate solutions. Lastly, we have to collect the numerical output for each iteration. The full details on how each library solves the Example~\ref{ex_firstorderode} are shown in Appendix~\ref{numsol}, Code~\ref{code_csharposlo}, and Code~\ref{code_pythonscipy}.

\section{Algorithm Options}
We can solve an ODE with many algorithms. The four selected libraries each provide many algorithms. We roughly classify available algorithms into four categories based on the type of algorithm they use. They are a family of Adams methods, a family of backward differentiation formula methods (BDF), a family of Runge-Kutta (RK) methods, and a ``catch all'' category of other methods. The commonality analysis we provide on available algorithms is a starting point. It is an incomplete approximation. Getting a complete commonality analysis will require help from domain experts in ODEs. Although the commonality is incomplete, the team still benefits from the current analysis. Not only can a future student quickly access information on which algorithm is available in each language, but also the analysis reminds us that we can increase the consistency of artifacts by providing one-to-one mapping for each algorithm in the four libraries. For example, if a user explicitly chooses a family of Adams methods as the targeted algorithm, all available libraries should use a family of Adams methods to solve the ODE. Unfortunately, not all libraries provide a family of Adams methods. Table~\ref{tab_algoexlib} shows the availability of a family of algorithms in each library. The full details of each library's algorithm availability are shown in Appendix~\ref{alg_externallib}.

\begin{sidewaystable}
\begin{adjustbox}{width=\columnwidth,center}
\begin{tabular}{p{0.18\textwidth} | p{0.22\textwidth} p{0.22\textwidth} p{0.29\textwidth} p{0.25\textwidth}}\hline
    \backslashbox{Algorithm}{Library}
    &\textbf{Scipy-Python}&\textbf{ACM-Java}&\textbf{ODEINT-C\texttt{++}}&\textbf{OSLO-C\#}\\
    \toprule
    Family of Adams & 
        \begin{itemize}[wide]
        \item Implicit Adams
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Adams Bashforth
        \item Adams Moulton
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Adams Bashforth Moulton
        \end{itemize} &\\ \hline
    Family of BDF & 
        \begin{itemize}[wide]
        \item BDF
        \end{itemize} &&& 
        \begin{itemize}[wide]
        \item Gearâ€™s BDF
        \end{itemize} \\ \hline
    Family of RK & 
        \begin{itemize}[wide]
        \item Dormand Prince (4)5 
        \item Dormand Prince 8(5,3) 
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Explicit Euler
        \item 2ed order
        \item 4th order
        \item Gill fourth order
        \item 3/8 fourth order
        \item Luther sixth order
        \item Higham and Hall 5(4)
        \item Dormand Prince 5(4) 
        \item Dormand Prince 8(5,3) 
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Explicit Euler
        \item Implicit Euler
        \item Symplectic Euler
        \item 4th order
        \item Dormand Prince 5
        \item Fehlberg 78
        \item Controlled Error Stepper
        \item Dense Output Stepper
        \item Rosenbrock 4
        \item Symplectic RKN McLachlan 6
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Dormand Prince RK547M
        \end{itemize} \\ \hline
    Others && 
        \begin{itemize}[wide]
        \item Gragg Bulirsch Stoer 
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Gragg Bulirsch Stoer 
        \end{itemize} &\\
    \bottomrule	
\end{tabular}
\end{adjustbox}
\caption{Algorithms support in external libraries}	
\label{tab_algoexlib}
\end{sidewaystable}

% There are some improvements that the Drasil team can do to make the ODE solution better. For example, we found some algorithms use a fixed step size for calculating numerical solutions, and others use an adaptive step size. We add the step size with the current time value to calculate the next value of dependent variables. A fixed step size means the step size is the same in each iteration. An adaptive step size means the step size is not always the same and could change based on other factors. In Table~\ref{tab_algacm}, the ACM library divides algorithms into one group that uses a fixed step and others that uses an adaptive step. This discovery can further influence the design choice of solving ODE numerically in the Drasil framework. Currently, Drasil treats all step sizes as a fixed value, and it would be ideal to allow the step size to be either fixed or adaptive in future.

\section{Output an ODE}
In the Drasil framework, we can generate modularized software. A modularized software will contain a controller module, an input module, a calculation module, and an output module. The controller module contains the main function, the start of the software. The input module handles all input parameters and constraints. We manually create a txt file that contains all input information. The input module will read this file and covert the information to its environment. The calculation module contains all the logic for solving the scientific problem. For example, in Double Pendulum, the calculation module contains all functions of calculating the numerical solution. Lastly, the output module will output the solution. In all ODE case studies, the output module will write the return of the calculation module as a string in a txt file. 

With each module interacting with others, we would like to study the output of the calculation module in ODE case studies. Currently, the calculation module will output a finite sequence of real numbers, $\mathbb{R}^i$. The $i$ is a natural number which depends on the start time, end time, and time step. A finite sequence of real numbers only captures a partial solution, and we ideally want to capture a complete solution. Therefore, we would like to explore options to output a different type for the calculation module. 

We have the following specification for the calculation module:

\begin{table}[ht]
\centering
\begin{tabular}{p{0.2\textwidth} | p{0.3\textwidth} | p{0.3\textwidth}} \hline
    \textbf{Module Name}&\textbf{Input}&\textbf{Output}\\
    \toprule
    Calculations & $\mathbb{R}^n$ & $\mathbb{R}^i$ \\
    \bottomrule	
\end{tabular}	
\caption{Specification for Calculations Module Return a Finite Sequence}	
\label{tab_srsforcal}
\end{table}
The $n$ is length of the sequence. The $\mathbb{R}^n$ is input values for calculating the ODE. In our study case, after running the generated program, it will create a file which contain the numerical solution of the ODE from the start time to end time. The numerical solution be written as a stream of real number in a txt file.

Most selected external libraries only provide numerical solutions in the form of a finite sequence of real numbers, $\mathbb{R}^i$. The C\# OSLO library not only supports outputting a finite sequence of real numbers but also an infinite sequence of real numbers. In C\# OSLO library, we can get an infinite numerical solution that contains all possible values of the dependent variable over time ($\mathbb{R}^j$). The $j$ is the length of the sequence, and it is a natural number. The function \verb|Ode.RK547M| returns an endless enumerable sequence of solution points. If we are interested in a partial solution ($\mathbb{R}^i$), we can filter it with parameters such as start time, end time, and time interval. Code~\ref{code_csharposlo} shows the full details of how to solve Example~\ref{ex_firstorderode} in the OSLO library.
\begin{listing}[ht]
\begin{csharp1}
public static List<double> func_y_t(double K_d, double K_p, double r_t, double t_sim, double t_step) {
    List<double> y_t;
    Func<double, Vector, Vector> f = (t, y_t_vec) => {
        return new Vector(y_t_vec[1], -(1.0 + K_d) * y_t_vec[1] + -(20.0 + K_p) * y_t_vec[0] + r_t * K_p);
    };
    Options opts = new Options();
    opts.AbsoluteTolerance = Constants.AbsTol;
    opts.RelativeTolerance = Constants.RelTol;
    
    Vector initv = new Vector(new double[] {0.0, 0.0});
    IEnumerable<SolPoint> sol = Ode.RK547M(0.0, initv, f, opts);
    IEnumerable<SolPoint> points = sol.SolveFromToStep(0.0, t_sim, t_step);
    y_t = new List<double> {};
    foreach (SolPoint sp in points) {
        y_t.Add(sp.X[0]);
    }
    
    return y_t;
}
\end{csharp1}
\captionof{listing}{Source code of solving PDController in OSLO}
\label{code_csharposlo}
\end{listing}

In Code~\ref{code_csharposlo}, between line 3 and line 4, we encode the ODE of the Example~\ref{ex_firstorderode} in a \verb|Vector|. Between line 7 and line 8, we set the absolute and relative tolerance in the \verb|Options| class. In line 10, we initialize initial values. Next, in line 11, we use \verb|Ode.RK547M| to get an endless sequence of real numbers, $\mathbb{R}^j$. In line 12, we use \verb|SolveFromToStep| to get a partial solution ($\mathbb{R}^i$) base on the start time, the final time, and the time step. Last, between line 13 and line 15, we run a loop to collect the process variable $x_1$. With the workflow we described above, the \verb|Ode.RK547M(0.0, initv, f, opts)| return an object has richer data, because {}$\mathbb{R}^i \subset \mathbb{R}^j$. Instead of returning $\mathbb{R}^i$, we can opt in returning the $\mathbb{R}^j$. Here is the new specification.
\begin{table}[ht]
\centering
\begin{tabular}{p{0.2\textwidth} | p{0.3\textwidth} | p{0.3\textwidth}} \hline
    \textbf{Module Name}&\textbf{Input}&\textbf{Output}\\
    \toprule
    Calculations & $\mathbb{R}^n$ & $\mathbb{R}^j$ \\
    \bottomrule	
\end{tabular}	
\caption{Specification for Calculations Module Return an Infinite Sequence}	
\label{tab_srsforcal}
\end{table}
The implementation of this specification is not completed, but it provides analysis on what options the C\# OSLO library provides.

Ideally the ODE is a function which mean giving an independent variable it will output dependent variables. Here is the purposed specification:
\begin{table}[ht]
\centering
\begin{tabular}{p{0.2\textwidth} | p{0.3\textwidth} | p{0.3\textwidth}} \hline
    \textbf{Module Name}&\textbf{Input}&\textbf{Output}\\
    \toprule
    Calculations & & $\mathbb{R} \rightarrow \mathbb{R}^k$ \\
    \bottomrule	
\end{tabular}	
\caption{Specification for Calculations Return a Funtion}	
\label{tab_srsforcal}
\end{table}

For $\mathbb{R} \rightarrow \mathbb{R}^k$, the $\mathbb{R}$ is the independent variable. The $\mathbb{R}^k$ is a sequence of dependent variables. For a fourth-order ODE, the $\mathbb{R}^k$ would be $\mathbb{R}^4$. Since Drasil Framework can generate a library, the idea of outputting an ODE as a function can be useful. A program can hook up the interface of the generated library, and the library will provide support for calculating the numerical solution of the ODE. The implementation of this specification is not completed, but it gives future students inspirations on how to generate a library to solve the ODE.

% Another ideal output of the calculation module can be $\mathbb{R} \rightarrow \mathbb{R}^k$. 

% Another output of the calculation module for solving the ODE is to output the solution as a function $\mathbb{R} \rightarrow \mathbb{R}^i$. The i is the number of equations in the ODE. The input is the independent variable, often time, and the output is a sequence of real numbers. In Example~\ref{ex_firstorderode}, the function type will be $\mathbb{R} \rightarrow \mathbb{R}^2$. The idea of outputting an ODE as a function can be useful when the Drasil framework generates a library. Users have the option to generate a runnable program or a standalone library. 

% On the one hand, the runnable program contains the main function so users can run generated software directly. On the other hand, the library contains all functions to solve the ODE so that outside software can utilize the generated library via its interfaces. The generated library can provide support for calculating the numerical solution of the ODE, and we find Python Scipy library supports outputting ODE as a function.

% In the Python Scipy library, we can return a generic interface called \verb|scipy.integrate.ode|~\citep{scipyfun}, which is a generic interface that can store ODE's information. It contains the relationship between the dependent variable, the independent variables, and other variables. Given an independent variable time, the \verb|scipy.integrate.ode| can calculate dependent variables. If we are interested in a partial numerical solution, we can add other ODE-related information, such as the start time, the end time, and the time step. Code~\ref{code_pythonscipy} shows the full details of how to solve Example~\ref{ex_firstorderode} in the Scipy library.

% \begin{listing}[ht]
% \begin{python1}
% def func_y_t(K_d, K_p, r_t, t_sim, t_step):
%     def f(t, y_t):
%         return [y_t[1], -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p]
    
%     r = scipy.integrate.ode(f)
%     r.set_integrator("dopri5", atol=Constants.Constants.AbsTol, rtol=Constants.Constants.RelTol)
%     r.set_initial_value([0.0, 0.0], 0.0)
%     y_t = [[0.0, 0.0][0]]
%     while r.successful() and r.t < t_sim:
%         r.integrate(r.t + t_step)
%         y_t.append(r.y[0])
    
%     return y_t
% \end{python1}
% \captionof{listing}{Source code of solving PDController in Scipy}
% \label{code_pythonscipy}
% \end{listing}
% In Code~\ref{code_pythonscipy}, between line 2 and line 3, we encode the ODE equation of Example~\ref{ex_firstorderode} in a list. In line 5, we call \verb|scipy.integrate.ode| to packing ODE information in the generic interface ($\mathbb{R} \rightarrow \mathbb{R}^i$). In line 6, we set the configuration for algorithm choices and how much absolute and relative tolerance are. In line 7, we set initial values and the start time. In line 8, we initialize the result collection. We specify which initial value we want to put in the result collection. In line 9, the while loop represents the whole iteration to calculate the ODE.  Line 10 adds the time step in each iteration. In this example, we are only interested in collecting the process variable $x_1$, so we only collect the process variable in line 11. Last, we return the collection of results in line 13. With the workflow described above, the generic interface \verb|scipy.integrate.ode(f)| captures the information of the ODE, and it represents the ODE as a function.

% Table~\ref{tab_outputtype} summarizes the availability of the calculation module's output type for solving an ODE numerically in the four selected libraries.
% \begin{table}[ht]
% \centering
% \begin{tabular}{p{0.2\textwidth} | p{0.6\textwidth} } \hline
%     \textbf{Library}&\textbf{Available Output Type}\\
%     \toprule
%     Scipy-Python & 
%     \begin{itemize}[wide]
%     \item $\mathbb{R}^k$ (k is a finite integer)
%     \item $\mathbb{R} \rightarrow \mathbb{R}^i$ (i is the number of equations in the ODE)
%     \end{itemize}  \\ \hline
%     ACM-Java &     
%     \begin{itemize}[wide]
%     \item $\mathbb{R}^k$
%     \end{itemize}  \\ \hline
%     ODEINT-C\texttt{++} & 
%     \begin{itemize}[wide]
%     \item $\mathbb{R}^k$
%     \end{itemize}\\ \hline
%     OSLO-C\# & 
%     \begin{itemize}[wide]
%     \item $\mathbb{R}^k$
%     \item $\mathbb{R}^n$ (n is an infinite integer)
%     \end{itemize} \\
%     \bottomrule	
% \end{tabular}	
% \caption{Available output type in external libraries}	
% \label{tab_outputtype}
% \end{table}

% \section{Management Libraries}
% Once the Drasil framework generates code, the generated code relies on external libraries to calculate an ODE. In the current setting, the Drasil framework keeps copies of external libraries in the repository. In the long run this is not practical because of the amount of space external libraries occupy. Moreover, external libraries are not currently shared across case studies, and each case study will have its own copy of external libraries. The current research has uncovered that the current way of handling dependencies in the Drasil framework is problematic. In the future, the team would like to find a better way to handle dependencies. We used a temporary solution, symbolic links, to share external libraries without duplications. By creating a symbolic link file, external libraries become sharable. In the future, the team will conduct further studies to tackle this problem.
