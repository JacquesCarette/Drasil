/** \file Calculations.cs
    \author Thulasi Jegatheesan
    \brief Provides functions for calculating the outputs
    \note Generated by Drasil v0.1-alpha
*/

using System;
using System.Collections.Generic;
using Microsoft.Research.Oslo;

public class Calculations {
    
    /** \brief Calculates volume of water (m^3)
        \param V_tank volume of the cylindrical tank (m^3)
        \return volume of water (m^3)
    */
    public static double func_V_W(double V_tank) {
        return V_tank;
    }
    
    /** \brief Calculates mass of water (kg)
        \param rho_W density of water (kg/m^3)
        \param V_W volume of water (m^3)
        \return mass of water (kg)
    */
    public static double func_m_W(double rho_W, double V_W) {
        return V_W * rho_W;
    }
    
    /** \brief Calculates ODE parameter for water related to decay time (s)
        \param C_W specific heat capacity of water (J/(kg degreeC))
        \param h_C convective heat transfer coefficient between coil and water (W/(m^2 degreeC))
        \param A_C heating coil surface area (m^2)
        \param m_W mass of water (kg)
        \return ODE parameter for water related to decay time (s)
    */
    public static double func_tau_W(double C_W, double h_C, double A_C, double m_W) {
        return m_W * C_W / (h_C * A_C);
    }
    
    /** \brief Calculates temperature of the water (degreeC)
        \param T_C temperature of the heating coil (degreeC)
        \param T_init initial temperature (degreeC)
        \param t_final final time (s)
        \param A_tol absolute tolerance
        \param R_tol relative tolerance
        \param t_step time step for simulation (s)
        \param tau_W ODE parameter for water related to decay time (s)
        \return temperature of the water (degreeC)
    */
    public static List<double> func_T_W(double T_C, double T_init, double t_final, double A_tol, double R_tol, double t_step, double tau_W) {
        List<double> T_W;
        Func<double, Vector, Vector> f = (t, T_W_vec) => {
            return new Vector(-(1.0 / tau_W) * tempW_arrayvec[0] + 1.0 / tau_W * T_C);
        };
        Options opts = new Options();
        opts.AbsoluteTolerance = A_tol;
        opts.RelativeTolerance = R_tol;
        
        Vector initv = new Vector(new double[] {T_init});
        IEnumerable<SolPoint> sol = Ode.RK547M(0.0, initv, f, opts);
        IEnumerable<SolPoint> points = sol.SolveFromToStep(0.0, t_final, t_step);
        T_W = new List<double> {};
        foreach (SolPoint sp in points) {
            T_W.Add(sp.X[0]);
        }
        
        return T_W;
    }
}
