-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Language SubPackage
--   
--   Please see the README on GitHub at
--   <a>https://github.com/JacquesCarette/Drasil#readme</a>
@package drasil-lang
@version 0.1.60.0


-- | Custom type for dates, in this case Month. This should, in time, be
--   switched out in favour of a proper package designed to handle all the
--   complexities of dates.
module Language.Drasil.Data.Date

-- | Custom type for months (abbreviated).
data Month
Jan :: Month
Feb :: Month
Mar :: Month
Apr :: Month
May :: Month
Jun :: Month
Jul :: Month
Aug :: Month
Sep :: Month
Oct :: Month
Nov :: Month
Dec :: Month
instance GHC.Classes.Ord Language.Drasil.Data.Date.Month
instance GHC.Classes.Eq Language.Drasil.Data.Date.Month
instance GHC.Show.Show Language.Drasil.Data.Date.Month


-- | A collection of <a>String</a>-handling routines as well as one for
--   making tables.
module Language.Drasil.Misc

-- | Create a table body (not including header row) by applying the given
--   functions to the column elements of the table rows (in order). The
--   first argument is a list of functions to be applied (one per column).
--   This essentially creates the rows. The second argument is a list of
--   elements apply the functions to.
--   
--   For example, <tt>mkTable [id, *5] [1,2,3]</tt> should produce a table:
--   
--   <pre>
--   | 1 |  5 |
--   | 2 | 10 |
--   | 3 | 15 |
--   </pre>
mkTable :: [a -> b] -> [a] -> [[b]]

-- | Returns the given string if it doesn't contain spaces and throws an
--   error if it does.
noSpaces :: String -> String

-- | Replace underscores in a string with periods (<tt>.</tt>).
repUnd :: String -> String


-- | Defines types and functions to encode people, names, and naming
--   convention. Used for referencing and authorship of work.
module Language.Drasil.People

-- | Members of this class must have a name.
class HasName p

-- | A person can have a given name, middle name(s), and surname, as well
--   as the naming convention they use.
data Person

-- | People is a synonymn for many <a>Person</a>s.
type People = [Person]

-- | Naming conventions.
data Conv

-- | Western style conventions are given name followed by middle names,
--   followed by surname.
Western :: Conv

-- | Eastern style conventions are surname followed by middle names,
--   followed by given name.
Eastern :: Conv

-- | Mononyms are for those people who have only one name (ex. Madonna).
Mono :: Conv

-- | Constructor for a person using Western naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   given name, surname.
person :: String -> String -> Person

-- | Constructor for a person using Eastern naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   surname, given name.
person' :: String -> String -> Person

-- | Constructor for a person using Western naming conventions. Similar to
--   the <a>person</a> constructor, except the middle argument is a list of
--   middle names.
personWM :: String -> [String] -> String -> Person

-- | Constructor for a person using Eastern naming conventions. Similar to
--   the <a>person'</a> constructor, except the middle argument is a list
--   of middle names.
personWM' :: String -> [String] -> String -> Person

-- | Constructor for a person with a mononym (only one name).
mononym :: String -> Person

-- | Gets the name of a <a>Person</a>. Adds a dot after any initials.
name :: HasName n => n -> String

-- | Provides the ability to hold a name.
nameStr :: HasName p => p -> String

-- | Gets the last name of a <a>Person</a>.
lstName :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, First Middle.
rendPersLFM :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, F. M.
rendPersLFM' :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, First M.
rendPersLFM'' :: Person -> String

-- | Orderes different groups of <a>Person</a>s. If two lists are the same
--   up to a point, the citation with more <a>Person</a>s will go last.
comparePeople :: [Person] -> [Person] -> Ordering
instance GHC.Classes.Eq Language.Drasil.People.Person
instance GHC.Classes.Eq Language.Drasil.People.Conv
instance Language.Drasil.People.HasName Language.Drasil.People.Person


-- | Contains all necessary types and constructors for citing sources in
--   Drasil.
module Language.Drasil.Data.Citation

-- | Fields used in citations.
data CiteField
Address :: String -> CiteField
Author :: People -> CiteField

-- | Used for <a>InCollection</a> references only.
BookTitle :: String -> CiteField
Chapter :: Int -> CiteField
Edition :: Int -> CiteField
Editor :: People -> CiteField

-- | Can be published via URL or something else.
HowPublished :: HP -> CiteField
Institution :: String -> CiteField
Journal :: String -> CiteField
Month :: Month -> CiteField
Note :: String -> CiteField
Number :: Int -> CiteField
Organization :: String -> CiteField

-- | Range of pages (ex1. 1-32; ex2. 7,31,52-55).
Pages :: [Int] -> CiteField
Publisher :: String -> CiteField
School :: String -> CiteField
Series :: String -> CiteField
Title :: String -> CiteField

-- | BibTeX "type" field.
Type :: String -> CiteField
Volume :: Int -> CiteField
Year :: Int -> CiteField

-- | How something is published. Necessary for URLs to work properly.
data HP
URL :: String -> HP
Verb :: String -> HP

-- | External references come in many flavours. Articles, Books, etc. (we
--   are using the types available in Bibtex).
data CitationKind
Article :: CitationKind
Book :: CitationKind
Booklet :: CitationKind
InBook :: CitationKind
InCollection :: CitationKind
InProceedings :: CitationKind
Manual :: CitationKind
MThesis :: CitationKind
Misc :: CitationKind
PhDThesis :: CitationKind
Proceedings :: CitationKind
TechReport :: CitationKind
Unpublished :: CitationKind

-- | Smart field constructor for a <a>CiteField</a>.
author :: People -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
editor :: People -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
address :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
bookTitle :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
howPublished :: String -> CiteField

-- | URL version of <a>howPublished</a>.
--   
--   Smart field constructor for a <a>CiteField</a>.
howPublishedU :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
institution :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
journal :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
note :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
organization :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
publisher :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
school :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
series :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
title :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
typeField :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
chapter :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
edition :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
number :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
volume :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
year :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
pages :: [Int] -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
month :: Month -> CiteField


-- | Defining classes that represent knowledge about Citations.
module Language.Drasil.Classes.Citations

-- | <tt>Citation</tt>s should have a fields (<a>CiteField</a>).
class HasFields c

-- | Provides a <tt>Lens</tt> to <a>CiteField</a>s.
getFields :: HasFields c => Lens' c [CiteField]


-- | Stages used for displaying symbols.
module Language.Drasil.Stages

-- | Stages correspond to what we're trying to look up. They range from
--   abstract to concrete. Equational stages are more theoretical and
--   oriented towards abstract design while the Implementation stages are
--   more oriented towards detailed design.
data Stage
Equational :: Stage
Implementation :: Stage
instance GHC.Show.Show Language.Drasil.Stages.Stage


-- | Unique Identifier used across Drasil.
module Language.Drasil.UID

-- | A <tt>UID</tt> is a 'unique identifier' for things that we will put
--   into our database of information. We use a newtype wrapper to make
--   sure we are only using <a>UID</a>s where desired.
newtype UID
UID :: String -> UID
[uidToStr] :: UID -> String
instance GHC.Classes.Ord Language.Drasil.UID.UID
instance GHC.Classes.Eq Language.Drasil.UID.UID
instance GHC.Show.Show Language.Drasil.UID.UID


-- | Even though we do not have <tt>Label</tt>s per se, here we define the
--   different ways of construction ways to mark labels.
module Language.Drasil.Label.Type

-- | Applying different pieces of information for a reference. An RP is a
--   decorated internal reference. Citation is a citation. URI is for URLs
--   and other external links.
data LblType
RP :: IRefProg -> String -> LblType
Citation :: String -> LblType
URI :: String -> LblType

-- | Created for different forms of references. Used in <a>LblType</a>.
data IRefProg

-- | Deferred lookup; done later. Used for domains in a
--   <tt>ConceptInstance</tt>.
Deferred :: UID -> IRefProg

-- | Lifts a <a>String</a> into a <tt>RefProg</tt>.
RS :: String -> IRefProg

-- | Concatenates with two subprograms.
RConcat :: IRefProg -> IRefProg -> IRefProg

-- | The <tt>Symbol</tt> to insert the <tt>ShortName</tt> directly.
Name :: IRefProg

-- | Retrieves the <a>String</a> contained in a <a>LblType</a>.
getAdd :: LblType -> String

-- | Constructor that gets the <a>Name</a> of an <a>IRefProg</a>.
name :: IRefProg

-- | Constructor that concatenates two subprograms.
(+::+) :: IRefProg -> IRefProg -> IRefProg

-- | Constructor for a <a>String</a> into an <a>IRefProg</a>.
raw :: String -> IRefProg

-- | Constructor to defer a <a>UID</a> lookup; done later.
defer :: UID -> IRefProg

-- | Prepends a <a>String</a> to an <a>IRefProg</a>.
prepend :: String -> IRefProg


-- | Abstract Syntax Tree for Uniform Resource Identifiers
module Language.Drasil.URI.AST

-- | A uniform resource identifier (uses URLs or ISBNs).
data URI
URL :: Scheme -> Authority -> Path -> Query -> Fragment -> URI
ISBN :: String -> URI

-- | URL scheme (either HTTP or FTP).
data Scheme
HTTP :: Scheme
FTP :: Scheme

-- | Authentication if necessary.
data Authority

-- | Full authentication.
Full :: Username -> Password -> Host -> Port -> Authority

-- | Simplify for when authentication isn't necessary.
Simple :: Host -> Port -> Authority
type Path = String " Type the full path excluding the first /."
type Query = [String] " Make sure [] doesn't print a "?". Separate elements with "&"."
type Fragment = String " Make sure "" becomes "" not "#" when printing."
type Username = String " Again make sure "" doesn't print anything."
type Password = String " Don't print anything if "" or if Username=""."
type Host = String " Type the host address (ex. "www.github.com")."
data Port

-- | Take an integer port number if applicable.
P :: Int -> Port

-- | Do nothing if port is not applicable.
NA :: Port


-- | Defines uncertainty types and functions.
module Language.Drasil.Uncertainty.Core

-- | Something that may contain an uncertainty value and a precision value.
data Uncertainty
uncert :: Lens' Uncertainty (Maybe Double)
prec :: Lens' Uncertainty (Maybe Int)

-- | Smart constructor for values with uncertainty.
uncty :: Double -> Maybe Int -> Uncertainty

-- | Smart constructor for exact values (no uncertainty).
exact :: Uncertainty


-- | Special type for unicode characters.
module Language.Drasil.Unicode

-- | Special characters include partial derivatives and the degree circle.
data Special
Partial :: Special
Circle :: Special

-- | Class for rendering special characters.
class RenderSpecial r
special :: RenderSpecial r => Special -> r
instance GHC.Classes.Ord Language.Drasil.Unicode.Special
instance GHC.Classes.Eq Language.Drasil.Unicode.Special


-- | Drasil uses symbols in expressions and sentences.
module Language.Drasil.Symbol

-- | Decorations on symbols/characters such as hats or Vector
--   representations (determines bolding, italics, etc).
data Decoration

-- | Places a <tt>^</tt> on top of a symbol.
Hat :: Decoration

-- | Makes a symbol bold.
Vector :: Decoration

-- | Appends a <tt>'</tt> to a symbol.
Prime :: Decoration

-- | Prepends a <tt>Δ</tt> to a symbol.
Delta :: Decoration

-- | Places <tt>||</tt> before and after a symbol.
Magnitude :: Decoration

-- | A <a>Symbol</a> is actually going to be a graphical description of
--   what gets rendered as a (unique) symbol. This is actually NOT based on
--   semantics at all, but just a description of how things look.
--   
--   Symbols can be:
--   
--   <ul>
--   <li><tt><a>Variable</a></tt> (string such as "x" that represent a
--   value that can vary)</li>
--   <li><tt><a>Label</a></tt> (strings such as "max" or "target" that
--   represent a single idea)</li>
--   <li><tt><a>Special</a></tt> characters (ex. unicode)</li>
--   <li><tt>Decorated</tt> symbols using <a>Atop</a></li>
--   <li><tt>Concatenations</tt> of symbols, including subscripts and
--   superscripts</li>
--   <li><tt><a>Empty</a></tt>! (this is to give this a monoid-like
--   flavour)</li>
--   </ul>
data Symbol

-- | Basic variable name creation.
Variable :: String -> Symbol

-- | For when symbols need more context, but we don't want to add a new
--   variable name. For example, <tt>v_f</tt> may be encoded as <tt>Concat
--   [variable "v", label "f"]</tt>.
Label :: String -> Symbol

-- | For using numbers in Symbols.
Integ :: Int -> Symbol

-- | For now, special characters are the degree and partial differentiation
--   symbols. These should eventually move elsewhere and the <a>Special</a>
--   type removed.
Special :: Special -> Symbol

-- | Used to decorate symbols. For things like vectors (which need to be
--   bold), primes, magnitudes, etc. See <a>Decoration</a> for more
--   details.
Atop :: Decoration -> Symbol -> Symbol

-- | Order of Symbols: upleft lowleft upright lowright base. Ex:
--   
--   <pre>
--   Corners [1]   [2]   [3]   [4]   [5]
--   </pre>
--   
--   <pre>
--   Visually:  [1]   [3]
--   
--                 [5]
--   
--              [2]   [4]
--   </pre>
Corners :: [Symbol] -> [Symbol] -> [Symbol] -> [Symbol] -> Symbol -> Symbol

-- | Concatentation of two symbols: <tt>[s1, s2] -&gt; s1s2</tt>
Concat :: [Symbol] -> Symbol

-- | Placeholder for when a symbol is not needed.
Empty :: Symbol

-- | The default compare function that sorts all the lower case symbols
--   after the upper case ones.
--   
--   Comparation is used twice for each <tt>Atomic</tt> case, once for
--   making sure they are the same letter, once for case sensitive. As far
--   as this comparison is considered, <tt>Δ</tt> is a "decoration" and
--   ignored unless the compared symbols are the exact same, in which case
--   it is ordered after the undecorated symbol.
--   
--   Superscripts and subscripts are ordered after the base symbols
--   (because they add additional context to a symbol). For example:
--   `v_f^{AB}` (expressed in LaTeX notation for clarity), where
--   <tt>v_f</tt> is a final velocity, and the `^{AB}` adds context that it
--   is the final velocity between points <tt>A</tt> and <tt>B</tt>. In
--   these cases, the sorting of `v_f^{AB}` should be following
--   <tt>v_f</tt> as it is logical to place it with its parent concept.
compsy :: Symbol -> Symbol -> Ordering
instance GHC.Classes.Eq Language.Drasil.Symbol.Symbol
instance GHC.Classes.Ord Language.Drasil.Symbol.Decoration
instance GHC.Classes.Eq Language.Drasil.Symbol.Decoration
instance GHC.Base.Semigroup Language.Drasil.Symbol.Symbol
instance GHC.Base.Monoid Language.Drasil.Symbol.Symbol


-- | Number space types and functions.
module Language.Drasil.Space

-- | The difference kinds of spaces that may exist. This type holds
--   numerical spaces (such as the set of integers, rationals, etc.), a
--   space for booleans, a space for characters, dimensional spaces
--   (vectors, arrays, etc.), a space for Actors, discrete sets (both for
--   numbers and strings), and a void space.
data Space
Integer :: Space
Rational :: Space
Real :: Space
Natural :: Space
Boolean :: Space
Char :: Space
String :: Space
Radians :: Space
Vect :: Space -> Space
Array :: Space -> Space
Actor :: String -> Space
DiscreteD :: [Double] -> Space
DiscreteS :: [String] -> Space
Function :: NonEmpty Primitive -> Primitive -> Space
Void :: Space

-- | A RealInterval is a subset of <a>Real</a> (as a <a>Space</a>). These
--   come in different flavours. For now, we embed <tt>Expr</tt> for the
--   bounds, but that will change as well.
data RealInterval a b
[Bounded] :: (Inclusive, a) -> (Inclusive, b) -> RealInterval a b
[UpTo] :: (Inclusive, a) -> RealInterval a b
[UpFrom] :: (Inclusive, b) -> RealInterval a b

-- | Inclusive or exclusive bounds.
data Inclusive
Inc :: Inclusive
Exc :: Inclusive

-- | Describes the domain of a <a>Symbol</a> given a topology. Can be
--   bounded or encase all of the domain.
data DomainDesc (tplgy :: RTopology) a b
[BoundedDD] :: Symbol -> RTopology -> a -> b -> DomainDesc 'Discrete a b
[AllDD] :: Symbol -> RTopology -> DomainDesc 'Continuous a b

-- | Topology of a subset of reals.
data RTopology
Continuous :: RTopology
Discrete :: RTopology
type DiscreteDomainDesc a b = DomainDesc 'Discrete a b
type ContinuousDomainDesc a b = DomainDesc 'Continuous a b

-- | Gets the name of an <a>Actor</a>.
getActorName :: Space -> String

-- | Gets the inner <a>Space</a> of a vector.
getInnerSpace :: Space -> Space
mkFunction :: [Primitive] -> Primitive -> Space
instance GHC.Show.Show Language.Drasil.Space.Space
instance GHC.Classes.Eq Language.Drasil.Space.Space


-- | The Drasil Expression language
module Language.Drasil.Expr.Lang

-- | A relation is just an expression (<a>Expr</a>).
type Relation = Expr

-- | The variable type is just a renamed <a>String</a>.
type Variable = String

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product).
data VVVBinOp
Cross :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
AddI :: AssocArithOper
AddRe :: AssocArithOper
MulI :: AssocArithOper
MulRe :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | For case expressions (either complete or incomplete).
data Completeness
Complete :: Completeness
Incomplete :: Completeness

-- | Drasil expressions.
data Expr

-- | Turns a decimal value (<a>Double</a>) into an expression.
[Dbl] :: Double -> Expr

-- | Turns an integer into an expression.
[Int] :: Integer -> Expr

-- | Represents decimal values that are exact as integers.
[ExactDbl] :: Integer -> Expr

-- | Turns a string into an expression.
[Str] :: String -> Expr

-- | Turns two integers into a fraction (or percent).
[Perc] :: Integer -> Integer -> Expr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [Expr] -> Expr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [Expr] -> Expr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> Expr

-- | A function call accepts a list of parameters and a list of named
--   parameters. For example
--   
--   <ul>
--   <li>F(x) is (FCall F [x] []).</li>
--   <li>F(x,y) would be (FCall F [x,y]).</li>
--   <li>F(x,n=y) would be (FCall F [x] [(n,y)]).</li>
--   </ul>
[FCall] :: UID -> [Expr] -> [(UID, Expr)] -> Expr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(Expr, Relation)] -> Expr

-- | Represents a matrix of expressions.
[Matrix] :: [[Expr]] -> Expr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> Expr -> Expr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> Expr -> Expr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> Expr -> Expr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> Expr -> Expr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> Expr -> Expr -> Expr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> Expr -> Expr -> Expr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> Expr -> Expr -> Expr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> Expr -> Expr -> Expr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> Expr -> Expr -> Expr

-- | Operators are generalized arithmetic operators over a
--   <tt>DomainDesc</tt> of an <a>Expr</a>. Could be called BigOp. ex:
--   Summation is represented via <tt>Add</tt> over a discrete domain.
[Operator] :: AssocArithOper -> DiscreteDomainDesc Expr Expr -> Expr -> Expr

-- | A different kind of <tt>IsIn</tt>. A <a>UID</a> is an element of an
--   interval.
[RealI] :: UID -> RealInterval Expr Expr -> Expr
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.Completeness
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.UFuncVN
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.UFuncVV
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.UFuncB
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.UFunc
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.AssocBoolOper
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.AssocArithOper
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.VVNBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.VVVBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.OrdBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.LABinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.BoolBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.EqBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.ArithBinOp
instance GHC.Classes.Eq Language.Drasil.Expr.Lang.Expr


-- | The Drasil Modelling Expression language
module Language.Drasil.ModelExpr.Lang

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product).
data VVVBinOp
Cross :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
AddI :: AssocArithOper
AddRe :: AssocArithOper
MulI :: AssocArithOper
MulRe :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper
Equivalence :: AssocBoolOper

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | Statements involving 2 arguments.
data StatBinOp
Defines :: StatBinOp

-- | <tt>Value -&gt; Space -&gt; Bool</tt> operators.
data SpaceBinOp
IsIn :: SpaceBinOp

-- | Determines the type of the derivative (either a partial derivative or
--   a total derivative).
data DerivType
Part :: DerivType
Total :: DerivType

-- | Drasil expressions.
data ModelExpr

-- | Turns a decimal value (<a>Double</a>) into an expression.
[Dbl] :: Double -> ModelExpr

-- | Turns an integer into an expression.
[Int] :: Integer -> ModelExpr

-- | Represents decimal values that are exact as integers.
[ExactDbl] :: Integer -> ModelExpr

-- | Turns a string into an expression.
[Str] :: String -> ModelExpr

-- | Introduce Space values into the expression language.
[Spc] :: Space -> ModelExpr

-- | Turns two integers into a fraction (or percent).
[Perc] :: Integer -> Integer -> ModelExpr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [ModelExpr] -> ModelExpr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [ModelExpr] -> ModelExpr

-- | Derivative syntax is: Type (<a>Part</a>ial or <a>Total</a>) -&gt;
--   principal part of change -&gt; with respect to For example: Deriv Part
--   y x1 would be (dy/dx1).
[Deriv] :: DerivType -> ModelExpr -> UID -> ModelExpr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> ModelExpr

-- | A function call accepts a list of parameters and a list of named
--   parameters. For example
--   
--   <ul>
--   <li>F(x) is (FCall F [x] []).</li>
--   <li>F(x,y) would be (FCall F [x,y]).</li>
--   <li>F(x,n=y) would be (FCall F [x] [(n,y)]).</li>
--   </ul>
[FCall] :: UID -> [ModelExpr] -> [(UID, ModelExpr)] -> ModelExpr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(ModelExpr, ModelExpr)] -> ModelExpr

-- | Represents a matrix of expressions.
[Matrix] :: [[ModelExpr]] -> ModelExpr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> ModelExpr -> ModelExpr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Space-related binary operations.
[SpaceBinaryOp] :: SpaceBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Statement-related binary operations.
[StatBinaryOp] :: StatBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Operators are generalized arithmetic operators over a
--   <a>DomainDesc</a> of an <tt>Expr</tt>. Could be called BigOp. ex:
--   Summation is represented via <tt>Add</tt> over a discrete domain.
[Operator] :: AssocArithOper -> DomainDesc t ModelExpr ModelExpr -> ModelExpr -> ModelExpr

-- | A different kind of <a>IsIn</a>. A <a>UID</a> is an element of an
--   interval.
[RealI] :: UID -> RealInterval ModelExpr ModelExpr -> ModelExpr

-- | Universal quantification
[ForAll] :: UID -> Space -> ModelExpr -> ModelExpr

-- | The variable type is just a renamed <a>String</a>.
type Variable = String
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.DerivType
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.SpaceBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.StatBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.UFuncVN
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.UFuncVV
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.UFuncB
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.UFunc
instance GHC.Show.Show Language.Drasil.ModelExpr.Lang.AssocBoolOper
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.AssocBoolOper
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.AssocArithOper
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.VVNBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.VVVBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.OrdBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.LABinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.BoolBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.EqBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.ArithBinOp
instance GHC.Classes.Eq Language.Drasil.ModelExpr.Lang.ModelExpr


-- | Defines operator precedence.
module Language.Drasil.ModelExpr.Precedence

-- | prec2Arith - precedence for arithmetic-related binary operations.
prec2Arith :: ArithBinOp -> Int

-- | prec2Bool - precedence for boolean-related binary operations.
prec2Bool :: BoolBinOp -> Int

-- | prec2Eq - precedence for equality-related binary operations.
prec2Eq :: EqBinOp -> Int

-- | prec2LA - precedence for access-related binary operations.
prec2LA :: LABinOp -> Int

-- | prec2Ord - precedence for order-related binary operations.
prec2Ord :: OrdBinOp -> Int
prec2Spc :: SpaceBinOp -> Int
prec2Stat :: StatBinOp -> Int

-- | prec2VVV - precedence for Vec-&gt;Vec-&gt;Vec-related binary
--   operations.
prec2VVV :: VVVBinOp -> Int

-- | prec2VVN - precedence for Vec-&gt;Vec-&gt;Num-related binary
--   operations.
prec2VVN :: VVNBinOp -> Int

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | prec1 - precedence of unary operators.
prec1 :: UFunc -> Int

-- | prec1B - precedence of boolean-related unary operators.
prec1B :: UFuncB -> Int

-- | prec1VV - precedence of vector-vector-related unary operators.
prec1VV :: UFuncVV -> Int

-- | prec1Vec - precedence of vector-number-related unary operators.
prec1VN :: UFuncVN -> Int

-- | eprec - <a>ModelExpr</a> precedence.
mePrec :: ModelExpr -> Int


-- | Defines functions to find Chunk UIDs within <a>ModelExpr</a>s.
module Language.Drasil.ModelExpr.Extract

-- | Generic traverse of all expressions that could lead to names.
meNames :: ModelExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>meNames</a>).
meNamesRI :: RealInterval ModelExpr ModelExpr -> [UID]

-- | Generic traverse of all positions that could lead to <a>meNames</a>
--   without functions. FIXME : this should really be done via post-facto
--   filtering, but right now the information needed to do this is not
--   available!
meNames' :: ModelExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names without functions (similar to <a>meNames'</a>).
meNamesRI' :: RealInterval ModelExpr ModelExpr -> [UID]

-- | Get dependencies from an equation.
meDep :: ModelExpr -> [UID]


-- | Defines functions to convert from the base expression language to
--   <a>ModelExpr</a>s.
module Language.Drasil.ModelExpr.Convert
assocArithOper :: AssocArithOper -> AssocArithOper
assocBoolOper :: AssocBoolOper -> AssocBoolOper
uFunc :: UFunc -> UFunc
uFuncB :: UFuncB -> UFuncB
uFuncVV :: UFuncVV -> UFuncVV
uFuncVN :: UFuncVN -> UFuncVN
arithBinOp :: ArithBinOp -> ArithBinOp
boolBinOp :: BoolBinOp -> BoolBinOp
eqBinOp :: EqBinOp -> EqBinOp
laBinOp :: LABinOp -> LABinOp
ordBinOp :: OrdBinOp -> OrdBinOp
vvvBinOp :: VVVBinOp -> VVVBinOp
vvnBinOp :: VVNBinOp -> VVNBinOp
expr :: Expr -> ModelExpr
realInterval :: RealInterval Expr Expr -> RealInterval ModelExpr ModelExpr
domainDesc :: DiscreteDomainDesc Expr Expr -> DiscreteDomainDesc ModelExpr ModelExpr


-- | Re-export functions and types related to <a>ModelExpr</a>
module Language.Drasil.ModelExpr.Development

-- | Drasil expressions.
data ModelExpr

-- | Turns a decimal value (<a>Double</a>) into an expression.
[Dbl] :: Double -> ModelExpr

-- | Turns an integer into an expression.
[Int] :: Integer -> ModelExpr

-- | Represents decimal values that are exact as integers.
[ExactDbl] :: Integer -> ModelExpr

-- | Turns a string into an expression.
[Str] :: String -> ModelExpr

-- | Introduce Space values into the expression language.
[Spc] :: Space -> ModelExpr

-- | Turns two integers into a fraction (or percent).
[Perc] :: Integer -> Integer -> ModelExpr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [ModelExpr] -> ModelExpr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [ModelExpr] -> ModelExpr

-- | Derivative syntax is: Type (<a>Part</a>ial or <a>Total</a>) -&gt;
--   principal part of change -&gt; with respect to For example: Deriv Part
--   y x1 would be (dy/dx1).
[Deriv] :: DerivType -> ModelExpr -> UID -> ModelExpr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> ModelExpr

-- | A function call accepts a list of parameters and a list of named
--   parameters. For example
--   
--   <ul>
--   <li>F(x) is (FCall F [x] []).</li>
--   <li>F(x,y) would be (FCall F [x,y]).</li>
--   <li>F(x,n=y) would be (FCall F [x] [(n,y)]).</li>
--   </ul>
[FCall] :: UID -> [ModelExpr] -> [(UID, ModelExpr)] -> ModelExpr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(ModelExpr, ModelExpr)] -> ModelExpr

-- | Represents a matrix of expressions.
[Matrix] :: [[ModelExpr]] -> ModelExpr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> ModelExpr -> ModelExpr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Space-related binary operations.
[SpaceBinaryOp] :: SpaceBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Statement-related binary operations.
[StatBinaryOp] :: StatBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Operators are generalized arithmetic operators over a
--   <a>DomainDesc</a> of an <tt>Expr</tt>. Could be called BigOp. ex:
--   Summation is represented via <tt>Add</tt> over a discrete domain.
[Operator] :: AssocArithOper -> DomainDesc t ModelExpr ModelExpr -> ModelExpr -> ModelExpr

-- | A different kind of <a>IsIn</a>. A <a>UID</a> is an element of an
--   interval.
[RealI] :: UID -> RealInterval ModelExpr ModelExpr -> ModelExpr

-- | Universal quantification
[ForAll] :: UID -> Space -> ModelExpr -> ModelExpr

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Value -&gt; Space -&gt; Bool</tt> operators.
data SpaceBinOp
IsIn :: SpaceBinOp

-- | Statements involving 2 arguments.
data StatBinOp
Defines :: StatBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product).
data VVVBinOp
Cross :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
AddI :: AssocArithOper
AddRe :: AssocArithOper
MulI :: AssocArithOper
MulRe :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper
Equivalence :: AssocBoolOper

-- | Determines the type of the derivative (either a partial derivative or
--   a total derivative).
data DerivType
Part :: DerivType
Total :: DerivType

-- | For case expressions (either complete or incomplete).
data Completeness
Complete :: Completeness
Incomplete :: Completeness
expr :: Expr -> ModelExpr

-- | Get dependencies from an equation.
meDep :: ModelExpr -> [UID]

-- | eprec - <a>ModelExpr</a> precedence.
mePrec :: ModelExpr -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int


-- | Defines classes for use with Drasil's expression language.
module Language.Drasil.ExprClasses

-- | Data that can be expressed using <a>ModelExpr</a>.
class Express c
express :: Express c => c -> ModelExpr
instance Language.Drasil.ExprClasses.Express Language.Drasil.Expr.Lang.Expr
instance Language.Drasil.ExprClasses.Express Language.Drasil.ModelExpr.Lang.ModelExpr


-- | Defines operator precedence.
module Language.Drasil.Expr.Precedence

-- | prec2Arith - precedence for arithmetic-related binary operations.
prec2Arith :: ArithBinOp -> Int

-- | prec2Bool - precedence for boolean-related binary operations.
prec2Bool :: BoolBinOp -> Int

-- | prec2Eq - precedence for equality-related binary operations.
prec2Eq :: EqBinOp -> Int

-- | prec2LA - precedence for access-related binary operations.
prec2LA :: LABinOp -> Int

-- | prec2Ord - precedence for order-related binary operations.
prec2Ord :: OrdBinOp -> Int

-- | prec2VVV - precedence for Vec-&gt;Vec-&gt;Vec-related binary
--   operations.
prec2VVV :: VVVBinOp -> Int

-- | prec2VVN - precedence for Vec-&gt;Vec-&gt;Num-related binary
--   operations.
prec2VVN :: VVNBinOp -> Int

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | prec1 - precedence of unary operators.
prec1 :: UFunc -> Int

-- | prec1B - precedence of boolean-related unary operators.
prec1B :: UFuncB -> Int

-- | prec1VV - precedence of vector-vector-related unary operators.
prec1VV :: UFuncVV -> Int

-- | prec1Vec - precedence of vector-number-related unary operators.
prec1VN :: UFuncVN -> Int

-- | eprec - <a>Expression</a> precedence.
eprec :: Expr -> Int


-- | Extract UIDs from an expression so that they can be looked up in the
--   chunk database and rendered.
module Language.Drasil.Expr.Extract

-- | Generic traverse of all expressions that could lead to names.
eNames :: Expr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>eNames</a>).
eNamesRI :: RealInterval Expr Expr -> [UID]

-- | Generic traverse of all positions that could lead to <a>eNames</a>
--   without functions. FIXME : this should really be done via post-facto
--   filtering, but right now the information needed to do this is not
--   available!
eNames' :: Expr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names without functions (similar to <a>eNames'</a>).
eNamesRI' :: RealInterval Expr Expr -> [UID]

-- | Get dependencies from an equation.
eDep :: Expr -> [UID]

module Language.Drasil.Expr.Development

-- | Drasil expressions.
data Expr

-- | Turns a decimal value (<a>Double</a>) into an expression.
[Dbl] :: Double -> Expr

-- | Turns an integer into an expression.
[Int] :: Integer -> Expr

-- | Represents decimal values that are exact as integers.
[ExactDbl] :: Integer -> Expr

-- | Turns a string into an expression.
[Str] :: String -> Expr

-- | Turns two integers into a fraction (or percent).
[Perc] :: Integer -> Integer -> Expr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [Expr] -> Expr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [Expr] -> Expr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> Expr

-- | A function call accepts a list of parameters and a list of named
--   parameters. For example
--   
--   <ul>
--   <li>F(x) is (FCall F [x] []).</li>
--   <li>F(x,y) would be (FCall F [x,y]).</li>
--   <li>F(x,n=y) would be (FCall F [x] [(n,y)]).</li>
--   </ul>
[FCall] :: UID -> [Expr] -> [(UID, Expr)] -> Expr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(Expr, Relation)] -> Expr

-- | Represents a matrix of expressions.
[Matrix] :: [[Expr]] -> Expr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> Expr -> Expr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> Expr -> Expr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> Expr -> Expr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> Expr -> Expr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> Expr -> Expr -> Expr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> Expr -> Expr -> Expr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> Expr -> Expr -> Expr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> Expr -> Expr -> Expr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> Expr -> Expr -> Expr

-- | Operators are generalized arithmetic operators over a
--   <tt>DomainDesc</tt> of an <a>Expr</a>. Could be called BigOp. ex:
--   Summation is represented via <tt>Add</tt> over a discrete domain.
[Operator] :: AssocArithOper -> DiscreteDomainDesc Expr Expr -> Expr -> Expr

-- | A different kind of <tt>IsIn</tt>. A <a>UID</a> is an element of an
--   interval.
[RealI] :: UID -> RealInterval Expr Expr -> Expr

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product).
data VVVBinOp
Cross :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
AddI :: AssocArithOper
AddRe :: AssocArithOper
MulI :: AssocArithOper
MulRe :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper

-- | For case expressions (either complete or incomplete).
data Completeness
Complete :: Completeness
Incomplete :: Completeness

-- | A relation is just an expression (<a>Expr</a>).
type Relation = Expr

-- | Get dependencies from an equation.
eDep :: Expr -> [UID]

-- | Generic traverse of all expressions that could lead to names.
eNames :: Expr -> [UID]

-- | Generic traverse of all positions that could lead to <a>eNames</a>
--   without functions. FIXME : this should really be done via post-facto
--   filtering, but right now the information needed to do this is not
--   available!
eNames' :: Expr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>eNames</a>).
eNamesRI :: RealInterval Expr Expr -> [UID]

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | eprec - <a>Expression</a> precedence.
eprec :: Expr -> Int


-- | Defines types and functions for constrained values.
module Language.Drasil.Constraint

-- | Holds constraints. May occur between an interval of <a>Expr</a>, a
--   list of <a>Double</a>s, or a list of <a>String</a>s.
data Constraint a

-- | By default, physical and software constraints are ranges.
[Range] :: ConstraintReason -> RealInterval a a -> Constraint a

-- | Type synonym for <a>ConstraintE</a>
type ConstraintE = Constraint Expr

-- | The reason behind the constraint's existence.
data ConstraintReason
Physical :: ConstraintReason
Software :: ConstraintReason

-- | Smart constructor for range of <a>Physical</a> constraints between two
--   given expressions.
physc :: RealInterval Expr Expr -> ConstraintE

-- | Smart constructor for range of <a>Software</a> constraints between two
--   given expressions.
sfwrc :: RealInterval Expr Expr -> ConstraintE

-- | Helpful for filtering for Physical constraints. True if constraint is
--   <a>Physical</a>.
isPhysC :: Constraint e -> Bool

-- | Helpful for filtering for Software constraints. True if constraint is
--   <a>Software</a>.
isSfwrC :: Constraint e -> Bool


-- | Re-export display-related functions and types to simplify external
--   use.
module Language.Drasil.Display

-- | Decorations on symbols/characters such as hats or Vector
--   representations (determines bolding, italics, etc).
data Decoration

-- | Places a <tt>^</tt> on top of a symbol.
Hat :: Decoration

-- | Makes a symbol bold.
Vector :: Decoration

-- | Appends a <tt>'</tt> to a symbol.
Prime :: Decoration

-- | Prepends a <tt>Δ</tt> to a symbol.
Delta :: Decoration

-- | Places <tt>||</tt> before and after a symbol.
Magnitude :: Decoration

-- | A <a>Symbol</a> is actually going to be a graphical description of
--   what gets rendered as a (unique) symbol. This is actually NOT based on
--   semantics at all, but just a description of how things look.
--   
--   Symbols can be:
--   
--   <ul>
--   <li><tt><a>Variable</a></tt> (string such as "x" that represent a
--   value that can vary)</li>
--   <li><tt><a>Label</a></tt> (strings such as "max" or "target" that
--   represent a single idea)</li>
--   <li><tt><a>Special</a></tt> characters (ex. unicode)</li>
--   <li><tt>Decorated</tt> symbols using <a>Atop</a></li>
--   <li><tt>Concatenations</tt> of symbols, including subscripts and
--   superscripts</li>
--   <li><tt><a>Empty</a></tt>! (this is to give this a monoid-like
--   flavour)</li>
--   </ul>
data Symbol

-- | Basic variable name creation.
Variable :: String -> Symbol

-- | For when symbols need more context, but we don't want to add a new
--   variable name. For example, <tt>v_f</tt> may be encoded as <tt>Concat
--   [variable "v", label "f"]</tt>.
Label :: String -> Symbol

-- | For using numbers in Symbols.
Integ :: Int -> Symbol

-- | For now, special characters are the degree and partial differentiation
--   symbols. These should eventually move elsewhere and the <a>Special</a>
--   type removed.
Special :: Special -> Symbol

-- | Used to decorate symbols. For things like vectors (which need to be
--   bold), primes, magnitudes, etc. See <a>Decoration</a> for more
--   details.
Atop :: Decoration -> Symbol -> Symbol

-- | Order of Symbols: upleft lowleft upright lowright base. Ex:
--   
--   <pre>
--   Corners [1]   [2]   [3]   [4]   [5]
--   </pre>
--   
--   <pre>
--   Visually:  [1]   [3]
--   
--                 [5]
--   
--              [2]   [4]
--   </pre>
Corners :: [Symbol] -> [Symbol] -> [Symbol] -> [Symbol] -> Symbol -> Symbol

-- | Concatentation of two symbols: <tt>[s1, s2] -&gt; s1s2</tt>
Concat :: [Symbol] -> Symbol

-- | Placeholder for when a symbol is not needed.
Empty :: Symbol

-- | The default compare function that sorts all the lower case symbols
--   after the upper case ones.
--   
--   Comparation is used twice for each <tt>Atomic</tt> case, once for
--   making sure they are the same letter, once for case sensitive. As far
--   as this comparison is considered, <tt>Δ</tt> is a "decoration" and
--   ignored unless the compared symbols are the exact same, in which case
--   it is ordered after the undecorated symbol.
--   
--   Superscripts and subscripts are ordered after the base symbols
--   (because they add additional context to a symbol). For example:
--   `v_f^{AB}` (expressed in LaTeX notation for clarity), where
--   <tt>v_f</tt> is a final velocity, and the `^{AB}` adds context that it
--   is the final velocity between points <tt>A</tt> and <tt>B</tt>. In
--   these cases, the sorting of `v_f^{AB}` should be following
--   <tt>v_f</tt> as it is logical to place it with its parent concept.
compsy :: Symbol -> Symbol -> Ordering


-- | Defining the core classes which represent knowledge-about-knowledge.
module Language.Drasil.Classes.Core

-- | The most basic item: having a unique identifier key, here a UID.
class HasUID c

-- | Provides a <i>unique</i> id for internal Drasil use.
uid :: HasUID c => Lens' c UID

-- | Members must have a reference address.
class HasRefAddress b

-- | Provides the ability to hold a reference address.
getRefAdd :: HasRefAddress b => b -> LblType

-- | A HasSymbol is anything which has a <a>Symbol</a>.
class HasSymbol c

-- | Provides the <a>Symbol</a> for a particular stage of generation.
symbol :: HasSymbol c => c -> Stage -> Symbol

-- | Members of this class have the ability to be referenced.
class (HasUID s, HasRefAddress s) => Referable s

-- | The referencing address (what we're linking to). Only visible in the
--   source (tex/html).
refAdd :: Referable s => s -> String

-- | Alternate form of reference.
renderRef :: Referable s => s -> LblType

module Language.Drasil.UID.Core

-- | Smart constructor for making a <a>UID</a> from a <a>String</a>.
uid :: String -> UID

-- | For when we need to modify a UID. We first take the base chunk's UID
--   and then append a suffix to it.
(+++) :: HasUID a => a -> String -> UID

-- | For when we need to append something to a UID.
(+++.) :: UID -> String -> UID
(+++!) :: (HasUID a, HasUID b) => a -> b -> UID

-- | Grabs the UID from something that has a UID and displays it as a
--   String.
showUID :: HasUID a => a -> String


-- | Routines to help with Symbols and Stages.
module Language.Drasil.Symbol.Helpers

-- | Helper function for getting a symbol in the Equational Stage.
eqSymb :: HasSymbol q => q -> Symbol

-- | Helper function for getting a symbol in the Implementation Stage.
codeSymb :: HasSymbol q => q -> Symbol

-- | Finds if a <a>Stage</a> symbol is real or Empty. True if real.
hasStageSymbol :: HasSymbol q => q -> Stage -> Bool

-- | Helper for creating a symbol with Unicode in it.
autoStage :: Symbol -> Stage -> Symbol

-- | Helper for creating a symbol with a hat ("^") atop it.
hat :: Symbol -> Symbol

-- | Helper for creating a Vector symbol.
prime :: Symbol -> Symbol

-- | Helper for creating a symbol that depends on the stage.
staged :: Symbol -> Symbol -> Stage -> Symbol

-- | Helper for creating a symbol with a subscript to the right. Arguments:
--   Base symbol, then subscripted symbol.
sub :: Symbol -> Symbol -> Symbol

-- | Helper for a common case of subscript, with a string Arguments: Base
--   symbol, then subscript <a>String</a>.
subStr :: Symbol -> String -> Symbol

-- | Helper for creating a symbol with a superscript to the right.
--   Arguments: Base symbol, then superscripted symbol.
sup :: Symbol -> Symbol -> Symbol

-- | Helper for autoStage that applies unicodeString to all <a>Symbol</a>s
--   with <a>String</a>s.
unicodeConv :: Symbol -> Symbol

-- | Helper for creating a symbol with a superscript on the left side of
--   the symbol. Arguments: Base symbol, then superscripted symbol.
upperLeft :: Symbol -> Symbol -> Symbol

-- | Helper for creating a Vector symbol.
vec :: Symbol -> Symbol

-- | Label smart constructor, requires non-empty labels
label :: String -> Symbol

-- | Variable smart constructor, requires non-empty variables
variable :: String -> Symbol


-- | Alphabet of capital/lowercase English letters as symbols.
module Language.Drasil.ShortHands

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cA :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cB :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cC :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cD :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cE :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cF :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cG :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cH :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cI :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cJ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cK :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cL :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cM :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cN :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cO :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cP :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cQ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cR :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cS :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cT :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cU :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cV :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cW :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cX :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cY :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cZ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lA :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lB :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lC :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lD :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lE :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lF :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lG :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lH :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lI :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lJ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lK :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lL :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lM :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lN :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lO :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lP :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lQ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lR :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lS :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lT :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lU :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lV :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lW :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lX :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lY :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lZ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lAlpha :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cAlpha :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lBeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cBeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lGamma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cGamma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lDelta :: Symbol

-- | <tt>Δ</tt> is often used as a decoration on top of a symbol. For
--   example, <tt>Δx</tt> and <tt>Δy</tt> represent the change in x and the
--   change in y. The variable defined here represents delta as its own
--   independent symbol and should not be used to represent "the change in"
--   something.
--   
--   Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cDelta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lEpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
vEpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cEpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lZeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cZeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lEta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cEta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lTheta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cTheta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lIota :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cIota :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lKappa :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cKappa :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lLambda :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cLambda :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lMu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cMu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lNu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cNu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lXi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cXi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lOmicron :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cOmicron :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cPi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lRho :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cRho :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lSigma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cSigma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lTau :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cTau :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lUpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cUpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPhi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
vPhi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cPhi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lChi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cChi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPsi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cPsi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lOmega :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cOmega :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lNabla :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lEll :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPosInf :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lNegInf :: Symbol

module Language.Drasil.ModelExpr.Class

-- | Helper for creating new smart constructors for Associative Binary
--   operations that require at least 1 expression.
assocCreate :: AssocBoolOper -> [ModelExpr] -> ModelExpr

-- | Helper for associative operations, removes embedded variants of the
--   same kind
assocSanitize :: AssocBoolOper -> [ModelExpr] -> [ModelExpr]
class ModelExprC r

-- | Gets the derivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
deriv :: (ModelExprC r, HasUID c, HasSymbol c) => r -> c -> r

-- | Gets the derivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
pderiv :: (ModelExprC r, HasUID c, HasSymbol c) => r -> c -> r

-- | One expression is "defined" by another.
defines :: ModelExprC r => r -> r -> r

-- | Space literals.
space :: ModelExprC r => Space -> r

-- | Check if a value belongs to a Space.
isIn :: ModelExprC r => r -> Space -> r

-- | Binary associative <a>Equivalence</a>.
equiv :: ModelExprC r => [r] -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
intAll :: ModelExprC r => Symbol -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
sumAll :: ModelExprC r => Symbol -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
prodAll :: ModelExprC r => Symbol -> r -> r
instance Language.Drasil.ModelExpr.Class.ModelExprC Language.Drasil.ModelExpr.Lang.ModelExpr


-- | Language for defining and manipulating units.
module Language.Drasil.UnitLang

-- | Language of units (how to build them up into a unit symbol). Of the
--   form (<a>Symbol</a> ^ <a>Integer</a>). The <a>Integer</a> may be
--   negative, but should not be zero.
newtype USymb
US :: [(Symbol, Integer)] -> USymb

-- | Language of unit equations, to define a unit relative to another.
data UDefn

-- | to define straight synonyms.
USynonym :: USymb -> UDefn

-- | scale, i.e. *.
UScale :: Double -> USymb -> UDefn

-- | shift, i.e. +.
UShift :: Double -> USymb -> UDefn

-- | When we define units, they come in three flavours: SI (base) units,
--   derived SI units (aka synonyms), and defined units. The type below
--   captures that knowledge.
data UnitSymbol
BaseSI :: USymb -> UnitSymbol
DerivedSI :: USymb -> USymb -> UDefn -> UnitSymbol
Defined :: USymb -> UDefn -> UnitSymbol

-- | Generates a default unit symbol.
fromUDefn :: UDefn -> USymb

-- | Hand-rolled version of compare. Should assume <a>USymb</a> is
--   normalized, so that some redundant EQ cases can be removed.
compUSymb :: USymb -> USymb -> Ordering

-- | Generates a default unit symbol.
getUSymb :: UnitSymbol -> USymb

-- | Gets the unit definition of a unit symbol.
getDefn :: UnitSymbol -> Maybe UDefn
instance GHC.Classes.Eq Language.Drasil.UnitLang.USymb


-- | Contains Sentences and helpers functions.
module Language.Drasil.Sentence

-- | For writing <a>Sentence</a>s via combining smaller elements.
--   <a>Sentence</a>s are made up of some known vocabulary of things:
--   
--   <ul>
--   <li>units (their visual representation)</li>
--   <li>words (via <a>String</a>s)</li>
--   <li>special characters</li>
--   <li>accented letters</li>
--   <li>references to specific layout objects</li>
--   </ul>
data Sentence

-- | Ch looks up the term for a given <a>UID</a> and displays the term with
--   a given <a>SentenceStyle</a> and <tt>CapitalizationRule</tt>. This
--   allows Sentences to hold plural forms of <tt>NounPhrase</tt>s and
--   <tt>NamedIdea</tt>s.
[Ch] :: SentenceStyle -> TermCapitalization -> UID -> Sentence

-- | A branch of Ch dedicated to SymbolStyle only.
[SyCh] :: UID -> Sentence

-- | Converts a unit symbol into a usable Sentence form.
[Sy] :: USymb -> Sentence

-- | Constructor for <a>String</a>s, used often for descriptions in Chunks.
[S] :: String -> Sentence

-- | Converts the graphical representation of a symbol into a usable
--   Sentence form.
[P] :: Symbol -> Sentence

-- | Lifts an expression into a Sentence.
[E] :: ModelExpr -> Sentence

-- | Takes a <a>UID</a> to a reference, a display name (<a>Sentence</a>),
--   and any additional reference display information (<a>RefInfo</a>).
--   Resolves the reference later (similar to Ch).
[Ref] :: UID -> Sentence -> RefInfo -> Sentence

-- | Adds quotation marks around a Sentence.
[Quote] :: Sentence -> Sentence

-- | Used for a % symbol.
[Percent] :: Sentence

-- | Direct concatenation of two Sentences (no implicit spaces!).
[:+:] :: Sentence -> Sentence -> Sentence

-- | Empty Sentence.
[EmptyS] :: Sentence
infixr 5 :+:

-- | Used in <a>Ch</a> constructor to determine the state of a term (can
--   record whether something is in plural form, a singular term, or in
--   short form).
data SentenceStyle
PluralTerm :: SentenceStyle
TermStyle :: SentenceStyle
ShortStyle :: SentenceStyle

-- | Holds any extra information needed for a <tt>Reference</tt>, be it an
--   equation, pages, a note, or nothing.
data RefInfo
None :: RefInfo
Equation :: [Int] -> RefInfo
Page :: [Int] -> RefInfo
RefNote :: String -> RefInfo

-- | Used in <a>Ch</a> constructor to determine the capitalization of a
--   term. CapF is for capitalizing the first word from the <a>UID</a> of
--   the given term. CapW is for capitalizing all words from the <a>UID</a>
--   of the given term. Mirrors <tt>CapFirst</tt> and <tt>CapWords</tt>
--   from <tt>CapitalizationRule</tt>.
data TermCapitalization
CapF :: TermCapitalization
CapW :: TermCapitalization
NoCap :: TermCapitalization

-- | Helper for concatenating two <a>Sentence</a>s with a space between
--   them.
(+:+) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two <a>Sentence</a>s using <a>+:+</a> and
--   appends a period.
(+:+.) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two sentences using <a>+:+</a> and appends a
--   colon.
(+:) :: Sentence -> Sentence -> Sentence

-- | Helper which appends a period to the end of a <a>Sentence</a> (used
--   often as a post-fix operator).
(!.) :: Sentence -> Sentence

-- | Capitalizes a Sentence.
capSent :: Sentence -> Sentence

-- | Gets a symbol and places it in a <a>Sentence</a>.
ch :: (HasUID c, HasSymbol c) => c -> Sentence
eS :: ModelExpr -> Sentence
eS' :: Express t => t -> Sentence

-- | Helper for concatenating two <a>Sentence</a>s with a comma and space
--   between them.
sC :: Sentence -> Sentence -> Sentence

-- | Helper for concatenating two <a>Sentence</a>s with a space-surrounded
--   dash between them.
sDash :: Sentence -> Sentence -> Sentence

-- | Helper for wrapping <a>Sentence</a>s in parentheses.
sParen :: Sentence -> Sentence

-- | Gets plural term of <a>UID</a>.
--   
--   Smart constructors for turning a <a>UID</a> into a <a>Sentence</a>.
sentencePlural :: UID -> Sentence

-- | Gets short form of <a>UID</a>.
--   
--   Smart constructors for turning a <a>UID</a> into a <a>Sentence</a>.
sentenceShort :: UID -> Sentence

-- | Gets symbol form of <a>UID</a>.
--   
--   Smart constructors for turning a <a>UID</a> into a <a>Sentence</a>.
sentenceSymb :: UID -> Sentence

-- | Gets singular form of <a>UID</a>.
--   
--   Smart constructors for turning a <a>UID</a> into a <a>Sentence</a>.
sentenceTerm :: UID -> Sentence
instance GHC.Base.Semigroup Language.Drasil.Sentence.Sentence
instance GHC.Base.Monoid Language.Drasil.Sentence.Sentence


-- | Short names are used for displaying references.
module Language.Drasil.ShortName

-- | Used for holding the short form of a name (as a <a>Sentence</a> with a
--   wrapper).
newtype ShortName
ShortNm :: Sentence -> ShortName

-- | Pulls the short form (as a <a>Sentence</a>) out of a <a>ShortName</a>.
getSentSN :: ShortName -> Sentence

-- | Smart constructor for making a <a>Sentence</a> into a
--   <a>ShortName</a>.
shortname' :: Sentence -> ShortName


-- | Defining the core classes which represent knowledge-about-knowledge.
--   For now, shortname must be here to avoid import cycles.
module Language.Drasil.Classes.Core2

-- | A <a>ShortName</a> is the text to be displayed for a link. Used for
--   referencing within a document that can include symbols and whatnot if
--   required. Visible in the typeset documents (pdf).
class HasShortName s
shortname :: HasShortName s => s -> ShortName


-- | Extract various kinds of UIDs from a Sentence. Used in conjunction
--   with the chunk database in order to render terms, symbols, and
--   references properly.
module Language.Drasil.Sentence.Extract

-- | This is to collect <i>symbolic</i> <a>UID</a>s that are printed out as
--   a <tt>Symbol</tt>.
sdep :: Sentence -> [UID]
shortdep :: Sentence -> [UID]

-- | Generic traverse of all positions that could lead to <i>reference</i>
--   <a>UID</a>s from <a>Sentence</a>s.
lnames :: Sentence -> [UID]

-- | Get <i>reference</i> <a>UID</a>s from <a>Sentence</a>s.
lnames' :: [Sentence] -> [UID]


-- | Defines a type used to hold referencing information.
module Language.Drasil.Reference

-- | A Reference contains the identifier (<a>UID</a>), a reference address
--   (<a>LblType</a>), a human-readable shortname (<a>ShortName</a>), and
--   any extra information about the reference (<a>RefInfo</a>).
data Reference
Reference :: UID -> LblType -> ShortName -> Reference

-- | Projector function that creates a <a>Reference</a> from something
--   <tt>Referable</tt>.
ref :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Reference

-- | Takes the reference <a>UID</a> and wraps it into a <a>Sentence</a>.
refS :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence

-- | Takes a <a>Reference</a> with a name to be displayed and wraps it into
--   a <a>Sentence</a>. Does not overwrite the shortname contained in the
--   reference, but will only display as the given <a>Sentence</a>.
namedRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence -> Sentence

-- | Takes a <a>Reference</a> with additional display info. Uses the
--   internal shortname for its display name.
complexRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> RefInfo -> Sentence

-- | Takes a <a>Reference</a> with a name to be displayed and any
--   additional information and wraps it into a <a>Sentence</a>. Does not
--   overwrite the shortname contained in the reference, but will only
--   display as the given <a>Sentence</a> along with the given
--   <a>RefInfo</a>.
namedComplexRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence -> RefInfo -> Sentence
instance GHC.Classes.Eq Language.Drasil.Reference.Reference
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Reference.Reference
instance Language.Drasil.Classes.Core.HasRefAddress Language.Drasil.Reference.Reference
instance Language.Drasil.Classes.Core2.HasShortName Language.Drasil.Reference.Reference


-- | Noun phrases are used to hold terms with knowledge of proper
--   capitalization and pluralization.
module Language.Drasil.NounPhrase.Core

-- | Capitalization rules.
data CapitalizationRule

-- | Capitalize the first letter of the first word only.
CapFirst :: CapitalizationRule

-- | Capitalize the first letter of each word.
CapWords :: CapitalizationRule

-- | Replace the noun phrase with the given <a>Sentence</a>. Used for
--   custom capitalization.
Replace :: Sentence -> CapitalizationRule

-- | For nouns and <tt>NounPhrase</tt>s. May be constructed from a proper
--   noun, common noun, or phrase (<a>Sentence</a>) and their respective
--   pluralization and capitalization rules.
data NP

-- | Stores a proper noun and its pluralization.
ProperNoun :: String -> PluralRule -> NP

-- | Stores a common noun and its pluralization.
CommonNoun :: String -> PluralRule -> CapitalizationRule -> NP

-- | Stores noun phrase and its pluralization. Phrase plurals can get very
--   odd, so it seems best (for now) to encode them directly. FIXME: If the
--   singular/plural phrase has special (replace) capitalization, one of
--   the two cannot be capitalized right now. The two capitalization rules
--   are for sentenceCase / titleCase respectively
Phrase :: Sentence -> PluralForm -> CapitalizationRule -> CapitalizationRule -> NP

-- | Synonym for <a>Sentence</a> typically used for plural forms.
type PluralForm = Sentence

-- | Pluralization rules.
data PluralRule

-- | Add "s" to the end of the noun phrase.
AddS :: PluralRule

-- | Add "e" to the end of the noun phrase.
AddE :: PluralRule

-- | Add "es" to the end of the noun phrase.
AddES :: PluralRule

-- | The noun phrase is already plural.
SelfPlur :: PluralRule

-- | Apply the given function to the noun phrase to get the plural.
IrregPlur :: (String -> String) -> PluralRule

module Language.Drasil.NounPhrase
class NounPhrase n

-- | Retrieves singular form of term. Ex. "the quick brown fox".
phraseNP :: NounPhrase n => n -> Sentence

-- | Retrieves plural form of term. Ex. "the quick brown foxes".
pluralNP :: NounPhrase n => n -> PluralForm

-- | Retrieves the singular form and applies a captalization rule (usually
--   capitalizes the first word) to produce a <a>Sentence</a>. Ex. "The
--   quick brown fox".
sentenceCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization

-- | Retrieves the singular form and applies a captalization rule (usually
--   capitalizes all words) to produce a <a>Sentence</a>. Ex. "The Quick
--   Brown Fox".
titleCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization

-- | For nouns and <tt>NounPhrase</tt>s. May be constructed from a proper
--   noun, common noun, or phrase (<a>Sentence</a>) and their respective
--   pluralization and capitalization rules.
data NP

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
atStartNP :: NounPhrase n => n -> Capitalization

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
atStartNP' :: NounPhrase n => n -> Capitalization

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP :: NounPhrase n => n -> Capitalization

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP' :: NounPhrase n => n -> Capitalization

-- | Self plural.
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn :: String -> NP

-- | Plural form simply adds "s" (ex. dog -&gt; dogs).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn' :: String -> NP

-- | Plural form adds "e" (ex. formula -&gt; formulae).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn'' :: String -> NP

-- | Plural form adds "es" (ex. bush -&gt; bushes).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn''' :: String -> NP

-- | Construct a common noun that pluralizes by dropping the last two
--   letters and adding an "ices" ending (ex. matrix -&gt; matrices).
cnICES :: String -> NP

-- | Constructs a common noun that pluralizes by dropping the last letter
--   and adding an "ies" ending (ex. body -&gt; bodies).
cnIES :: String -> NP

-- | Constructs a common noun that allows you to specify the pluralization
--   rule (as in <a>pnIrr</a>).
cnIP :: String -> PluralRule -> NP

-- | Constructs a common noun that pluralizes by dropping the last two
--   letters and adding "es" (ex. analysis -&gt; analyses).
cnIS :: String -> NP

-- | Common noun that allows you to specify both the pluralization rule and
--   the capitalization rule for sentence case (if the noun is used at the
--   beginning of a sentence).
cnIrr :: String -> PluralRule -> CapitalizationRule -> NP

-- | Constructs a common noun that pluralizes by dropping the last two
--   letters and adding "a" (ex. datum -&gt; data).
cnUM :: String -> NP

-- | Self plural.
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn :: String -> NP

-- | Plural form simply adds "s" (ex. Henderson -&gt; Hendersons).
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn' :: String -> NP

-- | Plural form adds "e".
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn'' :: String -> NP

-- | Plural form adds "es" (ex. Bush -&gt; Bushes).
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn''' :: String -> NP

-- | Constructs a <a>ProperNoun</a> with a custom plural rule (using
--   <a>IrregPlur</a> from <a>PluralRule</a>). First argument is the String
--   representing the noun, second is the rule.
pnIrr :: String -> PluralRule -> NP

-- | Creates a <a>NP</a> with a given singular and plural form (as
--   <a>String</a>s) that capitalizes the first letter of the first word
--   for sentence case.
nounPhrase :: String -> PluralString -> NP

-- | Similar to <a>nounPhrase</a>, but takes a specified capitalization
--   rule for the sentence case.
nounPhrase' :: String -> PluralString -> CapitalizationRule -> NP

-- | Custom noun phrase constructor that takes a singular form
--   (<a>Sentence</a>), plural form (<a>Sentence</a>), sentence case
--   capitalization rule, and title case capitalization rule.
nounPhrase'' :: Sentence -> PluralForm -> CapitalizationRule -> CapitalizationRule -> NP

-- | For things that should not be pluralized (or are self-plural). Works
--   like <a>nounPhrase</a>, but with only the first argument.
nounPhraseSP :: String -> NP

-- | Similar to nounPhrase, except it only accepts one <a>Sentence</a>.
--   Used for Requirements, Assumptions, LikelyChanges, etc. to allow for
--   referencing. Plural case is just <a>AddS</a>.
nounPhraseSent :: Sentence -> NP

-- | Combine two noun phrases. The singular form becomes <tt>phrase</tt>
--   from t1 followed by <tt>phrase</tt> of t2. The plural becomes
--   <tt>phrase</tt> of t1 followed by <tt>plural</tt> of t2. Uses standard
--   <a>CapFirst</a> sentence case and <a>CapWords</a> title case. For
--   example: <tt>compoundPhrase system constraint</tt> will have singular
--   form "system constraint" and plural "system constraints".
compoundPhrase :: (NounPhrase a, NounPhrase b) => a -> b -> NP

-- | Similar to <a>compoundPhrase</a>, but the sentence case is the same as
--   the title case (<a>CapWords</a>).
compoundPhrase' :: NP -> NP -> NP

-- | Similar to <a>compoundPhrase'</a>, but accepts two functions that will
--   be used to construct the plural form. For example,
--   <tt>compoundPhrase'' plural phrase system constraint</tt> would have
--   the plural form "systems constraint".
compoundPhrase'' :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Similar to <a>compoundPhrase</a>, but used when you need a special
--   function applied to the first term of both singular and pluralcases
--   (eg. short or plural).
compoundPhrase''' :: (NP -> Sentence) -> NP -> NP -> NP

-- | Similar to <a>compoundPhrase</a>, but pluralizes the first <a>NP</a>
--   for both singular and plural cases.
compoundPhraseP1 :: NP -> NP -> NP

-- | Capitalization rules.
data CapitalizationRule

-- | Capitalize the first letter of the first word only.
CapFirst :: CapitalizationRule

-- | Capitalize the first letter of each word.
CapWords :: CapitalizationRule

-- | Replace the noun phrase with the given <a>Sentence</a>. Used for
--   custom capitalization.
Replace :: Sentence -> CapitalizationRule

-- | Pluralization rules.
data PluralRule

-- | Add "s" to the end of the noun phrase.
AddS :: PluralRule

-- | Add "e" to the end of the noun phrase.
AddE :: PluralRule

-- | Add "es" to the end of the noun phrase.
AddES :: PluralRule

-- | The noun phrase is already plural.
SelfPlur :: PluralRule

-- | Apply the given function to the noun phrase to get the plural.
IrregPlur :: (String -> String) -> PluralRule
instance Language.Drasil.NounPhrase.NounPhrase Language.Drasil.NounPhrase.Core.NP


-- | Developing the expression language in Drasil. Re-export many things to
--   simplify external use.
module Language.Drasil.Development
class NounPhrase n

-- | Retrieves singular form of term. Ex. "the quick brown fox".
phraseNP :: NounPhrase n => n -> Sentence

-- | Retrieves plural form of term. Ex. "the quick brown foxes".
pluralNP :: NounPhrase n => n -> PluralForm

-- | This is to collect <i>symbolic</i> <a>UID</a>s that are printed out as
--   a <tt>Symbol</tt>.
sdep :: Sentence -> [UID]

-- | Generic traverse of all positions that could lead to <i>reference</i>
--   <a>UID</a>s from <a>Sentence</a>s.
lnames :: Sentence -> [UID]

-- | Get <i>reference</i> <a>UID</a>s from <a>Sentence</a>s.
lnames' :: [Sentence] -> [UID]

-- | Smart constructor for making a <a>UID</a> from a <a>String</a>.
uid :: String -> UID

-- | Grabs the UID from something that has a UID and displays it as a
--   String.
showUID :: HasUID a => a -> String


-- | For deriving equations in examples.
module Language.Drasil.Derivation

-- | Derivations are an ordered list of sentences and expressions. They are
--   rendered in order as paragraphs and equation blocks to display the
--   derivation.
data Derivation
Derivation :: Sentence -> [Sentence] -> Derivation

-- | Smart constructor for creating a <a>Derivation</a>.
mkDeriv :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but prepends "Detailed derivation of" to
--   the header.
mkDerivName :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but without a header <a>Sentence</a>.
mkDerivNoHeader :: [Sentence] -> Derivation


-- | References that have extra information.
module Language.Drasil.DecoratedReference

-- | For holding a <a>Reference</a> that is decorated with extra
--   information (ex. page numbers, equation sources, etc.).
data DecRef
DR :: Reference -> RefInfo -> DecRef
[_rf] :: DecRef -> Reference
[refInfo] :: DecRef -> RefInfo

-- | Same as <a>ref</a>, but for <a>DecRef</a> instead of <a>Reference</a>.
dRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> DecRef

-- | For creating a decorated reference (<a>DecRef</a>) with extra
--   reference information (<a>RefInfo</a>).
dRefInfo :: (HasUID r, HasRefAddress r, HasShortName r) => r -> RefInfo -> DecRef
instance GHC.Classes.Eq Language.Drasil.DecoratedReference.DecRef
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.DecoratedReference.DecRef
instance Language.Drasil.Classes.Core.HasRefAddress Language.Drasil.DecoratedReference.DecRef
instance Language.Drasil.Classes.Core2.HasShortName Language.Drasil.DecoratedReference.DecRef


-- | Defines the chunk type to hold citations.
module Language.Drasil.Chunk.Citation

-- | All citations require a unique identifier used by the Drasil chunk. We
--   will re-use the <a>UID</a> part as an EntryID (<a>String</a>) used for
--   creating reference links. Finally we will have the reference
--   information (<a>CitationKind</a>, <a>CiteField</a>s, and a
--   <a>ShortName</a>).
--   
--   Ex. A reference to a thesis paper like Koothoor's "Document driven
--   approach to certifying scientific computing software" would include
--   the affiliated university, publishing year, and city.
data Citation

-- | A list of <a>Citation</a>s.
type BibRef = [Citation]

-- | A <a>String</a> that should contain no spaces.
type EntryID = String
citeID :: Lens' Citation UID
citeKind :: Lens' Citation CitationKind

-- | Article citation requires author(s), title, journal, year. Optional
--   fields can be: volume, number, pages, month, and note. Implicitly uses
--   the EntryID as the chunk id.
cArticle :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by author.
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk id.
cBookA :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by editor.
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk id.
cBookE :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Booklet citation requires title. Optional fields can be author, how
--   published, address, month, year, note. Implicitly uses the EntryID as
--   the chunk id.
cBooklet :: String -> [CiteField] -> String -> Citation

-- | InBook citation by author.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id. This smart constructor includes both chapter
--   and page numbers.
cInBookACP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InBook citation by editor.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id. This smart constructor includes both chapter
--   and page numbers.
cInBookECP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookACP</a>.
--   
--   InBook citation excluding page numbers.
cInBookAC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookECP</a>.
--   
--   InBook citation excluding page numbers.
cInBookEC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookACP</a>.
--   
--   InBook citation excluding chapter.
cInBookAP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookECP</a>.
--   
--   InBook citation excluding chapter.
cInBookEP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InCollection citation requires author, title, bookTitle, publisher,
--   year. Optional fields can be editor, volume or number, series, type,
--   chapter, pages, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id.
cInCollection :: People -> String -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | InProceedings citation requires author, title, bookTitle, year.
--   Optional fields can be editor, volume or number, series, pages,
--   address, month, organization, publisher, and note. Implicitly uses the
--   EntryID as the chunk id.
cInProceedings :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Manual (technical documentation) citation requires title. Optional
--   fields can be author, organization, address, edition, month, year, and
--   note. Implicitly uses the EntryID as the chunk id.
cManual :: String -> [CiteField] -> String -> Citation

-- | Master's Thesis citation requires author, title, school, and year.
--   Optional fields can be type, address, month, and note. Implicitly uses
--   the EntryID as the chunk id.
cMThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Misc citation requires nothing. Optional fields can be author, title,
--   howpublished, month, year, and note. Implicitly uses the EntryID as
--   the chunk id.
cMisc :: [CiteField] -> String -> Citation

-- | PhD Thesis citation requires author, title, school, and year. Optional
--   fields can be type, address, month, and note. Implicitly uses the
--   EntryID as the chunk id.
cPhDThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Proceedings citation requires title and year. Optional fields can be
--   editor, volume or number, series, address, publisher, note, month, and
--   organization. Implicitly uses the EntryID as the chunk id.
cProceedings :: String -> Int -> [CiteField] -> String -> Citation

-- | Technical Report citation requires author, title, institution, and
--   year. Optional fields can be type, number, address, month, and note.
--   Implicitly uses the EntryID as the chunk id.
cTechReport :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Unpublished citation requires author, title, and note. Optional fields
--   can be month and year. Implicitly uses the EntryID as the chunk id.
cUnpublished :: People -> String -> String -> [CiteField] -> String -> Citation
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Citation.Citation
instance Language.Drasil.Classes.Core2.HasShortName Language.Drasil.Chunk.Citation.Citation
instance Language.Drasil.Classes.Citations.HasFields Language.Drasil.Chunk.Citation.Citation
instance Language.Drasil.Classes.Core.Referable Language.Drasil.Chunk.Citation.Citation
instance Language.Drasil.Classes.Core.HasRefAddress Language.Drasil.Chunk.Citation.Citation


-- | Contains types and functions common to aspects of generating
--   documents.
module Language.Drasil.Document.Core

-- | Denotes the different possible types that can be used as a list.
data ListType

-- | Bulleted list.
Bullet :: [(ItemType, Maybe String)] -> ListType

-- | Enumerated list.
Numeric :: [(ItemType, Maybe String)] -> ListType

-- | Simple list with items denoted by <tt>:</tt>. Renders as "Title: Item"
Simple :: [ListTuple] -> ListType

-- | Descriptive list, renders as "<b>Title: Item</b>" (see
--   <a>ListTuple</a>).
Desc :: [ListTuple] -> ListType

-- | Renders a list of "<tt><a>Title</a></tt> is the <tt>Item</tt>".
Definitions :: [ListTuple] -> ListType

-- | Denotes how something should behave in a list (<a>ListType</a>).
data ItemType

-- | Standard singular item.
Flat :: Sentence -> ItemType

-- | Nest a list (<a>ListType</a>) as an item.
Nested :: Header -> ListType -> ItemType

-- | MaxWidthPercent should be kept in the range 1-100. Values outside this
--   range may have unexpected results. Used for specifying max figure
--   width as <tt>pagewidth*MaxWidthPercent/100</tt>.
type MaxWidthPercent = Float
type Title = Sentence
type Author = Sentence
type Header = Sentence " Used when creating sublists."
type Depth = Int
type Width = Float
type Height = Float
type ListTuple = (Title, ItemType, Maybe String) " Formats as Title: Item. For use in lists."
type Filepath = String
type Lbl = Sentence " Label."

-- | Contents may be labelled or unlabelled.
data Contents
UlC :: UnlabelledContent -> Contents
LlC :: LabelledContent -> Contents

-- | Types of definitions (general, instance, theory, or data).
data DType
General :: DType
Instance :: DType
Theory :: DType
Data :: DType

-- | Types of layout objects we deal with explicitly.
data RawContent

-- | table has: header-row, data(rows), label/caption, and a bool that
--   determines whether or not to show label.
Table :: [Sentence] -> [[Sentence]] -> Title -> Bool -> RawContent

-- | Paragraphs are just sentences.
Paragraph :: Sentence -> RawContent

-- | Block of Equations holds an expression.
EqnBlock :: ModelExpr -> RawContent

-- | Grants the ability to label a group of <a>RawContent</a>.
DerivBlock :: Sentence -> [RawContent] -> RawContent

-- | For enumerated lists.
Enumeration :: ListType -> RawContent

-- | Defines something with a type, identifier, and <a>Contents</a>.
Defini :: DType -> [(Identifier, [Contents])] -> RawContent

-- | For creating figures in a document. Should use relative file path.
Figure :: Lbl -> Filepath -> MaxWidthPercent -> RawContent

-- | Grants the ability to reference something.
Bib :: BibRef -> RawContent

-- | Contain a graph with coordinates (<a>Sentence</a>s), maybe a width and
--   height, and a label (<a>Sentence</a>). | CodeBlock CodeExpr -- ^ Block
--   for codes TODO: Fill this one in.
Graph :: [(Sentence, Sentence)] -> Maybe Width -> Maybe Height -> Lbl -> RawContent

-- | An identifier is just a <a>String</a>.
type Identifier = String

-- | Contains a <a>Reference</a> and <a>RawContent</a>.
data LabelledContent
LblC :: Reference -> RawContent -> LabelledContent
[_ref] :: LabelledContent -> Reference
[_ctype] :: LabelledContent -> RawContent

-- | Only contains <a>RawContent</a>.
newtype UnlabelledContent
UnlblC :: RawContent -> UnlabelledContent
[_cntnts] :: UnlabelledContent -> RawContent
ref :: Lens' LabelledContent Reference
ctype :: Lens' LabelledContent RawContent
cntnts :: Iso' UnlabelledContent RawContent

-- | Members of this class must have <a>RawContent</a>.
class HasContents c

-- | Provides a <tt>Lens</tt> to the <a>RawContent</a>.
accessContents :: HasContents c => Lens' c RawContent

-- | Helper to prepend labels to <a>LabelledContent</a> when referencing.
prependLabel :: RawContent -> IRefProg
instance Language.Drasil.Document.Core.HasContents Language.Drasil.Document.Core.LabelledContent
instance Language.Drasil.Document.Core.HasContents Language.Drasil.Document.Core.UnlabelledContent
instance Language.Drasil.Document.Core.HasContents Language.Drasil.Document.Core.Contents
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Document.Core.LabelledContent
instance GHC.Classes.Eq Language.Drasil.Document.Core.LabelledContent
instance Language.Drasil.Classes.Core.HasRefAddress Language.Drasil.Document.Core.LabelledContent
instance Language.Drasil.Classes.Core2.HasShortName Language.Drasil.Document.Core.LabelledContent
instance Language.Drasil.Classes.Core.Referable Language.Drasil.Document.Core.LabelledContent


-- | Document Description Language.
module Language.Drasil.Document

-- | Section Contents are split into subsections or contents, where
--   contents are standard layout objects (see <a>Contents</a>).
data SecCons
Sub :: Section -> SecCons
Con :: Contents -> SecCons
data Partition
Sections :: Partition
Part :: Partition
Chapter :: Partition

-- | Sections have a title (<a>Sentence</a>), a list of contents
--   (<a>SecCons</a>) and a shortname (<a>Reference</a>).
data Section
Section :: Title -> [SecCons] -> Reference -> Section
[tle] :: Section -> Title
[cons] :: Section -> [SecCons]
[_lab] :: Section -> Reference
lab :: Lens' Section Reference

-- | A Document has a Title (<a>Sentence</a>), Author(s) (<a>Sentence</a>),
--   and <a>Section</a>s which hold the contents of the document.
data Document
Document :: Title -> Author -> ShowTableOfContents -> [Section] -> Document
Notebook :: Title -> Author -> [Section] -> Document

-- | Determines whether or not the table of contents appears on the
--   generated artifacts.
data ShowTableOfContents
ToC :: ShowTableOfContents
NoToC :: ShowTableOfContents

-- | Manually removes the first section of a document (table of contents
--   section). temp fix for Notebook (see if we need this in notebook
--   later)
checkToC :: Document -> Document

-- | Smart constructor for labelled content chunks.
llcc :: Reference -> RawContent -> LabelledContent

-- | Smart constructor for unlabelled content chunks (no <a>Reference</a>).
ulcc :: RawContent -> UnlabelledContent

-- | Smart constructor that wraps <a>UnlabelledContent</a> into
--   <a>Contents</a>.
mkParagraph :: Sentence -> Contents

-- | Smart constructor that wraps <a>LabelledContent</a> into
--   <a>Contents</a>.
mkFig :: Reference -> RawContent -> Contents

-- | Smart constructor similar to <a>llcc</a>, but takes in
--   <a>RawContent</a> first.
mkRawLC :: RawContent -> Reference -> LabelledContent

-- | Smart constructor for creating <a>Section</a>s with a title
--   (<a>Sentence</a>), introductory contents (ie. paragraphs, tables,
--   etc.), a list of subsections, and a shortname (<a>Reference</a>).
section :: Sentence -> [Contents] -> [Section] -> Reference -> Section

-- | Smart constructor for retrieving the contents (<a>Section</a>s) from a
--   <a>Document</a>.
extractSection :: Document -> [Section]

-- | Smart constructor for retrieving the subsections (<a>Section</a>s)
--   within a <a>Section</a>.
getSec :: Section -> [Section]

-- | Helper to retrieve subsections (<a>Section</a>s) from section contents
--   (<a>SecCons</a>).
getSecCons :: SecCons -> [Section]

-- | <a>Figure</a> smart constructor with a <a>Lbl</a> and a
--   <a>Filepath</a>. Assumes 100% of page width as max width.
fig :: Lbl -> Filepath -> RawContent

-- | <a>Figure</a> smart constructor that allows for customized max widths.
figWithWidth :: Lbl -> Filepath -> MaxWidthPercent -> RawContent

-- | Create a reference for a table. Takes in the name of a table (which
--   will also be used for its shortname).
makeTabRef :: String -> Reference

-- | Create a reference for a figure. Takes in the name of a figure (which
--   will also be used for its shortname).
makeFigRef :: String -> Reference

-- | Create a reference for a section. Takes in the name of a section and a
--   shortname for the section.
makeSecRef :: String -> Sentence -> Reference

-- | Create a reference for a equation. Takes in the name of the equation
--   (which will also be used for its shortname).
makeEqnRef :: String -> Reference

-- | Create a reference for a <a>URI</a>. Takes in a <a>UID</a> (as a
--   <a>String</a>), a reference address, and a shortname.
makeURI :: String -> String -> ShortName -> Reference

-- | Variants of <a>makeTabRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeTabRef' :: UID -> Reference

-- | Variants of <a>makeFigRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeFigRef' :: UID -> Reference

-- | Variants of <a>makeSecRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeSecRef' :: UID -> Sentence -> Reference

-- | Variants of <a>makeEqnRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeEqnRef' :: UID -> Reference

-- | Variants of <a>makeURI</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeURI' :: UID -> String -> ShortName -> Reference
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Document.Section
instance GHC.Classes.Eq Language.Drasil.Document.Section
instance Language.Drasil.Classes.Core2.HasShortName Language.Drasil.Document.Section
instance Language.Drasil.Classes.Core.Referable Language.Drasil.Document.Section
instance Language.Drasil.Classes.Core.HasRefAddress Language.Drasil.Document.Section


-- | Defining classes that represent knowledge about Documents.
module Language.Drasil.Classes.Document

-- | Some documents, as well as some pieces of knowledge, have citations.
class HasCitation c

-- | Provides a <tt>Lens</tt> to the citations.
getCitations :: HasCitation c => Lens' c [Citation]


-- | Defining all the classes which represent knowledge-about-knowledge.
module Language.Drasil.Classes

-- | A NamedIdea is a <a>term</a> that we've identified (has a <a>UID</a>)
--   as being worthy of naming.
class HasUID c => NamedIdea c

-- | Lens to the term (a noun phrase).
term :: NamedIdea c => Lens' c NP

-- | An <a>Idea</a> is the combination of a <a>NamedIdea</a> and a
--   <a>CommonIdea</a>. In other words, it <i>may</i> have an
--   acronym/abbreviation.
class NamedIdea c => Idea c

-- | Gets the acronym/abbreviation.
getA :: Idea c => c -> Maybe String

-- | CommonIdea is a <a>NamedIdea</a> with the additional constraint that
--   it <b>must</b> have an abbreviation.
class NamedIdea c => CommonIdea c

-- | Introduces abrv which necessarily provides an abbreviation.
abrv :: CommonIdea c => c -> String

-- | Concepts are <a>Idea</a>s with definitions and domains.
type Concept c = (Idea c, Definition c, ConceptDomain c)

-- | Defines a chunk.
class Definition c

-- | Provides (a <tt>Lens</tt> to) the definition for a chunk.
defn :: Definition c => Lens' c Sentence

-- | Some concepts have a domain (related information encoded in
--   <a>UID</a>s to other chunks).
class ConceptDomain c

-- | Provides Getter for the concept domain tags for a chunk
--   
--   <i>cdom</i> should be exported for use by the Drasil framework, but
--   should not be exported beyond that.
cdom :: ConceptDomain c => c -> [UID]

-- | A Quantity is an <a>Idea</a> with a <a>Space</a> and a
--   <tt>Symbol</tt>. In theory, it should also restrict to being a part of
--   <tt>MayHaveUnit</tt>, but that causes all sorts of import cycles (or
--   lots of orphans).
class (Idea c, HasSpace c, HasSymbol c) => Quantity c

-- | HasSpace is anything which has a <a>Space</a>.
class HasSpace c

-- | Provides a <tt>Lens</tt> to the <a>Space</a>.
typ :: HasSpace c => Lens' c Space

-- | Some chunks store a unit symbol.
class HasUnitSymbol u

-- | Provides the ability to hold a unit symbol (<a>USymb</a>).
usymb :: HasUnitSymbol u => u -> USymb

-- | A <a>Quantity</a> that could have a reasonable value.
class HasReasVal c

-- | Provides a <tt>Lens</tt> to the possible reasonable value.
reasVal :: HasReasVal c => Lens' c (Maybe Expr)

-- | The Constrained class is a <a>Quantity</a> that has value constraints.
--   It does not enforce <a>Quantity</a> at this point.
class Constrained c

-- | Provides a <tt>Lens</tt> to the <tt>Constraint</tt>s.
constraints :: Constrained c => Lens' c [ConstraintE]

-- | HasUncertainty is just a chunk with some uncertainty associated to it.
--   This uncertainty is represented as a decimal value between 0 and 1
--   (percentage).
class HasUncertainty c

-- | Provides the <tt>Lens</tt> to an <a>Uncertainty</a>.
unc :: HasUncertainty c => Lens' c Uncertainty

-- | Some chunks can be called like functions.
class (HasSymbol c) => Callable c

-- | Members must have a named argument.
class (HasSymbol c) => IsArgumentName c

-- | Records any additional notes needed to avoid losing information
class HasAdditionalNotes c

-- | Provides a <tt>Lens</tt> to the notes.
getNotes :: HasAdditionalNotes c => Lens' c [Sentence]

-- | Units are <a>Idea</a>s with a <a>Definition</a> which store a unit
--   symbol. They must also be explicitly declared to be instances of
--   IsUnit.
class (Idea u, Definition u, HasUnitSymbol u) => IsUnit u

-- | May have a unit definition.
udefn :: IsUnit u => u -> Maybe UDefn

-- | Holds units as a list of <a>UID</a>.
getUnits :: IsUnit u => u -> [UID]

-- | Contains a <a>UDefn</a>
class UnitEq u

-- | Provides the <tt>Lens</tt> to a unit definition.
uniteq :: UnitEq u => Lens' u UDefn

-- | A class that contains a list of <a>Reference</a>s.
class HasReference c

-- | Provides a <tt>Lens</tt> to the <a>Reference</a>s.
getReferences :: HasReference c => Lens' c [Reference]

-- | A class that contains a list of decorated references (<a>DecRef</a>s).
class HasDecRef c

-- | Provides a <tt>Lens</tt> to the <a>DecRef</a>s.
getDecRefs :: HasDecRef c => Lens' c [DecRef]

-- | Data that can be expressed using <a>ModelExpr</a>.
class Express c
express :: Express c => c -> ModelExpr

-- | A class that might have a <a>Derivation</a>.
class HasDerivation c

-- | Provides a <tt>Lens</tt> to a possible derivation.
derivations :: HasDerivation c => Lens' c (Maybe Derivation)
class DefiningExpr c

-- | Provides a <tt>Lens</tt> to the expression.
defnExpr :: (DefiningExpr c, Express e) => Lens' (c e) e


-- | Uncertainty functions.
module Language.Drasil.Uncertainty

-- | The default uncertainty is set to 0.1.
defaultUncrt :: Uncertainty

-- | Accessor for uncertainty value from something that has an uncertainty.
uncVal :: HasUncertainty x => x -> Double

-- | Accessor for precision value from something that has an uncertainty.
uncPrec :: HasUncertainty x => x -> Maybe Int

-- | Smart constructor for values with uncertainty.
uncty :: Double -> Maybe Int -> Uncertainty

-- | Smart constructor for exact values (no uncertainty).
exact :: Uncertainty

module Language.Drasil.Expr.Class
class ExprC r
($=) :: ExprC r => r -> r -> r
($!=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>=) :: ExprC r => r -> r -> r

-- | Smart constructor for the dot product of two equations.
($.) :: ExprC r => r -> r -> r

-- | Add two expressions (Integers).
addI :: ExprC r => r -> r -> r

-- | Add two expressions (Real numbers).
addRe :: ExprC r => r -> r -> r

-- | Multiply two expressions (Integers).
mulI :: ExprC r => r -> r -> r

-- | Multiply two expressions (Real numbers).
mulRe :: ExprC r => r -> r -> r
($-) :: ExprC r => r -> r -> r
($/) :: ExprC r => r -> r -> r
($^) :: ExprC r => r -> r -> r
($=>) :: ExprC r => r -> r -> r
($<=>) :: ExprC r => r -> r -> r
($&&) :: ExprC r => r -> r -> r
($||) :: ExprC r => r -> r -> r

-- | Smart constructor for taking the absolute value of an expression.
abs_ :: ExprC r => r -> r

-- | Smart constructor for negating an expression.
neg :: ExprC r => r -> r

-- | Smart constructor to take the log of an expression.
log :: ExprC r => r -> r

-- | Smart constructor to take the ln of an expression.
ln :: ExprC r => r -> r

-- | Smart constructor to take the square root of an expression.
sqrt :: ExprC r => r -> r

-- | Smart constructor to apply sin to an expression.
sin :: ExprC r => r -> r

-- | Smart constructor to apply cos to an expression.
cos :: ExprC r => r -> r

-- | Smart constructor to apply tan to an expression.
tan :: ExprC r => r -> r

-- | Smart constructor to apply sec to an expression.
sec :: ExprC r => r -> r

-- | Smart constructor to apply csc to an expression.
csc :: ExprC r => r -> r

-- | Smart constructor to apply cot to an expression.
cot :: ExprC r => r -> r

-- | Smart constructor to apply arcsin to an expression.
arcsin :: ExprC r => r -> r

-- | Smart constructor to apply arccos to an expression.
arccos :: ExprC r => r -> r

-- | Smart constructor to apply arctan to an expression.
arctan :: ExprC r => r -> r

-- | Smart constructor for the exponential (base e) function.
exp :: ExprC r => r -> r

-- | Smart constructor for calculating the dimension of a vector.
dim :: ExprC r => r -> r

-- | Smart constructor for calculating the normal form of a vector.
norm :: ExprC r => r -> r

-- | Smart constructor for negating vectors.
negVec :: ExprC r => r -> r

-- | Smart constructor for applying logical negation to an expression.
not_ :: ExprC r => r -> r

-- | Smart constructor for indexing.
idx :: ExprC r => r -> r -> r

-- | Smart constructor for integers.
int :: ExprC r => Integer -> r

-- | Smart constructor for doubles.
dbl :: ExprC r => Double -> r

-- | Smart constructor for exact doubles.
exactDbl :: ExprC r => Integer -> r

-- | Smart constructor for strings.
str :: ExprC r => String -> r

-- | Smart constructors for percents.
perc :: ExprC r => Integer -> Integer -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defint :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defsum :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defprod :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for 'real interval' membership.
realInterval :: (ExprC r, HasUID c) => c -> RealInterval r r -> r

-- | Euclidean function : takes a vector and returns the sqrt of the
--   sum-of-squares.
euclidean :: ExprC r => [r] -> r

-- | Smart constructor to cross product two expressions.
cross :: ExprC r => r -> r -> r

-- | Smart constructor for case statements with a complete set of cases.
completeCase :: ExprC r => [(r, r)] -> r

-- | Smart constructor for case statements with an incomplete set of cases.
incompleteCase :: ExprC r => [(r, r)] -> r

-- | Create a two-by-two matrix from four given values. For example:
--   
--   <pre>
--   &gt;&gt;&gt; m2x2 1 2 3 4
--   [ [1,2],
--     [3,4] ]
--   </pre>
m2x2 :: ExprC r => r -> r -> r -> r -> r

-- | Create a 2D vector (a matrix with two rows, one column). First
--   argument is placed above the second.
vec2D :: ExprC r => r -> r -> r

-- | Creates a diagonal two-by-two matrix. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dgnl2x2 1 2
--   [ [1, 0],
--     [0, 2] ]
--   </pre>
dgnl2x2 :: ExprC r => r -> r -> r

-- | Applies a given function with a list of parameters.
apply :: (ExprC r, HasUID f, HasSymbol f) => f -> [r] -> r

-- | Similar to <a>apply</a>, but takes a relation to apply to
--   <a>FCall</a>.
applyWithNamedArgs :: (ExprC r, HasUID f, HasSymbol f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Create an <a>Expr</a> from a <a>Symbol</a>ic Chunk.
sy :: (ExprC r, HasUID c, HasSymbol c) => c -> r
infixl 7 $/
infixr 8 $^
infixr 4 $=
infixr 9 $&&
infixr 9 $||

-- | Smart constructor for fractions.
frac :: ExprC r => Integer -> Integer -> r

-- | Smart constructor for rational expressions (only in 1/x form).
recip_ :: ExprC r => r -> r

-- | Smart constructor to square a function.
square :: ExprC r => r -> r

-- | Smart constructor to half a function exactly.
half :: ExprC r => r -> r

-- | 1/2, as an expression.
oneHalf :: ExprC r => r

-- | 1/3rd, as an expression.
oneThird :: ExprC r => r

-- | Similar to <a>apply</a>, but converts second argument into
--   <a>Symbol</a>s.
apply1 :: (ExprC r, HasUID f, HasSymbol f, HasUID a, HasSymbol a) => f -> a -> r

-- | Similar to <a>apply</a>, but the applied function takes two parameters
--   (which are both <a>Symbol</a>s).
apply2 :: (ExprC r, HasUID f, HasSymbol f, HasUID a, HasSymbol a, HasUID b, HasSymbol b) => f -> a -> b -> r
instance Language.Drasil.Expr.Class.ExprC Language.Drasil.Expr.Lang.Expr
instance Language.Drasil.Expr.Class.ExprC Language.Drasil.ModelExpr.Lang.ModelExpr


-- | Various helpers for building Sentences from other bits. Really ought
--   to be moved out to (likely) docLang, but is here for now.
module Language.Drasil.Development.Sentence

-- | Helper for getting the phrase from a <a>NamedIdea</a> using it's UID.
phrase :: (HasUID n, NamedIdea n) => n -> Sentence

-- | Helper for getting the plural of a phrase from a <a>NamedIdea</a>.
plural :: (HasUID n, NamedIdea n) => n -> Sentence

-- | Singular possesive function
--   
--   Helper for getting the possesive cases from the term of a
--   <a>NamedIdea</a>.
phrasePoss :: NamedIdea n => n -> Sentence

-- | Plural possesive function
--   
--   Helper for getting the possesive cases from the term of a
--   <a>NamedIdea</a>.
pluralPoss :: NamedIdea n => n -> Sentence

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   <a>NamedIdea</a>.
atStart :: NamedIdea n => n -> Sentence

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   <a>NamedIdea</a>.
atStart' :: NamedIdea n => n -> Sentence

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   <a>NamedIdea</a>.
titleize :: NamedIdea n => n -> Sentence

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   <a>NamedIdea</a>.
titleize' :: NamedIdea n => n -> Sentence

-- | Get short form (if it exists), else get term of an <a>Idea</a>.
short :: (Idea c, HasUID c) => c -> Sentence

-- | Helper for common pattern of introducing the title-case version of a
--   noun phrase (from an Idea) followed by its abbreviation in
--   parentheses.
introduceAbb :: Idea n => n -> Sentence


-- | The lowest level of chunks in Drasil. It all starts with an identifier
--   and a term.
module Language.Drasil.Chunk.NamedIdea

-- | Used for anything worth naming. Note that a <a>NamedChunk</a> does not
--   have an acronym/abbreviation as that's a <tt>CommonIdea</tt>, which
--   has its own representation. Contains a <a>UID</a> and a term that we
--   can capitalize or pluralize (<a>NP</a>).
--   
--   Ex. Anything worth naming must start out somewhere. Before we can
--   assign equations and values and symbols to something like the arm of a
--   pendulum, we must first give it a name.
data NamedChunk

-- | <a>IdeaDict</a> is the canonical dictionary associated to an
--   <a>Idea</a>. Contains a <a>NamedChunk</a> that could have an
--   abbreviation (<a>Maybe</a> <a>String</a>).
--   
--   Ex. The project name "Double Pendulum" may have the abbreviation
--   <a>DblPendulum</a>.
data IdeaDict

-- | <a>NamedChunk</a> constructor, takes a <a>String</a> for its
--   <a>UID</a> and a term.
nc :: String -> NP -> NamedChunk

-- | Similar to <a>nc</a>, but takes in the <a>UID</a> in the form of a
--   <a>UID</a> rather than a <a>String</a>.
ncUID :: UID -> NP -> NamedChunk

-- | Historical name: nw comes from 'named wrapped' from when
--   <a>NamedIdea</a> exported <a>getA</a> (now in <a>Idea</a>). But there
--   are no more wrappers, instead we have explicit dictionaries. Unwraps
--   an <a>Idea</a> and places its <a>UID</a> and <a>NP</a> into an
--   <a>IdeaDict</a> with <a>Nothing</a> for an abbreviation.
nw :: Idea c => c -> IdeaDict

-- | <a>IdeaDict</a> constructor, takes a <a>UID</a>, <a>NP</a>, and an
--   abbreviation in the form of <a>Maybe</a> <a>String</a>.
mkIdea :: String -> NP -> Maybe String -> IdeaDict

-- | Same as <a>mkIdea</a> but takes a <a>UID</a> rather than a
--   <a>String</a>.
mkIdeaUID :: UID -> NP -> Maybe String -> IdeaDict
instance GHC.Classes.Eq Language.Drasil.Chunk.NamedIdea.IdeaDict
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.NamedIdea.IdeaDict
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.NamedIdea.IdeaDict
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.NamedIdea.IdeaDict
instance GHC.Classes.Eq Language.Drasil.Chunk.NamedIdea.NamedChunk
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.NamedIdea.NamedChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.NamedIdea.NamedChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.NamedIdea.NamedChunk


-- | Contains the common idea type and respective constructors.
module Language.Drasil.Chunk.CommonIdea

-- | The common idea (with <tt>NounPhrase</tt>) data type. It must have a
--   <a>UID</a>, <tt>NounPhrase</tt> for its term, an abbreviation
--   (<a>String</a>), and a domain ([<a>UID</a>]). It is similar to
--   <a>NamedChunk</a> and <a>IdeaDict</a> in the sense that these are for
--   things worth naming, but this type also carries an abbreviation and
--   related domains of knowledge.
--   
--   Ex. The term "Operating System" has the abbreviation <a>OS</a> and
--   comes from the domain of computer science.
data CI

-- | The commonIdea smart constructor requires a chunk id (<a>String</a>),
--   a term (<a>NP</a>), an abbreviation (<a>String</a>), and a domain
--   ([<a>UID</a>]).
commonIdea :: String -> NP -> String -> [UID] -> CI

-- | Similar to <a>commonIdea</a>, but takes a list of <a>IdeaDict</a>
--   (often a domain).
commonIdeaWithDict :: String -> NP -> String -> [IdeaDict] -> CI

-- | Get abbreviation in <a>Sentence</a> form from a <a>CI</a>.
getAcc :: CI -> Sentence

-- | Get abbreviation in <a>String</a> form from a <a>CI</a>.
getAccStr :: CI -> String

-- | Prepends the abbreviation from a <a>CommonIdea</a> to a <a>String</a>.
prependAbrv :: CommonIdea c => c -> String -> String
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.CommonIdea.CI
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.CommonIdea.CI
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.CommonIdea.CI
instance Language.Drasil.Classes.CommonIdea Language.Drasil.Chunk.CommonIdea.CI
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.CommonIdea.CI


-- | Define concept-related chunks. A concept is usually something that has
--   a term, definition, and comes from some domain of knowledge.
module Language.Drasil.Chunk.Concept.Core

-- | The ConceptChunk datatype records a concept that contains an idea
--   (<a>IdeaDict</a>), a definition (<a>Sentence</a>), and an associated
--   domain of knowledge ([<a>UID</a>]).
--   
--   Ex. The concept of <a>Accuracy</a> may be defined as the quality or
--   state of being correct or precise.
data ConceptChunk
ConDict :: IdeaDict -> Sentence -> [UID] -> ConceptChunk

-- | Contains a common idea (<a>CI</a>) with a definition
--   (<a>Sentence</a>). Similar to <a>ConceptChunk</a>, but must have an
--   abbreviation.
data CommonConcept
ComConDict :: CI -> Sentence -> CommonConcept

-- | Contains a <a>ConceptChunk</a>, reference address, and a
--   <a>ShortName</a>. It is a concept that can be referred to, or rather,
--   a instance of where a concept is applied. Often used in Goal
--   Statements, Assumptions, Requirements, etc.
--   
--   Ex. Something like the assumption that gravity is 9.81 m/s. When we
--   write our equations, we can then link this assumption so that we do
--   not have to explicitly define that assumption when needed to verify
--   our work.
data ConceptInstance
ConInst :: ConceptChunk -> String -> ShortName -> ConceptInstance

-- | Check if something has one domain. Throws an error if there is more
--   than one.
sDom :: [UID] -> UID
instance GHC.Classes.Eq Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.Core2.HasShortName Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.Core.HasRefAddress Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance Language.Drasil.Classes.Core.Referable Language.Drasil.Chunk.Concept.Core.ConceptInstance
instance GHC.Classes.Eq Language.Drasil.Chunk.Concept.Core.CommonConcept
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Concept.Core.CommonConcept
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Concept.Core.CommonConcept
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Concept.Core.CommonConcept
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Concept.Core.CommonConcept
instance Language.Drasil.Classes.CommonIdea Language.Drasil.Chunk.Concept.Core.CommonConcept
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Concept.Core.CommonConcept
instance GHC.Classes.Eq Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Concept.Core.ConceptChunk
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Concept.Core.ConceptChunk


-- | Contains functions to create the concept related chunk types found in
--   <a>Language.Drasil.Chunk.Concept.Core</a>.
module Language.Drasil.Chunk.Concept

-- | The ConceptChunk datatype records a concept that contains an idea
--   (<a>IdeaDict</a>), a definition (<a>Sentence</a>), and an associated
--   domain of knowledge ([<a>UID</a>]).
--   
--   Ex. The concept of <a>Accuracy</a> may be defined as the quality or
--   state of being correct or precise.
data ConceptChunk

-- | Smart constructor for creating concept chunks given a <tt>UID</tt>,
--   <tt>NounPhrase</tt> (<a>NP</a>) and definition (as a <a>String</a>).
--   
--   Concept domain tagging is not yet implemented in this constructor.
dcc :: String -> NP -> String -> ConceptChunk

-- | Similar to <a>dcc</a>, except the definition takes a <a>Sentence</a>.
dccWDS :: String -> NP -> Sentence -> ConceptChunk

-- | Constructor for projecting an idea into a <a>ConceptChunk</a>. Takes
--   the definition of the <a>ConceptChunk</a> as a <a>String</a>. Does not
--   allow concept domain tagging.
cc :: Idea c => c -> String -> ConceptChunk

-- | Same as <a>cc</a>, except definition is a <a>Sentence</a>.
cc' :: Idea c => c -> Sentence -> ConceptChunk

-- | Similar to <a>cc'</a>, but allows explicit domain tagging.
ccs :: (Idea c, Concept d) => c -> Sentence -> [d] -> ConceptChunk

-- | For projecting out to the <a>ConceptChunk</a> data-type.
cw :: Concept c => c -> ConceptChunk

-- | Contains a common idea (<a>CI</a>) with a definition
--   (<a>Sentence</a>). Similar to <a>ConceptChunk</a>, but must have an
--   abbreviation.
data CommonConcept

-- | Identical to <a>dcc</a>, but takes an abbreviation (<a>String</a>) and
--   returns a <a>CommonConcept</a> instead.
dcc' :: String -> NP -> String -> String -> CommonConcept

-- | Similar to <a>dcc</a>, except the definition is a <a>Sentence</a>,
--   takes an abbreviation (<a>String</a>) and returns a
--   <a>CommonConcept</a> instead.
dccWDS' :: String -> NP -> Sentence -> String -> CommonConcept

-- | Contains a <a>ConceptChunk</a>, reference address, and a
--   <a>ShortName</a>. It is a concept that can be referred to, or rather,
--   a instance of where a concept is applied. Often used in Goal
--   Statements, Assumptions, Requirements, etc.
--   
--   Ex. Something like the assumption that gravity is 9.81 m/s. When we
--   write our equations, we can then link this assumption so that we do
--   not have to explicitly define that assumption when needed to verify
--   our work.
data ConceptInstance

-- | Constructor for a <a>ConceptInstance</a>. Takes in the Reference
--   Address (<a>String</a>), a definition (<a>Sentence</a>), a short name
--   (<a>String</a>), and a domain (for explicit tagging).
cic :: Concept c => String -> Sentence -> String -> c -> ConceptInstance


-- | For adding a relation (expression) to a concept.
module Language.Drasil.Chunk.Relation

-- | For a concept (<a>ConceptChunk</a>) that also has a <tt>Relation</tt>
--   (<a>ModelExpr</a>) attached.
--   
--   Ex. We can describe a pendulum arm and then apply an associated
--   equation so that we know its behaviour.
data RelationConcept

-- | Create a <a>RelationConcept</a> from a given <a>UID</a>, term
--   (<a>NP</a>), definition (<a>Sentence</a>), and <tt>Relation</tt>.
makeRC :: Express e => String -> NP -> Sentence -> e -> RelationConcept

-- | Create a new <a>RelationConcept</a> from an old <a>Concept</a>. Takes
--   a <a>Concept</a>, new <a>UID</a> and relation.
addRelToCC :: (Express e, Concept c) => c -> String -> e -> RelationConcept
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Relation.RelationConcept
instance GHC.Classes.Eq Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Relation.RelationConcept
instance Language.Drasil.ExprClasses.Express Language.Drasil.Chunk.Relation.RelationConcept


-- | For defining units built from a concept.
module Language.Drasil.Chunk.UnitDefn

-- | Types may contain a unit (<a>UnitDefn</a>).
class MayHaveUnit u
getUnit :: MayHaveUnit u => u -> Maybe UnitDefn

-- | Units are <a>Idea</a>s with a <a>Definition</a> which store a unit
--   symbol. They must also be explicitly declared to be instances of
--   IsUnit.
class (Idea u, Definition u, HasUnitSymbol u) => IsUnit u

-- | Holds units as a list of <a>UID</a>.
getUnits :: IsUnit u => u -> [UID]

-- | Temporary class to make sure chunks have a unit (in order to
--   eventually get rid of <a>MayHaveUnit</a>).
class TempHasUnit u
findUnit :: TempHasUnit u => u -> UnitDefn

-- | For defining units. It has a <a>ConceptChunk</a> (that defines what
--   kind of unit it is), a unit symbol, maybe another (when it is a
--   synonym), perhaps a definition, and a list of <a>UID</a> of the units
--   that make up the definition.
--   
--   Ex. Meter is a unit of length defined by the symbol (m).
data UnitDefn
UD :: ConceptChunk -> UnitSymbol -> [UID] -> UnitDefn
[_vc] :: UnitDefn -> ConceptChunk
[_cas] :: UnitDefn -> UnitSymbol
[_cu] :: UnitDefn -> [UID]

-- | Create a derived unit chunk from a concept and a unit equation.
makeDerU :: ConceptChunk -> UnitEquation -> UnitDefn

-- | Smart constructor for new derived units from existing units.
newUnit :: String -> UnitEquation -> UnitDefn

-- | Uses self-plural term.
--   
--   Create a derived unit chunk from a <a>UID</a>, term (<a>String</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Uses term that pluralizes by adding "s" to the end.
--   
--   Create a derived unit chunk from a <a>UID</a>, term (<a>String</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC' :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Create a derived unit chunk from a <a>UID</a>, term (<a>NP</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC'' :: String -> NP -> String -> Symbol -> UDefn -> UnitDefn

-- | Smart constructor for a "fundamental" unit.
fund :: String -> String -> String -> UnitDefn

-- | Variant of the <a>fund</a>, useful for degree.
fund' :: String -> String -> Symbol -> UnitDefn

-- | Create a <tt>SI_Unit</tt> with two <a>Symbol</a> representations. The
--   created <a>NP</a> is self-plural.
derCUC :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Similar to <a>derCUC</a>, but the created <a>NP</a> has the
--   <tt>AddS</tt> plural rule.
derCUC' :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Create a derived unit chunk from a <a>UID</a>, term (<a>NP</a>),
--   definition, <a>Symbol</a>, and unit equation.
derCUC'' :: String -> NP -> String -> Symbol -> UnitEquation -> UnitDefn

-- | For allowing lists to mix together chunks that are units by projecting
--   them into a <a>UnitDefn</a>. For now, this only works on
--   <a>UnitDefn</a>s.
unitWrapper :: IsUnit u => u -> UnitDefn

-- | Combinator for raising a unit to a power.
(^:) :: UnitDefn -> Integer -> UnitEquation

-- | Combinator for dividing one unit by another.
(/:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying two units together.
(*:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying a unit and a symbol.
(*$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for dividing a unit and a symbol.
(/$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for mulitiplying two unit equations.
(^$) :: UnitEquation -> UnitEquation -> UnitEquation

-- | Combinator for scaling one unit by some number.
scale :: IsUnit s => Double -> s -> UDefn

-- | Combinator for shifting one unit by some number.
shift :: IsUnit s => Double -> s -> UDefn

-- | Generates a default unit symbol.
fromUDefn :: UDefn -> USymb

-- | Helper for fundamental unit concept chunk creation. Uses the same
--   <a>String</a> for the identifier, term, and definition.
unitCon :: String -> ConceptChunk

-- | Get a list of <a>UID</a> of the units that make up the
--   <a>UnitEquation</a>.
getCu :: UnitEquation -> [UID]

-- | We don't want an Ord on units, but this still allows us to compare
--   them.
compUnitDefn :: UnitDefn -> UnitDefn -> Ordering
instance Language.Drasil.Classes.HasUnitSymbol Language.Drasil.Chunk.UnitDefn.UnitEquation
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.UnitDefn.UnitDefn
instance GHC.Classes.Eq Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.HasUnitSymbol Language.Drasil.Chunk.UnitDefn.UnitDefn
instance Language.Drasil.Classes.IsUnit Language.Drasil.Chunk.UnitDefn.UnitDefn


-- | Defines chunks that add quantities to an idea. Similar to
--   <tt>DefinedQuantityDict</tt>.
module Language.Drasil.Chunk.Quantity

-- | QuantityDict is a combination of an <a>IdeaDict</a> with a quantity.
--   Contains an <a>IdeaDict</a>, <a>Space</a>, a function from
--   <a>Stage</a> -&gt; <a>Symbol</a>, and <a>Maybe</a> a <a>UnitDefn</a>.
--   
--   Ex. A pendulum arm does not necessarily have to be defined as a
--   concept before we assign a space (Real numbers), a symbol (l), or
--   units (cm, m, etc.).
data QuantityDict

-- | Makes a <a>QuantityDict</a> from an <a>Idea</a>, <a>Symbol</a>, and
--   <a>Space</a>. <a>Symbol</a> is implementation-only.
codeVC :: Idea c => c -> Symbol -> Space -> QuantityDict

-- | Makes a variable that is implementation-only.
implVar :: String -> NP -> Space -> Symbol -> QuantityDict

-- | Similar to <a>implVar</a> but allows specification of abbreviation and
--   unit.
implVar' :: String -> NP -> Maybe String -> Space -> Symbol -> Maybe UnitDefn -> QuantityDict

-- | Similar to <a>implVar</a> but takes in a <a>UID</a> rather than a
--   <a>String</a>.
implVarUID :: UID -> NP -> Space -> Symbol -> QuantityDict

-- | Similar to <a>implVar'</a> but takes in a <a>UID</a> rather than a
--   <a>String</a>.
implVarUID' :: UID -> NP -> Maybe String -> Space -> Symbol -> Maybe UnitDefn -> QuantityDict

-- | Make a <a>QuantityDict</a> from a <a>UID</a>, <a>NP</a>,
--   <a>Symbol</a>, <a>Space</a>, <a>Maybe</a> <a>UnitDefn</a>, and an
--   abbreviation (<a>Maybe</a> <a>String</a>).
mkQuant :: String -> NP -> Symbol -> Space -> Maybe UnitDefn -> Maybe String -> QuantityDict

-- | Similar to <a>mkQuant</a>, but the abbreviation is moved to the third
--   argument (<a>Maybe</a> <a>String</a>), and the <a>Symbol</a> is now
--   dependent on <a>Stage</a>.
mkQuant' :: String -> NP -> Maybe String -> Space -> (Stage -> Symbol) -> Maybe UnitDefn -> QuantityDict

-- | Smart constructor for a <a>QuantityDict</a> from another
--   <a>Quantity</a> with units.
qw :: (Quantity q, MayHaveUnit q) => q -> QuantityDict

-- | Creates a <a>QuantityDict</a> from a <a>UID</a>, term (<a>NP</a>),
--   <a>Symbol</a>, and <a>Space</a>.
vc :: String -> NP -> Symbol -> Space -> QuantityDict

-- | Creates a <a>QuantityDict</a> from an <a>Idea</a>, <a>Symbol</a>, and
--   <a>Space</a>.
vc'' :: Idea c => c -> Symbol -> Space -> QuantityDict

-- | Similar to <a>vc</a>, but creates a <a>QuantityDict</a> from something
--   that knows about <a>Stage</a>s.
vcSt :: String -> NP -> (Stage -> Symbol) -> Space -> QuantityDict

-- | Creates a <a>QuantityDict</a> from a <a>UID</a>, term (<a>NP</a>),
--   <a>Symbol</a>, <a>Space</a>, and unit (<a>UnitDefn</a>).
vcUnit :: String -> NP -> Symbol -> Space -> UnitDefn -> QuantityDict
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Quantity.QuantityDict
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Quantity.QuantityDict
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Quantity.QuantityDict
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Quantity.QuantityDict
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Quantity.QuantityDict
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Quantity.QuantityDict
instance GHC.Classes.Eq Language.Drasil.Chunk.Quantity.QuantityDict
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Quantity.QuantityDict
instance Language.Drasil.ExprClasses.Express Language.Drasil.Chunk.Quantity.QuantityDict


-- | Defines chunks to add units to a quantity. Similar to
--   <tt>UnitalChunk</tt>.
module Language.Drasil.Chunk.Unitary

-- | A Unitary is a <a>Quantity</a> that <b>must</b> have a unit.
class (Quantity c) => Unitary c
unit :: Unitary c => c -> UnitDefn

-- | UnitaryChunks are for ideas with quantities that must have units.
--   Contains a <a>QuantityDict</a> and a <a>UnitDefn</a>.
--   
--   Ex. A pendulum arm is an idea associated with a symbol (l) and units
--   (cm, m, etc.).
data UnitaryChunk

-- | Makes a <a>UnitaryChunk</a> from a quantity with a unit.
mkUnitary :: (Unitary u, MayHaveUnit u) => u -> UnitaryChunk

-- | Builds the <a>QuantityDict</a> part from the <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, and <a>Space</a>. Assumes there's no
--   abbreviation.
unitary :: IsUnit u => String -> NP -> Symbol -> u -> Space -> UnitaryChunk

-- | Same as <a>unitary</a> but with a <a>Symbol</a> that changes based on
--   the <a>Stage</a>.
unitary' :: IsUnit u => String -> NP -> (Stage -> Symbol) -> u -> Space -> UnitaryChunk

-- | Helper for getting the unit's <a>Symbol</a> from a chunk, as opposed
--   to the symbols of the chunk itself.
unit_symb :: Unitary c => c -> USymb
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Unitary.UnitaryChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Unitary.UnitaryChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Unitary.UnitaryChunk
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Unitary.UnitaryChunk
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Unitary.UnitaryChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Unitary.UnitaryChunk
instance Language.Drasil.Chunk.Unitary.Unitary Language.Drasil.Chunk.Unitary.UnitaryChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Unitary.UnitaryChunk


-- | Named arguments used in generating code.
module Language.Drasil.Chunk.NamedArgument

-- | Any quantity can be a named argument (wrapper for
--   <a>QuantityDict</a>), but with more of a focus on generating code
--   arguments.
newtype NamedArgument
NA :: QuantityDict -> NamedArgument
[_qtd] :: NamedArgument -> QuantityDict

-- | Smart constructor for <a>NamedArgument</a> .
narg :: (Quantity q, MayHaveUnit q) => q -> NamedArgument
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.NamedArgument.NamedArgument
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.NamedArgument.NamedArgument
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.NamedArgument.NamedArgument
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.NamedArgument.NamedArgument
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.NamedArgument.NamedArgument
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.NamedArgument.NamedArgument
instance Language.Drasil.Classes.IsArgumentName Language.Drasil.Chunk.NamedArgument.NamedArgument
instance GHC.Classes.Eq Language.Drasil.Chunk.NamedArgument.NamedArgument
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.NamedArgument.NamedArgument


-- | Contains types that define quantities from concepts. Similar to
--   <tt>QuantityDict</tt>.
module Language.Drasil.Chunk.DefinedQuantity

-- | DefinedQuantityDict is the combination of a <a>Concept</a> and a
--   <a>Quantity</a>. Contains a <a>ConceptChunk</a>, a <a>Symbol</a>
--   dependent on <a>Stage</a>, a <a>Space</a>, and maybe a
--   <a>UnitDefn</a>. Used when we want to assign a quantity to a concept.
--   Includes the space, symbol, and units for that quantity.
--   
--   Ex. A pendulum arm can be defined as a concept with a symbol (l),
--   space (Real numbers), and units (cm, m, etc.).
data DefinedQuantityDict

-- | Smart constructor that creates a DefinedQuantityDict with a
--   <a>ConceptChunk</a>, a <a>Symbol</a> independent of <a>Stage</a>, a
--   <a>Space</a>, and a unit.
dqd :: IsUnit u => ConceptChunk -> Symbol -> Space -> u -> DefinedQuantityDict

-- | Similar to <a>dqd</a>, but without any units.
dqdNoUnit :: ConceptChunk -> Symbol -> Space -> DefinedQuantityDict

-- | Similar to <a>dqd</a>, but the <a>Symbol</a> is now dependent on the
--   <a>Stage</a>.
dqd' :: ConceptChunk -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> DefinedQuantityDict

-- | When we want to merge a quantity and a concept. This is suspicious.
dqdQd :: (Quantity c, MayHaveUnit c) => c -> ConceptChunk -> DefinedQuantityDict

-- | When the input already has all the necessary information. A
--   <tt>projection</tt> operator from some a type with instances of listed
--   classes to a <a>DefinedQuantityDict</a>.
dqdWr :: (Quantity c, Concept c, MayHaveUnit c) => c -> DefinedQuantityDict

-- | Temporary projection constructor, not to be used outside
--   <tt>drasil-lang</tt>.
tempdqdWr' :: (Quantity c, Concept c, MayHaveUnit c) => c -> DefinedQuantityDict
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance GHC.Classes.Eq Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict
instance Language.Drasil.ExprClasses.Express Language.Drasil.Chunk.DefinedQuantity.DefinedQuantityDict


-- | Defines chunks to add units to a quantity. Similar to
--   <tt>UnitaryChunk</tt>.
module Language.Drasil.Chunk.Unital

-- | Similar to a <a>DefinedQuantityDict</a>, UnitalChunks are concepts
--   with quantities that must have a unit definition. Contains
--   <a>DefinedQuantityDict</a>s and a <a>UnitDefn</a>.
--   
--   Ex. A pendulum arm is a tangible object with a symbol (l) and units
--   (cm, m, etc.).
data UnitalChunk
UC :: DefinedQuantityDict -> UnitDefn -> UnitalChunk
[_defq'] :: UnitalChunk -> DefinedQuantityDict
[_uni] :: UnitalChunk -> UnitDefn

-- | Creates a <a>UnitalChunk</a> in the same way as <a>uc'</a>, but with a
--   <a>Sentence</a> for the definition instead of a <a>String</a>.
makeUCWDS :: IsUnit u => String -> NP -> Sentence -> Symbol -> u -> UnitalChunk

-- | Used to create a <a>UnitalChunk</a> from a <a>Concept</a>,
--   <a>Symbol</a>, and <tt>Unit</tt>. Assumes the <a>Space</a> is Real.
uc :: (Concept c, IsUnit u) => c -> Symbol -> u -> UnitalChunk

-- | Similar to <a>uc</a>, except it builds the <a>Concept</a> portion of
--   the <a>UnitalChunk</a> from a given <tt>UID</tt>, term, and definition
--   (which are the first three arguments).
uc' :: IsUnit u => String -> NP -> String -> Symbol -> u -> UnitalChunk

-- | Similar to <a>uc'</a>, but <a>Symbol</a> is dependent on the
--   <a>Stage</a>.
ucStaged :: IsUnit u => String -> NP -> String -> (Stage -> Symbol) -> u -> UnitalChunk

-- | Similar to <a>uc'</a>, but does not assume the <a>Space</a>.
ucs :: IsUnit u => String -> NP -> String -> Symbol -> Space -> u -> UnitalChunk

-- | Similar to <a>uc</a> but does not assume the <a>Space</a>.
ucs' :: (Concept c, IsUnit u) => c -> Symbol -> Space -> u -> UnitalChunk

-- | Similar to <a>ucs</a>, but uses a <a>Sentence</a> for description.
ucsWS :: IsUnit u => String -> NP -> Sentence -> Symbol -> Space -> u -> UnitalChunk

-- | Attach units to a chunk that has a symbol and definition.
ucuc :: (Quantity c, Concept c, MayHaveUnit c) => c -> UnitDefn -> UnitalChunk

-- | Constructs a UnitalChunk from a <a>Concept</a> with <tt>Units</tt>.
ucw :: (Unitary c, Concept c, MayHaveUnit c) => c -> UnitalChunk
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Chunk.Unitary.Unitary Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.Chunk.UnitDefn.TempHasUnit Language.Drasil.Chunk.Unital.UnitalChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.Unital.UnitalChunk
instance Language.Drasil.ExprClasses.Express Language.Drasil.Chunk.Unital.UnitalChunk


-- | Contains chunks related to adding an expression to a quantitative
--   concept.
module Language.Drasil.Chunk.Eq
data QDefinition e

-- | Create a <a>QDefinition</a> with a <a>UID</a> (as a <a>String</a>),
--   term (<a>NP</a>), definition (<a>Sentence</a>), <a>Symbol</a>,
--   <a>Space</a>, unit, and defining expression.
fromEqn :: (Express e, IsUnit u) => String -> NP -> Sentence -> Symbol -> Space -> u -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but has no units.
fromEqn' :: Express e => String -> NP -> Sentence -> Symbol -> Space -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but symbol depends on stage.
fromEqnSt :: (Express e, IsUnit u) => UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> u -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but symbol depends on stage and has no units.
fromEqnSt' :: Express e => UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> e -> QDefinition e

-- | Same as <a>fromEqnSt'</a>, but takes a <a>String</a> instead of a
--   <a>UID</a>.
fromEqnSt'' :: Express e => String -> NP -> Sentence -> (Stage -> Symbol) -> Space -> e -> QDefinition e

-- | Wrapper for fromEqnSt and fromEqnSt'
mkQDefSt :: Express e => UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> e -> QDefinition e

-- | Used to help make <a>QDefinition</a>s when <a>UID</a>, term, and
--   <a>Symbol</a> come from the same source.
mkQuantDef :: (Quantity c, MayHaveUnit c, Express e) => c -> e -> QDefinition e

-- | Used to help make <a>QDefinition</a>s when <a>UID</a> and
--   <a>Symbol</a> come from the same source, with the term separate.
mkQuantDef' :: (Quantity c, MayHaveUnit c, Express e) => c -> NP -> e -> QDefinition e

-- | Smart constructor for QDefinitions. Requires a quantity and its
--   defining equation.
ec :: (Quantity c, MayHaveUnit c, Express e) => c -> e -> QDefinition e

-- | Create a <a>QDefinition</a> function with a symbol, name, term, list
--   of inputs, resultant units, and a defining Expr
mkFuncDef :: (HasUID f, HasSymbol f, HasSpace f, HasUID i, HasSymbol i, HasSpace i, IsUnit u, Express e) => f -> NP -> Sentence -> u -> [i] -> e -> QDefinition e

-- | Create a <a>QDefinition</a> function with a symbol, name, term, list
--   of inputs, and a defining Expr
mkFuncDef' :: (HasUID f, HasSymbol f, HasSpace f, HasUID i, HasSymbol i, HasSpace i, Express e) => f -> NP -> Sentence -> [i] -> e -> QDefinition e

-- | Create a <a>QDefinition</a> functions using a symbol, list of inputs,
--   and a defining Expr
mkFuncDefByQ :: (Quantity c, MayHaveUnit c, HasSpace c, Quantity i, HasSpace i, Express e) => c -> [i] -> e -> QDefinition e
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.Classes.Core.HasUID (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.Classes.NamedIdea (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.Classes.Idea (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.Classes.HasSpace (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.Classes.Core.HasSymbol (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.Classes.Definition (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.Classes.Quantity (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.ExprClasses.Express e => GHC.Classes.Eq (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.Chunk.UnitDefn.MayHaveUnit (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.Classes.DefiningExpr Language.Drasil.Chunk.Eq.QDefinition
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.ExprClasses.Express (Language.Drasil.Chunk.Eq.QDefinition e)
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.Classes.ConceptDomain (Language.Drasil.Chunk.Eq.QDefinition e)


-- | Parameterized types, at times, deserve their own names.
module Language.Drasil.Synonyms

-- | Commonly used type for QDefinitions containing Exprs.
type SimpleQDef = QDefinition Expr

-- | Commonly used type for QDefinitions containing ModelExprs.
type ModelQDef = QDefinition ModelExpr

-- | Commonly used type for polymorphic Exprs.
type PExpr = forall r. ExprC r => r


-- | Add constraints and a reasonable value to chunks that are quantities.
module Language.Drasil.Chunk.Constrained

-- | ConstrainedChunks are symbolic quantities (<a>QuantityDict</a>) with
--   <tt>Constraint</tt>s and maybe a typical value (<a>Maybe</a>
--   <a>Expr</a>).
--   
--   Ex. Measuring the length of a pendulum would have some reasonable
--   value (between 1 cm and 2 m) and the constraint that the length cannot
--   be a negative value.
data ConstrainedChunk
ConstrainedChunk :: QuantityDict -> [ConstraintE] -> Maybe Expr -> ConstrainedChunk
[_qd] :: ConstrainedChunk -> QuantityDict
[_constr] :: ConstrainedChunk -> [ConstraintE]
[_reasV] :: ConstrainedChunk -> Maybe Expr

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, unit, <a>Space</a>, <tt>Constraint</tt>s,
--   and an <a>Expr</a>.
cuc :: IsUnit u => String -> NP -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> ConstrainedChunk

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, <a>Space</a>, <tt>Constraint</tt>s, and a
--   <a>Maybe</a> <a>Expr</a> (Similar to <a>cuc</a> but no units).
cvc :: String -> NP -> Symbol -> Space -> [ConstraintE] -> Maybe Expr -> ConstrainedChunk

-- | Creates a new ConstrainedChunk from either a <a>ConstrainedChunk</a>,
--   <a>ConstrConcept</a>, <tt>UncertainChunk</tt>, or an <tt>UncertQ</tt>.
cnstrw :: (Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> ConstrainedChunk

-- | ConstrConcepts are conceptual symbolic quantities
--   (<a>DefinedQuantityDict</a>) with <tt>Constraint</tt>s and maybe a
--   reasonable value (no units!). Similar to <a>ConstrainedChunk</a> but
--   includes a definition and domain.
--   
--   Ex. Measuring the length of a pendulum arm could be a concept that has
--   some reasonable value (between 1 cm and 2 m) and the constraint that
--   the length cannot be a negative value.
data ConstrConcept
ConstrConcept :: DefinedQuantityDict -> [ConstraintE] -> Maybe Expr -> ConstrConcept
[_defq] :: ConstrConcept -> DefinedQuantityDict
[_constr'] :: ConstrConcept -> [ConstraintE]
[_reasV'] :: ConstrConcept -> Maybe Expr

-- | Similar to <a>cnstrw</a>, but types must also have a <a>Concept</a>.
cnstrw' :: (Quantity c, Concept c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> ConstrConcept

-- | Creates a <a>ConstrConcept</a> with a quantitative concept, a list of
--   <tt>Constraint</tt>s and an <a>Expr</a>.
constrained' :: (Concept c, MayHaveUnit c, Quantity c) => c -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to <a>constrained'</a>, but defaults <a>Maybe</a> <a>Expr</a>
--   to <a>Nothing</a>.
constrainedNRV' :: (Concept c, MayHaveUnit c, Quantity c) => c -> [ConstraintE] -> ConstrConcept

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), description (<a>String</a>), <a>Symbol</a>, unit,
--   <a>Space</a>, <tt>Constraint</tt>s, and an <a>Expr</a>.
cuc' :: IsUnit u => String -> NP -> String -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to <a>cuc'</a>, but <a>Symbol</a> is dependent on
--   <a>Stage</a>.
cuc'' :: IsUnit u => String -> NP -> String -> (Stage -> Symbol) -> u -> Space -> [ConstraintE] -> Expr -> ConstrConcept
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Constrained Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.HasReasVal Language.Drasil.Chunk.Constrained.ConstrConcept
instance GHC.Classes.Eq Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.ExprClasses.Express Language.Drasil.Chunk.Constrained.ConstrConcept
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Classes.Constrained Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Classes.HasReasVal Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.Constrained.ConstrainedChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.Constrained.ConstrainedChunk


-- | For adding an uncertainty value to quantities with constraints.
module Language.Drasil.Chunk.UncertainQuantity

-- | UncertQs are conceptual symbolic quantities with constraints and an
--   <a>Uncertainty</a>. Contains a <a>ConstrConcept</a> and an
--   <a>Uncertainty</a>.
--   
--   Ex. Measuring the length of a pendulum arm may be recorded with an
--   uncertainty value.
data UncertQ

-- | UncertainChunk is a symbolic quantity with constraints, a typical
--   value, and an uncertainty. Contains a <a>ConstrainedChunk</a> and an
--   <a>Uncertainty</a>.
--   
--   Ex. Measuring the length of a pendulum arm may be recorded with an
--   uncertainty value.
data UncertainChunk
UCh :: ConstrainedChunk -> Uncertainty -> UncertainChunk
[_conc] :: UncertainChunk -> ConstrainedChunk
[_unc'] :: UncertainChunk -> Uncertainty

-- | Smart constructor that requires a <a>Quantity</a>, a percentage, and a
--   typical value with an <a>Uncertainty</a>.
uq :: (Quantity c, Constrained c, Concept c, HasReasVal c, MayHaveUnit c) => c -> Uncertainty -> UncertQ

-- | Uncertainty quantity (<a>uq</a>) but with a constraint.
uqc :: IsUnit u => String -> NP -> String -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertQ

-- | Uncertainty quantity constraint (<a>uqc</a>) without a description.
uqcND :: IsUnit u => String -> NP -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertQ

-- | Smart constructor that can project to an <a>UncertainChunk</a> (also
--   given an <a>Uncertainty</a>).
uncrtnChunk :: (Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> Uncertainty -> UncertainChunk

-- | Creates an uncertain variable chunk. Takes <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, <a>Space</a>, <tt>Constrains</tt>,
--   <a>Expr</a>, and <a>Uncertainty</a>.
uvc :: String -> NP -> Symbol -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertainChunk

-- | Projection function into an <a>UncertainChunk</a> from <a>UncertQ</a>
--   or an <a>UncertainChunk</a>.
uncrtnw :: (HasUncertainty c, Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> UncertainChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.HasUncertainty Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Constrained Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.HasReasVal Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Definition Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.ConceptDomain Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.ExprClasses.Express Language.Drasil.Chunk.UncertainQuantity.UncertQ
instance Language.Drasil.Classes.Core.HasUID Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.NamedIdea Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.Idea Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.HasSpace Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.Core.HasSymbol Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.Constrained Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.HasReasVal Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Classes.HasUncertainty Language.Drasil.Chunk.UncertainQuantity.UncertainChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.UncertainQuantity.UncertainChunk


-- | The Drasil language, including expressions, chunks, sentences,
--   references, classes, datatypes, and generally useful functions.
--   Re-exports modules to simplify external use.
module Language.Drasil

-- | Drasil expressions.
data Expr
class ExprC r
($=) :: ExprC r => r -> r -> r
($!=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>=) :: ExprC r => r -> r -> r

-- | Smart constructor for the dot product of two equations.
($.) :: ExprC r => r -> r -> r

-- | Add two expressions (Integers).
addI :: ExprC r => r -> r -> r

-- | Add two expressions (Real numbers).
addRe :: ExprC r => r -> r -> r

-- | Multiply two expressions (Integers).
mulI :: ExprC r => r -> r -> r

-- | Multiply two expressions (Real numbers).
mulRe :: ExprC r => r -> r -> r
($-) :: ExprC r => r -> r -> r
($/) :: ExprC r => r -> r -> r
($^) :: ExprC r => r -> r -> r
($=>) :: ExprC r => r -> r -> r
($<=>) :: ExprC r => r -> r -> r
($&&) :: ExprC r => r -> r -> r
($||) :: ExprC r => r -> r -> r

-- | Smart constructor for taking the absolute value of an expression.
abs_ :: ExprC r => r -> r

-- | Smart constructor for negating an expression.
neg :: ExprC r => r -> r

-- | Smart constructor to take the log of an expression.
log :: ExprC r => r -> r

-- | Smart constructor to take the ln of an expression.
ln :: ExprC r => r -> r

-- | Smart constructor to take the square root of an expression.
sqrt :: ExprC r => r -> r

-- | Smart constructor to apply sin to an expression.
sin :: ExprC r => r -> r

-- | Smart constructor to apply cos to an expression.
cos :: ExprC r => r -> r

-- | Smart constructor to apply tan to an expression.
tan :: ExprC r => r -> r

-- | Smart constructor to apply sec to an expression.
sec :: ExprC r => r -> r

-- | Smart constructor to apply csc to an expression.
csc :: ExprC r => r -> r

-- | Smart constructor to apply cot to an expression.
cot :: ExprC r => r -> r

-- | Smart constructor to apply arcsin to an expression.
arcsin :: ExprC r => r -> r

-- | Smart constructor to apply arccos to an expression.
arccos :: ExprC r => r -> r

-- | Smart constructor to apply arctan to an expression.
arctan :: ExprC r => r -> r

-- | Smart constructor for the exponential (base e) function.
exp :: ExprC r => r -> r

-- | Smart constructor for calculating the dimension of a vector.
dim :: ExprC r => r -> r

-- | Smart constructor for calculating the normal form of a vector.
norm :: ExprC r => r -> r

-- | Smart constructor for negating vectors.
negVec :: ExprC r => r -> r

-- | Smart constructor for applying logical negation to an expression.
not_ :: ExprC r => r -> r

-- | Smart constructor for indexing.
idx :: ExprC r => r -> r -> r

-- | Smart constructor for integers.
int :: ExprC r => Integer -> r

-- | Smart constructor for doubles.
dbl :: ExprC r => Double -> r

-- | Smart constructor for exact doubles.
exactDbl :: ExprC r => Integer -> r

-- | Smart constructor for strings.
str :: ExprC r => String -> r

-- | Smart constructors for percents.
perc :: ExprC r => Integer -> Integer -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defint :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defsum :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defprod :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for 'real interval' membership.
realInterval :: (ExprC r, HasUID c) => c -> RealInterval r r -> r

-- | Euclidean function : takes a vector and returns the sqrt of the
--   sum-of-squares.
euclidean :: ExprC r => [r] -> r

-- | Smart constructor to cross product two expressions.
cross :: ExprC r => r -> r -> r

-- | Smart constructor for case statements with a complete set of cases.
completeCase :: ExprC r => [(r, r)] -> r

-- | Smart constructor for case statements with an incomplete set of cases.
incompleteCase :: ExprC r => [(r, r)] -> r

-- | Create a two-by-two matrix from four given values. For example:
--   
--   <pre>
--   &gt;&gt;&gt; m2x2 1 2 3 4
--   [ [1,2],
--     [3,4] ]
--   </pre>
m2x2 :: ExprC r => r -> r -> r -> r -> r

-- | Create a 2D vector (a matrix with two rows, one column). First
--   argument is placed above the second.
vec2D :: ExprC r => r -> r -> r

-- | Creates a diagonal two-by-two matrix. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dgnl2x2 1 2
--   [ [1, 0],
--     [0, 2] ]
--   </pre>
dgnl2x2 :: ExprC r => r -> r -> r

-- | Applies a given function with a list of parameters.
apply :: (ExprC r, HasUID f, HasSymbol f) => f -> [r] -> r

-- | Similar to <a>apply</a>, but takes a relation to apply to
--   <a>FCall</a>.
applyWithNamedArgs :: (ExprC r, HasUID f, HasSymbol f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Create an <a>Expr</a> from a <a>Symbol</a>ic Chunk.
sy :: (ExprC r, HasUID c, HasSymbol c) => c -> r
infixl 7 $/
infixr 8 $^
infixr 4 $=
infixr 9 $&&
infixr 9 $||

-- | Smart constructor for fractions.
frac :: ExprC r => Integer -> Integer -> r

-- | Smart constructor for rational expressions (only in 1/x form).
recip_ :: ExprC r => r -> r

-- | Smart constructor to square a function.
square :: ExprC r => r -> r

-- | Smart constructor to half a function exactly.
half :: ExprC r => r -> r

-- | 1/2, as an expression.
oneHalf :: ExprC r => r

-- | 1/3rd, as an expression.
oneThird :: ExprC r => r

-- | Similar to <a>apply</a>, but converts second argument into
--   <a>Symbol</a>s.
apply1 :: (ExprC r, HasUID f, HasSymbol f, HasUID a, HasSymbol a) => f -> a -> r

-- | Similar to <a>apply</a>, but the applied function takes two parameters
--   (which are both <a>Symbol</a>s).
apply2 :: (ExprC r, HasUID f, HasSymbol f, HasUID a, HasSymbol a, HasUID b, HasSymbol b) => f -> a -> b -> r

-- | For case expressions (either complete or incomplete).
data Completeness

-- | A relation is just an expression (<a>Expr</a>).
type Relation = Expr

-- | Drasil expressions.
data ModelExpr

-- | Determines the type of the derivative (either a partial derivative or
--   a total derivative).
data DerivType
class ModelExprC r

-- | Gets the derivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
deriv :: (ModelExprC r, HasUID c, HasSymbol c) => r -> c -> r

-- | Gets the derivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
pderiv :: (ModelExprC r, HasUID c, HasSymbol c) => r -> c -> r

-- | One expression is "defined" by another.
defines :: ModelExprC r => r -> r -> r

-- | Space literals.
space :: ModelExprC r => Space -> r

-- | Check if a value belongs to a Space.
isIn :: ModelExprC r => r -> Space -> r

-- | Binary associative <a>Equivalence</a>.
equiv :: ModelExprC r => [r] -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
intAll :: ModelExprC r => Symbol -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
sumAll :: ModelExprC r => Symbol -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
prodAll :: ModelExprC r => Symbol -> r -> r

-- | Special characters include partial derivatives and the degree circle.
data Special
Partial :: Special
Circle :: Special

-- | Class for rendering special characters.
class RenderSpecial r
special :: RenderSpecial r => Special -> r

-- | The most basic item: having a unique identifier key, here a UID.
class HasUID c

-- | Provides a <i>unique</i> id for internal Drasil use.
uid :: HasUID c => Lens' c UID

-- | A HasSymbol is anything which has a <a>Symbol</a>.
class HasSymbol c

-- | Provides the <a>Symbol</a> for a particular stage of generation.
symbol :: HasSymbol c => c -> Stage -> Symbol

-- | A NamedIdea is a <a>term</a> that we've identified (has a <a>UID</a>)
--   as being worthy of naming.
class HasUID c => NamedIdea c

-- | Lens to the term (a noun phrase).
term :: NamedIdea c => Lens' c NP

-- | An <a>Idea</a> is the combination of a <a>NamedIdea</a> and a
--   <a>CommonIdea</a>. In other words, it <i>may</i> have an
--   acronym/abbreviation.
class NamedIdea c => Idea c

-- | Gets the acronym/abbreviation.
getA :: Idea c => c -> Maybe String

-- | CommonIdea is a <a>NamedIdea</a> with the additional constraint that
--   it <b>must</b> have an abbreviation.
class NamedIdea c => CommonIdea c

-- | Introduces abrv which necessarily provides an abbreviation.
abrv :: CommonIdea c => c -> String

-- | Defines a chunk.
class Definition c

-- | Provides (a <tt>Lens</tt> to) the definition for a chunk.
defn :: Definition c => Lens' c Sentence

-- | Some concepts have a domain (related information encoded in
--   <a>UID</a>s to other chunks).
class ConceptDomain c

-- | Provides Getter for the concept domain tags for a chunk
--   
--   <i>cdom</i> should be exported for use by the Drasil framework, but
--   should not be exported beyond that.
cdom :: ConceptDomain c => c -> [UID]

-- | Concepts are <a>Idea</a>s with definitions and domains.
type Concept c = (Idea c, Definition c, ConceptDomain c)

-- | HasSpace is anything which has a <a>Space</a>.
class HasSpace c

-- | Provides a <tt>Lens</tt> to the <a>Space</a>.
typ :: HasSpace c => Lens' c Space

-- | Some chunks store a unit symbol.
class HasUnitSymbol u

-- | Provides the ability to hold a unit symbol (<a>USymb</a>).
usymb :: HasUnitSymbol u => u -> USymb

-- | A Quantity is an <a>Idea</a> with a <a>Space</a> and a
--   <tt>Symbol</tt>. In theory, it should also restrict to being a part of
--   <tt>MayHaveUnit</tt>, but that causes all sorts of import cycles (or
--   lots of orphans).
class (Idea c, HasSpace c, HasSymbol c) => Quantity c

-- | A <a>Quantity</a> that could have a reasonable value.
class HasReasVal c

-- | Provides a <tt>Lens</tt> to the possible reasonable value.
reasVal :: HasReasVal c => Lens' c (Maybe Expr)

-- | HasUncertainty is just a chunk with some uncertainty associated to it.
--   This uncertainty is represented as a decimal value between 0 and 1
--   (percentage).
class HasUncertainty c

-- | Provides the <tt>Lens</tt> to an <a>Uncertainty</a>.
unc :: HasUncertainty c => Lens' c Uncertainty

-- | The Constrained class is a <a>Quantity</a> that has value constraints.
--   It does not enforce <a>Quantity</a> at this point.
class Constrained c

-- | Provides a <tt>Lens</tt> to the <tt>Constraint</tt>s.
constraints :: Constrained c => Lens' c [ConstraintE]

-- | Records any additional notes needed to avoid losing information
class HasAdditionalNotes c

-- | Provides a <tt>Lens</tt> to the notes.
getNotes :: HasAdditionalNotes c => Lens' c [Sentence]

-- | A class that might have a <a>Derivation</a>.
class HasDerivation c

-- | Provides a <tt>Lens</tt> to a possible derivation.
derivations :: HasDerivation c => Lens' c (Maybe Derivation)

-- | Units are <a>Idea</a>s with a <a>Definition</a> which store a unit
--   symbol. They must also be explicitly declared to be instances of
--   IsUnit.
class (Idea u, Definition u, HasUnitSymbol u) => IsUnit u

-- | Holds units as a list of <a>UID</a>.
getUnits :: IsUnit u => u -> [UID]
class DefiningExpr c

-- | Provides a <tt>Lens</tt> to the expression.
defnExpr :: (DefiningExpr c, Express e) => Lens' (c e) e

-- | Data that can be expressed using <a>ModelExpr</a>.
class Express c
express :: Express c => c -> ModelExpr

-- | Members must have a reference address.
class HasRefAddress b

-- | Provides the ability to hold a reference address.
getRefAdd :: HasRefAddress b => b -> LblType

-- | Members of this class have the ability to be referenced.
class (HasUID s, HasRefAddress s) => Referable s

-- | The referencing address (what we're linking to). Only visible in the
--   source (tex/html).
refAdd :: Referable s => s -> String

-- | Alternate form of reference.
renderRef :: Referable s => s -> LblType

-- | A <a>ShortName</a> is the text to be displayed for a link. Used for
--   referencing within a document that can include symbols and whatnot if
--   required. Visible in the typeset documents (pdf).
class HasShortName s
shortname :: HasShortName s => s -> ShortName

-- | A class that contains a list of <a>Reference</a>s.
class HasReference c

-- | Provides a <tt>Lens</tt> to the <a>Reference</a>s.
getReferences :: HasReference c => Lens' c [Reference]

-- | A class that contains a list of decorated references (<a>DecRef</a>s).
class HasDecRef c

-- | Provides a <tt>Lens</tt> to the <a>DecRef</a>s.
getDecRefs :: HasDecRef c => Lens' c [DecRef]

-- | Some documents, as well as some pieces of knowledge, have citations.
class HasCitation c

-- | Provides a <tt>Lens</tt> to the citations.
getCitations :: HasCitation c => Lens' c [Citation]

-- | <tt>Citation</tt>s should have a fields (<a>CiteField</a>).
class HasFields c

-- | Provides a <tt>Lens</tt> to <a>CiteField</a>s.
getFields :: HasFields c => Lens' c [CiteField]

-- | Some chunks can be called like functions.
class (HasSymbol c) => Callable c

-- | Members must have a named argument.
class (HasSymbol c) => IsArgumentName c

-- | A <tt>UID</tt> is a 'unique identifier' for things that we will put
--   into our database of information. We use a newtype wrapper to make
--   sure we are only using <a>UID</a>s where desired.
data UID

-- | For when we need to modify a UID. We first take the base chunk's UID
--   and then append a suffix to it.
(+++) :: HasUID a => a -> String -> UID

-- | For when we need to append something to a UID.
(+++.) :: UID -> String -> UID
(+++!) :: (HasUID a, HasUID b) => a -> b -> UID

-- | Used for anything worth naming. Note that a <a>NamedChunk</a> does not
--   have an acronym/abbreviation as that's a <tt>CommonIdea</tt>, which
--   has its own representation. Contains a <a>UID</a> and a term that we
--   can capitalize or pluralize (<a>NP</a>).
--   
--   Ex. Anything worth naming must start out somewhere. Before we can
--   assign equations and values and symbols to something like the arm of a
--   pendulum, we must first give it a name.
data NamedChunk

-- | <a>NamedChunk</a> constructor, takes a <a>String</a> for its
--   <a>UID</a> and a term.
nc :: String -> NP -> NamedChunk

-- | Similar to <a>nc</a>, but takes in the <a>UID</a> in the form of a
--   <a>UID</a> rather than a <a>String</a>.
ncUID :: UID -> NP -> NamedChunk

-- | <a>IdeaDict</a> is the canonical dictionary associated to an
--   <a>Idea</a>. Contains a <a>NamedChunk</a> that could have an
--   abbreviation (<a>Maybe</a> <a>String</a>).
--   
--   Ex. The project name "Double Pendulum" may have the abbreviation
--   <a>DblPendulum</a>.
data IdeaDict

-- | <a>IdeaDict</a> constructor, takes a <a>UID</a>, <a>NP</a>, and an
--   abbreviation in the form of <a>Maybe</a> <a>String</a>.
mkIdea :: String -> NP -> Maybe String -> IdeaDict

-- | Historical name: nw comes from 'named wrapped' from when
--   <a>NamedIdea</a> exported <a>getA</a> (now in <a>Idea</a>). But there
--   are no more wrappers, instead we have explicit dictionaries. Unwraps
--   an <a>Idea</a> and places its <a>UID</a> and <a>NP</a> into an
--   <a>IdeaDict</a> with <a>Nothing</a> for an abbreviation.
nw :: Idea c => c -> IdeaDict

-- | The common idea (with <tt>NounPhrase</tt>) data type. It must have a
--   <a>UID</a>, <tt>NounPhrase</tt> for its term, an abbreviation
--   (<a>String</a>), and a domain ([<a>UID</a>]). It is similar to
--   <a>NamedChunk</a> and <a>IdeaDict</a> in the sense that these are for
--   things worth naming, but this type also carries an abbreviation and
--   related domains of knowledge.
--   
--   Ex. The term "Operating System" has the abbreviation <a>OS</a> and
--   comes from the domain of computer science.
data CI

-- | The commonIdea smart constructor requires a chunk id (<a>String</a>),
--   a term (<a>NP</a>), an abbreviation (<a>String</a>), and a domain
--   ([<a>UID</a>]).
commonIdea :: String -> NP -> String -> [UID] -> CI

-- | Get abbreviation in <a>Sentence</a> form from a <a>CI</a>.
getAcc :: CI -> Sentence

-- | Get abbreviation in <a>String</a> form from a <a>CI</a>.
getAccStr :: CI -> String

-- | Similar to <a>commonIdea</a>, but takes a list of <a>IdeaDict</a>
--   (often a domain).
commonIdeaWithDict :: String -> NP -> String -> [IdeaDict] -> CI

-- | Prepends the abbreviation from a <a>CommonIdea</a> to a <a>String</a>.
prependAbrv :: CommonIdea c => c -> String -> String

-- | The ConceptChunk datatype records a concept that contains an idea
--   (<a>IdeaDict</a>), a definition (<a>Sentence</a>), and an associated
--   domain of knowledge ([<a>UID</a>]).
--   
--   Ex. The concept of <a>Accuracy</a> may be defined as the quality or
--   state of being correct or precise.
data ConceptChunk

-- | Contains a common idea (<a>CI</a>) with a definition
--   (<a>Sentence</a>). Similar to <a>ConceptChunk</a>, but must have an
--   abbreviation.
data CommonConcept

-- | Contains a <a>ConceptChunk</a>, reference address, and a
--   <a>ShortName</a>. It is a concept that can be referred to, or rather,
--   a instance of where a concept is applied. Often used in Goal
--   Statements, Assumptions, Requirements, etc.
--   
--   Ex. Something like the assumption that gravity is 9.81 m/s. When we
--   write our equations, we can then link this assumption so that we do
--   not have to explicitly define that assumption when needed to verify
--   our work.
data ConceptInstance

-- | Check if something has one domain. Throws an error if there is more
--   than one.
sDom :: [UID] -> UID

-- | Smart constructor for creating concept chunks given a <tt>UID</tt>,
--   <tt>NounPhrase</tt> (<a>NP</a>) and definition (as a <a>String</a>).
--   
--   Concept domain tagging is not yet implemented in this constructor.
dcc :: String -> NP -> String -> ConceptChunk

-- | Identical to <a>dcc</a>, but takes an abbreviation (<a>String</a>) and
--   returns a <a>CommonConcept</a> instead.
dcc' :: String -> NP -> String -> String -> CommonConcept

-- | Similar to <a>dcc</a>, except the definition takes a <a>Sentence</a>.
dccWDS :: String -> NP -> Sentence -> ConceptChunk

-- | Similar to <a>dcc</a>, except the definition is a <a>Sentence</a>,
--   takes an abbreviation (<a>String</a>) and returns a
--   <a>CommonConcept</a> instead.
dccWDS' :: String -> NP -> Sentence -> String -> CommonConcept

-- | Constructor for projecting an idea into a <a>ConceptChunk</a>. Takes
--   the definition of the <a>ConceptChunk</a> as a <a>String</a>. Does not
--   allow concept domain tagging.
cc :: Idea c => c -> String -> ConceptChunk

-- | Same as <a>cc</a>, except definition is a <a>Sentence</a>.
cc' :: Idea c => c -> Sentence -> ConceptChunk

-- | Similar to <a>cc'</a>, but allows explicit domain tagging.
ccs :: (Idea c, Concept d) => c -> Sentence -> [d] -> ConceptChunk

-- | For projecting out to the <a>ConceptChunk</a> data-type.
cw :: Concept c => c -> ConceptChunk

-- | Constructor for a <a>ConceptInstance</a>. Takes in the Reference
--   Address (<a>String</a>), a definition (<a>Sentence</a>), a short name
--   (<a>String</a>), and a domain (for explicit tagging).
cic :: Concept c => String -> Sentence -> String -> c -> ConceptInstance

-- | For a concept (<a>ConceptChunk</a>) that also has a <tt>Relation</tt>
--   (<a>ModelExpr</a>) attached.
--   
--   Ex. We can describe a pendulum arm and then apply an associated
--   equation so that we know its behaviour.
data RelationConcept

-- | Create a <a>RelationConcept</a> from a given <a>UID</a>, term
--   (<a>NP</a>), definition (<a>Sentence</a>), and <tt>Relation</tt>.
makeRC :: Express e => String -> NP -> Sentence -> e -> RelationConcept

-- | Create a new <a>RelationConcept</a> from an old <a>Concept</a>. Takes
--   a <a>Concept</a>, new <a>UID</a> and relation.
addRelToCC :: (Express e, Concept c) => c -> String -> e -> RelationConcept

-- | QuantityDict is a combination of an <a>IdeaDict</a> with a quantity.
--   Contains an <a>IdeaDict</a>, <a>Space</a>, a function from
--   <a>Stage</a> -&gt; <a>Symbol</a>, and <a>Maybe</a> a <a>UnitDefn</a>.
--   
--   Ex. A pendulum arm does not necessarily have to be defined as a
--   concept before we assign a space (Real numbers), a symbol (l), or
--   units (cm, m, etc.).
data QuantityDict

-- | Smart constructor for a <a>QuantityDict</a> from another
--   <a>Quantity</a> with units.
qw :: (Quantity q, MayHaveUnit q) => q -> QuantityDict

-- | Make a <a>QuantityDict</a> from a <a>UID</a>, <a>NP</a>,
--   <a>Symbol</a>, <a>Space</a>, <a>Maybe</a> <a>UnitDefn</a>, and an
--   abbreviation (<a>Maybe</a> <a>String</a>).
mkQuant :: String -> NP -> Symbol -> Space -> Maybe UnitDefn -> Maybe String -> QuantityDict

-- | Similar to <a>mkQuant</a>, but the abbreviation is moved to the third
--   argument (<a>Maybe</a> <a>String</a>), and the <a>Symbol</a> is now
--   dependent on <a>Stage</a>.
mkQuant' :: String -> NP -> Maybe String -> Space -> (Stage -> Symbol) -> Maybe UnitDefn -> QuantityDict

-- | Makes a <a>QuantityDict</a> from an <a>Idea</a>, <a>Symbol</a>, and
--   <a>Space</a>. <a>Symbol</a> is implementation-only.
codeVC :: Idea c => c -> Symbol -> Space -> QuantityDict

-- | Makes a variable that is implementation-only.
implVar :: String -> NP -> Space -> Symbol -> QuantityDict

-- | Similar to <a>implVar</a> but allows specification of abbreviation and
--   unit.
implVar' :: String -> NP -> Maybe String -> Space -> Symbol -> Maybe UnitDefn -> QuantityDict

-- | Similar to <a>implVar</a> but takes in a <a>UID</a> rather than a
--   <a>String</a>.
implVarUID :: UID -> NP -> Space -> Symbol -> QuantityDict

-- | Similar to <a>implVar'</a> but takes in a <a>UID</a> rather than a
--   <a>String</a>.
implVarUID' :: UID -> NP -> Maybe String -> Space -> Symbol -> Maybe UnitDefn -> QuantityDict

-- | Creates a <a>QuantityDict</a> from a <a>UID</a>, term (<a>NP</a>),
--   <a>Symbol</a>, and <a>Space</a>.
vc :: String -> NP -> Symbol -> Space -> QuantityDict

-- | Creates a <a>QuantityDict</a> from an <a>Idea</a>, <a>Symbol</a>, and
--   <a>Space</a>.
vc'' :: Idea c => c -> Symbol -> Space -> QuantityDict

-- | Similar to <a>vc</a>, but creates a <a>QuantityDict</a> from something
--   that knows about <a>Stage</a>s.
vcSt :: String -> NP -> (Stage -> Symbol) -> Space -> QuantityDict

-- | Creates a <a>QuantityDict</a> from a <a>UID</a>, term (<a>NP</a>),
--   <a>Symbol</a>, <a>Space</a>, and unit (<a>UnitDefn</a>).
vcUnit :: String -> NP -> Symbol -> Space -> UnitDefn -> QuantityDict

-- | Any quantity can be a named argument (wrapper for
--   <a>QuantityDict</a>), but with more of a focus on generating code
--   arguments.
data NamedArgument

-- | Smart constructor for <a>NamedArgument</a> .
narg :: (Quantity q, MayHaveUnit q) => q -> NamedArgument
data QDefinition e

-- | Create a <a>QDefinition</a> with a <a>UID</a> (as a <a>String</a>),
--   term (<a>NP</a>), definition (<a>Sentence</a>), <a>Symbol</a>,
--   <a>Space</a>, unit, and defining expression.
fromEqn :: (Express e, IsUnit u) => String -> NP -> Sentence -> Symbol -> Space -> u -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but has no units.
fromEqn' :: Express e => String -> NP -> Sentence -> Symbol -> Space -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but symbol depends on stage.
fromEqnSt :: (Express e, IsUnit u) => UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> u -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but symbol depends on stage and has no units.
fromEqnSt' :: Express e => UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> e -> QDefinition e

-- | Same as <a>fromEqnSt'</a>, but takes a <a>String</a> instead of a
--   <a>UID</a>.
fromEqnSt'' :: Express e => String -> NP -> Sentence -> (Stage -> Symbol) -> Space -> e -> QDefinition e

-- | Wrapper for fromEqnSt and fromEqnSt'
mkQDefSt :: Express e => UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> e -> QDefinition e

-- | Used to help make <a>QDefinition</a>s when <a>UID</a>, term, and
--   <a>Symbol</a> come from the same source.
mkQuantDef :: (Quantity c, MayHaveUnit c, Express e) => c -> e -> QDefinition e

-- | Used to help make <a>QDefinition</a>s when <a>UID</a> and
--   <a>Symbol</a> come from the same source, with the term separate.
mkQuantDef' :: (Quantity c, MayHaveUnit c, Express e) => c -> NP -> e -> QDefinition e

-- | Smart constructor for QDefinitions. Requires a quantity and its
--   defining equation.
ec :: (Quantity c, MayHaveUnit c, Express e) => c -> e -> QDefinition e

-- | Create a <a>QDefinition</a> function with a symbol, name, term, list
--   of inputs, resultant units, and a defining Expr
mkFuncDef :: (HasUID f, HasSymbol f, HasSpace f, HasUID i, HasSymbol i, HasSpace i, IsUnit u, Express e) => f -> NP -> Sentence -> u -> [i] -> e -> QDefinition e

-- | Create a <a>QDefinition</a> function with a symbol, name, term, list
--   of inputs, and a defining Expr
mkFuncDef' :: (HasUID f, HasSymbol f, HasSpace f, HasUID i, HasSymbol i, HasSpace i, Express e) => f -> NP -> Sentence -> [i] -> e -> QDefinition e

-- | Create a <a>QDefinition</a> functions using a symbol, list of inputs,
--   and a defining Expr
mkFuncDefByQ :: (Quantity c, MayHaveUnit c, HasSpace c, Quantity i, HasSpace i, Express e) => c -> [i] -> e -> QDefinition e

-- | A Unitary is a <a>Quantity</a> that <b>must</b> have a unit.
class (Quantity c) => Unitary c
unit :: Unitary c => c -> UnitDefn

-- | UnitaryChunks are for ideas with quantities that must have units.
--   Contains a <a>QuantityDict</a> and a <a>UnitDefn</a>.
--   
--   Ex. A pendulum arm is an idea associated with a symbol (l) and units
--   (cm, m, etc.).
data UnitaryChunk

-- | Builds the <a>QuantityDict</a> part from the <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, and <a>Space</a>. Assumes there's no
--   abbreviation.
unitary :: IsUnit u => String -> NP -> Symbol -> u -> Space -> UnitaryChunk

-- | Same as <a>unitary</a> but with a <a>Symbol</a> that changes based on
--   the <a>Stage</a>.
unitary' :: IsUnit u => String -> NP -> (Stage -> Symbol) -> u -> Space -> UnitaryChunk

-- | Makes a <a>UnitaryChunk</a> from a quantity with a unit.
mkUnitary :: (Unitary u, MayHaveUnit u) => u -> UnitaryChunk

-- | Helper for getting the unit's <a>Symbol</a> from a chunk, as opposed
--   to the symbols of the chunk itself.
unit_symb :: Unitary c => c -> USymb

-- | DefinedQuantityDict is the combination of a <a>Concept</a> and a
--   <a>Quantity</a>. Contains a <a>ConceptChunk</a>, a <a>Symbol</a>
--   dependent on <a>Stage</a>, a <a>Space</a>, and maybe a
--   <a>UnitDefn</a>. Used when we want to assign a quantity to a concept.
--   Includes the space, symbol, and units for that quantity.
--   
--   Ex. A pendulum arm can be defined as a concept with a symbol (l),
--   space (Real numbers), and units (cm, m, etc.).
data DefinedQuantityDict

-- | Smart constructor that creates a DefinedQuantityDict with a
--   <a>ConceptChunk</a>, a <a>Symbol</a> independent of <a>Stage</a>, a
--   <a>Space</a>, and a unit.
dqd :: IsUnit u => ConceptChunk -> Symbol -> Space -> u -> DefinedQuantityDict

-- | Similar to <a>dqd</a>, but the <a>Symbol</a> is now dependent on the
--   <a>Stage</a>.
dqd' :: ConceptChunk -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> DefinedQuantityDict

-- | Similar to <a>dqd</a>, but without any units.
dqdNoUnit :: ConceptChunk -> Symbol -> Space -> DefinedQuantityDict

-- | When we want to merge a quantity and a concept. This is suspicious.
dqdQd :: (Quantity c, MayHaveUnit c) => c -> ConceptChunk -> DefinedQuantityDict

-- | When the input already has all the necessary information. A
--   <tt>projection</tt> operator from some a type with instances of listed
--   classes to a <a>DefinedQuantityDict</a>.
dqdWr :: (Quantity c, Concept c, MayHaveUnit c) => c -> DefinedQuantityDict

-- | Similar to a <a>DefinedQuantityDict</a>, UnitalChunks are concepts
--   with quantities that must have a unit definition. Contains
--   <a>DefinedQuantityDict</a>s and a <a>UnitDefn</a>.
--   
--   Ex. A pendulum arm is a tangible object with a symbol (l) and units
--   (cm, m, etc.).
data UnitalChunk
UC :: DefinedQuantityDict -> UnitDefn -> UnitalChunk
[_defq'] :: UnitalChunk -> DefinedQuantityDict
[_uni] :: UnitalChunk -> UnitDefn

-- | Creates a <a>UnitalChunk</a> in the same way as <a>uc'</a>, but with a
--   <a>Sentence</a> for the definition instead of a <a>String</a>.
makeUCWDS :: IsUnit u => String -> NP -> Sentence -> Symbol -> u -> UnitalChunk

-- | Used to create a <a>UnitalChunk</a> from a <a>Concept</a>,
--   <a>Symbol</a>, and <tt>Unit</tt>. Assumes the <a>Space</a> is Real.
uc :: (Concept c, IsUnit u) => c -> Symbol -> u -> UnitalChunk

-- | Similar to <a>uc</a>, except it builds the <a>Concept</a> portion of
--   the <a>UnitalChunk</a> from a given <tt>UID</tt>, term, and definition
--   (which are the first three arguments).
uc' :: IsUnit u => String -> NP -> String -> Symbol -> u -> UnitalChunk

-- | Similar to <a>uc'</a>, but <a>Symbol</a> is dependent on the
--   <a>Stage</a>.
ucStaged :: IsUnit u => String -> NP -> String -> (Stage -> Symbol) -> u -> UnitalChunk

-- | Similar to <a>uc'</a>, but does not assume the <a>Space</a>.
ucs :: IsUnit u => String -> NP -> String -> Symbol -> Space -> u -> UnitalChunk

-- | Similar to <a>uc</a> but does not assume the <a>Space</a>.
ucs' :: (Concept c, IsUnit u) => c -> Symbol -> Space -> u -> UnitalChunk

-- | Similar to <a>ucs</a>, but uses a <a>Sentence</a> for description.
ucsWS :: IsUnit u => String -> NP -> Sentence -> Symbol -> Space -> u -> UnitalChunk

-- | Attach units to a chunk that has a symbol and definition.
ucuc :: (Quantity c, Concept c, MayHaveUnit c) => c -> UnitDefn -> UnitalChunk

-- | Constructs a UnitalChunk from a <a>Concept</a> with <tt>Units</tt>.
ucw :: (Unitary c, Concept c, MayHaveUnit c) => c -> UnitalChunk

-- | For defining units. It has a <a>ConceptChunk</a> (that defines what
--   kind of unit it is), a unit symbol, maybe another (when it is a
--   synonym), perhaps a definition, and a list of <a>UID</a> of the units
--   that make up the definition.
--   
--   Ex. Meter is a unit of length defined by the symbol (m).
data UnitDefn
UD :: ConceptChunk -> UnitSymbol -> [UID] -> UnitDefn
[_vc] :: UnitDefn -> ConceptChunk
[_cas] :: UnitDefn -> UnitSymbol
[_cu] :: UnitDefn -> [UID]

-- | Generates a default unit symbol.
fromUDefn :: UDefn -> USymb

-- | Helper for fundamental unit concept chunk creation. Uses the same
--   <a>String</a> for the identifier, term, and definition.
unitCon :: String -> ConceptChunk

-- | Create a derived unit chunk from a concept and a unit equation.
makeDerU :: ConceptChunk -> UnitEquation -> UnitDefn

-- | Combinator for raising a unit to a power.
(^:) :: UnitDefn -> Integer -> UnitEquation

-- | Combinator for dividing one unit by another.
(/:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying two units together.
(*:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying a unit and a symbol.
(*$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for dividing a unit and a symbol.
(/$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for mulitiplying two unit equations.
(^$) :: UnitEquation -> UnitEquation -> UnitEquation

-- | Smart constructor for new derived units from existing units.
newUnit :: String -> UnitEquation -> UnitDefn

-- | Combinator for scaling one unit by some number.
scale :: IsUnit s => Double -> s -> UDefn

-- | Combinator for shifting one unit by some number.
shift :: IsUnit s => Double -> s -> UDefn

-- | Uses self-plural term.
--   
--   Create a derived unit chunk from a <a>UID</a>, term (<a>String</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Uses term that pluralizes by adding "s" to the end.
--   
--   Create a derived unit chunk from a <a>UID</a>, term (<a>String</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC' :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Create a derived unit chunk from a <a>UID</a>, term (<a>NP</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC'' :: String -> NP -> String -> Symbol -> UDefn -> UnitDefn

-- | Smart constructor for a "fundamental" unit.
fund :: String -> String -> String -> UnitDefn

-- | Variant of the <a>fund</a>, useful for degree.
fund' :: String -> String -> Symbol -> UnitDefn

-- | We don't want an Ord on units, but this still allows us to compare
--   them.
compUnitDefn :: UnitDefn -> UnitDefn -> Ordering

-- | Create a <tt>SI_Unit</tt> with two <a>Symbol</a> representations. The
--   created <a>NP</a> is self-plural.
derCUC :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Similar to <a>derCUC</a>, but the created <a>NP</a> has the
--   <tt>AddS</tt> plural rule.
derCUC' :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Create a derived unit chunk from a <a>UID</a>, term (<a>NP</a>),
--   definition, <a>Symbol</a>, and unit equation.
derCUC'' :: String -> NP -> String -> Symbol -> UnitEquation -> UnitDefn

-- | For allowing lists to mix together chunks that are units by projecting
--   them into a <a>UnitDefn</a>. For now, this only works on
--   <a>UnitDefn</a>s.
unitWrapper :: IsUnit u => u -> UnitDefn

-- | Get a list of <a>UID</a> of the units that make up the
--   <a>UnitEquation</a>.
getCu :: UnitEquation -> [UID]

-- | Types may contain a unit (<a>UnitDefn</a>).
class MayHaveUnit u
getUnit :: MayHaveUnit u => u -> Maybe UnitDefn

-- | The reason behind the constraint's existence.
data ConstraintReason
Physical :: ConstraintReason
Software :: ConstraintReason

-- | Holds constraints. May occur between an interval of <a>Expr</a>, a
--   list of <a>Double</a>s, or a list of <a>String</a>s.
data Constraint a

-- | By default, physical and software constraints are ranges.
[Range] :: ConstraintReason -> RealInterval a a -> Constraint a

-- | Type synonym for <a>ConstraintE</a>
type ConstraintE = Constraint Expr

-- | Smart constructor for range of <a>Physical</a> constraints between two
--   given expressions.
physc :: RealInterval Expr Expr -> ConstraintE

-- | Smart constructor for range of <a>Software</a> constraints between two
--   given expressions.
sfwrc :: RealInterval Expr Expr -> ConstraintE

-- | Helpful for filtering for Physical constraints. True if constraint is
--   <a>Physical</a>.
isPhysC :: Constraint e -> Bool

-- | Helpful for filtering for Software constraints. True if constraint is
--   <a>Software</a>.
isSfwrC :: Constraint e -> Bool

-- | ConstrainedChunks are symbolic quantities (<a>QuantityDict</a>) with
--   <tt>Constraint</tt>s and maybe a typical value (<a>Maybe</a>
--   <a>Expr</a>).
--   
--   Ex. Measuring the length of a pendulum would have some reasonable
--   value (between 1 cm and 2 m) and the constraint that the length cannot
--   be a negative value.
data ConstrainedChunk
ConstrainedChunk :: QuantityDict -> [ConstraintE] -> Maybe Expr -> ConstrainedChunk
[_qd] :: ConstrainedChunk -> QuantityDict
[_constr] :: ConstrainedChunk -> [ConstraintE]
[_reasV] :: ConstrainedChunk -> Maybe Expr

-- | ConstrConcepts are conceptual symbolic quantities
--   (<a>DefinedQuantityDict</a>) with <tt>Constraint</tt>s and maybe a
--   reasonable value (no units!). Similar to <a>ConstrainedChunk</a> but
--   includes a definition and domain.
--   
--   Ex. Measuring the length of a pendulum arm could be a concept that has
--   some reasonable value (between 1 cm and 2 m) and the constraint that
--   the length cannot be a negative value.
data ConstrConcept
ConstrConcept :: DefinedQuantityDict -> [ConstraintE] -> Maybe Expr -> ConstrConcept
[_defq] :: ConstrConcept -> DefinedQuantityDict
[_constr'] :: ConstrConcept -> [ConstraintE]
[_reasV'] :: ConstrConcept -> Maybe Expr

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, unit, <a>Space</a>, <tt>Constraint</tt>s,
--   and an <a>Expr</a>.
cuc :: IsUnit u => String -> NP -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> ConstrainedChunk

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, <a>Space</a>, <tt>Constraint</tt>s, and a
--   <a>Maybe</a> <a>Expr</a> (Similar to <a>cuc</a> but no units).
cvc :: String -> NP -> Symbol -> Space -> [ConstraintE] -> Maybe Expr -> ConstrainedChunk

-- | Creates a <a>ConstrConcept</a> with a quantitative concept, a list of
--   <tt>Constraint</tt>s and an <a>Expr</a>.
constrained' :: (Concept c, MayHaveUnit c, Quantity c) => c -> [ConstraintE] -> Expr -> ConstrConcept

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), description (<a>String</a>), <a>Symbol</a>, unit,
--   <a>Space</a>, <tt>Constraint</tt>s, and an <a>Expr</a>.
cuc' :: IsUnit u => String -> NP -> String -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to <a>cuc'</a>, but <a>Symbol</a> is dependent on
--   <a>Stage</a>.
cuc'' :: IsUnit u => String -> NP -> String -> (Stage -> Symbol) -> u -> Space -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to <a>constrained'</a>, but defaults <a>Maybe</a> <a>Expr</a>
--   to <a>Nothing</a>.
constrainedNRV' :: (Concept c, MayHaveUnit c, Quantity c) => c -> [ConstraintE] -> ConstrConcept

-- | Creates a new ConstrainedChunk from either a <a>ConstrainedChunk</a>,
--   <a>ConstrConcept</a>, <tt>UncertainChunk</tt>, or an <tt>UncertQ</tt>.
cnstrw :: (Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> ConstrainedChunk

-- | Similar to <a>cnstrw</a>, but types must also have a <a>Concept</a>.
cnstrw' :: (Quantity c, Concept c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> ConstrConcept

-- | UncertainChunk is a symbolic quantity with constraints, a typical
--   value, and an uncertainty. Contains a <a>ConstrainedChunk</a> and an
--   <a>Uncertainty</a>.
--   
--   Ex. Measuring the length of a pendulum arm may be recorded with an
--   uncertainty value.
data UncertainChunk
UCh :: ConstrainedChunk -> Uncertainty -> UncertainChunk
[_conc] :: UncertainChunk -> ConstrainedChunk
[_unc'] :: UncertainChunk -> Uncertainty

-- | UncertQs are conceptual symbolic quantities with constraints and an
--   <a>Uncertainty</a>. Contains a <a>ConstrConcept</a> and an
--   <a>Uncertainty</a>.
--   
--   Ex. Measuring the length of a pendulum arm may be recorded with an
--   uncertainty value.
data UncertQ

-- | Smart constructor that requires a <a>Quantity</a>, a percentage, and a
--   typical value with an <a>Uncertainty</a>.
uq :: (Quantity c, Constrained c, Concept c, HasReasVal c, MayHaveUnit c) => c -> Uncertainty -> UncertQ

-- | Uncertainty quantity (<a>uq</a>) but with a constraint.
uqc :: IsUnit u => String -> NP -> String -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertQ

-- | Uncertainty quantity constraint (<a>uqc</a>) without a description.
uqcND :: IsUnit u => String -> NP -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertQ

-- | Smart constructor that can project to an <a>UncertainChunk</a> (also
--   given an <a>Uncertainty</a>).
uncrtnChunk :: (Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> Uncertainty -> UncertainChunk

-- | Creates an uncertain variable chunk. Takes <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, <a>Space</a>, <tt>Constrains</tt>,
--   <a>Expr</a>, and <a>Uncertainty</a>.
uvc :: String -> NP -> Symbol -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertainChunk

-- | Projection function into an <a>UncertainChunk</a> from <a>UncertQ</a>
--   or an <a>UncertainChunk</a>.
uncrtnw :: (HasUncertainty c, Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> UncertainChunk

-- | Something that may contain an uncertainty value and a precision value.
data Uncertainty

-- | Smart constructor for values with uncertainty.
uncty :: Double -> Maybe Int -> Uncertainty

-- | The default uncertainty is set to 0.1.
defaultUncrt :: Uncertainty

-- | Accessor for uncertainty value from something that has an uncertainty.
uncVal :: HasUncertainty x => x -> Double

-- | Accessor for precision value from something that has an uncertainty.
uncPrec :: HasUncertainty x => x -> Maybe Int

-- | Smart constructor for exact values (no uncertainty).
exact :: Uncertainty

-- | Retrieves the <a>String</a> contained in a <a>LblType</a>.
getAdd :: LblType -> String

-- | Prepends a <a>String</a> to an <a>IRefProg</a>.
prepend :: String -> IRefProg

-- | Applying different pieces of information for a reference. An RP is a
--   decorated internal reference. Citation is a citation. URI is for URLs
--   and other external links.
data LblType
RP :: IRefProg -> String -> LblType
Citation :: String -> LblType
URI :: String -> LblType

-- | Created for different forms of references. Used in <a>LblType</a>.
data IRefProg

-- | Deferred lookup; done later. Used for domains in a
--   <tt>ConceptInstance</tt>.
Deferred :: UID -> IRefProg

-- | Lifts a <a>String</a> into a <tt>RefProg</tt>.
RS :: String -> IRefProg

-- | Concatenates with two subprograms.
RConcat :: IRefProg -> IRefProg -> IRefProg

-- | The <tt>Symbol</tt> to insert the <tt>ShortName</tt> directly.
Name :: IRefProg

-- | A Reference contains the identifier (<a>UID</a>), a reference address
--   (<a>LblType</a>), a human-readable shortname (<a>ShortName</a>), and
--   any extra information about the reference (<a>RefInfo</a>).
data Reference
Reference :: UID -> LblType -> ShortName -> Reference

-- | Projector function that creates a <a>Reference</a> from something
--   <tt>Referable</tt>.
ref :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Reference

-- | Takes the reference <a>UID</a> and wraps it into a <a>Sentence</a>.
refS :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence

-- | Takes a <a>Reference</a> with a name to be displayed and wraps it into
--   a <a>Sentence</a>. Does not overwrite the shortname contained in the
--   reference, but will only display as the given <a>Sentence</a>.
namedRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence -> Sentence

-- | Takes a <a>Reference</a> with additional display info. Uses the
--   internal shortname for its display name.
complexRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> RefInfo -> Sentence

-- | Takes a <a>Reference</a> with a name to be displayed and any
--   additional information and wraps it into a <a>Sentence</a>. Does not
--   overwrite the shortname contained in the reference, but will only
--   display as the given <a>Sentence</a> along with the given
--   <a>RefInfo</a>.
namedComplexRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence -> RefInfo -> Sentence

-- | For holding a <a>Reference</a> that is decorated with extra
--   information (ex. page numbers, equation sources, etc.).
data DecRef

-- | For creating a decorated reference (<a>DecRef</a>) with extra
--   reference information (<a>RefInfo</a>).
dRefInfo :: (HasUID r, HasRefAddress r, HasShortName r) => r -> RefInfo -> DecRef

-- | Same as <a>ref</a>, but for <a>DecRef</a> instead of <a>Reference</a>.
dRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> DecRef

-- | A <a>String</a> that should contain no spaces.
type EntryID = String

-- | All citations require a unique identifier used by the Drasil chunk. We
--   will re-use the <a>UID</a> part as an EntryID (<a>String</a>) used for
--   creating reference links. Finally we will have the reference
--   information (<a>CitationKind</a>, <a>CiteField</a>s, and a
--   <a>ShortName</a>).
--   
--   Ex. A reference to a thesis paper like Koothoor's "Document driven
--   approach to certifying scientific computing software" would include
--   the affiliated university, publishing year, and city.
data Citation

-- | A list of <a>Citation</a>s.
type BibRef = [Citation]
citeID :: Lens' Citation UID
citeKind :: Lens' Citation CitationKind

-- | Article citation requires author(s), title, journal, year. Optional
--   fields can be: volume, number, pages, month, and note. Implicitly uses
--   the EntryID as the chunk id.
cArticle :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by author.
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk id.
cBookA :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by editor.
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk id.
cBookE :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Booklet citation requires title. Optional fields can be author, how
--   published, address, month, year, note. Implicitly uses the EntryID as
--   the chunk id.
cBooklet :: String -> [CiteField] -> String -> Citation

-- | InBook citation by author.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id. This smart constructor includes both chapter
--   and page numbers.
cInBookACP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InBook citation by editor.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id. This smart constructor includes both chapter
--   and page numbers.
cInBookECP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookACP</a>.
--   
--   InBook citation excluding page numbers.
cInBookAC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookECP</a>.
--   
--   InBook citation excluding page numbers.
cInBookEC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookACP</a>.
--   
--   InBook citation excluding chapter.
cInBookAP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookECP</a>.
--   
--   InBook citation excluding chapter.
cInBookEP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InCollection citation requires author, title, bookTitle, publisher,
--   year. Optional fields can be editor, volume or number, series, type,
--   chapter, pages, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id.
cInCollection :: People -> String -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | InProceedings citation requires author, title, bookTitle, year.
--   Optional fields can be editor, volume or number, series, pages,
--   address, month, organization, publisher, and note. Implicitly uses the
--   EntryID as the chunk id.
cInProceedings :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Manual (technical documentation) citation requires title. Optional
--   fields can be author, organization, address, edition, month, year, and
--   note. Implicitly uses the EntryID as the chunk id.
cManual :: String -> [CiteField] -> String -> Citation

-- | Master's Thesis citation requires author, title, school, and year.
--   Optional fields can be type, address, month, and note. Implicitly uses
--   the EntryID as the chunk id.
cMThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Misc citation requires nothing. Optional fields can be author, title,
--   howpublished, month, year, and note. Implicitly uses the EntryID as
--   the chunk id.
cMisc :: [CiteField] -> String -> Citation

-- | PhD Thesis citation requires author, title, school, and year. Optional
--   fields can be type, address, month, and note. Implicitly uses the
--   EntryID as the chunk id.
cPhDThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Proceedings citation requires title and year. Optional fields can be
--   editor, volume or number, series, address, publisher, note, month, and
--   organization. Implicitly uses the EntryID as the chunk id.
cProceedings :: String -> Int -> [CiteField] -> String -> Citation

-- | Technical Report citation requires author, title, institution, and
--   year. Optional fields can be type, number, address, month, and note.
--   Implicitly uses the EntryID as the chunk id.
cTechReport :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Unpublished citation requires author, title, and note. Optional fields
--   can be month and year. Implicitly uses the EntryID as the chunk id.
cUnpublished :: People -> String -> String -> [CiteField] -> String -> Citation

-- | Custom type for months (abbreviated).
data Month
Jan :: Month
Feb :: Month
Mar :: Month
Apr :: Month
May :: Month
Jun :: Month
Jul :: Month
Aug :: Month
Sep :: Month
Oct :: Month
Nov :: Month
Dec :: Month

-- | Fields used in citations.
data CiteField
Address :: String -> CiteField
Author :: People -> CiteField

-- | Used for <a>InCollection</a> references only.
BookTitle :: String -> CiteField
Chapter :: Int -> CiteField
Edition :: Int -> CiteField
Editor :: People -> CiteField

-- | Can be published via URL or something else.
HowPublished :: HP -> CiteField
Institution :: String -> CiteField
Journal :: String -> CiteField
Month :: Month -> CiteField
Note :: String -> CiteField
Number :: Int -> CiteField
Organization :: String -> CiteField

-- | Range of pages (ex1. 1-32; ex2. 7,31,52-55).
Pages :: [Int] -> CiteField
Publisher :: String -> CiteField
School :: String -> CiteField
Series :: String -> CiteField
Title :: String -> CiteField

-- | BibTeX "type" field.
Type :: String -> CiteField
Volume :: Int -> CiteField
Year :: Int -> CiteField

-- | How something is published. Necessary for URLs to work properly.
data HP
URL :: String -> HP
Verb :: String -> HP

-- | External references come in many flavours. Articles, Books, etc. (we
--   are using the types available in Bibtex).
data CitationKind
Article :: CitationKind
Book :: CitationKind
Booklet :: CitationKind
InBook :: CitationKind
InCollection :: CitationKind
InProceedings :: CitationKind
Manual :: CitationKind
MThesis :: CitationKind
Misc :: CitationKind
PhDThesis :: CitationKind
Proceedings :: CitationKind
TechReport :: CitationKind
Unpublished :: CitationKind

-- | Smart field constructor for a <a>CiteField</a>.
author :: People -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
editor :: People -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
address :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
bookTitle :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
howPublished :: String -> CiteField

-- | URL version of <a>howPublished</a>.
--   
--   Smart field constructor for a <a>CiteField</a>.
howPublishedU :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
institution :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
journal :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
note :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
organization :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
publisher :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
school :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
series :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
title :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
typeField :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
chapter :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
edition :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
number :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
volume :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
year :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
pages :: [Int] -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
month :: Month -> CiteField

-- | People is a synonymn for many <a>Person</a>s.
type People = [Person]

-- | A person can have a given name, middle name(s), and surname, as well
--   as the naming convention they use.
data Person

-- | Constructor for a person using Western naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   given name, surname.
person :: String -> String -> Person

-- | Members of this class must have a name.
class HasName p

-- | Gets the name of a <a>Person</a>. Adds a dot after any initials.
name :: HasName n => n -> String

-- | Constructor for a person using Eastern naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   surname, given name.
person' :: String -> String -> Person

-- | Constructor for a person using Western naming conventions. Similar to
--   the <a>person</a> constructor, except the middle argument is a list of
--   middle names.
personWM :: String -> [String] -> String -> Person

-- | Constructor for a person using Eastern naming conventions. Similar to
--   the <a>person'</a> constructor, except the middle argument is a list
--   of middle names.
personWM' :: String -> [String] -> String -> Person

-- | Constructor for a person with a mononym (only one name).
mononym :: String -> Person

-- | Provides the ability to hold a name.
nameStr :: HasName p => p -> String

-- | Gets a <a>Person</a>'s name in the form: Last, First Middle.
rendPersLFM :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, F. M.
rendPersLFM' :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, First M.
rendPersLFM'' :: Person -> String

-- | Orderes different groups of <a>Person</a>s. If two lists are the same
--   up to a point, the citation with more <a>Person</a>s will go last.
comparePeople :: [Person] -> [Person] -> Ordering

-- | For writing <a>Sentence</a>s via combining smaller elements.
--   <a>Sentence</a>s are made up of some known vocabulary of things:
--   
--   <ul>
--   <li>units (their visual representation)</li>
--   <li>words (via <a>String</a>s)</li>
--   <li>special characters</li>
--   <li>accented letters</li>
--   <li>references to specific layout objects</li>
--   </ul>
data Sentence

-- | Ch looks up the term for a given <a>UID</a> and displays the term with
--   a given <a>SentenceStyle</a> and <tt>CapitalizationRule</tt>. This
--   allows Sentences to hold plural forms of <tt>NounPhrase</tt>s and
--   <tt>NamedIdea</tt>s.
[Ch] :: SentenceStyle -> TermCapitalization -> UID -> Sentence

-- | A branch of Ch dedicated to SymbolStyle only.
[SyCh] :: UID -> Sentence

-- | Converts a unit symbol into a usable Sentence form.
[Sy] :: USymb -> Sentence

-- | Constructor for <a>String</a>s, used often for descriptions in Chunks.
[S] :: String -> Sentence

-- | Converts the graphical representation of a symbol into a usable
--   Sentence form.
[P] :: Symbol -> Sentence

-- | Lifts an expression into a Sentence.
[E] :: ModelExpr -> Sentence

-- | Takes a <a>UID</a> to a reference, a display name (<a>Sentence</a>),
--   and any additional reference display information (<a>RefInfo</a>).
--   Resolves the reference later (similar to Ch).
[Ref] :: UID -> Sentence -> RefInfo -> Sentence

-- | Adds quotation marks around a Sentence.
[Quote] :: Sentence -> Sentence

-- | Used for a % symbol.
[Percent] :: Sentence

-- | Direct concatenation of two Sentences (no implicit spaces!).
[:+:] :: Sentence -> Sentence -> Sentence

-- | Empty Sentence.
[EmptyS] :: Sentence
infixr 5 :+:

-- | Used in <a>Ch</a> constructor to determine the state of a term (can
--   record whether something is in plural form, a singular term, or in
--   short form).
data SentenceStyle
PluralTerm :: SentenceStyle
TermStyle :: SentenceStyle
ShortStyle :: SentenceStyle

-- | Used in <a>Ch</a> constructor to determine the capitalization of a
--   term. CapF is for capitalizing the first word from the <a>UID</a> of
--   the given term. CapW is for capitalizing all words from the <a>UID</a>
--   of the given term. Mirrors <tt>CapFirst</tt> and <tt>CapWords</tt>
--   from <tt>CapitalizationRule</tt>.
data TermCapitalization
CapF :: TermCapitalization
CapW :: TermCapitalization
NoCap :: TermCapitalization

-- | Holds any extra information needed for a <tt>Reference</tt>, be it an
--   equation, pages, a note, or nothing.
data RefInfo
None :: RefInfo
Equation :: [Int] -> RefInfo
Page :: [Int] -> RefInfo
RefNote :: String -> RefInfo

-- | Helper for concatenating two <a>Sentence</a>s with a space between
--   them.
(+:+) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two <a>Sentence</a>s using <a>+:+</a> and
--   appends a period.
(+:+.) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two sentences using <a>+:+</a> and appends a
--   colon.
(+:) :: Sentence -> Sentence -> Sentence

-- | Helper which appends a period to the end of a <a>Sentence</a> (used
--   often as a post-fix operator).
(!.) :: Sentence -> Sentence

-- | Capitalizes a Sentence.
capSent :: Sentence -> Sentence

-- | Gets a symbol and places it in a <a>Sentence</a>.
ch :: (HasUID c, HasSymbol c) => c -> Sentence
eS :: ModelExpr -> Sentence
eS' :: Express t => t -> Sentence

-- | Helper for concatenating two <a>Sentence</a>s with a comma and space
--   between them.
sC :: Sentence -> Sentence -> Sentence

-- | Helper for concatenating two <a>Sentence</a>s with a space-surrounded
--   dash between them.
sDash :: Sentence -> Sentence -> Sentence

-- | Helper for wrapping <a>Sentence</a>s in parentheses.
sParen :: Sentence -> Sentence

-- | This is to collect <i>symbolic</i> <a>UID</a>s that are printed out as
--   a <tt>Symbol</tt>.
sdep :: Sentence -> [UID]
shortdep :: Sentence -> [UID]
class NounPhrase n

-- | Retrieves singular form of term. Ex. "the quick brown fox".
phraseNP :: NounPhrase n => n -> Sentence

-- | Retrieves plural form of term. Ex. "the quick brown foxes".
pluralNP :: NounPhrase n => n -> PluralForm

-- | Retrieves the singular form and applies a captalization rule (usually
--   capitalizes the first word) to produce a <a>Sentence</a>. Ex. "The
--   quick brown fox".
sentenceCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization

-- | Retrieves the singular form and applies a captalization rule (usually
--   capitalizes all words) to produce a <a>Sentence</a>. Ex. "The Quick
--   Brown Fox".
titleCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization

-- | For nouns and <tt>NounPhrase</tt>s. May be constructed from a proper
--   noun, common noun, or phrase (<a>Sentence</a>) and their respective
--   pluralization and capitalization rules.
data NP

-- | Self plural.
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn :: String -> NP

-- | Plural form simply adds "s" (ex. Henderson -&gt; Hendersons).
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn' :: String -> NP

-- | Plural form adds "e".
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn'' :: String -> NP

-- | Plural form adds "es" (ex. Bush -&gt; Bushes).
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn''' :: String -> NP

-- | Constructs a <a>ProperNoun</a> with a custom plural rule (using
--   <a>IrregPlur</a> from <a>PluralRule</a>). First argument is the String
--   representing the noun, second is the rule.
pnIrr :: String -> PluralRule -> NP

-- | Self plural.
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn :: String -> NP

-- | Plural form simply adds "s" (ex. dog -&gt; dogs).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn' :: String -> NP

-- | Plural form adds "e" (ex. formula -&gt; formulae).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn'' :: String -> NP

-- | Plural form adds "es" (ex. bush -&gt; bushes).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn''' :: String -> NP

-- | Constructs a common noun that allows you to specify the pluralization
--   rule (as in <a>pnIrr</a>).
cnIP :: String -> PluralRule -> NP

-- | Common noun that allows you to specify both the pluralization rule and
--   the capitalization rule for sentence case (if the noun is used at the
--   beginning of a sentence).
cnIrr :: String -> PluralRule -> CapitalizationRule -> NP

-- | Constructs a common noun that pluralizes by dropping the last letter
--   and adding an "ies" ending (ex. body -&gt; bodies).
cnIES :: String -> NP

-- | Construct a common noun that pluralizes by dropping the last two
--   letters and adding an "ices" ending (ex. matrix -&gt; matrices).
cnICES :: String -> NP

-- | Constructs a common noun that pluralizes by dropping the last two
--   letters and adding "es" (ex. analysis -&gt; analyses).
cnIS :: String -> NP

-- | Constructs a common noun that pluralizes by dropping the last two
--   letters and adding "a" (ex. datum -&gt; data).
cnUM :: String -> NP

-- | Creates a <a>NP</a> with a given singular and plural form (as
--   <a>String</a>s) that capitalizes the first letter of the first word
--   for sentence case.
nounPhrase :: String -> PluralString -> NP

-- | Similar to <a>nounPhrase</a>, but takes a specified capitalization
--   rule for the sentence case.
nounPhrase' :: String -> PluralString -> CapitalizationRule -> NP

-- | Capitalization rules.
data CapitalizationRule

-- | Capitalize the first letter of the first word only.
CapFirst :: CapitalizationRule

-- | Capitalize the first letter of each word.
CapWords :: CapitalizationRule

-- | Replace the noun phrase with the given <a>Sentence</a>. Used for
--   custom capitalization.
Replace :: Sentence -> CapitalizationRule

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
atStartNP :: NounPhrase n => n -> Capitalization

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
atStartNP' :: NounPhrase n => n -> Capitalization

-- | Pluralization rules.
data PluralRule

-- | Add "s" to the end of the noun phrase.
AddS :: PluralRule

-- | Add "e" to the end of the noun phrase.
AddE :: PluralRule

-- | Add "es" to the end of the noun phrase.
AddES :: PluralRule

-- | The noun phrase is already plural.
SelfPlur :: PluralRule

-- | Apply the given function to the noun phrase to get the plural.
IrregPlur :: (String -> String) -> PluralRule

-- | Combine two noun phrases. The singular form becomes <tt>phrase</tt>
--   from t1 followed by <tt>phrase</tt> of t2. The plural becomes
--   <tt>phrase</tt> of t1 followed by <tt>plural</tt> of t2. Uses standard
--   <a>CapFirst</a> sentence case and <a>CapWords</a> title case. For
--   example: <tt>compoundPhrase system constraint</tt> will have singular
--   form "system constraint" and plural "system constraints".
compoundPhrase :: (NounPhrase a, NounPhrase b) => a -> b -> NP

-- | Similar to <a>compoundPhrase</a>, but the sentence case is the same as
--   the title case (<a>CapWords</a>).
compoundPhrase' :: NP -> NP -> NP

-- | Similar to <a>compoundPhrase'</a>, but accepts two functions that will
--   be used to construct the plural form. For example,
--   <tt>compoundPhrase'' plural phrase system constraint</tt> would have
--   the plural form "systems constraint".
compoundPhrase'' :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Similar to <a>compoundPhrase</a>, but used when you need a special
--   function applied to the first term of both singular and pluralcases
--   (eg. short or plural).
compoundPhrase''' :: (NP -> Sentence) -> NP -> NP -> NP

-- | Similar to <a>compoundPhrase</a>, but pluralizes the first <a>NP</a>
--   for both singular and plural cases.
compoundPhraseP1 :: NP -> NP -> NP

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP :: NounPhrase n => n -> Capitalization

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP' :: NounPhrase n => n -> Capitalization

-- | Custom noun phrase constructor that takes a singular form
--   (<a>Sentence</a>), plural form (<a>Sentence</a>), sentence case
--   capitalization rule, and title case capitalization rule.
nounPhrase'' :: Sentence -> PluralForm -> CapitalizationRule -> CapitalizationRule -> NP

-- | For things that should not be pluralized (or are self-plural). Works
--   like <a>nounPhrase</a>, but with only the first argument.
nounPhraseSP :: String -> NP

-- | Similar to nounPhrase, except it only accepts one <a>Sentence</a>.
--   Used for Requirements, Assumptions, LikelyChanges, etc. to allow for
--   referencing. Plural case is just <a>AddS</a>.
nounPhraseSent :: Sentence -> NP

-- | Helper for common pattern of introducing the title-case version of a
--   noun phrase (from an Idea) followed by its abbreviation in
--   parentheses.
introduceAbb :: Idea n => n -> Sentence

-- | Helper for getting the phrase from a <a>NamedIdea</a> using it's UID.
phrase :: (HasUID n, NamedIdea n) => n -> Sentence

-- | Helper for getting the plural of a phrase from a <a>NamedIdea</a>.
plural :: (HasUID n, NamedIdea n) => n -> Sentence

-- | Singular possesive function
--   
--   Helper for getting the possesive cases from the term of a
--   <a>NamedIdea</a>.
phrasePoss :: NamedIdea n => n -> Sentence

-- | Plural possesive function
--   
--   Helper for getting the possesive cases from the term of a
--   <a>NamedIdea</a>.
pluralPoss :: NamedIdea n => n -> Sentence

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   <a>NamedIdea</a>.
atStart :: NamedIdea n => n -> Sentence

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   <a>NamedIdea</a>.
atStart' :: NamedIdea n => n -> Sentence

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   <a>NamedIdea</a>.
titleize :: NamedIdea n => n -> Sentence

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   <a>NamedIdea</a>.
titleize' :: NamedIdea n => n -> Sentence

-- | Get short form (if it exists), else get term of an <a>Idea</a>.
short :: (Idea c, HasUID c) => c -> Sentence

-- | Used for holding the short form of a name (as a <a>Sentence</a> with a
--   wrapper).
data ShortName

-- | Smart constructor for making a <a>Sentence</a> into a
--   <a>ShortName</a>.
shortname' :: Sentence -> ShortName

-- | Pulls the short form (as a <a>Sentence</a>) out of a <a>ShortName</a>.
getSentSN :: ShortName -> Sentence

-- | Derivations are an ordered list of sentences and expressions. They are
--   rendered in order as paragraphs and equation blocks to display the
--   derivation.
data Derivation
Derivation :: Sentence -> [Sentence] -> Derivation

-- | Smart constructor for creating a <a>Derivation</a>.
mkDeriv :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but prepends "Detailed derivation of" to
--   the header.
mkDerivName :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but without a header <a>Sentence</a>.
mkDerivNoHeader :: [Sentence] -> Derivation

-- | A Document has a Title (<a>Sentence</a>), Author(s) (<a>Sentence</a>),
--   and <a>Section</a>s which hold the contents of the document.
data Document
Document :: Title -> Author -> ShowTableOfContents -> [Section] -> Document
Notebook :: Title -> Author -> [Section] -> Document

-- | Determines whether or not the table of contents appears on the
--   generated artifacts.
data ShowTableOfContents
ToC :: ShowTableOfContents
NoToC :: ShowTableOfContents

-- | Types of definitions (general, instance, theory, or data).
data DType
General :: DType
Instance :: DType
Theory :: DType
Data :: DType

-- | Sections have a title (<a>Sentence</a>), a list of contents
--   (<a>SecCons</a>) and a shortname (<a>Reference</a>).
data Section
Section :: Title -> [SecCons] -> Reference -> Section
[tle] :: Section -> Title
[cons] :: Section -> [SecCons]
[_lab] :: Section -> Reference

-- | Contents may be labelled or unlabelled.
data Contents
UlC :: UnlabelledContent -> Contents
LlC :: LabelledContent -> Contents

-- | Section Contents are split into subsections or contents, where
--   contents are standard layout objects (see <a>Contents</a>).
data SecCons
Sub :: Section -> SecCons
Con :: Contents -> SecCons

-- | Denotes the different possible types that can be used as a list.
data ListType

-- | Bulleted list.
Bullet :: [(ItemType, Maybe String)] -> ListType

-- | Enumerated list.
Numeric :: [(ItemType, Maybe String)] -> ListType

-- | Simple list with items denoted by <tt>:</tt>. Renders as "Title: Item"
Simple :: [ListTuple] -> ListType

-- | Descriptive list, renders as "<b>Title: Item</b>" (see
--   <a>ListTuple</a>).
Desc :: [ListTuple] -> ListType

-- | Renders a list of "<tt><a>Title</a></tt> is the <tt>Item</tt>".
Definitions :: [ListTuple] -> ListType

-- | Denotes how something should behave in a list (<a>ListType</a>).
data ItemType

-- | Standard singular item.
Flat :: Sentence -> ItemType

-- | Nest a list (<a>ListType</a>) as an item.
Nested :: Header -> ListType -> ItemType
type ListTuple = (Title, ItemType, Maybe String) " Formats as Title: Item. For use in lists."

-- | Contains a <a>Reference</a> and <a>RawContent</a>.
data LabelledContent
LblC :: Reference -> RawContent -> LabelledContent
[_ref] :: LabelledContent -> Reference
[_ctype] :: LabelledContent -> RawContent

-- | Only contains <a>RawContent</a>.
newtype UnlabelledContent
UnlblC :: RawContent -> UnlabelledContent
[_cntnts] :: UnlabelledContent -> RawContent

-- | Smart constructor for retrieving the contents (<a>Section</a>s) from a
--   <a>Document</a>.
extractSection :: Document -> [Section]

-- | Smart constructor that wraps <a>UnlabelledContent</a> into
--   <a>Contents</a>.
mkParagraph :: Sentence -> Contents

-- | Smart constructor similar to <a>llcc</a>, but takes in
--   <a>RawContent</a> first.
mkRawLC :: RawContent -> Reference -> LabelledContent

-- | Manually removes the first section of a document (table of contents
--   section). temp fix for Notebook (see if we need this in notebook
--   later)
checkToC :: Document -> Document

-- | Smart constructor for labelled content chunks.
llcc :: Reference -> RawContent -> LabelledContent

-- | Smart constructor for unlabelled content chunks (no <a>Reference</a>).
ulcc :: RawContent -> UnlabelledContent

-- | Smart constructor for creating <a>Section</a>s with a title
--   (<a>Sentence</a>), introductory contents (ie. paragraphs, tables,
--   etc.), a list of subsections, and a shortname (<a>Reference</a>).
section :: Sentence -> [Contents] -> [Section] -> Reference -> Section

-- | <a>Figure</a> smart constructor with a <a>Lbl</a> and a
--   <a>Filepath</a>. Assumes 100% of page width as max width.
fig :: Lbl -> Filepath -> RawContent

-- | <a>Figure</a> smart constructor that allows for customized max widths.
figWithWidth :: Lbl -> Filepath -> MaxWidthPercent -> RawContent

-- | MaxWidthPercent should be kept in the range 1-100. Values outside this
--   range may have unexpected results. Used for specifying max figure
--   width as <tt>pagewidth*MaxWidthPercent/100</tt>.
type MaxWidthPercent = Float

-- | Members of this class must have <a>RawContent</a>.
class HasContents c

-- | Provides a <tt>Lens</tt> to the <a>RawContent</a>.
accessContents :: HasContents c => Lens' c RawContent

-- | Types of layout objects we deal with explicitly.
data RawContent

-- | table has: header-row, data(rows), label/caption, and a bool that
--   determines whether or not to show label.
Table :: [Sentence] -> [[Sentence]] -> Title -> Bool -> RawContent

-- | Paragraphs are just sentences.
Paragraph :: Sentence -> RawContent

-- | Block of Equations holds an expression.
EqnBlock :: ModelExpr -> RawContent

-- | Grants the ability to label a group of <a>RawContent</a>.
DerivBlock :: Sentence -> [RawContent] -> RawContent

-- | For enumerated lists.
Enumeration :: ListType -> RawContent

-- | Defines something with a type, identifier, and <a>Contents</a>.
Defini :: DType -> [(Identifier, [Contents])] -> RawContent

-- | For creating figures in a document. Should use relative file path.
Figure :: Lbl -> Filepath -> MaxWidthPercent -> RawContent

-- | Grants the ability to reference something.
Bib :: BibRef -> RawContent

-- | Contain a graph with coordinates (<a>Sentence</a>s), maybe a width and
--   height, and a label (<a>Sentence</a>). | CodeBlock CodeExpr -- ^ Block
--   for codes TODO: Fill this one in.
Graph :: [(Sentence, Sentence)] -> Maybe Width -> Maybe Height -> Lbl -> RawContent

-- | Smart constructor that wraps <a>LabelledContent</a> into
--   <a>Contents</a>.
mkFig :: Reference -> RawContent -> Contents

-- | Create a reference for a table. Takes in the name of a table (which
--   will also be used for its shortname).
makeTabRef :: String -> Reference

-- | Create a reference for a figure. Takes in the name of a figure (which
--   will also be used for its shortname).
makeFigRef :: String -> Reference

-- | Create a reference for a section. Takes in the name of a section and a
--   shortname for the section.
makeSecRef :: String -> Sentence -> Reference

-- | Create a reference for a equation. Takes in the name of the equation
--   (which will also be used for its shortname).
makeEqnRef :: String -> Reference

-- | Create a reference for a <a>URI</a>. Takes in a <a>UID</a> (as a
--   <a>String</a>), a reference address, and a shortname.
makeURI :: String -> String -> ShortName -> Reference

-- | Variants of <a>makeTabRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeTabRef' :: UID -> Reference

-- | Variants of <a>makeFigRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeFigRef' :: UID -> Reference

-- | Variants of <a>makeSecRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeSecRef' :: UID -> Sentence -> Reference

-- | Variants of <a>makeEqnRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeEqnRef' :: UID -> Reference

-- | Variants of <a>makeURI</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeURI' :: UID -> String -> ShortName -> Reference

-- | The difference kinds of spaces that may exist. This type holds
--   numerical spaces (such as the set of integers, rationals, etc.), a
--   space for booleans, a space for characters, dimensional spaces
--   (vectors, arrays, etc.), a space for Actors, discrete sets (both for
--   numbers and strings), and a void space.
data Space
Integer :: Space
Rational :: Space
Real :: Space
Natural :: Space
Boolean :: Space
Char :: Space
String :: Space
Radians :: Space
Vect :: Space -> Space
Array :: Space -> Space
Actor :: String -> Space
DiscreteD :: [Double] -> Space
DiscreteS :: [String] -> Space
Function :: NonEmpty Primitive -> Primitive -> Space
Void :: Space

-- | A RealInterval is a subset of <a>Real</a> (as a <a>Space</a>). These
--   come in different flavours. For now, we embed <tt>Expr</tt> for the
--   bounds, but that will change as well.
data RealInterval a b
[Bounded] :: (Inclusive, a) -> (Inclusive, b) -> RealInterval a b
[UpTo] :: (Inclusive, a) -> RealInterval a b
[UpFrom] :: (Inclusive, b) -> RealInterval a b

-- | Inclusive or exclusive bounds.
data Inclusive
Inc :: Inclusive
Exc :: Inclusive

-- | Describes the domain of a <a>Symbol</a> given a topology. Can be
--   bounded or encase all of the domain.
data DomainDesc (tplgy :: RTopology) a b
[BoundedDD] :: Symbol -> RTopology -> a -> b -> DomainDesc 'Discrete a b
[AllDD] :: Symbol -> RTopology -> DomainDesc 'Continuous a b

-- | Topology of a subset of reals.
data RTopology
Continuous :: RTopology
Discrete :: RTopology
type ContinuousDomainDesc a b = DomainDesc 'Continuous a b
type DiscreteDomainDesc a b = DomainDesc 'Discrete a b

-- | Gets the name of an <a>Actor</a>.
getActorName :: Space -> String

-- | Gets the inner <a>Space</a> of a vector.
getInnerSpace :: Space -> Space

-- | Decorations on symbols/characters such as hats or Vector
--   representations (determines bolding, italics, etc).
data Decoration

-- | A <a>Symbol</a> is actually going to be a graphical description of
--   what gets rendered as a (unique) symbol. This is actually NOT based on
--   semantics at all, but just a description of how things look.
--   
--   Symbols can be:
--   
--   <ul>
--   <li><tt><a>Variable</a></tt> (string such as "x" that represent a
--   value that can vary)</li>
--   <li><tt><a>Label</a></tt> (strings such as "max" or "target" that
--   represent a single idea)</li>
--   <li><tt><a>Special</a></tt> characters (ex. unicode)</li>
--   <li><tt>Decorated</tt> symbols using <a>Atop</a></li>
--   <li><tt>Concatenations</tt> of symbols, including subscripts and
--   superscripts</li>
--   <li><tt><a>Empty</a></tt>! (this is to give this a monoid-like
--   flavour)</li>
--   </ul>
data Symbol

-- | Language of units (how to build them up into a unit symbol). Of the
--   form (<a>Symbol</a> ^ <a>Integer</a>). The <a>Integer</a> may be
--   negative, but should not be zero.
newtype USymb
US :: [(Symbol, Integer)] -> USymb

-- | Create a table body (not including header row) by applying the given
--   functions to the column elements of the table rows (in order). The
--   first argument is a list of functions to be applied (one per column).
--   This essentially creates the rows. The second argument is a list of
--   elements apply the functions to.
--   
--   For example, <tt>mkTable [id, *5] [1,2,3]</tt> should produce a table:
--   
--   <pre>
--   | 1 |  5 |
--   | 2 | 10 |
--   | 3 | 15 |
--   </pre>
mkTable :: [a -> b] -> [a] -> [[b]]

-- | Stages correspond to what we're trying to look up. They range from
--   abstract to concrete. Equational stages are more theoretical and
--   oriented towards abstract design while the Implementation stages are
--   more oriented towards detailed design.
data Stage
Equational :: Stage
Implementation :: Stage

-- | Helper function for getting a symbol in the Equational Stage.
eqSymb :: HasSymbol q => q -> Symbol

-- | Helper function for getting a symbol in the Implementation Stage.
codeSymb :: HasSymbol q => q -> Symbol

-- | Finds if a <a>Stage</a> symbol is real or Empty. True if real.
hasStageSymbol :: HasSymbol q => q -> Stage -> Bool

-- | Helper for creating a symbol with Unicode in it.
autoStage :: Symbol -> Stage -> Symbol

-- | Helper for creating a symbol with a hat ("^") atop it.
hat :: Symbol -> Symbol

-- | Helper for creating a Vector symbol.
prime :: Symbol -> Symbol

-- | Helper for creating a symbol that depends on the stage.
staged :: Symbol -> Symbol -> Stage -> Symbol

-- | Helper for creating a symbol with a subscript to the right. Arguments:
--   Base symbol, then subscripted symbol.
sub :: Symbol -> Symbol -> Symbol

-- | Helper for a common case of subscript, with a string Arguments: Base
--   symbol, then subscript <a>String</a>.
subStr :: Symbol -> String -> Symbol

-- | Helper for creating a symbol with a superscript to the right.
--   Arguments: Base symbol, then superscripted symbol.
sup :: Symbol -> Symbol -> Symbol

-- | Helper for autoStage that applies unicodeString to all <a>Symbol</a>s
--   with <a>String</a>s.
unicodeConv :: Symbol -> Symbol

-- | Helper for creating a symbol with a superscript on the left side of
--   the symbol. Arguments: Base symbol, then superscripted symbol.
upperLeft :: Symbol -> Symbol -> Symbol

-- | Helper for creating a Vector symbol.
vec :: Symbol -> Symbol

-- | Label smart constructor, requires non-empty labels
label :: String -> Symbol

-- | Variable smart constructor, requires non-empty variables
variable :: String -> Symbol

-- | Commonly used type for QDefinitions containing Exprs.
type SimpleQDef = QDefinition Expr

-- | Commonly used type for QDefinitions containing ModelExprs.
type ModelQDef = QDefinition ModelExpr

-- | Commonly used type for polymorphic Exprs.
type PExpr = forall r. ExprC r => r
