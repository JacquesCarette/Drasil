\chapter{Introduction}

Documentation is good\cite{AckroydEtAl2008, AlMatiiAndBoujarwah2002, 
CarverEtAl2007, EasterbrookAndJohns2009, FlattEtAl2009, 
FritzsonGunnarssonAndJirstrand2002, HattonAndRoberts1994, Hyman1990, 
JohnsonAndJohnson1997, Kelly2007, Kelly2013, Kelly2015, Knuth1984, Kotula2000, 
Leisch2002, Lenth2009, LenthEtAl2007, MatthewsEtAl2008, Parnas2010, 
ParnasAndClements1986, ParnasEtAl1994, PieterseKourieAndBoake2004, Ramsey1994, 
Roache1998, SandersAndKelly2008, SchulteEtAl2012, ShumAndCook1993, Simonis2003, 
SmithAndKoothoor2016, SmithAndYu2009, SmithEtAl2013, SmithEtAl2015-SS-TR, 
SmithEtAl2015SQJ, SmithKoothoorAndNedialkov2014, Thimbleby1986}, yet it is not 
often prioritized on software projects. Many projects focus heavily on source 
code, treating it as the primary artifact, while documentation is often 
neglected despite its necessary role. Documentation serves as a critical 
bridge between stakeholders, enabling effective communication, knowledge 
transfer, and long-term maintainability. It helps clarify requirements, 
supports onboarding of new team members, facilitates regulatory compliance, and 
provides a reference for future maintenance and evolution. Well-maintained 
documentation reduces the risk of misunderstandings, errors, and knowledge 
loss, ultimately contributing to higher quality and more reliable software 
systems. 

To simplify our discussion of both source code and documentation, this thesis 
introduces the term \sf{} to refer to any artifact produced during software 
development that conveys knowledge, including source code, 
requirements, design documents, test cases, user manuals, and any other 
relevant materials. Code and other software artifacts (\sfs{}) by their nature 
must say the same thing, albeit to different audiences (ie. developers, 
maintainers, regulators, or end users); if they did not, they would be 
describing different systems. This principle applies regardless of the context 
of the \sf{}. Take this thesis for example: it is written 
for an audience familiar with classical software engineering, including those 
who have experience with requirements documents, design documents, and the 
challenges of maintaining large, long-lived software systems. The examples and 
case studies are drawn from scientific computing, but the pain points and 
solutions discussed are relevant to wider software engineering contexts as a 
whole.

Speaking broadly about \sfs{}, let us consider a few different documents. A 
software requirements document is a human-readable abstraction of \textit{what} 
the software is supposed to do. Whereas a design document is a human-readable 
version of \textit{how} the software is supposed to fulfill its requirements. 
The source code itself is a computer-readable list of instructions combining 
\textit{what} must be done and, in many languages, \textit{how} that is to be 
accomplished. Importantly, this multiplicity of views is not limited to 
separate \sfs{}; even within a single artifact the same information may appear 
in multiple forms. For example, a requirements document may include natural 
language descriptions, mathematical equations, and other relationships 
expressed in a multitude of ways (tables, graphs, diagrams, etc.).

\begin{table}[h]
\centering
\caption{The same information as natural language, equation, and code}
\label{tab:proj-views}
\begin{tabular}{|p{0.3\linewidth}|p{0.22\linewidth}|p{0.48\linewidth}|}
\hline
\textbf{\rule{0pt}{4.5ex}Description} & 
\textbf{Equation} & 
\textbf{Code (Python)} \\
\hline
\vspace{1.5ex} $P_b$ is the Probability of Breakage &
\vspace{1.5ex} $P_b = 1 - e^-B$ &
\begin{minipage}[t]{\linewidth}
\begin{lstlisting}[language=Python,basicstyle=\ttfamily\footnotesize]
def func_P_b(B):
    return 1.0 - math.exp(-B)
\end{lstlisting}
\end{minipage} \\
\hline
\end{tabular}
\end{table}

Table~\ref{tab:proj-views} shows how the same information (the definition of 
$P_b$) can be represented in several different views: as a natural language 
description, equation, and code definition. We aim to take advantage of the 
inherent redundancy across these views to distill a single source of 
information, thus removing the need to manually duplicate information across 
\sfs{}. This example illustrates a broader challenge: when the same knowledge 
must be expressed in multiple forms for different audiences or purposes, the 
effort to keep these representations consistent becomes significant.

Manually writing and maintaining a full range of software artifacts (ie.
multiple documents for different audiences plus the source code) is
redundant and tedious. Factor in deadlines, changing requirements, and other
common issues faced during development and you have a perfect storm for
inter-artifact syncronization issues.

How can we avoid having our artifacts fall out of sync with each other?
Some would argue ``just write code!" And that is exactly what a number of other
approaches have tried. Documentation generators like Doxygen, Javadoc, Pandoc,
and more take a code-centric view of the problem. Typically, they work by having
natural-language descriptions and/or explanations written as specially delimited
comments in the code which are later automatically compiled into a
human-readable document.

While these approaches definitely have their place and can come in quite handy,
they do not solve the underlying redundancy problem. The developers are still
forced to manually write descriptions of systems in both code and comments.
They also do not generate all software artifacts - commonly they are used to
generate only API documentation targeted towards developers or user manuals.

If we can truly understand the differences and commonalities between 
software artifacts, we can develop tools to capitalize on them and streamline 
the process of creating and maintaining software artifacts. For that we first 
need to break down common artifacts to develop an understanding of their 
contents, intended audience, and how they differ whether on intra- or 
inter-project scales.

We propose a new framework, Drasil\footnote{The name Drasil comes from a 
shortening of the name Yggdrasil from Norse mythology, as we believe Drasil can 
span the many worlds (domains) of software engineering.}, alongside a 
knowledge-centric view of software, to help take advantage of inherent 
redundancy while reducing manual duplication and synchronization problems. Our 
approach looks at what underlies the problems we solve using software and 
capturing that ``common" or ``core" knowledge. We then use that knowledge to 
generate our software artifacts\footnote{For the purpose of this thesis we 
focus on source code, requirements, and build instructions, but Drasil is 
extensible and can be adapted to generate additional artifact types.}, thus 
gaining the benefits inherent to the generation process: lack of manual 
duplication, one source to maintain, and 'free' traceability of information.

\section{Problem Statement and Motivation}
Despite the recognized value of documentation and software artifacts (\sfs{}), 
the process of creating and maintaining them is fraught with redundancy, 
tedium, and potential risks of inconsistency. Change is inevitable in software 
projects: requirements evolve, bugs are fixed, and features are added. As 
software evolves, artifacts (requirements documents, design documents, source 
code, etc.) often fall out of sync, leading to errors, increased maintenance 
costs, and reduced trust in documentation. This thesis addresses the challenge: 
\emph{How can we systematically reduce unnecessary redundancy and improve 
consistency across software artifacts, especially in domains where correctness 
and traceability are critical?}

The root of the problem is rooted in the same knowledge needing to be expressed 
in multiple forms for different audiences and purposes. Each artifact is 
typically maintained separately, requiring manual updates whenever changes 
occur. This manual process is error-prone and time-consuming, and the effort 
required to keep all artifacts synchronized grows rapidly as projects become 
more complex or requirements change more frequently.

Existing approaches, such as documentation generators and code-centric tools,
alleviate some of the burden but do not eliminate the underlying redundancy.
They often focus on generating a limited subset of artifacts (such as API
documentation) and still require developers to duplicate information in code
and comments. As a result, inconsistencies persist, and the benefits of
automation are only partially realized.

The consequences of these challenges are particularly acute in scientific
computing and other domains where correctness, traceability, and regulatory
compliance are essential. In such contexts, even minor inconsistencies can
undermine confidence in the software and its documentation, potentially
leading to costly errors or rework.

Motivated by these issues, this thesis seeks to develop a knowledge-centric
approach that captures the core information underlying a system and uses it to
generate all relevant \sfs{}. By reducing manual duplication and
synchronization effort, we aim to improve consistency, maintainability, and
traceability across the software lifecycle.

\section{The mundane and why it matters}

What we are doing is not big and flashy; instead, it is focused on the tedium
we deal with in our day-to-day lives as software engineers. We are focused on
improving the development experience holistically. The small annoyances can be
more frustrating than solving larger problems. For example, the feeling of
hours spent banging heads against walls for an off-by-one error or a typo that 
somehow snuck past review, versus the sublime joy of finding a novel, 
interesting, scalable, and maintainable solution to a problem.

These little pain points, including having to manually update artifacts after
modifying code, especially in regulated industries, accumulate over time and
can have a significant impact on productivity and morale. While each instance
may seem minor, together they represent a substantial barrier to efficient and
reliable software development, particularly in domains where correctness and
traceability are essential.

Drasil is our approach to address these everyday frustrations by systematically
reducing manual duplication and synchronization effort. By capturing core
knowledge explicitly and generating artifacts from a single source, Drasil
helps ensure that changes propagate consistently and automatically across all
relevant documents and code. This approach not only reduces the risk of
inconsistencies, but also supports practices such as continuous integration and
refactoring, keeping artifacts in a steady-state of consistency.

The value of this approach is most apparent in the small details: the hours
saved by not having to update documentation by hand, the confidence that comes
from knowing all artifacts are synchronized, and the ability to trace the
origin of any piece of information. These improvements may not be as
immediately dramatic as solving a major technical challenge, but they
accumulate to create a more reliable, maintainable, and satisfying development
experience. In this way, Drasil demonstrates that addressing the mundane is not
only worthwhile, but essential for advancing the practice of software
engineering.

\section{Scope}
\label{sec:scope}
We are well aware of the ambitious nature of attempting to solve the problem of
manual duplication and unnecessary redundancy across all possible software
systems. Frankly, it would be highly impractical to attempt to solve such a
broad spectrum of problems. Each software domain poses its own challenges,
alongside specific benefits and drawbacks. 

Our work on Drasil is most relevant to software that is 
well-understood~\cite{CaretteEtAl2023} and undergoes frequent change 
(maintenance). Good candidates for development using Drasil are long-lived (10+ 
years) software projects with artifacts of interest to multiple stakeholders. 
With that in mind, we have decided to focus on Scientific Computing (SC) 
software. Specifically, we are looking at software that follows the pattern 
\mbox{\emph{input~$\rightarrow$~process~$\rightarrow$~output}}. This focus 
allows us to make the initial implementation of Drasil feasible and tractable, 
while still capturing a broad class of scientific computing problems.

SC software has a strong fundamental underpinning of well-understood concepts.
It also has the benefit of seldomly changing, and when it does, existing models
are not necessarily invalidated. For example, rigid-body problems in physics are
well-understood and the underlying modeling equations are unlikely to change.
However, should they change, the current models will likely remain as good
approximations under a specific set of assumptions. For instance, who hasn't
heard ``assume each body is a sphere" during a physics lecture?

SC software could also benefit from buy-in to good software development 
practices as many SC software developers put the emphasis on science and not 
development~\citep{Kelly2007}. Rather than following rigid, process-heavy 
approaches deemed unfavourable~\citep{CarverEtAl2007}, developers of SC 
software choose to use knowledge acquisition driven~\citep{Kelly2015}, 
agile~\citep{Segal2005, CarverEtAl2007, AckroydEtAl2008, 
EasterbrookAndJohns2009}, or amethododical~\citep{Kelly2013} processes instead.

Finally, while recent advances in Machine Learning (ML), Large Language Models 
(LLMs), and other Artificial Intelligence (AI) based tooling have shown promise 
in automating aspects of software engineering, Drasil intentionally does not 
employ these approaches. This is because our focus is on achieving determinism 
and reproducibility: properties that are essential in scientific computing. The 
artifacts generated by Drasil must be consistent and repeatable, which is not 
guaranteed by current AI-based methods.

\section{Roadmap}

The remainder of this thesis is organized as follows:
\begin{itemize}
    \item \textbf{Chapter~\ref{c:background}: Background} reviews relevant 
	literature on software artifacts, redundancy, reuse, literate programming, 
    and generative programming.
    \item \textbf{Chapter~\ref{c:process}: Our Process} details the methods 
    used to analyze \sfs{}, identify redundancy, and motivate our 
    knowledge-centric approach.
    \item \textbf{Chapter~\ref{c:drasil}: The Drasil Framework} presents the 
    design, architecture, and implementation of Drasil, including its 
    knowledge capture and artifact generation capabilities.
    \item \textbf{Chapter~\ref{c:results}: Results} presents observations
    and analysis from reimplementing existing case studies using Drasil,
    highlighting practical benefits.
    \item \textbf{Chapter~\ref{c:discussion}: Discussion} interprets the 
    results, explores the implications of the knowledge-centric approach, and
    discusses limitations and challenges encountered.
    \item \textbf{Chapter~\ref{c:conclusion}: Conclusion} summarizes the 
    findings, contributions, and implications of this work and outlines 
    potential extensions, open questions, and directions for further research.
\end{itemize}

\section{Contributions}

The main contributions of this thesis are:

\begin{itemize}
    \item \textbf{Systematic analysis of redundancy and inconsistency in 
    software artifacts.} Through detailed breakdowns of \sfs{} across multiple 
    scientific computing case studies, this work exposes patterns and sources 
    of unnecessary duplication and inconsistency that plague traditional 
    artifact-centric workflows.

    \item \textbf{Operationalization of knowledge-centric artifact generation.}
    The thesis develops and formalizes a process for capturing, organizing,
    and projecting domain knowledge, operationalizing software engineering
    principles to enable automated generation of diverse artifacts from a
    single source of truth.

    \item \textbf{Design and implementation of the Drasil framework.}
    Drasil is presented as a novel, extensible framework for knowledge-centric
    software artifact generation. Its architecture includes robust mechanisms
    for knowledge capture (chunks), projection (recipes), and rendering 
    (multi-format output), supporting traceability and maintainability by 
    construction.

    \item \textbf{Demonstration of Drasil's effectiveness via reimplementation 
    of case studies.} The thesis documents the reimplementation of several 
    scientific computing systems using Drasil, showing that local changes to 
    domain knowledge propagate automatically and consistently across all 
    generated artifacts. This approach reduces manual effort, increases error 
    visibility, and supports rapid adaptation and software family evolution.

    \item \textbf{Empirical observations on consistency, traceability, and 
    reproducibility.} Through case study analysis and artifact comparison, the 
    thesis provides evidence that Drasil enforces consistency by construction, 
    improves traceability through explicit provenance, and supports 
    reproducibility via deterministic artifact generation.

    \item \textbf{Identification and clarification of tacit knowledge and 
    implicit assumptions.} By forcing explicit encoding of all domain 
    knowledge, Drasil surfaces hidden assumptions and semantic inconsistencies, 
    enabling their correction and documentation across all artifacts.

    \item \textbf{Framework for rapid generation and maintenance of software 
    families.} The single-source approach and recipe DSL enable efficient 
    creation of software family variants, minimizing duplication and ensuring 
    consistency across related products.

    \item \textbf{Lessons learned and guidance for future research.}
    The thesis distills practical lessons from iterative development,
    onboarding, and refinement, highlighting the importance of centralized
    knowledge, improved authoring tools, and formal validation. It outlines
    open questions and directions for extending Drasil to new domains and
    improving usability. \ds{Is this too much?}

    \item \textbf{Advancing the value of addressing everyday software 
    engineering pain points.} By focusing on the ``mundane'' sources of tedium 
    and error in artifact maintenance, the thesis demonstrates that holistic 
    improvements to development workflows can yield substantial benefits for 
    reliability, maintainability, and developer experience.
\end{itemize}

Drasil allows developers to focus on the system being built as a whole rather than the individual artifacts. We can still produce a ``rational design"~\cite{ParnasAndClements1986} without the explicit tedium of manually keeping everything in sync.

\textit{Note:} While the core techniques and framework were developed by the author, Drasil's ongoing development and case study evolution are collaborative efforts by the Drasil team. This thesis focuses on the author's initial, original contributions and foundational work.