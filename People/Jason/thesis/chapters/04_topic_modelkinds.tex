% ModelKinds -- Theory types / discrimination -- ``Expressions in context''

\chapter{Framing Theories}
\label{chap:modelkinds}

In working to understand some phenomenon, we often look to the boundaries of our
understandings of the phenomenon — the open-ended questions and gaps in our
knowledge. In any domain of knowledge (such as mathematics, philosophy, physics,
chemistry, biology, computer science, or any other studied subject), we often
think about various phenomenon in logical terms of theories and axioms, where
the theories and axioms are written using a global logical language with precise
meanings\todo{I almost make it sound like we're not using English/Any other
	language to communicate ideas, I should clarify this.}. The language is
typically tailored to the field of knowledge. As this work pertains to Drasil,
one language of interest to this research is that of the mathematical language.
A mathematical language is heavily used in science, conveying important
theories, axioms, corollaries, amongst other things. As mathematicians
transferring knowledge to one another, we often use a written form of knowledge,
though unlikely, potentially, with a precise structure to our transcription of
the knowledge, but still, the structure is textual. We might break up the
transcription of the knowledge into its logical constituents. The components of
a theory may be a name, a natural language description, a derivation, some
information regarding its origin (e.g., a reference), and a formalization of the
theories important information in a precise language. Of course, for a
mathematical theory, a mathematical language would be used. Describing a
programming language artifact, we might prefer to call our theories by a series
of other names (e.g., functions/methods, constants, modules, packages,
libraries, \acsp{api}, \acsp{ast}).

In Drasil, both of these languages are of great importance. The mathematical
field of knowledge is directly used in at least two domains currently captured:
the scientific theories, and \acs{gool} \cite{Carette2019}. Meanwhile, the
programming language theory (artifacts) is only directly used in \acs{gool}, and
its various renderers. The SmithEtAl \acs{srs} \cite{SmithAndLai2005} template
generator uses knowledge transcribed as scientific requirements to automatically
generate a series of representational software programs. Thankfully, Smith and
Lai \cite{SmithAndLai2005} break down theories relevant to \acs{scs} into at
least four (4) kinds for their \acs{srs} template:

\intodo{There is a better discussion of these 4 on GitHub (Issue \#2599).}
\intodo{Insider knowledge: the 3 ``models'' are actively being re-thought, and
	\textit{are} being renamed to just ``theories''.}

\begin{enumerate}

	\item \textbf{Theory Models}: A ``theory presentation'' \todo{Cite ``Theory
		      Presentation'', I'm not quite sure what to cite for this yet}: an
	      abstract theory, highly general and unspecific, with room for
	      refinement. Typically, these are names coupled with information
	      contained as axioms and data that make up a coherent story, but
	      that are too vague to be immediately usable by the developers
	      other than for refining into Instance Models.

	\item \textbf{General Definitions}: A partially refined theory, typically
	      bearing a stronger relation to the context of the \acs{srs} than the
	      Theory Models. However, still, these are generally theoretical and
	      abstract, much like Theory Models.

	\item \textbf{Instance Models}: A fully refined theory, derived from the
	      Theory Models and General Definitions, and directly usable by
	      implementors of the \acs{srs}.

	\item \textbf{Data Definitions}: Symbols that are defined with basic
	      expressions of other symbols and inputs. Typically, these are
	      definitions that are ``given'', and used for making inputs easier to
	      work with for the instance models.

\end{enumerate}

\intodo{Example of a theory/instance model here.}

The Instance Models and Data Definitions are to be directly used in the solving
algorithm for the whole system, while the General Definitions and Theory Models
provide justification for the existence of the Instance Models, and the Data
Definitions are provided and relatively unimportant/uncritical to the system.

Since the SmithEtAl generator focuses itself on knowledge captured in the form
of the \acs{srs} template, Drasil requires a comprehensive understanding of both
fields in order to generate representational software for the \acs{srs}. The
focus of the scientific requirements documents are to transcribe the relevant
knowledge of a \acs{scs} system for end-user developers to satisfy when
developing \acs{scs}, and as developed by a domain/scientific expert. For
example, \todo{SRS document example} is used to fully explain \todo{something}
such that a software developer can construct a program based on it. Of course,
if the \acs{srs} document is to be truly sufficient for a software developer to
unambiguously create a representational software artifact, then the software
developer (who potentially knows nothing about the domain discussed in the
\acs{srs} document) will need to be able to credibly transcribe everything into
their program, matching the requirements as set by the \acs{srs} document.
Drasil is an apparatus for testing our understanding of these scenarios, rather
than having a read-only ``view'' of the scientists/domain experts knowledge
available to the software developer, the knowledge itself is available, in its
most raw encoded form.

Drasil relies on searching for a calculation path that relates the inputs and
outputs designated in an \acs{srs} document. The relations are based on the
grounded theories (\textit{Instance Models}) designated in the \acs{srs}. The
relations themselves are currently required to be of the form \(x = f(a, b, c,
\ldots{})\), with some exceptions made for \acsp{ode}. \acsp{ode} are being
actively developed to remove the manually written exceptions made for them
(outside the scope of this work).

Instance Models, General Definitions, and Data Definitions each rely on a
\textit{Relation Concept} (\RelationConcept{}): a notable and named mathematical
relation with a description and abbreviated name. A \RelationConcept{} is
modelled as a \Relation{} coupled with a \ConceptChunk{} (\todo{Add ConceptChunk
	original definition to thesis appendix.}, a named \textit{thing} with a name,
abbreviation, and natural language description):

\originalRelationConcept{}

The \Relation{}s \todo{add a reference to an appendix entry for the ``type
	Relation = Expr'' definition} in the \RelationConcept{} are, fundamentally,
just an instance of a universal mathematical language which conveys their
information, but given a type synonym to indicate that the instance should
be a mathematical relation.

\intodo{Theory Models as well rely on this same mathematical language used in
	\RelationConcept{}s to describe their own theories as well. The encoding is
	slightly better as it exposes more of the expressions, but, still, the
	expressions are left problematic.}

\section{A Universal Math Language}
\label{sec:modelkinds:language}

\originalExprHaskell

\Expr{} (defined above, in \refOriginalExprHaskell{} with an \acs{adt}\todo{I
	should probably discuss the ADT portion a bit more.}) represents the
hypothetical mathematical language used to discuss the mathematics relevant
to common \acs{scs}, specifically, at least to under/graduate-level physics
problems. The language contains the commonly found operations in a
well-understood physics textbook (here, with a focus on graduate-level
scientific problems). The mathematical language is universal, covering a
wide range of knowledge, including facilities for creating commonly used
primitive data types, operations, and functions  in mathematics, physics,
and computer science and programming languages. For example, \todo{An
	expression.} is transcribed in Drasil as follows:

\intodo{Transcription of the above expression.}

This transcription relies on smart constructors, such as \todo{Ref\. a new
	appendix entry for new smart constructors.}. The smart constructors used are
all specialized to \Expr{} and perform simplifications along the way (such
as folding \(1 \cdot x\) into \(x\)).

\section{A Universal Theory Description Language}

As Drasils theories rely heavily on \Relation{}s (and \RelationConcept{}s)
(\todo{Ref\. the definitions of DDs, IMs, GDs, and TMs}), we may observe that
the theories are an accurate reflection of writing out mathematics involved as
one might write them down on paper: exactly as they please. In modelling any
problem, one will, of course, model the work of their pencil and paper. This is
exactly what occurs here. Theories here are shallow representations of
knowledge, that mimic your pencil and papers work to a clueless reader.

\section{Usage: Converting to Software}\todo{\ldots{} and \acs{srs} sections}

Drasil relies on converting the various kinds of theories described in the
\acs{srs} template \cite{SmithAndLai2005}, essentially encoded in Drasil as
\RelationConcept{}s, into representational code.

\intodo{Example of an IMs conversion into Java code.}

Unfortunately, issues occur when attempting to convert the knowledge contained
in \RelationConcept{}s. Namely,

\intodo{I should probably rewrite the below point form notes as paragraphs as
	well, even though I originally intended to have it as a numbered list.}

\begin{enumerate}

	\item The transformation of \(\RelationConcept{} \rightarrow \acs{gool}\) is
	      not \textit{total} (i.e., not all terms of the \Expr{} language can be
	      mapped into a representational \acs{gool} term).

	      \begin{itemize}

		      \item Not all terms of the \Expr{} language have a definite value.

		      \item Some terms in \Expr{} require extra information before they
		            can be converted into code. At times, this information is a
		            conscious choice that the developer should be making instead
		            of imposed on them.

	      \end{itemize}

	\item It is very easy to write ``difficult/impossible to interpret''
	      expressions. For example, it is possible to create expressions for
	      which aren't directly calculable (i.e., things that require an extra
	      paper and pencil/mental mathematics before performing), either without
	      extra surrounding information or simply impossible.

	      \begin{itemize}

		      \item When writing with pencil and paper, we usually write with
		            extra context (generally more information that needs to be
		            read to fully understand some expression), assuming the
		            reader understands that context. We might also infer
		            information about the model. Unfortunately, mechanizing
		            inference, without any sort of context or other knowledge,
		            is difficult, artificial learning is a whole field of study
		            of its own, and we're not interested in it here! As such, we
		            reverse the relationship of the inference by having
		            knowledge container expose everything on its own. We
		            additionally expect knowledge as a requisite to working with
		            the model.

		      \item Transformation requires a comprehensive understanding of the
		            inputs to outputs translation, but much of the input
		            knowledge requires complex analysis that would only appear
		            in the transformer, discarding its usability elsewhere —
		            information loss.

		      \item An \Expr{} alone is a weak conveyor of the inner knowledge
		            of theories, similar to normal pencil-and-paper mathematical
		            expressions, without extra information, the expression alone
		            may be ineffectual or nearly unusable in code generation.

		      \item It is important that each knowledge encoding in Drasil
		            exposes as much information as reasonably possible (and
		            useful). We want to expose the ``specifications'' of each
		            piece of knowledge that we are encoding so that transformers
		            and generators may appropriately make use of contained
		            knowledge.

	      \end{itemize}

	\item Drasil is limited to using theories with expressions written in a very
	      precise form: \(x = f(a, b, c, \ldots{})\) \todo{Discuss
		      \QDefinition{}s.}

	      \begin{itemize}

		      \item The \(=\) sign is being overloaded here to mean definition,
		            when it is supposed to mean equality. While \(y = x\) might
		            conventionally be seen as ``y is equal to x'', we might
		            want, in our model, for it to be understood as ``x is
		            defined by y'' but displayed differently.

		      \item Any other form of theories are unusable. Equational
		            constraints at the very least should be immediately usable
		            in creating assertions in the generated code.

		      \item The conversion relied on the \intodo{relToQD} hack.\todo{Add
			            code snippet of original relToQD and discuss how it
			            wasn't a sustainable solution for the long-term. relToQD
			            was exactly the implicit knowledge I mentioned, it
			            assumes, without statically checking consistency, that
			            the Relations/Exprs provided as input for code
			            generation were all of the form: \(y = f(\ldots{})\).
			            See
			            \url{https://github.com/JacquesCarette/Drasil/issues/628}
			            for more information about state of relToQD w.r.t. RCs.}

		      \item The above is what leads to the brittle untotal conversion of
		            theories to code.

	      \end{itemize}

	\item Existing transformation of \RelationConcept{}s into \acs{gool} relies
	      on unstable transformation caused by need to write in a precise
	      digestible form, with no static checks done at compile-time.
	      \intodo{Mention ODE -> code generation.}

\end{enumerate}

Therefore, mathematical knowledge flow is unstable in Drasil, as shown in
\refTheoriesWithoutModelKinds{}. The focal issue with the existing way theories
are encoded is that the \textit{theories (\RelationConcept{}s) do not contain
	the meaningful usable mathematical knowledge at all}. The mathematical knowledge
is implicitly held within the Haskell-based functions\todo{I need to phrase this
	better, but, the Haskell calculation functionality should be used as
	infrequently as possible.}. In order to proceed, this mathematical knowledge
must be reconciled and merged with the \RelationConcept{}s in some capacity.

\theoriesWithoutModelKinds{}

\section{Reconciling Mathematical Knowledge}

Fundamentally, the issue lies in that the information exposed for Drasil to make
use of is too ``shallow''. The raw expressions are great for viewing and
human-guided inference by experts, but not an inexperienced person, or for a
computer to systematically use to generate things. At the moment, the available
tools' type signatures (\todo{Show a type signature}) would appear as something
too amazing, so much so in fact, that one would (and should) question its
accuracy. A hypothetical type signature, \inlineHs{RelationConcept -> Code}, is
quite far fetched. Not all expressions that can possibly be contained in a
\RelationConcept{} are usable in code generation\todo{Note somewhere in the
	thesis above that when we discuss ``code'', we really mean \acs{oo} programs and
	snippets}.

\section{Language Division}

\acs{gool} currently bears the burden of creating a family of software artifacts
through describing a single \acs{gool} program. As we are specifically
interested in generating families of \acs{scs} through strong knowledge capture,
this work partially bears the burden of testing to ensure that the conversion of
the knowledge contained in the SmithEtAl template \cite{SmithAndLai2005} is
stable and reliable. At the moment, it is possible to describe mathematical
expressions that are completely unusable in \acs{gool} because \acsp{gool}
primary targets are languages that rely on expressions with, at least, definite
values. Of course, \Expr{} already contains terms that are without definite
values. For example, \Expr{} (\refOriginalExprHaskell{}) discusses derivations,
integrations, spaces as primitive/literal values (largely symbolic, and
unavailable in \acs{oo} languages), definition statements, equivalence\todo{I
	guess it's less-so about definite value, moreso about lack of representation in
	\acs{oo} languages.}, and infinite series. Realistically, this information
already \textit{exists} in Drasil, but it is not strongly enforced at Drasils
Haskell-level compile-time. In other words, the information is not
\textit{exposed} to Haskells type system, but to Drasils runtime.

In order to ensure that developers can only write ``usable'' grounded theories
(``InstanceModels'') for the code generator to use, we have chosen to expose
this information to the compiler. In particular, we have chosen to expose it via
language division and type information.

\languageDivision{}

\intodo{Re: TTF: What Haskell/GHC language extensions did we need to use?}

\Expr{} has its indefinite values split off into \ModelExpr{}
(\refCurrentModelExprHaskell{})\todo{List notable terms moved, Deriv, Continuous
	vs Discrete ranges, Space, etc}, a deeply embedded universal mathematical
language. As we desire for it to be equally usable as \Expr{}, it is,
essentially, the original \Expr{} without the language terms related to
``code''\todo{i.e., \ldots{}}. In order to alleviate the stress involved with
writing out the same expression in two (2) different languages, we use a
\ACF{ttf} encoding of the two (2) languages (\refCurrentExprTTFHaskell{} and
\refCurrentModelExprTTFHaskell{}). The \acs{ttf} encoding allows us to
seamlessly write expressions in either, or both, languages at the same time.
\ModelExpr{}s \acs{ttf} encoding strictly contains the terms unique to
\ModelExpr{}. As such, the \acs{ttf} encoding won't allow terms from
\ModelExpr{} to be interpreted into \Expr{} unless they have a definite value
because it will be impossible to describe the terms unique to \ModelExpr{} in
terms of the \Expr{} language. However, it is possible (and is done normally) to
convert \Expr{}s into \ModelExpr{}s for usage in generating the \acs{srs}
documents, which primarily expect \ModelExpr{}s for transcribing mathematical
expressions. Furthermore, with \ModelExpr{}, we may use instances of \todo{ref
	Current Express Typeclass} to define how various chunks can be described
visually, using this mathematical modelling language.

Continuing, we've noticed that there are residual terms left in \Expr{} that
don't quite relate to mathematics, but to ``code'' specifically (here, ``code''
meaning the \acs{oo} ``code''). As such, we continue the division by moving
those less related into their own language, specifically tailored to ``code''
expressions: \CodeExpr{} (\todo{ref Current CodeExpr Haskell}).

Finally, we end up with 3 languages, as shown in \refLanguageDivision{}: \Expr{}
(\refCurrentExprHaskell{}), \ModelExpr{} (\refCurrentModelExprHaskell{}), and
\CodeExpr{} (\todo{ref Current CodeExpr Haskell}). Each language has its own
specific domain, and, although there is some overlap between each, we are able
to enforce weaker rules on each formation through their \acs{ttf} instances if
needed.

Relating back to \refTheoriesWithoutModelKinds{}, we may observe that there is a
transformation from \textit{Theory} (realistically, these expression languages
discussed) to \textit{Mathematical Knowledge}. This may seem peculiar because
one might expect the \textit{theory} to be precisely the \textit{mathematical
	knowledge}. Presently, the mathematical knowledge is implicitly built into
transformers that work with \RelationConcept{}s (theories). The explicit
information is \textit{lost} in both the Haskell-level transformation function
that makes generation possible and the external knowledge used to create the
actual expression itself. To resolve this, we need to reconcile
\textit{theories} with \textit{mathematical knowledge}, strengthening the
\textit{depth of knowledge} contained in a theory. Should this occur, we should
observe \refTheoriesWithoutModelKinds{} having the \textit{Theory} and
\textit{Mathematical Knowledge} nodes merged, and have the expressions
understood to only be one of many possible ``views'' of higher-level usable
knowledge. In other words, the expressions would not be used to transfer
knowledge any longer, but they might remain as one component of it. Through
resolving these issues, we will have deeper knowledge available at Drasils
compile-time, and we will be able to better understand which theories are usable
in code generation, and which aren't. Additionally, we will be able to better
handle more \textit{kinds} of theories without needing to create complex
traversal and analysis algorithms to recognize when certain kinds of theories
were transcribed in the expressions.

\section{``Classify All The Theories''}

Issues occurring due to weak knowledge capture may be resolved through strong
knowledge capture. Beginning with the existing case studies of Drasil, we will
attempt to classify our existing knowledge better. We aim to make
\RelationConcept{} a ``view'' of other ``higher-order''\todo{Seems inaccurate to
	say higher-order, need something else most likely.} knowledge encodings. In
other words, we replace \Expr{} as a knowledge container, and restrict its usage
to strictly ``mathematical expressions'', as opposed to ``expressions'' and
information about models/theories. One notable change is that we will require
the new theory knowledge containers to be able to fully re-create the original
shallow/raw \Expr{}s as a property of the new theory encodings. The once
meta-level knowledge of the theories, lost in the Haskell implementation,
becomes exposed and understood to Drasil. Ultimately, this is done through
replacing \RelationConcept{} usage with \ModelKind{}, an aggregation of existing
Drasil-related knowledge of mathematical theories. \ModelKind{} is defined using
a \acs{gadt}, with one (1) type parameter. The type parameter is currently used
to determine whether the model is ``fully refined''/``grounded'' or not, and,
hence, usable in code generation. \refCurrentModelKindsHaskell{} displays the
creation of \ModelKind{} and \ModelKinds{}. Please note that this aggregation is
based purely on the existing model examples in the existing Drasil case studies,
and the existing models are \textit{incomplete} in the larger scope.

\intodo{What must each kind of model provide for them to be candidates for a
	ModelKind type? One: they must be able to re-create the original Expr they
	had been encoded as, in the new ModelExpr language, via their ``Express''
	instance.}

\currentModelKindsHaskell{}

\subsection{Quantity Definitions}

Assume \(y = x\) is transcribed as a \RelationConcept{}: while \(y = x\) might
conventionally be seen as ``y is equal to x'', we might want, in our model, for
it to be understood as ``x is defined by y'' but displayed differently. Here,
\(=\) is overloaded as ``definition'', instead of what \(=\) was defined as in
\Expr{}, as an ``equality'' operator. To resolve this overloading and weak
knowledge capture of definitions, we create \EquationalModel{}s: theories that
contain information about definitions of symbols, built using a
\QDefinition{}\todo{ref Current QDefinition Haskell}. If an \EquationalModel{}
deals with theoretical symbols and is defined using either a \ModelExpr{} or an
\Expr{}, it may be used in Theory Models and General Definitions. If an
\EquationalModel{} is defined using an \Expr{} and deals with only the
non-abstract\todo{Is there a name for this?} symbols, then the
\EquationalModel{} is usable for code generation. At the moment, there is no
information attached to symbols yet regarding whether they are abstract or
instanced, so that portion of the rule is not enforced\todo{Future Work: make
	typed distinction between abstract and instanced symbols}.

\intodo{Example of an EquationalModel/QDefinition in Haskell code, the SRS, and
	the generated code.}

\subsection{Constraints}

Theories that define expressions that constrain models in some way are defined
using \EquationalConstraints{}, which are built on \ConstraintSet{}s\todo{ref
	Current ConstraintSet Haskell}\todo{Describe what a ConstraintSet actually is.}.
At the moment, these are not used in code generation, and are pending design for
usage in code generation as the translation from them into software is unclear
and may be interpreted differently by readers. This model can, and should,
eventually also be usable in code generation once there is interest in creating
runtime assertions of symbols.

\intodo{Example of an EquationalConstraints/ConstraintSet in Haskell code, and
	the SRS.}

\subsection{Definition Realms}

The Theory Models and General Definition Models are unrefined, and may contain
multiple ways for a particular theoretical symbol to be defined. This is
captured in Drasil by \EquationalRealm{}s: modelled after realms\todo{Cite
	realms? If so, from Dr. Carette and Yasmines paper?}. This model kind is
intended specifically for retaining information about conscious choices made
along the way to create Instance Models. An \EquationalRealm{} is based on a
\MultiDefn{}\todo{ref Current MultiDefn Haskell}, and is intended for forming
\QDefinition{}s through choosing definitions, through refinements, from the
\MultiDefn{}s.

\intodo{Example of an EquationalRealm/MultiDefn in Haskell code, and the SRS.}

\subsection{Differential Equations}

\DEModel{} is the simple \RelationConcept{}-style capture of differential
equation-related theories, and only exists as a placeholder until all
differential equation models are converted into one of the other \ModelKinds{}.
For related solving of differential equations, \DEModel{} implicitly relies on a
developer writing a related \ODEInfo{}\todo{ref Current ODEInfo} packet which
the code generator can use to solve the system.\todo{Rewrite above to be more
	descriptive.} Actively being reconstructed in Drasil\todo{Cite Dongs work?},
\NewDEModel{} is the replacement for \DEModel{}, aiming to expose more
information about well-understood differential equations and related areas.
\NewDEModel{} will eventually be renamed to \DEModel{} once all existing
\DEModel{} models have been upgraded.

\intodo{Example of a DEModel/NewDEModel and a RelationConcept in Haskell code,
	the SRS, and the related ODEInfo and code.}

\subsection{Leftovers}

\intodo{Instead of writing anything here, I'm going to re-evaluate the existing
	leftover models and see if they can be replaced with any of the existing or
	if they need a new one.}

\begin{itemize}

	\item \OthModel{} \ldots{}

\end{itemize}

\section{Theories Undiscussed}

\ModelKinds{} is an enumeration of the currently handled model types. Each
``model'' is meant to expose information to the Haskell compiler and for other
fragments of knowledge to make use of. \ModelKinds{} is obviously an incomplete
enumeration, and will grow as the need for more kinds of models arises.

Through incorporating \ModelKinds{} and reaping its benefits, we obtain,
approximately, the flow of mathematical knowledge as shown below, in
\refTheoriesWithModelKinds{}.

\theoriesWithModelKinds{}

Comparing \refTheoriesWithModelKinds{} with \refTheoriesWithoutModelKinds{}, we
observe a decrease in the scary orange colouring! The focal difference in the
two figures (and the difference between the work pre-existing and current) lies
in the understanding of a theory. Previously, the ``theory'' was captured by the
\RelationConcept{}s themselves, captured fully by a single \Expr{} (the original
universal version). The mathematical knowledge of the theory was never
explicitly captured, and usage of theories was unsustainable due to reliance on
brittle transformations \todo{ref Original relToQD Haskell} and implicit
expectations of the written transcriptions. Now, the theories and the
mathematical knowledge are unified with information exposed both by dissection
of components as record entries, and by creating type information for
classifying theories and relevant information. Notably, from the new encodings
of the theories, we are still able to recreate the original \Expr{}s (or, now
\ModelExpr{}s) that once represented them.

\intodo{Side-by-side figure comparison of \refTheoriesWithModelKinds{} and
	\refTheoriesWithoutModelKinds{}}

\intodo{What do we learn from doing this conversion, about the greater part
	about encoding knowledge? \ldots{}}

From this, we obtain a new general rule for future knowledge
dissection/capture/encoding: when extracting information about the formation of
certain language snippets and classifying that contextual information, we must
ensure that we have obtained a generic means (algorithm) for reproducing the
originating term from an instance of the new contextual information\todo{This is
	awkwardly worded.}. In other words, there should be a generic method to
reproduce the original information from the new information — this is finding
areas where we can add to the generation possibilities of Drasil.

\section{Residual Issues}

While the information is now encoded, it is not without its own issues:

\begin{enumerate}

	\item As \ModelKinds{} is written using a GADT, it is difficult to extend
	      its functionality (the ``expression problem''\todo{Cite the original
		      expression problem paper.}). A work in progress re-design of
	      \ModelKinds{}, relying on \acs{ghc}s \ConstraintKinds{}\todo{Should I
		      cite something about \ConstraintKinds{}?} language extension, uses
	      Haskell-level typeclasses to describe what a model satisfying the
	      needs of being a ``model kind'' must provide in order to be treated as
	      a ``model kind''. These typeclass instances may be thought of as
	      proofs that satisfy the requirements.

	\item The type parameter in \ModelKinds{} is peculiar. It is used to
	      indicate usability of a certain model in code generation through
	      either having an \Expr{} or a \ModelExpr{}. A \inlineHs{ModelKind
		      Expr} indicates that a model is usable in code generation, while a
	      \inlineHs{ModelKind ModelExpr} indicates that the model is not to be
	      used in code generation.

	\item While we've gained information about the reason what the expressions
	      described, the expression language, as a whole, allows for poorly
	      typed expressions to be formed. We lack enforcement regarding the
	      validity of \Expr{} as ``expressions''.

\end{enumerate}

However, these first two (2) issues are relatively unimportant for now. (1) has
a proof of concept solution (as discussed above), and (2) is a matter of the
Haskell implementation we choose. (3) is the next area of focus in regard to
expressions.
