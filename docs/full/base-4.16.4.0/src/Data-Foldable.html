<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Data/Foldable.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE DeriveFoldable #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE FlexibleInstances #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE NoImplicitPrelude #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE ScopedTypeVariables #-}</span>
<a name="line-5"></a><span class='hs-comment'>{-# LANGUAGE StandaloneDeriving #-}</span>
<a name="line-6"></a><span class='hs-comment'>{-# LANGUAGE Trustworthy #-}</span>
<a name="line-7"></a><span class='hs-comment'>{-# LANGUAGE TypeOperators #-}</span>
<a name="line-8"></a>
<a name="line-9"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-10"></a><span class='hs-comment'>-- |</span>
<a name="line-11"></a><span class='hs-comment'>-- Module      :  Data.Foldable</span>
<a name="line-12"></a><span class='hs-comment'>-- Copyright   :  Ross Paterson 2005</span>
<a name="line-13"></a><span class='hs-comment'>-- License     :  BSD-style (see the LICENSE file in the distribution)</span>
<a name="line-14"></a><span class='hs-comment'>--</span>
<a name="line-15"></a><span class='hs-comment'>-- Maintainer  :  libraries@haskell.org</span>
<a name="line-16"></a><span class='hs-comment'>-- Stability   :  experimental</span>
<a name="line-17"></a><span class='hs-comment'>-- Portability :  portable</span>
<a name="line-18"></a><span class='hs-comment'>--</span>
<a name="line-19"></a><span class='hs-comment'>-- Class of data structures that can be folded to a summary value.</span>
<a name="line-20"></a><span class='hs-comment'>--</span>
<a name="line-21"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-22"></a>
<a name="line-23"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Data.Foldable</span> <span class='hs-layout'>(</span>
<a name="line-24"></a>    <span class='hs-conid'>Foldable</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-25"></a>    <span class='hs-comment'>-- * Special biased folds</span>
<a name="line-26"></a>    <span class='hs-varid'>foldrM</span><span class='hs-layout'>,</span>
<a name="line-27"></a>    <span class='hs-varid'>foldlM</span><span class='hs-layout'>,</span>
<a name="line-28"></a>    <span class='hs-comment'>-- * Folding actions</span>
<a name="line-29"></a>    <span class='hs-comment'>-- ** Applicative actions</span>
<a name="line-30"></a>    <span class='hs-varid'>traverse_</span><span class='hs-layout'>,</span>
<a name="line-31"></a>    <span class='hs-varid'>for_</span><span class='hs-layout'>,</span>
<a name="line-32"></a>    <span class='hs-varid'>sequenceA_</span><span class='hs-layout'>,</span>
<a name="line-33"></a>    <span class='hs-varid'>asum</span><span class='hs-layout'>,</span>
<a name="line-34"></a>    <span class='hs-comment'>-- ** Monadic actions</span>
<a name="line-35"></a>    <span class='hs-varid'>mapM_</span><span class='hs-layout'>,</span>
<a name="line-36"></a>    <span class='hs-varid'>forM_</span><span class='hs-layout'>,</span>
<a name="line-37"></a>    <span class='hs-varid'>sequence_</span><span class='hs-layout'>,</span>
<a name="line-38"></a>    <span class='hs-varid'>msum</span><span class='hs-layout'>,</span>
<a name="line-39"></a>    <span class='hs-comment'>-- * Specialized folds</span>
<a name="line-40"></a>    <span class='hs-varid'>concat</span><span class='hs-layout'>,</span>
<a name="line-41"></a>    <span class='hs-varid'>concatMap</span><span class='hs-layout'>,</span>
<a name="line-42"></a>    <span class='hs-varid'>and</span><span class='hs-layout'>,</span>
<a name="line-43"></a>    <span class='hs-varid'>or</span><span class='hs-layout'>,</span>
<a name="line-44"></a>    <span class='hs-varid'>any</span><span class='hs-layout'>,</span>
<a name="line-45"></a>    <span class='hs-varid'>all</span><span class='hs-layout'>,</span>
<a name="line-46"></a>    <span class='hs-varid'>maximumBy</span><span class='hs-layout'>,</span>
<a name="line-47"></a>    <span class='hs-varid'>minimumBy</span><span class='hs-layout'>,</span>
<a name="line-48"></a>    <span class='hs-comment'>-- * Searches</span>
<a name="line-49"></a>    <span class='hs-varid'>notElem</span><span class='hs-layout'>,</span>
<a name="line-50"></a>    <span class='hs-varid'>find</span>
<a name="line-51"></a>
<a name="line-52"></a>    <span class='hs-comment'>-- * Overview</span>
<a name="line-53"></a>    <span class='hs-comment'>-- $overview</span>
<a name="line-54"></a>
<a name="line-55"></a>    <span class='hs-comment'>-- ** Expectation of efficient left-to-right iteration</span>
<a name="line-56"></a>    <span class='hs-comment'>-- $chirality</span>
<a name="line-57"></a>
<a name="line-58"></a>    <span class='hs-comment'>-- ** Recursive and corecursive reduction</span>
<a name="line-59"></a>    <span class='hs-comment'>-- $reduction</span>
<a name="line-60"></a>
<a name="line-61"></a>    <span class='hs-comment'>-- *** Strict recursive folds</span>
<a name="line-62"></a>    <span class='hs-comment'>-- $strict</span>
<a name="line-63"></a>
<a name="line-64"></a>    <span class='hs-comment'>-- **** List of strict functions</span>
<a name="line-65"></a>    <span class='hs-comment'>-- $strictlist</span>
<a name="line-66"></a>
<a name="line-67"></a>    <span class='hs-comment'>-- *** Lazy corecursive folds</span>
<a name="line-68"></a>    <span class='hs-comment'>-- $lazy</span>
<a name="line-69"></a>
<a name="line-70"></a>    <span class='hs-comment'>-- **** List of lazy functions</span>
<a name="line-71"></a>    <span class='hs-comment'>-- $lazylist</span>
<a name="line-72"></a>
<a name="line-73"></a>    <span class='hs-comment'>-- *** Short-circuit folds</span>
<a name="line-74"></a>    <span class='hs-comment'>-- $shortcircuit</span>
<a name="line-75"></a>
<a name="line-76"></a>    <span class='hs-comment'>-- **** List of short-circuit functions</span>
<a name="line-77"></a>    <span class='hs-comment'>-- $shortlist</span>
<a name="line-78"></a>
<a name="line-79"></a>    <span class='hs-comment'>-- *** Hybrid folds</span>
<a name="line-80"></a>    <span class='hs-comment'>-- $hybrid</span>
<a name="line-81"></a>
<a name="line-82"></a>    <span class='hs-comment'>-- ** Generative Recursion</span>
<a name="line-83"></a>    <span class='hs-comment'>-- $generative</span>
<a name="line-84"></a>
<a name="line-85"></a>    <span class='hs-comment'>-- ** Avoiding multi-pass folds</span>
<a name="line-86"></a>    <span class='hs-comment'>-- $multipass</span>
<a name="line-87"></a>
<a name="line-88"></a>    <span class='hs-comment'>-- * Defining instances</span>
<a name="line-89"></a>    <span class='hs-comment'>-- $instances</span>
<a name="line-90"></a>
<a name="line-91"></a>    <span class='hs-comment'>-- *** Being strict by being lazy</span>
<a name="line-92"></a>    <span class='hs-comment'>-- $strictlazy</span>
<a name="line-93"></a>
<a name="line-94"></a>    <span class='hs-comment'>-- * Laws</span>
<a name="line-95"></a>    <span class='hs-comment'>-- $laws</span>
<a name="line-96"></a>
<a name="line-97"></a>    <span class='hs-comment'>-- * Notes</span>
<a name="line-98"></a>    <span class='hs-comment'>-- $notes</span>
<a name="line-99"></a>
<a name="line-100"></a>    <span class='hs-comment'>-- ** Generally linear-time `elem`</span>
<a name="line-101"></a>    <span class='hs-comment'>-- $linear</span>
<a name="line-102"></a>
<a name="line-103"></a>    <span class='hs-comment'>-- * See also</span>
<a name="line-104"></a>    <span class='hs-comment'>-- $also</span>
<a name="line-105"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-106"></a>
<a name="line-107"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Bool</span>
<a name="line-108"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Either</span>
<a name="line-109"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Eq</span>
<a name="line-110"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Functor.Utils</span> <span class='hs-layout'>(</span><span class='hs-conid'>Max</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Min</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#.</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-111"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>GHC.List</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>List</span>
<a name="line-112"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Maybe</span>
<a name="line-113"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Monoid</span>
<a name="line-114"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Ord</span>
<a name="line-115"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Proxy</span>
<a name="line-116"></a>
<a name="line-117"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Arr</span>  <span class='hs-layout'>(</span> <span class='hs-conid'>Array</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>elems</span><span class='hs-layout'>,</span> <span class='hs-varid'>numElements</span><span class='hs-layout'>,</span>
<a name="line-118"></a>                  <span class='hs-varid'>foldlElems</span><span class='hs-layout'>,</span> <span class='hs-varid'>foldrElems</span><span class='hs-layout'>,</span>
<a name="line-119"></a>                  <span class='hs-varid'>foldlElems'</span><span class='hs-layout'>,</span> <span class='hs-varid'>foldrElems'</span><span class='hs-layout'>,</span>
<a name="line-120"></a>                  <span class='hs-varid'>foldl1Elems</span><span class='hs-layout'>,</span> <span class='hs-varid'>foldr1Elems</span><span class='hs-layout'>)</span>
<a name="line-121"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Base</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>)</span>
<a name="line-122"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Generics</span>
<a name="line-123"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tuple</span> <span class='hs-layout'>(</span><span class='hs-conid'>Solo</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-124"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Num</span>  <span class='hs-layout'>(</span> <span class='hs-conid'>Num</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-125"></a>
<a name="line-126"></a><span class='hs-comment'>-- $setup</span>
<a name="line-127"></a><span class='hs-comment'>-- &gt;&gt;&gt; :set -XDeriveFoldable</span>
<a name="line-128"></a><span class='hs-comment'>-- &gt;&gt;&gt; import Prelude</span>
<a name="line-129"></a><span class='hs-comment'>-- &gt;&gt;&gt; import Data.Monoid (Product (..), Sum (..))</span>
<a name="line-130"></a><span class='hs-comment'>-- &gt;&gt;&gt; data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a) deriving (Show, Foldable)</span>
<a name="line-131"></a>
<a name="line-132"></a><span class='hs-keyword'>infix</span>  <span class='hs-num'>4</span> <span class='hs-varop'>`elem`</span><span class='hs-layout'>,</span> <span class='hs-varop'>`notElem`</span>
<a name="line-133"></a>
<a name="line-134"></a><span class='hs-comment'>-- XXX: Missing haddock feature.  Links to anchors in other modules</span>
<a name="line-135"></a><span class='hs-comment'>-- don't have a sensible way to name the link within the module itself.</span>
<a name="line-136"></a><span class='hs-comment'>-- Thus, the below "Data.Foldable#overview" works well when shown as</span>
<a name="line-137"></a><span class='hs-comment'>-- @Data.Foldable@ from other modules, but in the home module it should</span>
<a name="line-138"></a><span class='hs-comment'>-- be possible to specify alternative link text. :-(</span>
<a name="line-139"></a>
<a name="line-140"></a><span class='hs-comment'>-- | The Foldable class represents data structures that can be reduced to a</span>
<a name="line-141"></a><span class='hs-comment'>-- summary value one element at a time.  Strict left-associative folds are a</span>
<a name="line-142"></a><span class='hs-comment'>-- good fit for space-efficient reduction, while lazy right-associative folds</span>
<a name="line-143"></a><span class='hs-comment'>-- are a good fit for corecursive iteration, or for folds that short-circuit</span>
<a name="line-144"></a><span class='hs-comment'>-- after processing an initial subsequence of the structure's elements.</span>
<a name="line-145"></a><span class='hs-comment'>--</span>
<a name="line-146"></a><span class='hs-comment'>-- Instances can be derived automatically by enabling the @DeriveFoldable@</span>
<a name="line-147"></a><span class='hs-comment'>-- extension.  For example, a derived instance for a binary tree might be:</span>
<a name="line-148"></a><span class='hs-comment'>--</span>
<a name="line-149"></a><span class='hs-comment'>-- &gt; {-# LANGUAGE DeriveFoldable #-}</span>
<a name="line-150"></a><span class='hs-comment'>-- &gt; data Tree a = Empty</span>
<a name="line-151"></a><span class='hs-comment'>-- &gt;             | Leaf a</span>
<a name="line-152"></a><span class='hs-comment'>-- &gt;             | Node (Tree a) a (Tree a)</span>
<a name="line-153"></a><span class='hs-comment'>-- &gt;     deriving Foldable</span>
<a name="line-154"></a><span class='hs-comment'>--</span>
<a name="line-155"></a><span class='hs-comment'>-- A more detailed description can be found in the __Overview__ section of</span>
<a name="line-156"></a><span class='hs-comment'>-- "Data.Foldable#overview".</span>
<a name="line-157"></a><span class='hs-comment'>--</span>
<a name="line-158"></a><span class='hs-comment'>-- For the class laws see the __Laws__ section of "Data.Foldable#laws".</span>
<a name="line-159"></a><span class='hs-comment'>--</span>
<a name="line-160"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span> <span class='hs-keyword'>where</span>
<a name="line-161"></a>    <span class='hs-comment'>{-# MINIMAL foldMap | foldr #-}</span>
<a name="line-162"></a>
<a name="line-163"></a>    <span class='hs-comment'>-- | Given a structure with elements whose type is a 'Monoid', combine them</span>
<a name="line-164"></a>    <span class='hs-comment'>-- via the monoid's @('&lt;&gt;')@ operator.  This fold is right-associative and</span>
<a name="line-165"></a>    <span class='hs-comment'>-- lazy in the accumulator.  When you need a strict left-associative fold,</span>
<a name="line-166"></a>    <span class='hs-comment'>-- use 'foldMap'' instead, with 'id' as the map.</span>
<a name="line-167"></a>    <span class='hs-comment'>--</span>
<a name="line-168"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-169"></a>    <span class='hs-comment'>--</span>
<a name="line-170"></a>    <span class='hs-comment'>-- Basic usage:</span>
<a name="line-171"></a>    <span class='hs-comment'>--</span>
<a name="line-172"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; fold [[1, 2, 3], [4, 5], [6], []]</span>
<a name="line-173"></a>    <span class='hs-comment'>-- [1,2,3,4,5,6]</span>
<a name="line-174"></a>    <span class='hs-comment'>--</span>
<a name="line-175"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; fold $ Node (Leaf (Sum 1)) (Sum 3) (Leaf (Sum 5))</span>
<a name="line-176"></a>    <span class='hs-comment'>-- Sum {getSum = 9}</span>
<a name="line-177"></a>    <span class='hs-comment'>--</span>
<a name="line-178"></a>    <span class='hs-comment'>-- Folds of unbounded structures do not terminate when the monoid's</span>
<a name="line-179"></a>    <span class='hs-comment'>-- @('&lt;&gt;')@ operator is strict:</span>
<a name="line-180"></a>    <span class='hs-comment'>--</span>
<a name="line-181"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; fold (repeat Nothing)</span>
<a name="line-182"></a>    <span class='hs-comment'>-- * Hangs forever *</span>
<a name="line-183"></a>    <span class='hs-comment'>--</span>
<a name="line-184"></a>    <span class='hs-comment'>-- Lazy corecursive folds of unbounded structures are fine:</span>
<a name="line-185"></a>    <span class='hs-comment'>--</span>
<a name="line-186"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; take 12 $ fold $ map (\i -&gt; [i..i+2]) [0..]</span>
<a name="line-187"></a>    <span class='hs-comment'>-- [0,1,2,1,2,3,2,3,4,3,4,5]</span>
<a name="line-188"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; sum $ take 4000000 $ fold $ map (\i -&gt; [i..i+2]) [0..]</span>
<a name="line-189"></a>    <span class='hs-comment'>-- 2666668666666</span>
<a name="line-190"></a>    <span class='hs-comment'>--</span>
<a name="line-191"></a>    <span class='hs-varid'>fold</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span>
<a name="line-192"></a>    <span class='hs-varid'>fold</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldMap</span> <span class='hs-varid'>id</span>
<a name="line-193"></a>
<a name="line-194"></a>    <span class='hs-comment'>-- | Map each element of the structure into a monoid, and combine the</span>
<a name="line-195"></a>    <span class='hs-comment'>-- results with @('&lt;&gt;')@.  This fold is right-associative and lazy in the</span>
<a name="line-196"></a>    <span class='hs-comment'>-- accumulator.  For strict left-associative folds consider 'foldMap''</span>
<a name="line-197"></a>    <span class='hs-comment'>-- instead.</span>
<a name="line-198"></a>    <span class='hs-comment'>--</span>
<a name="line-199"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-200"></a>    <span class='hs-comment'>--</span>
<a name="line-201"></a>    <span class='hs-comment'>-- Basic usage:</span>
<a name="line-202"></a>    <span class='hs-comment'>--</span>
<a name="line-203"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldMap Sum [1, 3, 5]</span>
<a name="line-204"></a>    <span class='hs-comment'>-- Sum {getSum = 9}</span>
<a name="line-205"></a>    <span class='hs-comment'>--</span>
<a name="line-206"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldMap Product [1, 3, 5]</span>
<a name="line-207"></a>    <span class='hs-comment'>-- Product {getProduct = 15}</span>
<a name="line-208"></a>    <span class='hs-comment'>--</span>
<a name="line-209"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldMap (replicate 3) [1, 2, 3]</span>
<a name="line-210"></a>    <span class='hs-comment'>-- [1,1,1,2,2,2,3,3,3]</span>
<a name="line-211"></a>    <span class='hs-comment'>--</span>
<a name="line-212"></a>    <span class='hs-comment'>-- When a Monoid's @('&lt;&gt;')@ is lazy in its second argument, 'foldMap' can</span>
<a name="line-213"></a>    <span class='hs-comment'>-- return a result even from an unbounded structure.  For example, lazy</span>
<a name="line-214"></a>    <span class='hs-comment'>-- accumulation enables "Data.ByteString.Builder" to efficiently serialise</span>
<a name="line-215"></a>    <span class='hs-comment'>-- large data structures and produce the output incrementally:</span>
<a name="line-216"></a>    <span class='hs-comment'>--</span>
<a name="line-217"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; import qualified Data.ByteString.Lazy as L</span>
<a name="line-218"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; import qualified Data.ByteString.Builder as B</span>
<a name="line-219"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; let bld :: Int -&gt; B.Builder; bld i = B.intDec i &lt;&gt; B.word8 0x20</span>
<a name="line-220"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; let lbs = B.toLazyByteString $ foldMap bld [0..]</span>
<a name="line-221"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; L.take 64 lbs</span>
<a name="line-222"></a>    <span class='hs-comment'>-- "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"</span>
<a name="line-223"></a>    <span class='hs-comment'>--</span>
<a name="line-224"></a>    <span class='hs-varid'>foldMap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span>
<a name="line-225"></a>    <span class='hs-comment'>{-# INLINE foldMap #-}</span>
<a name="line-226"></a>    <span class='hs-comment'>-- This INLINE allows more list functions to fuse.  See #9848.</span>
<a name="line-227"></a>    <span class='hs-varid'>foldMap</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>mappend</span> <span class='hs-varop'>.</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varid'>mempty</span>
<a name="line-228"></a>
<a name="line-229"></a>    <span class='hs-comment'>-- | A left-associative variant of 'foldMap' that is strict in the</span>
<a name="line-230"></a>    <span class='hs-comment'>-- accumulator.  Use this method for strict reduction when partial</span>
<a name="line-231"></a>    <span class='hs-comment'>-- results are merged via @('&lt;&gt;')@.</span>
<a name="line-232"></a>    <span class='hs-comment'>--</span>
<a name="line-233"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-234"></a>    <span class='hs-comment'>--</span>
<a name="line-235"></a>    <span class='hs-comment'>-- Define a 'Monoid' over finite bit strings under 'xor'.  Use it to</span>
<a name="line-236"></a>    <span class='hs-comment'>-- strictly compute the `xor` of a list of 'Int' values.</span>
<a name="line-237"></a>    <span class='hs-comment'>--</span>
<a name="line-238"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; :set -XGeneralizedNewtypeDeriving</span>
<a name="line-239"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; import Data.Bits (Bits, FiniteBits, xor, zeroBits)</span>
<a name="line-240"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; import Data.Foldable (foldMap')</span>
<a name="line-241"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; import Numeric (showHex)</span>
<a name="line-242"></a>    <span class='hs-comment'>-- &gt;&gt;&gt;</span>
<a name="line-243"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; newtype X a = X a deriving (Eq, Bounded, Enum, Bits, FiniteBits)</span>
<a name="line-244"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; instance Bits a =&gt; Semigroup (X a) where X a &lt;&gt; X b = X (a `xor` b)</span>
<a name="line-245"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; instance Bits a =&gt; Monoid    (X a) where mempty     = X zeroBits</span>
<a name="line-246"></a>    <span class='hs-comment'>-- &gt;&gt;&gt;</span>
<a name="line-247"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; let bits :: [Int]; bits = [0xcafe, 0xfeed, 0xdeaf, 0xbeef, 0x5411]</span>
<a name="line-248"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; (\ (X a) -&gt; showString "0x" . showHex a $ "") $ foldMap' X bits</span>
<a name="line-249"></a>    <span class='hs-comment'>-- "0x42"</span>
<a name="line-250"></a>    <span class='hs-comment'>--</span>
<a name="line-251"></a>    <span class='hs-comment'>-- @since 4.13.0.0</span>
<a name="line-252"></a>    <span class='hs-varid'>foldMap'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span>
<a name="line-253"></a>    <span class='hs-varid'>foldMap'</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>acc</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>acc</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varid'>mempty</span>
<a name="line-254"></a>
<a name="line-255"></a>    <span class='hs-comment'>-- | Right-associative fold of a structure, lazy in the accumulator.</span>
<a name="line-256"></a>    <span class='hs-comment'>--</span>
<a name="line-257"></a>    <span class='hs-comment'>-- In the case of lists, 'foldr', when applied to a binary operator, a</span>
<a name="line-258"></a>    <span class='hs-comment'>-- starting value (typically the right-identity of the operator), and a</span>
<a name="line-259"></a>    <span class='hs-comment'>-- list, reduces the list using the binary operator, from right to left:</span>
<a name="line-260"></a>    <span class='hs-comment'>--</span>
<a name="line-261"></a>    <span class='hs-comment'>-- &gt; foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)</span>
<a name="line-262"></a>    <span class='hs-comment'>--</span>
<a name="line-263"></a>    <span class='hs-comment'>-- Note that since the head of the resulting expression is produced by an</span>
<a name="line-264"></a>    <span class='hs-comment'>-- application of the operator to the first element of the list, given an</span>
<a name="line-265"></a>    <span class='hs-comment'>-- operator lazy in its right argument, 'foldr' can produce a terminating</span>
<a name="line-266"></a>    <span class='hs-comment'>-- expression from an unbounded list.</span>
<a name="line-267"></a>    <span class='hs-comment'>--</span>
<a name="line-268"></a>    <span class='hs-comment'>-- For a general 'Foldable' structure this should be semantically identical</span>
<a name="line-269"></a>    <span class='hs-comment'>-- to,</span>
<a name="line-270"></a>    <span class='hs-comment'>--</span>
<a name="line-271"></a>    <span class='hs-comment'>-- @foldr f z = 'List.foldr' f z . 'toList'@</span>
<a name="line-272"></a>    <span class='hs-comment'>--</span>
<a name="line-273"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-274"></a>    <span class='hs-comment'>--</span>
<a name="line-275"></a>    <span class='hs-comment'>-- Basic usage:</span>
<a name="line-276"></a>    <span class='hs-comment'>--</span>
<a name="line-277"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldr (||) False [False, True, False]</span>
<a name="line-278"></a>    <span class='hs-comment'>-- True</span>
<a name="line-279"></a>    <span class='hs-comment'>--</span>
<a name="line-280"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldr (||) False []</span>
<a name="line-281"></a>    <span class='hs-comment'>-- False</span>
<a name="line-282"></a>    <span class='hs-comment'>--</span>
<a name="line-283"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']</span>
<a name="line-284"></a>    <span class='hs-comment'>-- "foodcba"</span>
<a name="line-285"></a>    <span class='hs-comment'>--</span>
<a name="line-286"></a>    <span class='hs-comment'>-- ===== Infinite structures</span>
<a name="line-287"></a>    <span class='hs-comment'>--</span>
<a name="line-288"></a>    <span class='hs-comment'>-- ⚠️ Applying 'foldr' to infinite structures usually doesn't terminate.</span>
<a name="line-289"></a>    <span class='hs-comment'>--</span>
<a name="line-290"></a>    <span class='hs-comment'>-- It may still terminate under one of the following conditions:</span>
<a name="line-291"></a>    <span class='hs-comment'>--</span>
<a name="line-292"></a>    <span class='hs-comment'>-- * the folding function is short-circuiting</span>
<a name="line-293"></a>    <span class='hs-comment'>-- * the folding function is lazy on its second argument</span>
<a name="line-294"></a>    <span class='hs-comment'>--</span>
<a name="line-295"></a>    <span class='hs-comment'>-- ====== Short-circuiting</span>
<a name="line-296"></a>    <span class='hs-comment'>--</span>
<a name="line-297"></a>    <span class='hs-comment'>-- @('||')@ short-circuits on 'True' values, so the following terminates</span>
<a name="line-298"></a>    <span class='hs-comment'>-- because there is a 'True' value finitely far from the left side:</span>
<a name="line-299"></a>    <span class='hs-comment'>--</span>
<a name="line-300"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldr (||) False (True : repeat False)</span>
<a name="line-301"></a>    <span class='hs-comment'>-- True</span>
<a name="line-302"></a>    <span class='hs-comment'>--</span>
<a name="line-303"></a>    <span class='hs-comment'>-- But the following doesn't terminate:</span>
<a name="line-304"></a>    <span class='hs-comment'>--</span>
<a name="line-305"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])</span>
<a name="line-306"></a>    <span class='hs-comment'>-- * Hangs forever *</span>
<a name="line-307"></a>    <span class='hs-comment'>--</span>
<a name="line-308"></a>    <span class='hs-comment'>-- ====== Laziness in the second argument</span>
<a name="line-309"></a>    <span class='hs-comment'>--</span>
<a name="line-310"></a>    <span class='hs-comment'>-- Applying 'foldr' to infinite structures terminates when the operator is</span>
<a name="line-311"></a>    <span class='hs-comment'>-- lazy in its second argument (the initial accumulator is never used in</span>
<a name="line-312"></a>    <span class='hs-comment'>-- this case, and so could be left 'undefined', but @[]@ is more clear):</span>
<a name="line-313"></a>    <span class='hs-comment'>--</span>
<a name="line-314"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)</span>
<a name="line-315"></a>    <span class='hs-comment'>-- [1,4,7,10,13]</span>
<a name="line-316"></a>    <span class='hs-varid'>foldr</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-317"></a>    <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>appEndo</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldMap</span> <span class='hs-layout'>(</span><span class='hs-conid'>Endo</span> <span class='hs-cpp'>#.</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>z</span>
<a name="line-318"></a>
<a name="line-319"></a>    <span class='hs-comment'>-- | Right-associative fold of a structure, strict in the accumulator.</span>
<a name="line-320"></a>    <span class='hs-comment'>-- This is rarely what you want.</span>
<a name="line-321"></a>    <span class='hs-comment'>--</span>
<a name="line-322"></a>    <span class='hs-comment'>-- @since 4.6.0.0</span>
<a name="line-323"></a>    <span class='hs-varid'>foldr'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-324"></a>    <span class='hs-varid'>foldr'</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z0</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-varid'>f'</span> <span class='hs-varid'>id</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>z0</span>
<a name="line-325"></a>      <span class='hs-keyword'>where</span> <span class='hs-varid'>f'</span> <span class='hs-varid'>k</span> <span class='hs-varid'>x</span> <span class='hs-varid'>z</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>z</span>
<a name="line-326"></a>
<a name="line-327"></a>    <span class='hs-comment'>-- | Left-associative fold of a structure, lazy in the accumulator.  This</span>
<a name="line-328"></a>    <span class='hs-comment'>-- is rarely what you want, but can work well for structures with efficient</span>
<a name="line-329"></a>    <span class='hs-comment'>-- right-to-left sequencing and an operator that is lazy in its left</span>
<a name="line-330"></a>    <span class='hs-comment'>-- argument.</span>
<a name="line-331"></a>    <span class='hs-comment'>--</span>
<a name="line-332"></a>    <span class='hs-comment'>-- In the case of lists, 'foldl', when applied to a binary operator, a</span>
<a name="line-333"></a>    <span class='hs-comment'>-- starting value (typically the left-identity of the operator), and a</span>
<a name="line-334"></a>    <span class='hs-comment'>-- list, reduces the list using the binary operator, from left to right:</span>
<a name="line-335"></a>    <span class='hs-comment'>--</span>
<a name="line-336"></a>    <span class='hs-comment'>-- &gt; foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn</span>
<a name="line-337"></a>    <span class='hs-comment'>--</span>
<a name="line-338"></a>    <span class='hs-comment'>-- Note that to produce the outermost application of the operator the</span>
<a name="line-339"></a>    <span class='hs-comment'>-- entire input list must be traversed.  Like all left-associative folds,</span>
<a name="line-340"></a>    <span class='hs-comment'>-- 'foldl' will diverge if given an infinite list.</span>
<a name="line-341"></a>    <span class='hs-comment'>--</span>
<a name="line-342"></a>    <span class='hs-comment'>-- If you want an efficient strict left-fold, you probably want to use</span>
<a name="line-343"></a>    <span class='hs-comment'>-- 'foldl'' instead of 'foldl'.  The reason for this is that the latter</span>
<a name="line-344"></a>    <span class='hs-comment'>-- does not force the /inner/ results (e.g. @z \`f\` x1@ in the above</span>
<a name="line-345"></a>    <span class='hs-comment'>-- example) before applying them to the operator (e.g. to @(\`f\` x2)@).</span>
<a name="line-346"></a>    <span class='hs-comment'>-- This results in a thunk chain \(\mathcal{O}(n)\) elements long, which</span>
<a name="line-347"></a>    <span class='hs-comment'>-- then must be evaluated from the outside-in.</span>
<a name="line-348"></a>    <span class='hs-comment'>--</span>
<a name="line-349"></a>    <span class='hs-comment'>-- For a general 'Foldable' structure this should be semantically identical</span>
<a name="line-350"></a>    <span class='hs-comment'>-- to:</span>
<a name="line-351"></a>    <span class='hs-comment'>--</span>
<a name="line-352"></a>    <span class='hs-comment'>-- @foldl f z = 'List.foldl' f z . 'toList'@</span>
<a name="line-353"></a>    <span class='hs-comment'>--</span>
<a name="line-354"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-355"></a>    <span class='hs-comment'>--</span>
<a name="line-356"></a>    <span class='hs-comment'>-- The first example is a strict fold, which in practice is best performed</span>
<a name="line-357"></a>    <span class='hs-comment'>-- with 'foldl''.</span>
<a name="line-358"></a>    <span class='hs-comment'>--</span>
<a name="line-359"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]</span>
<a name="line-360"></a>    <span class='hs-comment'>-- 52</span>
<a name="line-361"></a>    <span class='hs-comment'>--</span>
<a name="line-362"></a>    <span class='hs-comment'>-- Though the result below is lazy, the input is reversed before prepending</span>
<a name="line-363"></a>    <span class='hs-comment'>-- it to the initial accumulator, so corecursion begins only after traversing</span>
<a name="line-364"></a>    <span class='hs-comment'>-- the entire input string.</span>
<a name="line-365"></a>    <span class='hs-comment'>--</span>
<a name="line-366"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"</span>
<a name="line-367"></a>    <span class='hs-comment'>-- "hgfeabcd"</span>
<a name="line-368"></a>    <span class='hs-comment'>--</span>
<a name="line-369"></a>    <span class='hs-comment'>-- A left fold of a structure that is infinite on the right cannot</span>
<a name="line-370"></a>    <span class='hs-comment'>-- terminate, even when for any finite input the fold just returns the</span>
<a name="line-371"></a>    <span class='hs-comment'>-- initial accumulator:</span>
<a name="line-372"></a>    <span class='hs-comment'>--</span>
<a name="line-373"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1</span>
<a name="line-374"></a>    <span class='hs-comment'>-- * Hangs forever *</span>
<a name="line-375"></a>    <span class='hs-comment'>--</span>
<a name="line-376"></a>    <span class='hs-comment'>-- WARNING: When it comes to lists, you always want to use either 'foldl'' or 'foldr' instead.</span>
<a name="line-377"></a>    <span class='hs-varid'>foldl</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-378"></a>    <span class='hs-varid'>foldl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>appEndo</span> <span class='hs-layout'>(</span><span class='hs-varid'>getDual</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldMap</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dual</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Endo</span> <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>z</span>
<a name="line-379"></a>    <span class='hs-comment'>-- There's no point mucking around with coercions here,</span>
<a name="line-380"></a>    <span class='hs-comment'>-- because flip forces us to build a new function anyway.</span>
<a name="line-381"></a>
<a name="line-382"></a>    <span class='hs-comment'>-- | Left-associative fold of a structure but with strict application of</span>
<a name="line-383"></a>    <span class='hs-comment'>-- the operator.</span>
<a name="line-384"></a>    <span class='hs-comment'>--</span>
<a name="line-385"></a>    <span class='hs-comment'>-- This ensures that each step of the fold is forced to Weak Head Normal</span>
<a name="line-386"></a>    <span class='hs-comment'>-- Form before being applied, avoiding the collection of thunks that would</span>
<a name="line-387"></a>    <span class='hs-comment'>-- otherwise occur.  This is often what you want to strictly reduce a</span>
<a name="line-388"></a>    <span class='hs-comment'>-- finite structure to a single strict result (e.g. 'sum').</span>
<a name="line-389"></a>    <span class='hs-comment'>--</span>
<a name="line-390"></a>    <span class='hs-comment'>-- For a general 'Foldable' structure this should be semantically identical</span>
<a name="line-391"></a>    <span class='hs-comment'>-- to,</span>
<a name="line-392"></a>    <span class='hs-comment'>--</span>
<a name="line-393"></a>    <span class='hs-comment'>-- @foldl' f z = 'List.foldl'' f z . 'toList'@</span>
<a name="line-394"></a>    <span class='hs-comment'>--</span>
<a name="line-395"></a>    <span class='hs-comment'>-- @since 4.6.0.0</span>
<a name="line-396"></a>    <span class='hs-varid'>foldl'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-397"></a>    <span class='hs-varid'>foldl'</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z0</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>f'</span> <span class='hs-varid'>id</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>z0</span>
<a name="line-398"></a>      <span class='hs-keyword'>where</span> <span class='hs-varid'>f'</span> <span class='hs-varid'>x</span> <span class='hs-varid'>k</span> <span class='hs-varid'>z</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-varid'>x</span>
<a name="line-399"></a>
<a name="line-400"></a>    <span class='hs-comment'>-- | A variant of 'foldr' that has no base case,</span>
<a name="line-401"></a>    <span class='hs-comment'>-- and thus may only be applied to non-empty structures.</span>
<a name="line-402"></a>    <span class='hs-comment'>--</span>
<a name="line-403"></a>    <span class='hs-comment'>-- This function is non-total and will raise a runtime exception if the</span>
<a name="line-404"></a>    <span class='hs-comment'>-- structure happens to be empty.</span>
<a name="line-405"></a>    <span class='hs-comment'>--</span>
<a name="line-406"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-407"></a>    <span class='hs-comment'>--</span>
<a name="line-408"></a>    <span class='hs-comment'>-- Basic usage:</span>
<a name="line-409"></a>    <span class='hs-comment'>--</span>
<a name="line-410"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldr1 (+) [1..4]</span>
<a name="line-411"></a>    <span class='hs-comment'>-- 10</span>
<a name="line-412"></a>    <span class='hs-comment'>--</span>
<a name="line-413"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldr1 (+) []</span>
<a name="line-414"></a>    <span class='hs-comment'>-- Exception: Prelude.foldr1: empty list</span>
<a name="line-415"></a>    <span class='hs-comment'>--</span>
<a name="line-416"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldr1 (+) Nothing</span>
<a name="line-417"></a>    <span class='hs-comment'>-- *** Exception: foldr1: empty structure</span>
<a name="line-418"></a>    <span class='hs-comment'>--</span>
<a name="line-419"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldr1 (-) [1..4]</span>
<a name="line-420"></a>    <span class='hs-comment'>-- -2</span>
<a name="line-421"></a>    <span class='hs-comment'>--</span>
<a name="line-422"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]</span>
<a name="line-423"></a>    <span class='hs-comment'>-- False</span>
<a name="line-424"></a>    <span class='hs-comment'>--</span>
<a name="line-425"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldr1 (||) [False, False, True, True]</span>
<a name="line-426"></a>    <span class='hs-comment'>-- True</span>
<a name="line-427"></a>    <span class='hs-comment'>--</span>
<a name="line-428"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldr1 (+) [1..]</span>
<a name="line-429"></a>    <span class='hs-comment'>-- * Hangs forever *</span>
<a name="line-430"></a>    <span class='hs-varid'>foldr1</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-431"></a>    <span class='hs-varid'>foldr1</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fromMaybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>errorWithoutStackTrace</span> <span class='hs-str'>"foldr1: empty structure"</span><span class='hs-layout'>)</span>
<a name="line-432"></a>                    <span class='hs-layout'>(</span><span class='hs-varid'>foldr</span> <span class='hs-varid'>mf</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
<a name="line-433"></a>      <span class='hs-keyword'>where</span>
<a name="line-434"></a>        <span class='hs-varid'>mf</span> <span class='hs-varid'>x</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>case</span> <span class='hs-varid'>m</span> <span class='hs-keyword'>of</span>
<a name="line-435"></a>                         <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span>
<a name="line-436"></a>                         <span class='hs-conid'>Just</span> <span class='hs-varid'>y</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-437"></a>
<a name="line-438"></a>    <span class='hs-comment'>-- | A variant of 'foldl' that has no base case,</span>
<a name="line-439"></a>    <span class='hs-comment'>-- and thus may only be applied to non-empty structures.</span>
<a name="line-440"></a>    <span class='hs-comment'>--</span>
<a name="line-441"></a>    <span class='hs-comment'>-- This function is non-total and will raise a runtime exception if the</span>
<a name="line-442"></a>    <span class='hs-comment'>-- structure happens to be empty.</span>
<a name="line-443"></a>    <span class='hs-comment'>--</span>
<a name="line-444"></a>    <span class='hs-comment'>-- @'foldl1' f = 'List.foldl1' f . 'toList'@</span>
<a name="line-445"></a>    <span class='hs-comment'>--</span>
<a name="line-446"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-447"></a>    <span class='hs-comment'>--</span>
<a name="line-448"></a>    <span class='hs-comment'>-- Basic usage:</span>
<a name="line-449"></a>    <span class='hs-comment'>--</span>
<a name="line-450"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldl1 (+) [1..4]</span>
<a name="line-451"></a>    <span class='hs-comment'>-- 10</span>
<a name="line-452"></a>    <span class='hs-comment'>--</span>
<a name="line-453"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldl1 (+) []</span>
<a name="line-454"></a>    <span class='hs-comment'>-- *** Exception: Prelude.foldl1: empty list</span>
<a name="line-455"></a>    <span class='hs-comment'>--</span>
<a name="line-456"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldl1 (+) Nothing</span>
<a name="line-457"></a>    <span class='hs-comment'>-- *** Exception: foldl1: empty structure</span>
<a name="line-458"></a>    <span class='hs-comment'>--</span>
<a name="line-459"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldl1 (-) [1..4]</span>
<a name="line-460"></a>    <span class='hs-comment'>-- -8</span>
<a name="line-461"></a>    <span class='hs-comment'>--</span>
<a name="line-462"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]</span>
<a name="line-463"></a>    <span class='hs-comment'>-- False</span>
<a name="line-464"></a>    <span class='hs-comment'>--</span>
<a name="line-465"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldl1 (||) [False, False, True, True]</span>
<a name="line-466"></a>    <span class='hs-comment'>-- True</span>
<a name="line-467"></a>    <span class='hs-comment'>--</span>
<a name="line-468"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; foldl1 (+) [1..]</span>
<a name="line-469"></a>    <span class='hs-comment'>-- * Hangs forever *</span>
<a name="line-470"></a>    <span class='hs-varid'>foldl1</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-471"></a>    <span class='hs-varid'>foldl1</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fromMaybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>errorWithoutStackTrace</span> <span class='hs-str'>"foldl1: empty structure"</span><span class='hs-layout'>)</span>
<a name="line-472"></a>                    <span class='hs-layout'>(</span><span class='hs-varid'>foldl</span> <span class='hs-varid'>mf</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
<a name="line-473"></a>      <span class='hs-keyword'>where</span>
<a name="line-474"></a>        <span class='hs-varid'>mf</span> <span class='hs-varid'>m</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>case</span> <span class='hs-varid'>m</span> <span class='hs-keyword'>of</span>
<a name="line-475"></a>                         <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span>
<a name="line-476"></a>                         <span class='hs-conid'>Just</span> <span class='hs-varid'>x</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-477"></a>
<a name="line-478"></a>    <span class='hs-comment'>-- | List of elements of a structure, from left to right.  If the entire</span>
<a name="line-479"></a>    <span class='hs-comment'>-- list is intended to be reduced via a fold, just fold the structure</span>
<a name="line-480"></a>    <span class='hs-comment'>-- directly bypassing the list.</span>
<a name="line-481"></a>    <span class='hs-comment'>--</span>
<a name="line-482"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-483"></a>    <span class='hs-comment'>--</span>
<a name="line-484"></a>    <span class='hs-comment'>-- Basic usage:</span>
<a name="line-485"></a>    <span class='hs-comment'>--</span>
<a name="line-486"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; toList Nothing</span>
<a name="line-487"></a>    <span class='hs-comment'>-- []</span>
<a name="line-488"></a>    <span class='hs-comment'>--</span>
<a name="line-489"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; toList (Just 42)</span>
<a name="line-490"></a>    <span class='hs-comment'>-- [42]</span>
<a name="line-491"></a>    <span class='hs-comment'>--</span>
<a name="line-492"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; toList (Left "foo")</span>
<a name="line-493"></a>    <span class='hs-comment'>-- []</span>
<a name="line-494"></a>    <span class='hs-comment'>--</span>
<a name="line-495"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; toList (Node (Leaf 5) 17 (Node Empty 12 (Leaf 8)))</span>
<a name="line-496"></a>    <span class='hs-comment'>-- [5,17,12,8]</span>
<a name="line-497"></a>    <span class='hs-comment'>--</span>
<a name="line-498"></a>    <span class='hs-comment'>-- For lists, 'toList' is the identity:</span>
<a name="line-499"></a>    <span class='hs-comment'>--</span>
<a name="line-500"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; toList [1, 2, 3]</span>
<a name="line-501"></a>    <span class='hs-comment'>-- [1,2,3]</span>
<a name="line-502"></a>    <span class='hs-comment'>--</span>
<a name="line-503"></a>    <span class='hs-comment'>-- @since 4.8.0.0</span>
<a name="line-504"></a>    <span class='hs-varid'>toList</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-505"></a>    <span class='hs-comment'>{-# INLINE toList #-}</span>
<a name="line-506"></a>    <span class='hs-varid'>toList</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>build</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>c</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>c</span> <span class='hs-varid'>n</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-507"></a>
<a name="line-508"></a>    <span class='hs-comment'>-- | Test whether the structure is empty.  The default implementation is</span>
<a name="line-509"></a>    <span class='hs-comment'>-- Left-associative and lazy in both the initial element and the</span>
<a name="line-510"></a>    <span class='hs-comment'>-- accumulator.  Thus optimised for structures where the first element can</span>
<a name="line-511"></a>    <span class='hs-comment'>-- be accessed in constant time.  Structures where this is not the case</span>
<a name="line-512"></a>    <span class='hs-comment'>-- should have a non-default implementation.</span>
<a name="line-513"></a>    <span class='hs-comment'>--</span>
<a name="line-514"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-515"></a>    <span class='hs-comment'>--</span>
<a name="line-516"></a>    <span class='hs-comment'>-- Basic usage:</span>
<a name="line-517"></a>    <span class='hs-comment'>--</span>
<a name="line-518"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; null []</span>
<a name="line-519"></a>    <span class='hs-comment'>-- True</span>
<a name="line-520"></a>    <span class='hs-comment'>--</span>
<a name="line-521"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; null [1]</span>
<a name="line-522"></a>    <span class='hs-comment'>-- False</span>
<a name="line-523"></a>    <span class='hs-comment'>--</span>
<a name="line-524"></a>    <span class='hs-comment'>-- 'null' is expected to terminate even for infinite structures.</span>
<a name="line-525"></a>    <span class='hs-comment'>-- The default implementation terminates provided the structure</span>
<a name="line-526"></a>    <span class='hs-comment'>-- is bounded on the left (there is a leftmost element).</span>
<a name="line-527"></a>    <span class='hs-comment'>--</span>
<a name="line-528"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; null [1..]</span>
<a name="line-529"></a>    <span class='hs-comment'>-- False</span>
<a name="line-530"></a>    <span class='hs-comment'>--</span>
<a name="line-531"></a>    <span class='hs-comment'>-- @since 4.8.0.0</span>
<a name="line-532"></a>    <span class='hs-varid'>null</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-533"></a>    <span class='hs-varid'>null</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-conid'>True</span>
<a name="line-534"></a>
<a name="line-535"></a>    <span class='hs-comment'>-- | Returns the size/length of a finite structure as an 'Int'.  The</span>
<a name="line-536"></a>    <span class='hs-comment'>-- default implementation just counts elements starting with the leftmost.</span>
<a name="line-537"></a>    <span class='hs-comment'>-- Instances for structures that can compute the element count faster</span>
<a name="line-538"></a>    <span class='hs-comment'>-- than via element-by-element counting, should provide a specialised</span>
<a name="line-539"></a>    <span class='hs-comment'>-- implementation.</span>
<a name="line-540"></a>    <span class='hs-comment'>--</span>
<a name="line-541"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-542"></a>    <span class='hs-comment'>--</span>
<a name="line-543"></a>    <span class='hs-comment'>-- Basic usage:</span>
<a name="line-544"></a>    <span class='hs-comment'>--</span>
<a name="line-545"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; length []</span>
<a name="line-546"></a>    <span class='hs-comment'>-- 0</span>
<a name="line-547"></a>    <span class='hs-comment'>--</span>
<a name="line-548"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; length ['a', 'b', 'c']</span>
<a name="line-549"></a>    <span class='hs-comment'>-- 3</span>
<a name="line-550"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; length [1..]</span>
<a name="line-551"></a>    <span class='hs-comment'>-- * Hangs forever *</span>
<a name="line-552"></a>    <span class='hs-comment'>--</span>
<a name="line-553"></a>    <span class='hs-comment'>-- @since 4.8.0.0</span>
<a name="line-554"></a>    <span class='hs-varid'>length</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-555"></a>    <span class='hs-varid'>length</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>c</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-num'>0</span>
<a name="line-556"></a>
<a name="line-557"></a>    <span class='hs-comment'>-- | Does the element occur in the structure?</span>
<a name="line-558"></a>    <span class='hs-comment'>--</span>
<a name="line-559"></a>    <span class='hs-comment'>-- Note: 'elem' is often used in infix form.</span>
<a name="line-560"></a>    <span class='hs-comment'>--</span>
<a name="line-561"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-562"></a>    <span class='hs-comment'>--</span>
<a name="line-563"></a>    <span class='hs-comment'>-- Basic usage:</span>
<a name="line-564"></a>    <span class='hs-comment'>--</span>
<a name="line-565"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; 3 `elem` []</span>
<a name="line-566"></a>    <span class='hs-comment'>-- False</span>
<a name="line-567"></a>    <span class='hs-comment'>--</span>
<a name="line-568"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; 3 `elem` [1,2]</span>
<a name="line-569"></a>    <span class='hs-comment'>-- False</span>
<a name="line-570"></a>    <span class='hs-comment'>--</span>
<a name="line-571"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]</span>
<a name="line-572"></a>    <span class='hs-comment'>-- True</span>
<a name="line-573"></a>    <span class='hs-comment'>--</span>
<a name="line-574"></a>    <span class='hs-comment'>-- For infinite structures, the default implementation of 'elem'</span>
<a name="line-575"></a>    <span class='hs-comment'>-- terminates if the sought-after value exists at a finite distance</span>
<a name="line-576"></a>    <span class='hs-comment'>-- from the left side of the structure:</span>
<a name="line-577"></a>    <span class='hs-comment'>--</span>
<a name="line-578"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; 3 `elem` [1..]</span>
<a name="line-579"></a>    <span class='hs-comment'>-- True</span>
<a name="line-580"></a>    <span class='hs-comment'>--</span>
<a name="line-581"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])</span>
<a name="line-582"></a>    <span class='hs-comment'>-- * Hangs forever *</span>
<a name="line-583"></a>    <span class='hs-comment'>--</span>
<a name="line-584"></a>    <span class='hs-comment'>-- @since 4.8.0.0</span>
<a name="line-585"></a>    <span class='hs-varid'>elem</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-586"></a>    <span class='hs-varid'>elem</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span>
<a name="line-587"></a>
<a name="line-588"></a>    <span class='hs-comment'>-- | The largest element of a non-empty structure.</span>
<a name="line-589"></a>    <span class='hs-comment'>--</span>
<a name="line-590"></a>    <span class='hs-comment'>-- This function is non-total and will raise a runtime exception if the</span>
<a name="line-591"></a>    <span class='hs-comment'>-- structure happens to be empty.  A structure that supports random access</span>
<a name="line-592"></a>    <span class='hs-comment'>-- and maintains its elements in order should provide a specialised</span>
<a name="line-593"></a>    <span class='hs-comment'>-- implementation to return the maximum in faster than linear time.</span>
<a name="line-594"></a>    <span class='hs-comment'>--</span>
<a name="line-595"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-596"></a>    <span class='hs-comment'>--</span>
<a name="line-597"></a>    <span class='hs-comment'>-- Basic usage:</span>
<a name="line-598"></a>    <span class='hs-comment'>--</span>
<a name="line-599"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; maximum [1..10]</span>
<a name="line-600"></a>    <span class='hs-comment'>-- 10</span>
<a name="line-601"></a>    <span class='hs-comment'>--</span>
<a name="line-602"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; maximum []</span>
<a name="line-603"></a>    <span class='hs-comment'>-- *** Exception: Prelude.maximum: empty list</span>
<a name="line-604"></a>    <span class='hs-comment'>--</span>
<a name="line-605"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; maximum Nothing</span>
<a name="line-606"></a>    <span class='hs-comment'>-- *** Exception: maximum: empty structure</span>
<a name="line-607"></a>    <span class='hs-comment'>--</span>
<a name="line-608"></a>    <span class='hs-comment'>-- WARNING: This function is partial for possibly-empty structures like lists.</span>
<a name="line-609"></a>    <span class='hs-comment'>--</span>
<a name="line-610"></a>    <span class='hs-comment'>-- @since 4.8.0.0</span>
<a name="line-611"></a>    <span class='hs-varid'>maximum</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-612"></a>    <span class='hs-varid'>maximum</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fromMaybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>errorWithoutStackTrace</span> <span class='hs-str'>"maximum: empty structure"</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span>
<a name="line-613"></a>       <span class='hs-varid'>getMax</span> <span class='hs-varop'>.</span> <span class='hs-varid'>foldMap'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Max</span> <span class='hs-cpp'>#.</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-614"></a>    <span class='hs-comment'>{-# INLINEABLE maximum #-}</span>
<a name="line-615"></a>
<a name="line-616"></a>    <span class='hs-comment'>-- | The least element of a non-empty structure.</span>
<a name="line-617"></a>    <span class='hs-comment'>--</span>
<a name="line-618"></a>    <span class='hs-comment'>-- This function is non-total and will raise a runtime exception if the</span>
<a name="line-619"></a>    <span class='hs-comment'>-- structure happens to be empty.  A structure that supports random access</span>
<a name="line-620"></a>    <span class='hs-comment'>-- and maintains its elements in order should provide a specialised</span>
<a name="line-621"></a>    <span class='hs-comment'>-- implementation to return the minimum in faster than linear time.</span>
<a name="line-622"></a>    <span class='hs-comment'>--</span>
<a name="line-623"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-624"></a>    <span class='hs-comment'>--</span>
<a name="line-625"></a>    <span class='hs-comment'>-- Basic usage:</span>
<a name="line-626"></a>    <span class='hs-comment'>--</span>
<a name="line-627"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; minimum [1..10]</span>
<a name="line-628"></a>    <span class='hs-comment'>-- 1</span>
<a name="line-629"></a>    <span class='hs-comment'>--</span>
<a name="line-630"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; minimum []</span>
<a name="line-631"></a>    <span class='hs-comment'>-- *** Exception: Prelude.minimum: empty list</span>
<a name="line-632"></a>    <span class='hs-comment'>--</span>
<a name="line-633"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; minimum Nothing</span>
<a name="line-634"></a>    <span class='hs-comment'>-- *** Exception: minimum: empty structure</span>
<a name="line-635"></a>    <span class='hs-comment'>--</span>
<a name="line-636"></a>    <span class='hs-comment'>-- WARNING: This function is partial for possibly-empty structures like lists.</span>
<a name="line-637"></a>    <span class='hs-comment'>--</span>
<a name="line-638"></a>    <span class='hs-comment'>-- @since 4.8.0.0</span>
<a name="line-639"></a>    <span class='hs-varid'>minimum</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-640"></a>    <span class='hs-varid'>minimum</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fromMaybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>errorWithoutStackTrace</span> <span class='hs-str'>"minimum: empty structure"</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span>
<a name="line-641"></a>       <span class='hs-varid'>getMin</span> <span class='hs-varop'>.</span> <span class='hs-varid'>foldMap'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Min</span> <span class='hs-cpp'>#.</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-642"></a>    <span class='hs-comment'>{-# INLINEABLE minimum #-}</span>
<a name="line-643"></a>
<a name="line-644"></a>    <span class='hs-comment'>-- | The 'sum' function computes the sum of the numbers of a structure.</span>
<a name="line-645"></a>    <span class='hs-comment'>--</span>
<a name="line-646"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-647"></a>    <span class='hs-comment'>--</span>
<a name="line-648"></a>    <span class='hs-comment'>-- Basic usage:</span>
<a name="line-649"></a>    <span class='hs-comment'>--</span>
<a name="line-650"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; sum []</span>
<a name="line-651"></a>    <span class='hs-comment'>-- 0</span>
<a name="line-652"></a>    <span class='hs-comment'>--</span>
<a name="line-653"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; sum [42]</span>
<a name="line-654"></a>    <span class='hs-comment'>-- 42</span>
<a name="line-655"></a>    <span class='hs-comment'>--</span>
<a name="line-656"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; sum [1..10]</span>
<a name="line-657"></a>    <span class='hs-comment'>-- 55</span>
<a name="line-658"></a>    <span class='hs-comment'>--</span>
<a name="line-659"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; sum [4.1, 2.0, 1.7]</span>
<a name="line-660"></a>    <span class='hs-comment'>-- 7.8</span>
<a name="line-661"></a>    <span class='hs-comment'>--</span>
<a name="line-662"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; sum [1..]</span>
<a name="line-663"></a>    <span class='hs-comment'>-- * Hangs forever *</span>
<a name="line-664"></a>    <span class='hs-comment'>--</span>
<a name="line-665"></a>    <span class='hs-comment'>-- @since 4.8.0.0</span>
<a name="line-666"></a>    <span class='hs-varid'>sum</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-667"></a>    <span class='hs-varid'>sum</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getSum</span> <span class='hs-cpp'>#.</span> <span class='hs-varid'>foldMap'</span> <span class='hs-conid'>Sum</span>
<a name="line-668"></a>    <span class='hs-comment'>{-# INLINEABLE sum #-}</span>
<a name="line-669"></a>
<a name="line-670"></a>    <span class='hs-comment'>-- | The 'product' function computes the product of the numbers of a</span>
<a name="line-671"></a>    <span class='hs-comment'>-- structure.</span>
<a name="line-672"></a>    <span class='hs-comment'>--</span>
<a name="line-673"></a>    <span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-674"></a>    <span class='hs-comment'>--</span>
<a name="line-675"></a>    <span class='hs-comment'>-- Basic usage:</span>
<a name="line-676"></a>    <span class='hs-comment'>--</span>
<a name="line-677"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; product []</span>
<a name="line-678"></a>    <span class='hs-comment'>-- 1</span>
<a name="line-679"></a>    <span class='hs-comment'>--</span>
<a name="line-680"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; product [42]</span>
<a name="line-681"></a>    <span class='hs-comment'>-- 42</span>
<a name="line-682"></a>    <span class='hs-comment'>--</span>
<a name="line-683"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; product [1..10]</span>
<a name="line-684"></a>    <span class='hs-comment'>-- 3628800</span>
<a name="line-685"></a>    <span class='hs-comment'>--</span>
<a name="line-686"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; product [4.1, 2.0, 1.7]</span>
<a name="line-687"></a>    <span class='hs-comment'>-- 13.939999999999998</span>
<a name="line-688"></a>    <span class='hs-comment'>--</span>
<a name="line-689"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; product [1..]</span>
<a name="line-690"></a>    <span class='hs-comment'>-- * Hangs forever *</span>
<a name="line-691"></a>    <span class='hs-comment'>--</span>
<a name="line-692"></a>    <span class='hs-comment'>-- @since 4.8.0.0</span>
<a name="line-693"></a>    <span class='hs-varid'>product</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-694"></a>    <span class='hs-varid'>product</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getProduct</span> <span class='hs-cpp'>#.</span> <span class='hs-varid'>foldMap'</span> <span class='hs-conid'>Product</span>
<a name="line-695"></a>    <span class='hs-comment'>{-# INLINEABLE product #-}</span>
<a name="line-696"></a>
<a name="line-697"></a><span class='hs-comment'>-- instances for Prelude types</span>
<a name="line-698"></a>
<a name="line-699"></a><a name="instance%20Foldable%20Maybe"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-700"></a><a name="instance%20Foldable%20Maybe"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>Maybe</span> <span class='hs-keyword'>where</span>
<a name="line-701"></a>    <span class='hs-varid'>foldMap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maybe</span> <span class='hs-varid'>mempty</span>
<a name="line-702"></a>
<a name="line-703"></a>    <span class='hs-varid'>foldr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>z</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>z</span>
<a name="line-704"></a>    <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>z</span>
<a name="line-705"></a>
<a name="line-706"></a>    <span class='hs-varid'>foldl</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>z</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>z</span>
<a name="line-707"></a>    <span class='hs-varid'>foldl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-varid'>x</span>
<a name="line-708"></a>
<a name="line-709"></a><a name="instance%20Foldable%20%5b%5d"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-710"></a><a name="instance%20Foldable%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>where</span>
<a name="line-711"></a>    <span class='hs-varid'>elem</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.elem</span>
<a name="line-712"></a>    <span class='hs-varid'>foldl</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.foldl</span>
<a name="line-713"></a>    <span class='hs-varid'>foldl'</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.foldl'</span>
<a name="line-714"></a>    <span class='hs-varid'>foldl1</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.foldl1</span>
<a name="line-715"></a>    <span class='hs-varid'>foldr</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.foldr</span>
<a name="line-716"></a>    <span class='hs-varid'>foldr1</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.foldr1</span>
<a name="line-717"></a>    <span class='hs-varid'>length</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.length</span>
<a name="line-718"></a>    <span class='hs-varid'>maximum</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.maximum</span>
<a name="line-719"></a>    <span class='hs-varid'>minimum</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.minimum</span>
<a name="line-720"></a>    <span class='hs-varid'>null</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.null</span>
<a name="line-721"></a>    <span class='hs-varid'>product</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.product</span>
<a name="line-722"></a>    <span class='hs-varid'>sum</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.sum</span>
<a name="line-723"></a>    <span class='hs-varid'>toList</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span>
<a name="line-724"></a>
<a name="line-725"></a><a name="instance%20Foldable%20NonEmpty"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-726"></a><a name="instance%20Foldable%20NonEmpty"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>NonEmpty</span> <span class='hs-keyword'>where</span>
<a name="line-727"></a>  <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-conid'>List.foldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-728"></a>  <span class='hs-varid'>foldl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.foldl</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span>
<a name="line-729"></a>  <span class='hs-varid'>foldl1</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.foldl</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>as</span>
<a name="line-730"></a>
<a name="line-731"></a>  <span class='hs-comment'>-- GHC isn't clever enough to transform the default definition</span>
<a name="line-732"></a>  <span class='hs-comment'>-- into anything like this, so we'd end up shuffling a bunch of</span>
<a name="line-733"></a>  <span class='hs-comment'>-- Maybes around.</span>
<a name="line-734"></a>  <span class='hs-varid'>foldr1</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>p</span> <span class='hs-conop'>:|</span> <span class='hs-varid'>ps</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>go</span> <span class='hs-varid'>id</span> <span class='hs-varid'>ps</span> <span class='hs-varid'>p</span>
<a name="line-735"></a>    <span class='hs-keyword'>where</span>
<a name="line-736"></a>      <span class='hs-varid'>go</span> <span class='hs-varid'>x</span> <span class='hs-varid'>r</span> <span class='hs-varid'>prev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>prev</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-737"></a>
<a name="line-738"></a>  <span class='hs-comment'>-- We used to say</span>
<a name="line-739"></a>  <span class='hs-comment'>--</span>
<a name="line-740"></a>  <span class='hs-comment'>--   length (_ :| as) = 1 + length as</span>
<a name="line-741"></a>  <span class='hs-comment'>--</span>
<a name="line-742"></a>  <span class='hs-comment'>-- but the default definition is better, counting from 1.</span>
<a name="line-743"></a>  <span class='hs-comment'>--</span>
<a name="line-744"></a>  <span class='hs-comment'>-- The default definition also works great for null and foldl'.</span>
<a name="line-745"></a>  <span class='hs-comment'>-- As usual for cons lists, foldr' is basically hopeless.</span>
<a name="line-746"></a>
<a name="line-747"></a>  <span class='hs-varid'>foldMap</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>foldMap</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>as</span>
<a name="line-748"></a>  <span class='hs-varid'>fold</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-conop'>:|</span> <span class='hs-varid'>ms</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>fold</span> <span class='hs-varid'>ms</span>
<a name="line-749"></a>  <span class='hs-varid'>toList</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>as</span>
<a name="line-750"></a>
<a name="line-751"></a><a name="instance%20Foldable%20(Either%20a)"></a><span class='hs-comment'>-- | @since 4.7.0.0</span>
<a name="line-752"></a><a name="instance%20Foldable%20(Either%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-753"></a>    <span class='hs-varid'>foldMap</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-754"></a>    <span class='hs-varid'>foldMap</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>y</span>
<a name="line-755"></a>
<a name="line-756"></a>    <span class='hs-varid'>foldr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>z</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>z</span>
<a name="line-757"></a>    <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>y</span> <span class='hs-varid'>z</span>
<a name="line-758"></a>
<a name="line-759"></a>    <span class='hs-varid'>length</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-760"></a>    <span class='hs-varid'>length</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-761"></a>
<a name="line-762"></a>    <span class='hs-varid'>null</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isLeft</span>
<a name="line-763"></a>
<a name="line-764"></a><span class='hs-comment'>-- | @since 4.15</span>
<a name="line-765"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>Solo</span>
<a name="line-766"></a>
<a name="line-767"></a><a name="instance%20Foldable%20((,)%20a)"></a><span class='hs-comment'>-- | @since 4.7.0.0</span>
<a name="line-768"></a><a name="instance%20Foldable%20((,)%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,)</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-769"></a>    <span class='hs-varid'>foldMap</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>y</span>
<a name="line-770"></a>
<a name="line-771"></a>    <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>y</span> <span class='hs-varid'>z</span>
<a name="line-772"></a>    <span class='hs-varid'>length</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-773"></a>    <span class='hs-varid'>null</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-774"></a>
<a name="line-775"></a><a name="instance%20Foldable%20(Array%20i)"></a><span class='hs-comment'>-- | @since 4.8.0.0</span>
<a name="line-776"></a><a name="instance%20Foldable%20(Array%20i)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-layout'>(</span><span class='hs-conid'>Array</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-777"></a>    <span class='hs-varid'>foldr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrElems</span>
<a name="line-778"></a>    <span class='hs-varid'>foldl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldlElems</span>
<a name="line-779"></a>    <span class='hs-varid'>foldl'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldlElems'</span>
<a name="line-780"></a>    <span class='hs-varid'>foldr'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrElems'</span>
<a name="line-781"></a>    <span class='hs-varid'>foldl1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl1Elems</span>
<a name="line-782"></a>    <span class='hs-varid'>foldr1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr1Elems</span>
<a name="line-783"></a>    <span class='hs-varid'>toList</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>elems</span>
<a name="line-784"></a>    <span class='hs-varid'>length</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>numElements</span>
<a name="line-785"></a>    <span class='hs-varid'>null</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>numElements</span> <span class='hs-varid'>a</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span>
<a name="line-786"></a>
<a name="line-787"></a><a name="instance%20Foldable%20Proxy"></a><span class='hs-comment'>-- | @since 4.7.0.0</span>
<a name="line-788"></a><a name="instance%20Foldable%20Proxy"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>Proxy</span> <span class='hs-keyword'>where</span>
<a name="line-789"></a>    <span class='hs-varid'>foldMap</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-790"></a>    <span class='hs-comment'>{-# INLINE foldMap #-}</span>
<a name="line-791"></a>    <span class='hs-varid'>fold</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-792"></a>    <span class='hs-comment'>{-# INLINE fold #-}</span>
<a name="line-793"></a>    <span class='hs-varid'>foldr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>z</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>z</span>
<a name="line-794"></a>    <span class='hs-comment'>{-# INLINE foldr #-}</span>
<a name="line-795"></a>    <span class='hs-varid'>foldl</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>z</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>z</span>
<a name="line-796"></a>    <span class='hs-comment'>{-# INLINE foldl #-}</span>
<a name="line-797"></a>    <span class='hs-varid'>foldl1</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>errorWithoutStackTrace</span> <span class='hs-str'>"foldl1: Proxy"</span>
<a name="line-798"></a>    <span class='hs-varid'>foldr1</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>errorWithoutStackTrace</span> <span class='hs-str'>"foldr1: Proxy"</span>
<a name="line-799"></a>    <span class='hs-varid'>length</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-800"></a>    <span class='hs-varid'>null</span> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-801"></a>    <span class='hs-varid'>elem</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-802"></a>    <span class='hs-varid'>sum</span> <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-803"></a>    <span class='hs-varid'>product</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-804"></a>
<a name="line-805"></a><a name="instance%20Foldable%20Dual"></a><span class='hs-comment'>-- | @since 4.8.0.0</span>
<a name="line-806"></a><a name="instance%20Foldable%20Dual"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>Dual</span> <span class='hs-keyword'>where</span>
<a name="line-807"></a>    <span class='hs-varid'>foldMap</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coerce</span>
<a name="line-808"></a>
<a name="line-809"></a>    <span class='hs-varid'>elem</span>               <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>.</span> <span class='hs-varid'>getDual</span><span class='hs-layout'>)</span> <span class='hs-cpp'>#.</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span>
<a name="line-810"></a>    <span class='hs-varid'>foldl</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coerce</span>
<a name="line-811"></a>    <span class='hs-varid'>foldl'</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coerce</span>
<a name="line-812"></a>    <span class='hs-varid'>foldl1</span> <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getDual</span>
<a name="line-813"></a>    <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dual</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>z</span>
<a name="line-814"></a>    <span class='hs-varid'>foldr'</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span>
<a name="line-815"></a>    <span class='hs-varid'>foldr1</span> <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getDual</span>
<a name="line-816"></a>    <span class='hs-varid'>length</span> <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-817"></a>    <span class='hs-varid'>maximum</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getDual</span>
<a name="line-818"></a>    <span class='hs-varid'>minimum</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getDual</span>
<a name="line-819"></a>    <span class='hs-varid'>null</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-820"></a>    <span class='hs-varid'>product</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getDual</span>
<a name="line-821"></a>    <span class='hs-varid'>sum</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getDual</span>
<a name="line-822"></a>    <span class='hs-varid'>toList</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dual</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>
<a name="line-823"></a>
<a name="line-824"></a><a name="instance%20Foldable%20Sum"></a><span class='hs-comment'>-- | @since 4.8.0.0</span>
<a name="line-825"></a><a name="instance%20Foldable%20Sum"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>Sum</span> <span class='hs-keyword'>where</span>
<a name="line-826"></a>    <span class='hs-varid'>foldMap</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coerce</span>
<a name="line-827"></a>
<a name="line-828"></a>    <span class='hs-varid'>elem</span>               <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>.</span> <span class='hs-varid'>getSum</span><span class='hs-layout'>)</span> <span class='hs-cpp'>#.</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span>
<a name="line-829"></a>    <span class='hs-varid'>foldl</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coerce</span>
<a name="line-830"></a>    <span class='hs-varid'>foldl'</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coerce</span>
<a name="line-831"></a>    <span class='hs-varid'>foldl1</span> <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getSum</span>
<a name="line-832"></a>    <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-layout'>(</span><span class='hs-conid'>Sum</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>z</span>
<a name="line-833"></a>    <span class='hs-varid'>foldr'</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span>
<a name="line-834"></a>    <span class='hs-varid'>foldr1</span> <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getSum</span>
<a name="line-835"></a>    <span class='hs-varid'>length</span> <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-836"></a>    <span class='hs-varid'>maximum</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getSum</span>
<a name="line-837"></a>    <span class='hs-varid'>minimum</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getSum</span>
<a name="line-838"></a>    <span class='hs-varid'>null</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-839"></a>    <span class='hs-varid'>product</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getSum</span>
<a name="line-840"></a>    <span class='hs-varid'>sum</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getSum</span>
<a name="line-841"></a>    <span class='hs-varid'>toList</span> <span class='hs-layout'>(</span><span class='hs-conid'>Sum</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>
<a name="line-842"></a>
<a name="line-843"></a><a name="instance%20Foldable%20Product"></a><span class='hs-comment'>-- | @since 4.8.0.0</span>
<a name="line-844"></a><a name="instance%20Foldable%20Product"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>Product</span> <span class='hs-keyword'>where</span>
<a name="line-845"></a>    <span class='hs-varid'>foldMap</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coerce</span>
<a name="line-846"></a>
<a name="line-847"></a>    <span class='hs-varid'>elem</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>.</span> <span class='hs-varid'>getProduct</span><span class='hs-layout'>)</span> <span class='hs-cpp'>#.</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span>
<a name="line-848"></a>    <span class='hs-varid'>foldl</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coerce</span>
<a name="line-849"></a>    <span class='hs-varid'>foldl'</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coerce</span>
<a name="line-850"></a>    <span class='hs-varid'>foldl1</span> <span class='hs-keyword'>_</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getProduct</span>
<a name="line-851"></a>    <span class='hs-varid'>foldr</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-layout'>(</span><span class='hs-conid'>Product</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>z</span>
<a name="line-852"></a>    <span class='hs-varid'>foldr'</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span>
<a name="line-853"></a>    <span class='hs-varid'>foldr1</span> <span class='hs-keyword'>_</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getProduct</span>
<a name="line-854"></a>    <span class='hs-varid'>length</span> <span class='hs-keyword'>_</span>              <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-855"></a>    <span class='hs-varid'>maximum</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getProduct</span>
<a name="line-856"></a>    <span class='hs-varid'>minimum</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getProduct</span>
<a name="line-857"></a>    <span class='hs-varid'>null</span> <span class='hs-keyword'>_</span>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-858"></a>    <span class='hs-varid'>product</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getProduct</span>
<a name="line-859"></a>    <span class='hs-varid'>sum</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getProduct</span>
<a name="line-860"></a>    <span class='hs-varid'>toList</span> <span class='hs-layout'>(</span><span class='hs-conid'>Product</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>
<a name="line-861"></a>
<a name="line-862"></a><a name="instance%20Foldable%20First"></a><span class='hs-comment'>-- | @since 4.8.0.0</span>
<a name="line-863"></a><a name="instance%20Foldable%20First"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>First</span> <span class='hs-keyword'>where</span>
<a name="line-864"></a>    <span class='hs-varid'>foldMap</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldMap</span> <span class='hs-varid'>f</span> <span class='hs-varop'>.</span> <span class='hs-varid'>getFirst</span>
<a name="line-865"></a>
<a name="line-866"></a><a name="instance%20Foldable%20Last"></a><span class='hs-comment'>-- | @since 4.8.0.0</span>
<a name="line-867"></a><a name="instance%20Foldable%20Last"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>Last</span> <span class='hs-keyword'>where</span>
<a name="line-868"></a>    <span class='hs-varid'>foldMap</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldMap</span> <span class='hs-varid'>f</span> <span class='hs-varop'>.</span> <span class='hs-varid'>getLast</span>
<a name="line-869"></a>
<a name="line-870"></a><a name="instance%20Foldable%20(Alt%20f)"></a><span class='hs-comment'>-- | @since 4.12.0.0</span>
<a name="line-871"></a><a name="instance%20Foldable%20(Alt%20f)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Foldable</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-872"></a>    <span class='hs-varid'>foldMap</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldMap</span> <span class='hs-varid'>f</span> <span class='hs-varop'>.</span> <span class='hs-varid'>getAlt</span>
<a name="line-873"></a>
<a name="line-874"></a><a name="instance%20Foldable%20(Ap%20f)"></a><span class='hs-comment'>-- | @since 4.12.0.0</span>
<a name="line-875"></a><a name="instance%20Foldable%20(Ap%20f)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Foldable</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ap</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-876"></a>    <span class='hs-varid'>foldMap</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldMap</span> <span class='hs-varid'>f</span> <span class='hs-varop'>.</span> <span class='hs-varid'>getAp</span>
<a name="line-877"></a>
<a name="line-878"></a><a name="instance%20Foldable%20U1"></a><span class='hs-comment'>-- Instances for GHC.Generics</span>
<a name="line-879"></a><a name="instance%20Foldable%20U1"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-880"></a><a name="instance%20Foldable%20U1"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>U1</span> <span class='hs-keyword'>where</span>
<a name="line-881"></a>    <span class='hs-varid'>foldMap</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-882"></a>    <span class='hs-comment'>{-# INLINE foldMap #-}</span>
<a name="line-883"></a>    <span class='hs-varid'>fold</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-884"></a>    <span class='hs-comment'>{-# INLINE fold #-}</span>
<a name="line-885"></a>    <span class='hs-varid'>foldr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>z</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>z</span>
<a name="line-886"></a>    <span class='hs-comment'>{-# INLINE foldr #-}</span>
<a name="line-887"></a>    <span class='hs-varid'>foldl</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>z</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>z</span>
<a name="line-888"></a>    <span class='hs-comment'>{-# INLINE foldl #-}</span>
<a name="line-889"></a>    <span class='hs-varid'>foldl1</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>errorWithoutStackTrace</span> <span class='hs-str'>"foldl1: U1"</span>
<a name="line-890"></a>    <span class='hs-varid'>foldr1</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>errorWithoutStackTrace</span> <span class='hs-str'>"foldr1: U1"</span>
<a name="line-891"></a>    <span class='hs-varid'>length</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-892"></a>    <span class='hs-varid'>null</span> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-893"></a>    <span class='hs-varid'>elem</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-894"></a>    <span class='hs-varid'>sum</span> <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-895"></a>    <span class='hs-varid'>product</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-896"></a>
<a name="line-897"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-898"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>V1</span>
<a name="line-899"></a>
<a name="line-900"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-901"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>Par1</span>
<a name="line-902"></a>
<a name="line-903"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-904"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Foldable</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec1</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span>
<a name="line-905"></a>
<a name="line-906"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-907"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-layout'>(</span><span class='hs-conid'>K1</span> <span class='hs-varid'>i</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-908"></a>
<a name="line-909"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-910"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Foldable</span> <span class='hs-layout'>(</span><span class='hs-conid'>M1</span> <span class='hs-varid'>i</span> <span class='hs-varid'>c</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span>
<a name="line-911"></a>
<a name="line-912"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-913"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Foldable</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-conop'>:+:</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
<a name="line-914"></a>
<a name="line-915"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-916"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Foldable</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-conop'>:*:</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
<a name="line-917"></a>
<a name="line-918"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-919"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Foldable</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-conop'>:.:</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
<a name="line-920"></a>
<a name="line-921"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-922"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>UAddr</span>
<a name="line-923"></a>
<a name="line-924"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-925"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>UChar</span>
<a name="line-926"></a>
<a name="line-927"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-928"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>UDouble</span>
<a name="line-929"></a>
<a name="line-930"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-931"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>UFloat</span>
<a name="line-932"></a>
<a name="line-933"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-934"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>UInt</span>
<a name="line-935"></a>
<a name="line-936"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-937"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>UWord</span>
<a name="line-938"></a>
<a name="line-939"></a><span class='hs-comment'>-- Instances for Data.Ord</span>
<a name="line-940"></a><span class='hs-comment'>-- | @since 4.12.0.0</span>
<a name="line-941"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Foldable</span> <span class='hs-conid'>Down</span>
<a name="line-942"></a>
<a name="line-943"></a><a name="foldrM"></a><span class='hs-comment'>-- | Right-to-left monadic fold over the elements of a structure.</span>
<a name="line-944"></a><span class='hs-comment'>--</span>
<a name="line-945"></a><span class='hs-comment'>-- Given a structure @t@ with elements @(a, b, c, ..., x, y)@, the result of</span>
<a name="line-946"></a><span class='hs-comment'>-- a fold with an operator function @f@ is equivalent to:</span>
<a name="line-947"></a><span class='hs-comment'>--</span>
<a name="line-948"></a><span class='hs-comment'>-- &gt; foldrM f z t = do</span>
<a name="line-949"></a><span class='hs-comment'>-- &gt;     yy &lt;- f y z</span>
<a name="line-950"></a><span class='hs-comment'>-- &gt;     xx &lt;- f x yy</span>
<a name="line-951"></a><span class='hs-comment'>-- &gt;     ...</span>
<a name="line-952"></a><span class='hs-comment'>-- &gt;     bb &lt;- f b cc</span>
<a name="line-953"></a><span class='hs-comment'>-- &gt;     aa &lt;- f a bb</span>
<a name="line-954"></a><span class='hs-comment'>-- &gt;     return aa -- Just @return z@ when the structure is empty</span>
<a name="line-955"></a><span class='hs-comment'>--</span>
<a name="line-956"></a><span class='hs-comment'>-- For a Monad @m@, given two functions @f1 :: a -&gt; m b@ and @f2 :: b -&gt; m c@,</span>
<a name="line-957"></a><span class='hs-comment'>-- their Kleisli composition @(f1 &gt;=&gt; f2) :: a -&gt; m c@ is defined by:</span>
<a name="line-958"></a><span class='hs-comment'>--</span>
<a name="line-959"></a><span class='hs-comment'>-- &gt; (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2</span>
<a name="line-960"></a><span class='hs-comment'>--</span>
<a name="line-961"></a><span class='hs-comment'>-- Another way of thinking about @foldrM@ is that it amounts to an application</span>
<a name="line-962"></a><span class='hs-comment'>-- to @z@ of a Kleisli composition:</span>
<a name="line-963"></a><span class='hs-comment'>--</span>
<a name="line-964"></a><span class='hs-comment'>-- &gt; foldrM f z t = f y &gt;=&gt; f x &gt;=&gt; ... &gt;=&gt; f b &gt;=&gt; f a $ z</span>
<a name="line-965"></a><span class='hs-comment'>--</span>
<a name="line-966"></a><span class='hs-comment'>-- The monadic effects of @foldrM@ are sequenced from right to left, and e.g.</span>
<a name="line-967"></a><span class='hs-comment'>-- folds of infinite lists will diverge.</span>
<a name="line-968"></a><span class='hs-comment'>--</span>
<a name="line-969"></a><span class='hs-comment'>-- If at some step the bind operator @('&gt;&gt;=')@ short-circuits (as with, e.g.,</span>
<a name="line-970"></a><span class='hs-comment'>-- 'mzero' in a 'MonadPlus'), the evaluated effects will be from a tail of the</span>
<a name="line-971"></a><span class='hs-comment'>-- element sequence.  If you want to evaluate the monadic effects in</span>
<a name="line-972"></a><span class='hs-comment'>-- left-to-right order, or perhaps be able to short-circuit after an initial</span>
<a name="line-973"></a><span class='hs-comment'>-- sequence of elements, you'll need to use `foldlM` instead.</span>
<a name="line-974"></a><span class='hs-comment'>--</span>
<a name="line-975"></a><span class='hs-comment'>-- If the monadic effects don't short-circuit, the outermost application of</span>
<a name="line-976"></a><span class='hs-comment'>-- @f@ is to the leftmost element @a@, so that, ignoring effects, the result</span>
<a name="line-977"></a><span class='hs-comment'>-- looks like a right fold:</span>
<a name="line-978"></a><span class='hs-comment'>--</span>
<a name="line-979"></a><span class='hs-comment'>-- &gt; a `f` (b `f` (c `f` (... (x `f` (y `f` z))))).</span>
<a name="line-980"></a><span class='hs-comment'>--</span>
<a name="line-981"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-982"></a><span class='hs-comment'>--</span>
<a name="line-983"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-984"></a><span class='hs-comment'>--</span>
<a name="line-985"></a><span class='hs-comment'>-- &gt;&gt;&gt; let f i acc = do { print i ; return $ i : acc }</span>
<a name="line-986"></a><span class='hs-comment'>-- &gt;&gt;&gt; foldrM f [] [0..3]</span>
<a name="line-987"></a><span class='hs-comment'>-- 3</span>
<a name="line-988"></a><span class='hs-comment'>-- 2</span>
<a name="line-989"></a><span class='hs-comment'>-- 1</span>
<a name="line-990"></a><span class='hs-comment'>-- 0</span>
<a name="line-991"></a><span class='hs-comment'>-- [0,1,2,3]</span>
<a name="line-992"></a><span class='hs-comment'>--</span>
<a name="line-993"></a><span class='hs-definition'>foldrM</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span>
<a name="line-994"></a><span class='hs-definition'>foldrM</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z0</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-varid'>c</span> <span class='hs-varid'>return</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>z0</span>
<a name="line-995"></a>  <span class='hs-comment'>-- See Note [List fusion and continuations in 'c']</span>
<a name="line-996"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>c</span> <span class='hs-varid'>k</span> <span class='hs-varid'>x</span> <span class='hs-varid'>z</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>z</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span>
<a name="line-997"></a>        <span class='hs-comment'>{-# INLINE c #-}</span>
<a name="line-998"></a>
<a name="line-999"></a><a name="foldlM"></a><span class='hs-comment'>-- | Left-to-right monadic fold over the elements of a structure.</span>
<a name="line-1000"></a><span class='hs-comment'>--</span>
<a name="line-1001"></a><span class='hs-comment'>-- Given a structure @t@ with elements @(a, b, ..., w, x, y)@, the result of</span>
<a name="line-1002"></a><span class='hs-comment'>-- a fold with an operator function @f@ is equivalent to:</span>
<a name="line-1003"></a><span class='hs-comment'>--</span>
<a name="line-1004"></a><span class='hs-comment'>-- &gt; foldlM f z t = do</span>
<a name="line-1005"></a><span class='hs-comment'>-- &gt;     aa &lt;- f z a</span>
<a name="line-1006"></a><span class='hs-comment'>-- &gt;     bb &lt;- f aa b</span>
<a name="line-1007"></a><span class='hs-comment'>-- &gt;     ...</span>
<a name="line-1008"></a><span class='hs-comment'>-- &gt;     xx &lt;- f ww x</span>
<a name="line-1009"></a><span class='hs-comment'>-- &gt;     yy &lt;- f xx y</span>
<a name="line-1010"></a><span class='hs-comment'>-- &gt;     return yy -- Just @return z@ when the structure is empty</span>
<a name="line-1011"></a><span class='hs-comment'>--</span>
<a name="line-1012"></a><span class='hs-comment'>-- For a Monad @m@, given two functions @f1 :: a -&gt; m b@ and @f2 :: b -&gt; m c@,</span>
<a name="line-1013"></a><span class='hs-comment'>-- their Kleisli composition @(f1 &gt;=&gt; f2) :: a -&gt; m c@ is defined by:</span>
<a name="line-1014"></a><span class='hs-comment'>--</span>
<a name="line-1015"></a><span class='hs-comment'>-- &gt; (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2</span>
<a name="line-1016"></a><span class='hs-comment'>--</span>
<a name="line-1017"></a><span class='hs-comment'>-- Another way of thinking about @foldlM@ is that it amounts to an application</span>
<a name="line-1018"></a><span class='hs-comment'>-- to @z@ of a Kleisli composition:</span>
<a name="line-1019"></a><span class='hs-comment'>--</span>
<a name="line-1020"></a><span class='hs-comment'>-- &gt; foldlM f z t =</span>
<a name="line-1021"></a><span class='hs-comment'>-- &gt;     flip f a &gt;=&gt; flip f b &gt;=&gt; ... &gt;=&gt; flip f x &gt;=&gt; flip f y $ z</span>
<a name="line-1022"></a><span class='hs-comment'>--</span>
<a name="line-1023"></a><span class='hs-comment'>-- The monadic effects of @foldlM@ are sequenced from left to right.</span>
<a name="line-1024"></a><span class='hs-comment'>--</span>
<a name="line-1025"></a><span class='hs-comment'>-- If at some step the bind operator @('&gt;&gt;=')@ short-circuits (as with, e.g.,</span>
<a name="line-1026"></a><span class='hs-comment'>-- 'mzero' in a 'MonadPlus'), the evaluated effects will be from an initial</span>
<a name="line-1027"></a><span class='hs-comment'>-- segment of the element sequence.  If you want to evaluate the monadic</span>
<a name="line-1028"></a><span class='hs-comment'>-- effects in right-to-left order, or perhaps be able to short-circuit after</span>
<a name="line-1029"></a><span class='hs-comment'>-- processing a tail of the sequence of elements, you'll need to use `foldrM`</span>
<a name="line-1030"></a><span class='hs-comment'>-- instead.</span>
<a name="line-1031"></a><span class='hs-comment'>--</span>
<a name="line-1032"></a><span class='hs-comment'>-- If the monadic effects don't short-circuit, the outermost application of</span>
<a name="line-1033"></a><span class='hs-comment'>-- @f@ is to the rightmost element @y@, so that, ignoring effects, the result</span>
<a name="line-1034"></a><span class='hs-comment'>-- looks like a left fold:</span>
<a name="line-1035"></a><span class='hs-comment'>--</span>
<a name="line-1036"></a><span class='hs-comment'>-- &gt; ((((z `f` a) `f` b) ... `f` w) `f` x) `f` y</span>
<a name="line-1037"></a><span class='hs-comment'>--</span>
<a name="line-1038"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1039"></a><span class='hs-comment'>--</span>
<a name="line-1040"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1041"></a><span class='hs-comment'>--</span>
<a name="line-1042"></a><span class='hs-comment'>-- &gt;&gt;&gt; let f a e = do { print e ; return $ e : a }</span>
<a name="line-1043"></a><span class='hs-comment'>-- &gt;&gt;&gt; foldlM f [] [0..3]</span>
<a name="line-1044"></a><span class='hs-comment'>-- 0</span>
<a name="line-1045"></a><span class='hs-comment'>-- 1</span>
<a name="line-1046"></a><span class='hs-comment'>-- 2</span>
<a name="line-1047"></a><span class='hs-comment'>-- 3</span>
<a name="line-1048"></a><span class='hs-comment'>-- [3,2,1,0]</span>
<a name="line-1049"></a><span class='hs-comment'>--</span>
<a name="line-1050"></a><span class='hs-definition'>foldlM</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span>
<a name="line-1051"></a><span class='hs-definition'>foldlM</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z0</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>c</span> <span class='hs-varid'>return</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>z0</span>
<a name="line-1052"></a>  <span class='hs-comment'>-- See Note [List fusion and continuations in 'c']</span>
<a name="line-1053"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>c</span> <span class='hs-varid'>x</span> <span class='hs-varid'>k</span> <span class='hs-varid'>z</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span>
<a name="line-1054"></a>        <span class='hs-comment'>{-# INLINE c #-}</span>
<a name="line-1055"></a>
<a name="line-1056"></a><a name="traverse_"></a><span class='hs-comment'>-- | Map each element of a structure to an 'Applicative' action, evaluate these</span>
<a name="line-1057"></a><span class='hs-comment'>-- actions from left to right, and ignore the results.  For a version that</span>
<a name="line-1058"></a><span class='hs-comment'>-- doesn't ignore the results see 'Data.Traversable.traverse'.</span>
<a name="line-1059"></a><span class='hs-comment'>--</span>
<a name="line-1060"></a><span class='hs-comment'>-- 'traverse_' is just like 'mapM_', but generalised to 'Applicative' actions.</span>
<a name="line-1061"></a><span class='hs-comment'>--</span>
<a name="line-1062"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1063"></a><span class='hs-comment'>--</span>
<a name="line-1064"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1065"></a><span class='hs-comment'>--</span>
<a name="line-1066"></a><span class='hs-comment'>-- &gt;&gt;&gt; traverse_ print ["Hello", "world", "!"]</span>
<a name="line-1067"></a><span class='hs-comment'>-- "Hello"</span>
<a name="line-1068"></a><span class='hs-comment'>-- "world"</span>
<a name="line-1069"></a><span class='hs-comment'>-- "!"</span>
<a name="line-1070"></a><span class='hs-definition'>traverse_</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-conid'>()</span>
<a name="line-1071"></a><span class='hs-definition'>traverse_</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>c</span> <span class='hs-layout'>(</span><span class='hs-varid'>pure</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span>
<a name="line-1072"></a>  <span class='hs-comment'>-- See Note [List fusion and continuations in 'c']</span>
<a name="line-1073"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>c</span> <span class='hs-varid'>x</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varop'>*&gt;</span> <span class='hs-varid'>k</span>
<a name="line-1074"></a>        <span class='hs-comment'>{-# INLINE c #-}</span>
<a name="line-1075"></a>
<a name="line-1076"></a><a name="for_"></a><span class='hs-comment'>-- | 'for_' is 'traverse_' with its arguments flipped.  For a version</span>
<a name="line-1077"></a><span class='hs-comment'>-- that doesn't ignore the results see 'Data.Traversable.for'.  This</span>
<a name="line-1078"></a><span class='hs-comment'>-- is 'forM_' generalised to 'Applicative' actions.</span>
<a name="line-1079"></a><span class='hs-comment'>--</span>
<a name="line-1080"></a><span class='hs-comment'>-- 'for_' is just like 'forM_', but generalised to 'Applicative' actions.</span>
<a name="line-1081"></a><span class='hs-comment'>--</span>
<a name="line-1082"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1083"></a><span class='hs-comment'>--</span>
<a name="line-1084"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1085"></a><span class='hs-comment'>--</span>
<a name="line-1086"></a><span class='hs-comment'>-- &gt;&gt;&gt; for_ [1..4] print</span>
<a name="line-1087"></a><span class='hs-comment'>-- 1</span>
<a name="line-1088"></a><span class='hs-comment'>-- 2</span>
<a name="line-1089"></a><span class='hs-comment'>-- 3</span>
<a name="line-1090"></a><span class='hs-comment'>-- 4</span>
<a name="line-1091"></a><span class='hs-definition'>for_</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-conid'>()</span>
<a name="line-1092"></a><span class='hs-comment'>{-# INLINE for_ #-}</span>
<a name="line-1093"></a><span class='hs-definition'>for_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>traverse_</span>
<a name="line-1094"></a>
<a name="line-1095"></a><a name="mapM_"></a><span class='hs-comment'>-- | Map each element of a structure to a monadic action, evaluate</span>
<a name="line-1096"></a><span class='hs-comment'>-- these actions from left to right, and ignore the results.  For a</span>
<a name="line-1097"></a><span class='hs-comment'>-- version that doesn't ignore the results see</span>
<a name="line-1098"></a><span class='hs-comment'>-- 'Data.Traversable.mapM'.</span>
<a name="line-1099"></a><span class='hs-comment'>--</span>
<a name="line-1100"></a><span class='hs-comment'>-- 'mapM_' is just like 'traverse_', but specialised to monadic actions.</span>
<a name="line-1101"></a><span class='hs-comment'>--</span>
<a name="line-1102"></a><span class='hs-definition'>mapM_</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-conid'>()</span>
<a name="line-1103"></a><span class='hs-definition'>mapM_</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>c</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span>
<a name="line-1104"></a>  <span class='hs-comment'>-- See Note [List fusion and continuations in 'c']</span>
<a name="line-1105"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>c</span> <span class='hs-varid'>x</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>k</span>
<a name="line-1106"></a>        <span class='hs-comment'>{-# INLINE c #-}</span>
<a name="line-1107"></a>
<a name="line-1108"></a><a name="forM_"></a><span class='hs-comment'>-- | 'forM_' is 'mapM_' with its arguments flipped.  For a version that</span>
<a name="line-1109"></a><span class='hs-comment'>-- doesn't ignore the results see 'Data.Traversable.forM'.</span>
<a name="line-1110"></a><span class='hs-comment'>--</span>
<a name="line-1111"></a><span class='hs-comment'>-- 'forM_' is just like 'for_', but specialised to monadic actions.</span>
<a name="line-1112"></a><span class='hs-comment'>--</span>
<a name="line-1113"></a><span class='hs-definition'>forM_</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-conid'>()</span>
<a name="line-1114"></a><span class='hs-comment'>{-# INLINE forM_ #-}</span>
<a name="line-1115"></a><span class='hs-definition'>forM_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>mapM_</span>
<a name="line-1116"></a>
<a name="line-1117"></a><a name="sequenceA_"></a><span class='hs-comment'>-- | Evaluate each action in the structure from left to right, and</span>
<a name="line-1118"></a><span class='hs-comment'>-- ignore the results.  For a version that doesn't ignore the results</span>
<a name="line-1119"></a><span class='hs-comment'>-- see 'Data.Traversable.sequenceA'.</span>
<a name="line-1120"></a><span class='hs-comment'>--</span>
<a name="line-1121"></a><span class='hs-comment'>-- 'sequenceA_' is just like 'sequence_', but generalised to 'Applicative'</span>
<a name="line-1122"></a><span class='hs-comment'>-- actions.</span>
<a name="line-1123"></a><span class='hs-comment'>--</span>
<a name="line-1124"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1125"></a><span class='hs-comment'>--</span>
<a name="line-1126"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1127"></a><span class='hs-comment'>--</span>
<a name="line-1128"></a><span class='hs-comment'>-- &gt;&gt;&gt; sequenceA_ [print "Hello", print "world", print "!"]</span>
<a name="line-1129"></a><span class='hs-comment'>-- "Hello"</span>
<a name="line-1130"></a><span class='hs-comment'>-- "world"</span>
<a name="line-1131"></a><span class='hs-comment'>-- "!"</span>
<a name="line-1132"></a><span class='hs-definition'>sequenceA_</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-conid'>()</span>
<a name="line-1133"></a><span class='hs-definition'>sequenceA_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>c</span> <span class='hs-layout'>(</span><span class='hs-varid'>pure</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span>
<a name="line-1134"></a>  <span class='hs-comment'>-- See Note [List fusion and continuations in 'c']</span>
<a name="line-1135"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>c</span> <span class='hs-varid'>m</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m</span> <span class='hs-varop'>*&gt;</span> <span class='hs-varid'>k</span>
<a name="line-1136"></a>        <span class='hs-comment'>{-# INLINE c #-}</span>
<a name="line-1137"></a>
<a name="line-1138"></a><a name="sequence_"></a><span class='hs-comment'>-- | Evaluate each monadic action in the structure from left to right,</span>
<a name="line-1139"></a><span class='hs-comment'>-- and ignore the results.  For a version that doesn't ignore the</span>
<a name="line-1140"></a><span class='hs-comment'>-- results see 'Data.Traversable.sequence'.</span>
<a name="line-1141"></a><span class='hs-comment'>--</span>
<a name="line-1142"></a><span class='hs-comment'>-- 'sequence_' is just like 'sequenceA_', but specialised to monadic</span>
<a name="line-1143"></a><span class='hs-comment'>-- actions.</span>
<a name="line-1144"></a><span class='hs-comment'>--</span>
<a name="line-1145"></a><span class='hs-definition'>sequence_</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-conid'>()</span>
<a name="line-1146"></a><span class='hs-definition'>sequence_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>c</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span>
<a name="line-1147"></a>  <span class='hs-comment'>-- See Note [List fusion and continuations in 'c']</span>
<a name="line-1148"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>c</span> <span class='hs-varid'>m</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>k</span>
<a name="line-1149"></a>        <span class='hs-comment'>{-# INLINE c #-}</span>
<a name="line-1150"></a>
<a name="line-1151"></a><a name="asum"></a><span class='hs-comment'>-- | The sum of a collection of actions, generalizing 'concat'.</span>
<a name="line-1152"></a><span class='hs-comment'>--</span>
<a name="line-1153"></a><span class='hs-comment'>-- 'asum' is just like 'msum', but generalised to 'Alternative'.</span>
<a name="line-1154"></a><span class='hs-comment'>--</span>
<a name="line-1155"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1156"></a><span class='hs-comment'>--</span>
<a name="line-1157"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1158"></a><span class='hs-comment'>--</span>
<a name="line-1159"></a><span class='hs-comment'>-- &gt;&gt;&gt; asum [Just "Hello", Nothing, Just "World"]</span>
<a name="line-1160"></a><span class='hs-comment'>-- Just "Hello"</span>
<a name="line-1161"></a><span class='hs-definition'>asum</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-conid'>Alternative</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-1162"></a><span class='hs-comment'>{-# INLINE asum #-}</span>
<a name="line-1163"></a><span class='hs-definition'>asum</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;|&gt;</span><span class='hs-layout'>)</span> <span class='hs-varid'>empty</span>
<a name="line-1164"></a>
<a name="line-1165"></a><a name="msum"></a><span class='hs-comment'>-- | The sum of a collection of actions, generalizing 'concat'.</span>
<a name="line-1166"></a><span class='hs-comment'>--</span>
<a name="line-1167"></a><span class='hs-comment'>-- 'msum' is just like 'asum', but specialised to 'MonadPlus'.</span>
<a name="line-1168"></a><span class='hs-comment'>--</span>
<a name="line-1169"></a><span class='hs-definition'>msum</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-conid'>MonadPlus</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-1170"></a><span class='hs-comment'>{-# INLINE msum #-}</span>
<a name="line-1171"></a><span class='hs-definition'>msum</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>asum</span>
<a name="line-1172"></a>
<a name="line-1173"></a><a name="concat"></a><span class='hs-comment'>-- | The concatenation of all the elements of a container of lists.</span>
<a name="line-1174"></a><span class='hs-comment'>--</span>
<a name="line-1175"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1176"></a><span class='hs-comment'>--</span>
<a name="line-1177"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1178"></a><span class='hs-comment'>--</span>
<a name="line-1179"></a><span class='hs-comment'>-- &gt;&gt;&gt; concat (Just [1, 2, 3])</span>
<a name="line-1180"></a><span class='hs-comment'>-- [1,2,3]</span>
<a name="line-1181"></a><span class='hs-comment'>--</span>
<a name="line-1182"></a><span class='hs-comment'>-- &gt;&gt;&gt; concat (Left 42)</span>
<a name="line-1183"></a><span class='hs-comment'>-- []</span>
<a name="line-1184"></a><span class='hs-comment'>--</span>
<a name="line-1185"></a><span class='hs-comment'>-- &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]</span>
<a name="line-1186"></a><span class='hs-comment'>-- [1,2,3,4,5,6]</span>
<a name="line-1187"></a><span class='hs-definition'>concat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-1188"></a><span class='hs-definition'>concat</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>build</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>c</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>c</span> <span class='hs-varid'>y</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>n</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
<a name="line-1189"></a><span class='hs-comment'>{-# INLINE concat #-}</span>
<a name="line-1190"></a>
<a name="line-1191"></a><a name="concatMap"></a><span class='hs-comment'>-- | Map a function over all the elements of a container and concatenate</span>
<a name="line-1192"></a><span class='hs-comment'>-- the resulting lists.</span>
<a name="line-1193"></a><span class='hs-comment'>--</span>
<a name="line-1194"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1195"></a><span class='hs-comment'>--</span>
<a name="line-1196"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1197"></a><span class='hs-comment'>--</span>
<a name="line-1198"></a><span class='hs-comment'>-- &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]</span>
<a name="line-1199"></a><span class='hs-comment'>-- [1,2,3,10,11,12,100,101,102,1000,1001,1002]</span>
<a name="line-1200"></a><span class='hs-comment'>--</span>
<a name="line-1201"></a><span class='hs-comment'>-- &gt;&gt;&gt; concatMap (take 3) (Just [1..])</span>
<a name="line-1202"></a><span class='hs-comment'>-- [1,2,3]</span>
<a name="line-1203"></a><span class='hs-definition'>concatMap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-1204"></a><span class='hs-definition'>concatMap</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>build</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>c</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>c</span> <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>n</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
<a name="line-1205"></a><span class='hs-comment'>{-# INLINE concatMap #-}</span>
<a name="line-1206"></a>
<a name="line-1207"></a><span class='hs-comment'>-- These use foldr rather than foldMap to avoid repeated concatenation.</span>
<a name="line-1208"></a>
<a name="line-1209"></a><a name="and"></a><span class='hs-comment'>-- | 'and' returns the conjunction of a container of Bools.  For the</span>
<a name="line-1210"></a><span class='hs-comment'>-- result to be 'True', the container must be finite; 'False', however,</span>
<a name="line-1211"></a><span class='hs-comment'>-- results from a 'False' value finitely far from the left end.</span>
<a name="line-1212"></a><span class='hs-comment'>--</span>
<a name="line-1213"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1214"></a><span class='hs-comment'>--</span>
<a name="line-1215"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1216"></a><span class='hs-comment'>--</span>
<a name="line-1217"></a><span class='hs-comment'>-- &gt;&gt;&gt; and []</span>
<a name="line-1218"></a><span class='hs-comment'>-- True</span>
<a name="line-1219"></a><span class='hs-comment'>--</span>
<a name="line-1220"></a><span class='hs-comment'>-- &gt;&gt;&gt; and [True]</span>
<a name="line-1221"></a><span class='hs-comment'>-- True</span>
<a name="line-1222"></a><span class='hs-comment'>--</span>
<a name="line-1223"></a><span class='hs-comment'>-- &gt;&gt;&gt; and [False]</span>
<a name="line-1224"></a><span class='hs-comment'>-- False</span>
<a name="line-1225"></a><span class='hs-comment'>--</span>
<a name="line-1226"></a><span class='hs-comment'>-- &gt;&gt;&gt; and [True, True, False]</span>
<a name="line-1227"></a><span class='hs-comment'>-- False</span>
<a name="line-1228"></a><span class='hs-comment'>--</span>
<a name="line-1229"></a><span class='hs-comment'>-- &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...</span>
<a name="line-1230"></a><span class='hs-comment'>-- False</span>
<a name="line-1231"></a><span class='hs-comment'>--</span>
<a name="line-1232"></a><span class='hs-comment'>-- &gt;&gt;&gt; and (repeat True)</span>
<a name="line-1233"></a><span class='hs-comment'>-- * Hangs forever *</span>
<a name="line-1234"></a><span class='hs-definition'>and</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1235"></a><span class='hs-definition'>and</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getAll</span> <span class='hs-cpp'>#.</span> <span class='hs-varid'>foldMap</span> <span class='hs-conid'>All</span>
<a name="line-1236"></a>
<a name="line-1237"></a><a name="or"></a><span class='hs-comment'>-- | 'or' returns the disjunction of a container of Bools.  For the</span>
<a name="line-1238"></a><span class='hs-comment'>-- result to be 'False', the container must be finite; 'True', however,</span>
<a name="line-1239"></a><span class='hs-comment'>-- results from a 'True' value finitely far from the left end.</span>
<a name="line-1240"></a><span class='hs-comment'>--</span>
<a name="line-1241"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1242"></a><span class='hs-comment'>--</span>
<a name="line-1243"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1244"></a><span class='hs-comment'>--</span>
<a name="line-1245"></a><span class='hs-comment'>-- &gt;&gt;&gt; or []</span>
<a name="line-1246"></a><span class='hs-comment'>-- False</span>
<a name="line-1247"></a><span class='hs-comment'>--</span>
<a name="line-1248"></a><span class='hs-comment'>-- &gt;&gt;&gt; or [True]</span>
<a name="line-1249"></a><span class='hs-comment'>-- True</span>
<a name="line-1250"></a><span class='hs-comment'>--</span>
<a name="line-1251"></a><span class='hs-comment'>-- &gt;&gt;&gt; or [False]</span>
<a name="line-1252"></a><span class='hs-comment'>-- False</span>
<a name="line-1253"></a><span class='hs-comment'>--</span>
<a name="line-1254"></a><span class='hs-comment'>-- &gt;&gt;&gt; or [True, True, False]</span>
<a name="line-1255"></a><span class='hs-comment'>-- True</span>
<a name="line-1256"></a><span class='hs-comment'>--</span>
<a name="line-1257"></a><span class='hs-comment'>-- &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...</span>
<a name="line-1258"></a><span class='hs-comment'>-- True</span>
<a name="line-1259"></a><span class='hs-comment'>--</span>
<a name="line-1260"></a><span class='hs-comment'>-- &gt;&gt;&gt; or (repeat False)</span>
<a name="line-1261"></a><span class='hs-comment'>-- * Hangs forever *</span>
<a name="line-1262"></a><span class='hs-definition'>or</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1263"></a><span class='hs-definition'>or</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getAny</span> <span class='hs-cpp'>#.</span> <span class='hs-varid'>foldMap</span> <span class='hs-conid'>Any</span>
<a name="line-1264"></a>
<a name="line-1265"></a><a name="any"></a><span class='hs-comment'>-- | Determines whether any element of the structure satisfies the predicate.</span>
<a name="line-1266"></a><span class='hs-comment'>--</span>
<a name="line-1267"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1268"></a><span class='hs-comment'>--</span>
<a name="line-1269"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1270"></a><span class='hs-comment'>--</span>
<a name="line-1271"></a><span class='hs-comment'>-- &gt;&gt;&gt; any (&gt; 3) []</span>
<a name="line-1272"></a><span class='hs-comment'>-- False</span>
<a name="line-1273"></a><span class='hs-comment'>--</span>
<a name="line-1274"></a><span class='hs-comment'>-- &gt;&gt;&gt; any (&gt; 3) [1,2]</span>
<a name="line-1275"></a><span class='hs-comment'>-- False</span>
<a name="line-1276"></a><span class='hs-comment'>--</span>
<a name="line-1277"></a><span class='hs-comment'>-- &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]</span>
<a name="line-1278"></a><span class='hs-comment'>-- True</span>
<a name="line-1279"></a><span class='hs-comment'>--</span>
<a name="line-1280"></a><span class='hs-comment'>-- &gt;&gt;&gt; any (&gt; 3) [1..]</span>
<a name="line-1281"></a><span class='hs-comment'>-- True</span>
<a name="line-1282"></a><span class='hs-comment'>--</span>
<a name="line-1283"></a><span class='hs-comment'>-- &gt;&gt;&gt; any (&gt; 3) [0, -1..]</span>
<a name="line-1284"></a><span class='hs-comment'>-- * Hangs forever *</span>
<a name="line-1285"></a><span class='hs-definition'>any</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1286"></a><span class='hs-definition'>any</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getAny</span> <span class='hs-cpp'>#.</span> <span class='hs-varid'>foldMap</span> <span class='hs-layout'>(</span><span class='hs-conid'>Any</span> <span class='hs-cpp'>#.</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-1287"></a>
<a name="line-1288"></a><a name="all"></a><span class='hs-comment'>-- | Determines whether all elements of the structure satisfy the predicate.</span>
<a name="line-1289"></a><span class='hs-comment'>--</span>
<a name="line-1290"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1291"></a><span class='hs-comment'>--</span>
<a name="line-1292"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1293"></a><span class='hs-comment'>--</span>
<a name="line-1294"></a><span class='hs-comment'>-- &gt;&gt;&gt; all (&gt; 3) []</span>
<a name="line-1295"></a><span class='hs-comment'>-- True</span>
<a name="line-1296"></a><span class='hs-comment'>--</span>
<a name="line-1297"></a><span class='hs-comment'>-- &gt;&gt;&gt; all (&gt; 3) [1,2]</span>
<a name="line-1298"></a><span class='hs-comment'>-- False</span>
<a name="line-1299"></a><span class='hs-comment'>--</span>
<a name="line-1300"></a><span class='hs-comment'>-- &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]</span>
<a name="line-1301"></a><span class='hs-comment'>-- False</span>
<a name="line-1302"></a><span class='hs-comment'>--</span>
<a name="line-1303"></a><span class='hs-comment'>-- &gt;&gt;&gt; all (&gt; 3) [1..]</span>
<a name="line-1304"></a><span class='hs-comment'>-- False</span>
<a name="line-1305"></a><span class='hs-comment'>--</span>
<a name="line-1306"></a><span class='hs-comment'>-- &gt;&gt;&gt; all (&gt; 3) [4..]</span>
<a name="line-1307"></a><span class='hs-comment'>-- * Hangs forever *</span>
<a name="line-1308"></a><span class='hs-definition'>all</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1309"></a><span class='hs-definition'>all</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getAll</span> <span class='hs-cpp'>#.</span> <span class='hs-varid'>foldMap</span> <span class='hs-layout'>(</span><span class='hs-conid'>All</span> <span class='hs-cpp'>#.</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-1310"></a>
<a name="line-1311"></a><span class='hs-comment'>-- | The largest element of a non-empty structure with respect to the</span>
<a name="line-1312"></a><span class='hs-comment'>-- given comparison function.</span>
<a name="line-1313"></a><span class='hs-comment'>--</span>
<a name="line-1314"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1315"></a><span class='hs-comment'>--</span>
<a name="line-1316"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1317"></a><span class='hs-comment'>--</span>
<a name="line-1318"></a><span class='hs-comment'>-- &gt;&gt;&gt; maximumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]</span>
<a name="line-1319"></a><span class='hs-comment'>-- "Longest"</span>
<a name="line-1320"></a><span class='hs-comment'>--</span>
<a name="line-1321"></a><span class='hs-comment'>-- WARNING: This function is partial for possibly-empty structures like lists.</span>
<a name="line-1322"></a>
<a name="line-1323"></a><a name="maximumBy"></a><span class='hs-comment'>-- See Note [maximumBy/minimumBy space usage]</span>
<a name="line-1324"></a><span class='hs-definition'>maximumBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1325"></a><span class='hs-definition'>maximumBy</span> <span class='hs-varid'>cmp</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fromMaybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>errorWithoutStackTrace</span> <span class='hs-str'>"maximumBy: empty structure"</span><span class='hs-layout'>)</span>
<a name="line-1326"></a>  <span class='hs-varop'>.</span> <span class='hs-varid'>foldl'</span> <span class='hs-varid'>max'</span> <span class='hs-conid'>Nothing</span>
<a name="line-1327"></a>  <span class='hs-keyword'>where</span>
<a name="line-1328"></a>    <span class='hs-varid'>max'</span> <span class='hs-varid'>mx</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varop'>$!</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mx</span> <span class='hs-keyword'>of</span>
<a name="line-1329"></a>      <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span>
<a name="line-1330"></a>      <span class='hs-conid'>Just</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>cmp</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>of</span>
<a name="line-1331"></a>        <span class='hs-conid'>GT</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span>
<a name="line-1332"></a>        <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span>
<a name="line-1333"></a><span class='hs-comment'>{-# INLINEABLE maximumBy #-}</span>
<a name="line-1334"></a>
<a name="line-1335"></a><span class='hs-comment'>-- | The least element of a non-empty structure with respect to the</span>
<a name="line-1336"></a><span class='hs-comment'>-- given comparison function.</span>
<a name="line-1337"></a><span class='hs-comment'>--</span>
<a name="line-1338"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1339"></a><span class='hs-comment'>--</span>
<a name="line-1340"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1341"></a><span class='hs-comment'>--</span>
<a name="line-1342"></a><span class='hs-comment'>-- &gt;&gt;&gt; minimumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]</span>
<a name="line-1343"></a><span class='hs-comment'>-- "!"</span>
<a name="line-1344"></a><span class='hs-comment'>--</span>
<a name="line-1345"></a><span class='hs-comment'>-- WARNING: This function is partial for possibly-empty structures like lists.</span>
<a name="line-1346"></a>
<a name="line-1347"></a><a name="minimumBy"></a><span class='hs-comment'>-- See Note [maximumBy/minimumBy space usage]</span>
<a name="line-1348"></a><span class='hs-definition'>minimumBy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1349"></a><span class='hs-definition'>minimumBy</span> <span class='hs-varid'>cmp</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fromMaybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>errorWithoutStackTrace</span> <span class='hs-str'>"minimumBy: empty structure"</span><span class='hs-layout'>)</span>
<a name="line-1350"></a>  <span class='hs-varop'>.</span> <span class='hs-varid'>foldl'</span> <span class='hs-varid'>min'</span> <span class='hs-conid'>Nothing</span>
<a name="line-1351"></a>  <span class='hs-keyword'>where</span>
<a name="line-1352"></a>    <span class='hs-varid'>min'</span> <span class='hs-varid'>mx</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varop'>$!</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mx</span> <span class='hs-keyword'>of</span>
<a name="line-1353"></a>      <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span>
<a name="line-1354"></a>      <span class='hs-conid'>Just</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>cmp</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>of</span>
<a name="line-1355"></a>        <span class='hs-conid'>GT</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span>
<a name="line-1356"></a>        <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span>
<a name="line-1357"></a><span class='hs-comment'>{-# INLINEABLE minimumBy #-}</span>
<a name="line-1358"></a>
<a name="line-1359"></a><a name="notElem"></a><span class='hs-comment'>-- | 'notElem' is the negation of 'elem'.</span>
<a name="line-1360"></a><span class='hs-comment'>--</span>
<a name="line-1361"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1362"></a><span class='hs-comment'>--</span>
<a name="line-1363"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1364"></a><span class='hs-comment'>--</span>
<a name="line-1365"></a><span class='hs-comment'>-- &gt;&gt;&gt; 3 `notElem` []</span>
<a name="line-1366"></a><span class='hs-comment'>-- True</span>
<a name="line-1367"></a><span class='hs-comment'>--</span>
<a name="line-1368"></a><span class='hs-comment'>-- &gt;&gt;&gt; 3 `notElem` [1,2]</span>
<a name="line-1369"></a><span class='hs-comment'>-- True</span>
<a name="line-1370"></a><span class='hs-comment'>--</span>
<a name="line-1371"></a><span class='hs-comment'>-- &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]</span>
<a name="line-1372"></a><span class='hs-comment'>-- False</span>
<a name="line-1373"></a><span class='hs-comment'>--</span>
<a name="line-1374"></a><span class='hs-comment'>-- For infinite structures, 'notElem' terminates if the value exists at a</span>
<a name="line-1375"></a><span class='hs-comment'>-- finite distance from the left side of the structure:</span>
<a name="line-1376"></a><span class='hs-comment'>--</span>
<a name="line-1377"></a><span class='hs-comment'>-- &gt;&gt;&gt; 3 `notElem` [1..]</span>
<a name="line-1378"></a><span class='hs-comment'>-- False</span>
<a name="line-1379"></a><span class='hs-comment'>--</span>
<a name="line-1380"></a><span class='hs-comment'>-- &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])</span>
<a name="line-1381"></a><span class='hs-comment'>-- * Hangs forever *</span>
<a name="line-1382"></a><span class='hs-definition'>notElem</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1383"></a><span class='hs-definition'>notElem</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>elem</span> <span class='hs-varid'>x</span>
<a name="line-1384"></a>
<a name="line-1385"></a><a name="find"></a><span class='hs-comment'>-- | The 'find' function takes a predicate and a structure and returns</span>
<a name="line-1386"></a><span class='hs-comment'>-- the leftmost element of the structure matching the predicate, or</span>
<a name="line-1387"></a><span class='hs-comment'>-- 'Nothing' if there is no such element.</span>
<a name="line-1388"></a><span class='hs-comment'>--</span>
<a name="line-1389"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-1390"></a><span class='hs-comment'>--</span>
<a name="line-1391"></a><span class='hs-comment'>-- Basic usage:</span>
<a name="line-1392"></a><span class='hs-comment'>--</span>
<a name="line-1393"></a><span class='hs-comment'>-- &gt;&gt;&gt; find (&gt; 42) [0, 5..]</span>
<a name="line-1394"></a><span class='hs-comment'>-- Just 45</span>
<a name="line-1395"></a><span class='hs-comment'>--</span>
<a name="line-1396"></a><span class='hs-comment'>-- &gt;&gt;&gt; find (&gt; 12) [1..7]</span>
<a name="line-1397"></a><span class='hs-comment'>-- Nothing</span>
<a name="line-1398"></a><span class='hs-definition'>find</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Foldable</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span>
<a name="line-1399"></a><span class='hs-definition'>find</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getFirst</span> <span class='hs-varop'>.</span> <span class='hs-varid'>foldMap</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>First</span> <span class='hs-layout'>(</span><span class='hs-keyword'>if</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>then</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>else</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1400"></a>
<a name="line-1401"></a><span class='hs-comment'>{-
<a name="line-1402"></a>Note [List fusion and continuations in 'c']
<a name="line-1403"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1404"></a>Suppose we define
<a name="line-1405"></a>  mapM_ f = foldr ((&gt;&gt;) . f) (return ())
<a name="line-1406"></a>(this is the way it used to be).
<a name="line-1407"></a>
<a name="line-1408"></a>Now suppose we want to optimise the call
<a name="line-1409"></a>
<a name="line-1410"></a>  mapM_ &lt;big&gt; (build g)
<a name="line-1411"></a>    where
<a name="line-1412"></a>  g c n = ...(c x1 y1)...(c x2 y2)....n...
<a name="line-1413"></a>
<a name="line-1414"></a>GHC used to proceed like this:
<a name="line-1415"></a>
<a name="line-1416"></a>  mapM_ &lt;big&gt; (build g)
<a name="line-1417"></a>
<a name="line-1418"></a>  = { Definition of mapM_ }
<a name="line-1419"></a>    foldr ((&gt;&gt;) . &lt;big&gt;) (return ()) (build g)
<a name="line-1420"></a>
<a name="line-1421"></a>  = { foldr/build rule }
<a name="line-1422"></a>    g ((&gt;&gt;) . &lt;big&gt;) (return ())
<a name="line-1423"></a>
<a name="line-1424"></a>  = { Inline g }
<a name="line-1425"></a>    let c = (&gt;&gt;) . &lt;big&gt;
<a name="line-1426"></a>        n = return ()
<a name="line-1427"></a>    in ...(c x1 y1)...(c x2 y2)....n...
<a name="line-1428"></a>
<a name="line-1429"></a>The trouble is that `c`, being big, will not be inlined.  And that can
<a name="line-1430"></a>be absolutely terrible for performance, as we saw in #8763.
<a name="line-1431"></a>
<a name="line-1432"></a>It's much better to define
<a name="line-1433"></a>
<a name="line-1434"></a>  mapM_ f = foldr c (return ())
<a name="line-1435"></a>    where
<a name="line-1436"></a>      c x k = f x &gt;&gt; k
<a name="line-1437"></a>      {-# INLINE c #-}
<a name="line-1438"></a>
<a name="line-1439"></a>Now we get
<a name="line-1440"></a>  mapM_ &lt;big&gt; (build g)
<a name="line-1441"></a>
<a name="line-1442"></a>  = { inline mapM_ }
<a name="line-1443"></a>    foldr c (return ()) (build g)
<a name="line-1444"></a>      where c x k = f x &gt;&gt; k
<a name="line-1445"></a>            {-# INLINE c #-}
<a name="line-1446"></a>            f = &lt;big&gt;
<a name="line-1447"></a>
<a name="line-1448"></a>Notice that `f` does not inline into the RHS of `c`,
<a name="line-1449"></a>because the INLINE pragma stops it; see
<a name="line-1450"></a>Note [Simplifying inside stable unfoldings] in GHC.Core.Opt.Simplify.Utils.
<a name="line-1451"></a>Continuing:
<a name="line-1452"></a>
<a name="line-1453"></a>  = { foldr/build rule }
<a name="line-1454"></a>    g c (return ())
<a name="line-1455"></a>      where ...
<a name="line-1456"></a>         c x k = f x &gt;&gt; k
<a name="line-1457"></a>         {-# INLINE c #-}
<a name="line-1458"></a>            f = &lt;big&gt;
<a name="line-1459"></a>
<a name="line-1460"></a>  = { inline g }
<a name="line-1461"></a>    ...(c x1 y1)...(c x2 y2)....n...
<a name="line-1462"></a>      where c x k = f x &gt;&gt; k
<a name="line-1463"></a>            {-# INLINE c #-}
<a name="line-1464"></a>            f = &lt;big&gt;
<a name="line-1465"></a>            n = return ()
<a name="line-1466"></a>
<a name="line-1467"></a>      Now, crucially, `c` does inline
<a name="line-1468"></a>
<a name="line-1469"></a>  = { inline c }
<a name="line-1470"></a>    ...(f x1 &gt;&gt; y1)...(f x2 &gt;&gt; y2)....n...
<a name="line-1471"></a>      where f = &lt;big&gt;
<a name="line-1472"></a>            n = return ()
<a name="line-1473"></a>
<a name="line-1474"></a>And all is well!  The key thing is that the fragment
<a name="line-1475"></a>`(f x1 &gt;&gt; y1)` is inlined into the body of the builder
<a name="line-1476"></a>`g`.
<a name="line-1477"></a>-}</span>
<a name="line-1478"></a>
<a name="line-1479"></a><span class='hs-comment'>{-
<a name="line-1480"></a>Note [maximumBy/minimumBy space usage]
<a name="line-1481"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1482"></a>When the type signatures of maximumBy and minimumBy were generalized to work
<a name="line-1483"></a>over any Foldable instance (instead of just lists), they were defined using
<a name="line-1484"></a>foldr1.  This was problematic for space usage, as the semantics of maximumBy
<a name="line-1485"></a>and minimumBy essentially require that they examine every element of the
<a name="line-1486"></a>data structure.  Using foldr1 to examine every element results in space usage
<a name="line-1487"></a>proportional to the size of the data structure.  For the common case of lists,
<a name="line-1488"></a>this could be particularly bad (see #10830).
<a name="line-1489"></a>
<a name="line-1490"></a>For the common case of lists, switching the implementations of maximumBy and
<a name="line-1491"></a>minimumBy to foldl1 solves the issue, assuming GHC's strictness analysis can then
<a name="line-1492"></a>make these functions only use O(1) stack space.  As of base 4.16, we have
<a name="line-1493"></a>switched to employing foldl' over foldl1, not relying on GHC's optimiser.  See
<a name="line-1494"></a>https://gitlab.haskell.org/ghc/ghc/-/issues/17867 for more context.
<a name="line-1495"></a>-}</span>
<a name="line-1496"></a>
<a name="line-1497"></a><span class='hs-comment'>--------------</span>
<a name="line-1498"></a>
<a name="line-1499"></a><span class='hs-comment'>-- $overview</span>
<a name="line-1500"></a><span class='hs-comment'>--</span>
<a name="line-1501"></a><span class='hs-comment'>-- #overview#</span>
<a name="line-1502"></a><span class='hs-comment'>-- The Foldable class generalises some common "Data.List" functions to</span>
<a name="line-1503"></a><span class='hs-comment'>-- structures that can be reduced to a summary value one element at a time.</span>
<a name="line-1504"></a><span class='hs-comment'>--</span>
<a name="line-1505"></a><span class='hs-comment'>-- == Left and right folds</span>
<a name="line-1506"></a><span class='hs-comment'>--</span>
<a name="line-1507"></a><span class='hs-comment'>-- #leftright#</span>
<a name="line-1508"></a><span class='hs-comment'>-- The contribution of each element to the final result is combined with an</span>
<a name="line-1509"></a><span class='hs-comment'>-- accumulator via a suitable /operator/.  The operator may be explicitly</span>
<a name="line-1510"></a><span class='hs-comment'>-- provided by the caller as with `foldr` or may be implicit as in `length`.</span>
<a name="line-1511"></a><span class='hs-comment'>-- In the case of `foldMap`, the caller provides a function mapping each</span>
<a name="line-1512"></a><span class='hs-comment'>-- element into a suitable 'Monoid', which makes it possible to merge the</span>
<a name="line-1513"></a><span class='hs-comment'>-- per-element contributions via that monoid's `mappend` function.</span>
<a name="line-1514"></a><span class='hs-comment'>--</span>
<a name="line-1515"></a><span class='hs-comment'>-- A key distinction is between left-associative and right-associative</span>
<a name="line-1516"></a><span class='hs-comment'>-- folds:</span>
<a name="line-1517"></a><span class='hs-comment'>--</span>
<a name="line-1518"></a><span class='hs-comment'>-- * In left-associative folds the accumulator is a partial fold over the</span>
<a name="line-1519"></a><span class='hs-comment'>--   elements that __precede__ the current element, and is passed to the</span>
<a name="line-1520"></a><span class='hs-comment'>--   operator as its first (left) argument.  The outermost application of the</span>
<a name="line-1521"></a><span class='hs-comment'>--   operator merges the contribution of the last element of the structure with</span>
<a name="line-1522"></a><span class='hs-comment'>--   the contributions of all its predecessors.</span>
<a name="line-1523"></a><span class='hs-comment'>--</span>
<a name="line-1524"></a><span class='hs-comment'>-- * In right-associative folds the accumulator is a partial fold over the</span>
<a name="line-1525"></a><span class='hs-comment'>--   elements that __follow__ the current element, and is passed to the</span>
<a name="line-1526"></a><span class='hs-comment'>--   operator as its second (right) argument.  The outermost application of</span>
<a name="line-1527"></a><span class='hs-comment'>--   the operator merges the contribution of the first element of the structure</span>
<a name="line-1528"></a><span class='hs-comment'>--   with the contributions of all its successors.</span>
<a name="line-1529"></a><span class='hs-comment'>--</span>
<a name="line-1530"></a><span class='hs-comment'>-- These two types of folds are typified by the left-associative strict</span>
<a name="line-1531"></a><span class='hs-comment'>-- 'foldl'' and the right-associative lazy `foldr`.</span>
<a name="line-1532"></a><span class='hs-comment'>--</span>
<a name="line-1533"></a><span class='hs-comment'>-- @</span>
<a name="line-1534"></a><span class='hs-comment'>-- 'foldl'' :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</span>
<a name="line-1535"></a><span class='hs-comment'>-- `foldr`  :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span>
<a name="line-1536"></a><span class='hs-comment'>-- @</span>
<a name="line-1537"></a><span class='hs-comment'>--</span>
<a name="line-1538"></a><span class='hs-comment'>-- Example usage:</span>
<a name="line-1539"></a><span class='hs-comment'>--</span>
<a name="line-1540"></a><span class='hs-comment'>-- &gt;&gt;&gt; foldl' (+) 0 [1..100]</span>
<a name="line-1541"></a><span class='hs-comment'>-- 5050</span>
<a name="line-1542"></a><span class='hs-comment'>-- &gt;&gt;&gt; foldr (&amp;&amp;) True (repeat False)</span>
<a name="line-1543"></a><span class='hs-comment'>-- False</span>
<a name="line-1544"></a><span class='hs-comment'>--</span>
<a name="line-1545"></a><span class='hs-comment'>-- The first argument of both is an explicit /operator/ that merges the</span>
<a name="line-1546"></a><span class='hs-comment'>-- contribution of an element of the structure with a partial fold over,</span>
<a name="line-1547"></a><span class='hs-comment'>-- respectively, either the preceding or following elements of the structure.</span>
<a name="line-1548"></a><span class='hs-comment'>--</span>
<a name="line-1549"></a><span class='hs-comment'>-- The second argument of both is an initial accumulator value @z@ of type</span>
<a name="line-1550"></a><span class='hs-comment'>-- @b@.  This is the result of the fold when the structure is empty.</span>
<a name="line-1551"></a><span class='hs-comment'>-- When the structure is non-empty, this is the accumulator value merged with</span>
<a name="line-1552"></a><span class='hs-comment'>-- the first element in left-associative folds, or with the last element in</span>
<a name="line-1553"></a><span class='hs-comment'>-- right-associative folds.</span>
<a name="line-1554"></a><span class='hs-comment'>--</span>
<a name="line-1555"></a><span class='hs-comment'>-- The third and final argument is a @Foldable@ structure containing elements</span>
<a name="line-1556"></a><span class='hs-comment'>-- @(a, b, c, &amp;#x2026;)@.</span>
<a name="line-1557"></a><span class='hs-comment'>--</span>
<a name="line-1558"></a><span class='hs-comment'>-- * __'foldl''__ takes an operator argument of the form:</span>
<a name="line-1559"></a><span class='hs-comment'>--</span>
<a name="line-1560"></a><span class='hs-comment'>--     @</span>
<a name="line-1561"></a><span class='hs-comment'>--     f :: b -- accumulated fold of the initial elements</span>
<a name="line-1562"></a><span class='hs-comment'>--       -&gt; a -- current element</span>
<a name="line-1563"></a><span class='hs-comment'>--       -&gt; b -- updated fold, inclusive of current element</span>
<a name="line-1564"></a><span class='hs-comment'>--     @</span>
<a name="line-1565"></a><span class='hs-comment'>--</span>
<a name="line-1566"></a><span class='hs-comment'>--     If the structure's last element is @y@, the result of the fold is:</span>
<a name="line-1567"></a><span class='hs-comment'>--</span>
<a name="line-1568"></a><span class='hs-comment'>--     @</span>
<a name="line-1569"></a><span class='hs-comment'>--     g y . &amp;#x2026; . g c . g b . g a $ z</span>
<a name="line-1570"></a><span class='hs-comment'>--       where g element !acc = f acc element</span>
<a name="line-1571"></a><span class='hs-comment'>--     @</span>
<a name="line-1572"></a><span class='hs-comment'>--</span>
<a name="line-1573"></a><span class='hs-comment'>--     Since 'foldl'' is strict in the accumulator, this is always</span>
<a name="line-1574"></a><span class='hs-comment'>--     a [strict](#strict) reduction with no opportunity for early return or</span>
<a name="line-1575"></a><span class='hs-comment'>--     intermediate results.  The structure must be finite, since no result is</span>
<a name="line-1576"></a><span class='hs-comment'>--     returned until the last element is processed.  The advantage of</span>
<a name="line-1577"></a><span class='hs-comment'>--     strictness is space efficiency: the final result can be computed without</span>
<a name="line-1578"></a><span class='hs-comment'>--     storing a potentially deep stack of lazy intermediate results.</span>
<a name="line-1579"></a><span class='hs-comment'>--</span>
<a name="line-1580"></a><span class='hs-comment'>-- * __`foldr`__ takes an operator argument of the form:</span>
<a name="line-1581"></a><span class='hs-comment'>--</span>
<a name="line-1582"></a><span class='hs-comment'>--     @</span>
<a name="line-1583"></a><span class='hs-comment'>--     f :: a -- current element</span>
<a name="line-1584"></a><span class='hs-comment'>--       -&gt; b -- accumulated fold of the remaining elements</span>
<a name="line-1585"></a><span class='hs-comment'>--       -&gt; b -- updated fold, inclusive of current element</span>
<a name="line-1586"></a><span class='hs-comment'>--     @</span>
<a name="line-1587"></a><span class='hs-comment'>--</span>
<a name="line-1588"></a><span class='hs-comment'>--     the result of the fold is:</span>
<a name="line-1589"></a><span class='hs-comment'>--</span>
<a name="line-1590"></a><span class='hs-comment'>--     @f a . f b . f c . &amp;#x2026; $ z@</span>
<a name="line-1591"></a><span class='hs-comment'>--</span>
<a name="line-1592"></a><span class='hs-comment'>--     If each call of @f@ on the current element @e@, (referenced as @(f e)@</span>
<a name="line-1593"></a><span class='hs-comment'>--     below) returns a structure in which its second argument is captured in a</span>
<a name="line-1594"></a><span class='hs-comment'>--     lazily-evaluated component, then the fold of the remaining elements is</span>
<a name="line-1595"></a><span class='hs-comment'>--     available to the caller of `foldr` as a pending computation (thunk) that</span>
<a name="line-1596"></a><span class='hs-comment'>--     is computed only when that component is evaluated.</span>
<a name="line-1597"></a><span class='hs-comment'>--</span>
<a name="line-1598"></a><span class='hs-comment'>--     Alternatively, if any of the @(f e)@ ignore their second argument, the</span>
<a name="line-1599"></a><span class='hs-comment'>--     fold stops there, with the remaining elements unused.  As a result,</span>
<a name="line-1600"></a><span class='hs-comment'>--     `foldr` is well suited to define both [corecursive](#corec)</span>
<a name="line-1601"></a><span class='hs-comment'>--     and [short-circuit](#short) reductions.</span>
<a name="line-1602"></a><span class='hs-comment'>--</span>
<a name="line-1603"></a><span class='hs-comment'>--     When the operator is always strict in its second argument, 'foldl'' is</span>
<a name="line-1604"></a><span class='hs-comment'>--     generally a better choice than `foldr`.  When `foldr` is called with a</span>
<a name="line-1605"></a><span class='hs-comment'>--     strict operator, evaluation cannot begin until the last element is</span>
<a name="line-1606"></a><span class='hs-comment'>--     reached, by which point a deep stack of pending function applications</span>
<a name="line-1607"></a><span class='hs-comment'>--     may have been built up in memory.</span>
<a name="line-1608"></a><span class='hs-comment'>--</span>
<a name="line-1609"></a>
<a name="line-1610"></a><span class='hs-comment'>-- $chirality</span>
<a name="line-1611"></a><span class='hs-comment'>--</span>
<a name="line-1612"></a><span class='hs-comment'>-- #chirality#</span>
<a name="line-1613"></a><span class='hs-comment'>-- Foldable structures are generally expected to be efficiently iterable from</span>
<a name="line-1614"></a><span class='hs-comment'>-- left to right. Right-to-left iteration may be substantially more costly, or</span>
<a name="line-1615"></a><span class='hs-comment'>-- even impossible (as with, for example, infinite lists).  The text in the</span>
<a name="line-1616"></a><span class='hs-comment'>-- sections that follow that suggests performance differences between</span>
<a name="line-1617"></a><span class='hs-comment'>-- left-associative and right-associative folds assumes /left-handed/</span>
<a name="line-1618"></a><span class='hs-comment'>-- structures in which left-to-right iteration is cheaper than right-to-left</span>
<a name="line-1619"></a><span class='hs-comment'>-- iteration.</span>
<a name="line-1620"></a><span class='hs-comment'>--</span>
<a name="line-1621"></a><span class='hs-comment'>-- In finite structures for which right-to-left sequencing no less efficient</span>
<a name="line-1622"></a><span class='hs-comment'>-- than left-to-right sequencing, there is no inherent performance distinction</span>
<a name="line-1623"></a><span class='hs-comment'>-- between left-associative and right-associative folds.  If the structure's</span>
<a name="line-1624"></a><span class='hs-comment'>-- @Foldable@ instance takes advantage of this symmetry to also make strict</span>
<a name="line-1625"></a><span class='hs-comment'>-- right folds space-efficient and lazy left folds corecursive, one need only</span>
<a name="line-1626"></a><span class='hs-comment'>-- take care to choose either a strict or lazy method for the task at hand.</span>
<a name="line-1627"></a><span class='hs-comment'>--</span>
<a name="line-1628"></a><span class='hs-comment'>-- Foldable instances for symmetric structures should strive to provide equally</span>
<a name="line-1629"></a><span class='hs-comment'>-- performant left-associative and right-associative interfaces. The main</span>
<a name="line-1630"></a><span class='hs-comment'>-- limitations are:</span>
<a name="line-1631"></a><span class='hs-comment'>--</span>
<a name="line-1632"></a><span class='hs-comment'>-- * The lazy 'fold', 'foldMap' and 'toList' methods have no right-associative</span>
<a name="line-1633"></a><span class='hs-comment'>--   counterparts.</span>
<a name="line-1634"></a><span class='hs-comment'>-- * The strict 'foldMap'' method has no left-associative counterpart.</span>
<a name="line-1635"></a><span class='hs-comment'>--</span>
<a name="line-1636"></a><span class='hs-comment'>-- Thus, for some foldable structures 'foldr'' is just as efficient as 'foldl''</span>
<a name="line-1637"></a><span class='hs-comment'>-- for strict reduction, and 'foldl' may be just as appropriate for corecursive</span>
<a name="line-1638"></a><span class='hs-comment'>-- folds as 'foldr'.</span>
<a name="line-1639"></a><span class='hs-comment'>--</span>
<a name="line-1640"></a><span class='hs-comment'>-- Finally, in some less common structures (e.g. /snoc/ lists) right to left</span>
<a name="line-1641"></a><span class='hs-comment'>-- iterations are cheaper than left to right.  Such structures are poor</span>
<a name="line-1642"></a><span class='hs-comment'>-- candidates for a @Foldable@ instance, and are perhaps best handled via their</span>
<a name="line-1643"></a><span class='hs-comment'>-- type-specific interfaces.  If nevertheless a @Foldable@ instance is</span>
<a name="line-1644"></a><span class='hs-comment'>-- provided, the material in the sections that follow applies to these also, by</span>
<a name="line-1645"></a><span class='hs-comment'>-- replacing each method with one with the opposite associativity (when</span>
<a name="line-1646"></a><span class='hs-comment'>-- available) and switching the order of arguments in the fold's /operator/.</span>
<a name="line-1647"></a><span class='hs-comment'>--</span>
<a name="line-1648"></a><span class='hs-comment'>-- You may need to pay careful attention to strictness of the fold's /operator/</span>
<a name="line-1649"></a><span class='hs-comment'>-- when its strictness is different between its first and second argument.</span>
<a name="line-1650"></a><span class='hs-comment'>-- For example, while @('+')@ is expected to be commutative and strict in both</span>
<a name="line-1651"></a><span class='hs-comment'>-- arguments, the list concatenation operator @('++')@ is not commutative and</span>
<a name="line-1652"></a><span class='hs-comment'>-- is only strict in the initial constructor of its first argument.  The fold:</span>
<a name="line-1653"></a><span class='hs-comment'>--</span>
<a name="line-1654"></a><span class='hs-comment'>-- &gt; myconcat xs = foldr (\a b -&gt; a ++ b) [] xs</span>
<a name="line-1655"></a><span class='hs-comment'>--</span>
<a name="line-1656"></a><span class='hs-comment'>-- is substantially cheaper (linear in the length of the consumed portion of</span>
<a name="line-1657"></a><span class='hs-comment'>-- the final list, thus e.g. constant time/space for just the first element)</span>
<a name="line-1658"></a><span class='hs-comment'>-- than:</span>
<a name="line-1659"></a><span class='hs-comment'>--</span>
<a name="line-1660"></a><span class='hs-comment'>-- &gt; revconcat xs = foldr (\a b -&gt; b ++ a) [] xs</span>
<a name="line-1661"></a><span class='hs-comment'>--</span>
<a name="line-1662"></a><span class='hs-comment'>-- In which the total cost scales up with both the number of lists combined and</span>
<a name="line-1663"></a><span class='hs-comment'>-- the number of elements ultimately consumed.  A more efficient way to combine</span>
<a name="line-1664"></a><span class='hs-comment'>-- lists in reverse order, is to use:</span>
<a name="line-1665"></a><span class='hs-comment'>--</span>
<a name="line-1666"></a><span class='hs-comment'>-- &gt; revconcat = foldr (++) [] . reverse</span>
<a name="line-1667"></a>
<a name="line-1668"></a><span class='hs-comment'>--------------</span>
<a name="line-1669"></a>
<a name="line-1670"></a><span class='hs-comment'>-- $reduction</span>
<a name="line-1671"></a><span class='hs-comment'>--</span>
<a name="line-1672"></a><span class='hs-comment'>-- As observed in the [above description](#leftright) of left and right folds,</span>
<a name="line-1673"></a><span class='hs-comment'>-- there are three general ways in which a structure can be reduced to a</span>
<a name="line-1674"></a><span class='hs-comment'>-- summary value:</span>
<a name="line-1675"></a><span class='hs-comment'>--</span>
<a name="line-1676"></a><span class='hs-comment'>-- * __Recursive__ reduction, which is strict in all the elements of the</span>
<a name="line-1677"></a><span class='hs-comment'>--   structure.  This produces a single final result only after processing the</span>
<a name="line-1678"></a><span class='hs-comment'>--   entire input structure, and so the input must be finite.</span>
<a name="line-1679"></a><span class='hs-comment'>--</span>
<a name="line-1680"></a><span class='hs-comment'>-- * __Corecursion__, which yields intermediate results as it encounters</span>
<a name="line-1681"></a><span class='hs-comment'>--   additional input elements.  Lazy processing of the remaining elements</span>
<a name="line-1682"></a><span class='hs-comment'>--   makes the intermediate results available even before the rest of the</span>
<a name="line-1683"></a><span class='hs-comment'>--   input is processed.  The input may be unbounded, and the caller can</span>
<a name="line-1684"></a><span class='hs-comment'>--   stop processing intermediate results early.</span>
<a name="line-1685"></a><span class='hs-comment'>--</span>
<a name="line-1686"></a><span class='hs-comment'>-- * __Short-circuit__ reduction, which examines some initial sequence of the</span>
<a name="line-1687"></a><span class='hs-comment'>--   input elements, but stops once a termination condition is met, returning a</span>
<a name="line-1688"></a><span class='hs-comment'>--   final result based only on the elements considered up to that point.  The</span>
<a name="line-1689"></a><span class='hs-comment'>--   remaining elements are not considered.  The input should generally be</span>
<a name="line-1690"></a><span class='hs-comment'>--   finite, because the termination condition might otherwise never be met.</span>
<a name="line-1691"></a><span class='hs-comment'>--</span>
<a name="line-1692"></a><span class='hs-comment'>-- Whether a fold is recursive, corecursive or short-circuiting can depend on</span>
<a name="line-1693"></a><span class='hs-comment'>-- both the method chosen to perform the fold and on the operator passed to</span>
<a name="line-1694"></a><span class='hs-comment'>-- that method (which may be implicit, as with the `mappend` method of a monoid</span>
<a name="line-1695"></a><span class='hs-comment'>-- instance).</span>
<a name="line-1696"></a><span class='hs-comment'>--</span>
<a name="line-1697"></a><span class='hs-comment'>-- There are also hybrid cases, where the method and/or operator are not well</span>
<a name="line-1698"></a><span class='hs-comment'>-- suited to the task at hand, resulting in a fold that fails to yield</span>
<a name="line-1699"></a><span class='hs-comment'>-- incremental results until the entire input is processed, or fails to</span>
<a name="line-1700"></a><span class='hs-comment'>-- strictly evaluate results as it goes, deferring all the work to the</span>
<a name="line-1701"></a><span class='hs-comment'>-- evaluation of a large final thunk.  Such cases should be avoided, either by</span>
<a name="line-1702"></a><span class='hs-comment'>-- selecting a more appropriate @Foldable@ method, or by tailoring the operator</span>
<a name="line-1703"></a><span class='hs-comment'>-- to the chosen method.</span>
<a name="line-1704"></a><span class='hs-comment'>--</span>
<a name="line-1705"></a><span class='hs-comment'>-- The distinction between these types of folds is critical, both in deciding</span>
<a name="line-1706"></a><span class='hs-comment'>-- which @Foldable@ method to use to perform the reduction efficiently, and in</span>
<a name="line-1707"></a><span class='hs-comment'>-- writing @Foldable@ instances for new structures.  Below is a more detailed</span>
<a name="line-1708"></a><span class='hs-comment'>-- overview of each type.</span>
<a name="line-1709"></a>
<a name="line-1710"></a><span class='hs-comment'>--------------</span>
<a name="line-1711"></a>
<a name="line-1712"></a><span class='hs-comment'>-- $strict</span>
<a name="line-1713"></a><span class='hs-comment'>-- #strict#</span>
<a name="line-1714"></a><span class='hs-comment'>--</span>
<a name="line-1715"></a><span class='hs-comment'>-- Common examples of strict recursive reduction are the various /aggregate/</span>
<a name="line-1716"></a><span class='hs-comment'>-- functions, like 'sum', 'product', 'length', as well as more complex</span>
<a name="line-1717"></a><span class='hs-comment'>-- summaries such as frequency counts.  These functions return only a single</span>
<a name="line-1718"></a><span class='hs-comment'>-- value after processing the entire input structure.  In such cases, lazy</span>
<a name="line-1719"></a><span class='hs-comment'>-- processing of the tail of the input structure is generally not only</span>
<a name="line-1720"></a><span class='hs-comment'>-- unnecessary, but also inefficient.  Thus, these and similar folds should be</span>
<a name="line-1721"></a><span class='hs-comment'>-- implemented in terms of strict left-associative @Foldable@ methods (typically</span>
<a name="line-1722"></a><span class='hs-comment'>-- 'foldl'') to perform an efficient reduction in constant space.</span>
<a name="line-1723"></a><span class='hs-comment'>--</span>
<a name="line-1724"></a><span class='hs-comment'>-- Conversely, an implementation of @Foldable@ for a new structure should</span>
<a name="line-1725"></a><span class='hs-comment'>-- ensure that 'foldl'' actually performs a strict left-associative reduction.</span>
<a name="line-1726"></a><span class='hs-comment'>--</span>
<a name="line-1727"></a><span class='hs-comment'>-- The 'foldMap'' method is a special case of 'foldl'', in which the initial</span>
<a name="line-1728"></a><span class='hs-comment'>-- accumulator is `mempty` and the operator is @mappend . f@, where @f@ maps</span>
<a name="line-1729"></a><span class='hs-comment'>-- each input element into the 'Monoid' in question.  Therefore, 'foldMap'' is</span>
<a name="line-1730"></a><span class='hs-comment'>-- an appropriate choice under essentially the same conditions as 'foldl'', and</span>
<a name="line-1731"></a><span class='hs-comment'>-- its implementation for a given @Foldable@ structure should also be a strict</span>
<a name="line-1732"></a><span class='hs-comment'>-- left-associative reduction.</span>
<a name="line-1733"></a><span class='hs-comment'>--</span>
<a name="line-1734"></a><span class='hs-comment'>-- While the examples below are not necessarily the most optimal definitions of</span>
<a name="line-1735"></a><span class='hs-comment'>-- the intended functions, they are all cases in which 'foldMap'' is far more</span>
<a name="line-1736"></a><span class='hs-comment'>-- appropriate (as well as more efficient) than the lazy `foldMap`.</span>
<a name="line-1737"></a><span class='hs-comment'>--</span>
<a name="line-1738"></a><span class='hs-comment'>-- &gt; length  = getSum     . foldMap' (const (Sum 1))</span>
<a name="line-1739"></a><span class='hs-comment'>-- &gt; sum     = getSum     . foldMap' Sum</span>
<a name="line-1740"></a><span class='hs-comment'>-- &gt; product = getProduct . foldMap' Product</span>
<a name="line-1741"></a><span class='hs-comment'>--</span>
<a name="line-1742"></a><span class='hs-comment'>-- [ The actual default definitions employ coercions to optimise out</span>
<a name="line-1743"></a><span class='hs-comment'>--   'getSum' and 'getProduct'. ]</span>
<a name="line-1744"></a>
<a name="line-1745"></a><span class='hs-comment'>--------------</span>
<a name="line-1746"></a>
<a name="line-1747"></a><span class='hs-comment'>-- $strictlist</span>
<a name="line-1748"></a><span class='hs-comment'>--</span>
<a name="line-1749"></a><span class='hs-comment'>-- The full list of strict recursive functions in this module is:</span>
<a name="line-1750"></a><span class='hs-comment'>--</span>
<a name="line-1751"></a><span class='hs-comment'>-- * Provided the operator is strict in its left argument:</span>
<a name="line-1752"></a><span class='hs-comment'>--</span>
<a name="line-1753"></a><span class='hs-comment'>--     @'foldl'' :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b@</span>
<a name="line-1754"></a><span class='hs-comment'>--</span>
<a name="line-1755"></a><span class='hs-comment'>-- * Provided `mappend` is strict in its left argument:</span>
<a name="line-1756"></a><span class='hs-comment'>--</span>
<a name="line-1757"></a><span class='hs-comment'>--     @'foldMap'' :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m@</span>
<a name="line-1758"></a><span class='hs-comment'>--</span>
<a name="line-1759"></a><span class='hs-comment'>-- * Provided the instance is correctly defined:</span>
<a name="line-1760"></a><span class='hs-comment'>--</span>
<a name="line-1761"></a><span class='hs-comment'>--     @</span>
<a name="line-1762"></a><span class='hs-comment'>--     `length`    :: Foldable t =&gt; t a -&gt; Int</span>
<a name="line-1763"></a><span class='hs-comment'>--     `sum`       :: (Foldable t, Num a) =&gt; t a -&gt; a</span>
<a name="line-1764"></a><span class='hs-comment'>--     `product`   :: (Foldable t, Num a) =&gt; t a -&gt; a</span>
<a name="line-1765"></a><span class='hs-comment'>--     `maximum`   :: (Foldable t, Ord a) =&gt; t a -&gt; a</span>
<a name="line-1766"></a><span class='hs-comment'>--     `minimum`   :: (Foldable t, Ord a) =&gt; t a -&gt; a</span>
<a name="line-1767"></a><span class='hs-comment'>--     `maximumBy` :: Foldable t =&gt; (a -&gt; a -&gt; Ordering) -&gt; t a -&gt; a</span>
<a name="line-1768"></a><span class='hs-comment'>--     `minimumBy` :: Foldable t =&gt; (a -&gt; a -&gt; Ordering) -&gt; t a -&gt; a</span>
<a name="line-1769"></a><span class='hs-comment'>--     @</span>
<a name="line-1770"></a>
<a name="line-1771"></a><span class='hs-comment'>--------------</span>
<a name="line-1772"></a>
<a name="line-1773"></a><span class='hs-comment'>-- $lazy</span>
<a name="line-1774"></a><span class='hs-comment'>--</span>
<a name="line-1775"></a><span class='hs-comment'>-- #corec#</span>
<a name="line-1776"></a><span class='hs-comment'>-- Common examples of lazy corecursive reduction are functions that map and</span>
<a name="line-1777"></a><span class='hs-comment'>-- flatten a structure to a lazy stream of result values, i.e.  an iterator</span>
<a name="line-1778"></a><span class='hs-comment'>-- over the transformed input elements.  In such cases, it is important to</span>
<a name="line-1779"></a><span class='hs-comment'>-- choose a @Foldable@ method that is lazy in the tail of the structure, such</span>
<a name="line-1780"></a><span class='hs-comment'>-- as `foldr` (or `foldMap`, if the result @Monoid@ has a lazy `mappend` as</span>
<a name="line-1781"></a><span class='hs-comment'>-- with e.g. ByteString Builders).</span>
<a name="line-1782"></a><span class='hs-comment'>--</span>
<a name="line-1783"></a><span class='hs-comment'>-- Conversely, an implementation of `foldr` for a structure that can</span>
<a name="line-1784"></a><span class='hs-comment'>-- accommodate a large (and possibly unbounded) number of elements is expected</span>
<a name="line-1785"></a><span class='hs-comment'>-- to be lazy in the tail of the input, allowing operators that are lazy in the</span>
<a name="line-1786"></a><span class='hs-comment'>-- accumulator to yield intermediate results incrementally.  Such folds are</span>
<a name="line-1787"></a><span class='hs-comment'>-- right-associative, with the tail of the stream returned as a lazily</span>
<a name="line-1788"></a><span class='hs-comment'>-- evaluated component of the result (an element of a tuple or some other</span>
<a name="line-1789"></a><span class='hs-comment'>-- non-strict constructor, e.g. the @(:)@ constructor for lists).</span>
<a name="line-1790"></a><span class='hs-comment'>--</span>
<a name="line-1791"></a><span class='hs-comment'>-- The @toList@ function below lazily transforms a @Foldable@ structure to a</span>
<a name="line-1792"></a><span class='hs-comment'>-- List.  Note that this transformation may be lossy, e.g.  for a keyed</span>
<a name="line-1793"></a><span class='hs-comment'>-- container (@Map@, @HashMap@, &amp;#x2026;) the output stream holds only the</span>
<a name="line-1794"></a><span class='hs-comment'>-- values, not the keys.  Lossless transformations to\/from lists of @(key,</span>
<a name="line-1795"></a><span class='hs-comment'>-- value)@ pairs are typically available in the modules for the specific</span>
<a name="line-1796"></a><span class='hs-comment'>-- container types.</span>
<a name="line-1797"></a><span class='hs-comment'>--</span>
<a name="line-1798"></a><span class='hs-comment'>-- &gt; toList = foldr (:) []</span>
<a name="line-1799"></a><span class='hs-comment'>--</span>
<a name="line-1800"></a><span class='hs-comment'>-- A more complex example is concatenation of a list of lists expressed as a</span>
<a name="line-1801"></a><span class='hs-comment'>-- nested right fold (bypassing @('++')@).  We can check that the definition is</span>
<a name="line-1802"></a><span class='hs-comment'>-- indeed lazy by folding an infinite list of lists, and taking an initial</span>
<a name="line-1803"></a><span class='hs-comment'>-- segment.</span>
<a name="line-1804"></a><span class='hs-comment'>--</span>
<a name="line-1805"></a><span class='hs-comment'>-- &gt;&gt;&gt; myconcat = foldr (\x z -&gt; foldr (:) z x) []</span>
<a name="line-1806"></a><span class='hs-comment'>-- &gt;&gt;&gt; take 15 $ myconcat $ map (\i -&gt; [0..i]) [0..]</span>
<a name="line-1807"></a><span class='hs-comment'>-- [0,0,1,0,1,2,0,1,2,3,0,1,2,3,4]</span>
<a name="line-1808"></a><span class='hs-comment'>--</span>
<a name="line-1809"></a><span class='hs-comment'>-- Of course in this case another way to achieve the same result is via a</span>
<a name="line-1810"></a><span class='hs-comment'>-- list comprehension:</span>
<a name="line-1811"></a><span class='hs-comment'>--</span>
<a name="line-1812"></a><span class='hs-comment'>-- &gt; myconcat xss = [x | xs &lt;- xss, x &lt;- xs]</span>
<a name="line-1813"></a>
<a name="line-1814"></a><span class='hs-comment'>--------------</span>
<a name="line-1815"></a>
<a name="line-1816"></a><span class='hs-comment'>-- $lazylist</span>
<a name="line-1817"></a><span class='hs-comment'>--</span>
<a name="line-1818"></a><span class='hs-comment'>-- The full list of lazy corecursive functions in this module is:</span>
<a name="line-1819"></a><span class='hs-comment'>--</span>
<a name="line-1820"></a><span class='hs-comment'>-- * Provided the reduction function is lazy in its second argument,</span>
<a name="line-1821"></a><span class='hs-comment'>--   (otherwise best to use a strict recursive reduction):</span>
<a name="line-1822"></a><span class='hs-comment'>--</span>
<a name="line-1823"></a><span class='hs-comment'>--     @</span>
<a name="line-1824"></a><span class='hs-comment'>--     `foldr`  :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span>
<a name="line-1825"></a><span class='hs-comment'>--     `foldr1` :: Foldable t =&gt; (a -&gt; a -&gt; a) -&gt; t a -&gt; a</span>
<a name="line-1826"></a><span class='hs-comment'>--     @</span>
<a name="line-1827"></a><span class='hs-comment'>--</span>
<a name="line-1828"></a><span class='hs-comment'>-- * Provided the 'Monoid' `mappend` is lazy in its second argument</span>
<a name="line-1829"></a><span class='hs-comment'>--   (otherwise best to use a strict recursive reduction):</span>
<a name="line-1830"></a><span class='hs-comment'>--</span>
<a name="line-1831"></a><span class='hs-comment'>--     @</span>
<a name="line-1832"></a><span class='hs-comment'>--     `fold`    :: Foldable t =&gt; Monoid m =&gt; t m -&gt; m</span>
<a name="line-1833"></a><span class='hs-comment'>--     `foldMap` :: Foldable t =&gt; Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m</span>
<a name="line-1834"></a><span class='hs-comment'>--     @</span>
<a name="line-1835"></a><span class='hs-comment'>--</span>
<a name="line-1836"></a><span class='hs-comment'>-- * Provided the instance is correctly defined:</span>
<a name="line-1837"></a><span class='hs-comment'>--</span>
<a name="line-1838"></a><span class='hs-comment'>--     @</span>
<a name="line-1839"></a><span class='hs-comment'>--     `toList`    :: Foldable t =&gt; t a -&gt; [a]</span>
<a name="line-1840"></a><span class='hs-comment'>--     `concat`    :: Foldable t =&gt; t [a] -&gt; [a]</span>
<a name="line-1841"></a><span class='hs-comment'>--     `concatMap` :: Foldable t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]</span>
<a name="line-1842"></a><span class='hs-comment'>--     @</span>
<a name="line-1843"></a>
<a name="line-1844"></a><span class='hs-comment'>--------------</span>
<a name="line-1845"></a>
<a name="line-1846"></a><span class='hs-comment'>-- $shortcircuit</span>
<a name="line-1847"></a><span class='hs-comment'>--</span>
<a name="line-1848"></a><span class='hs-comment'>-- #short#</span>
<a name="line-1849"></a><span class='hs-comment'>-- Examples of short-circuit reduction include various boolean predicates that</span>
<a name="line-1850"></a><span class='hs-comment'>-- test whether some or all the elements of a structure satisfy a given</span>
<a name="line-1851"></a><span class='hs-comment'>-- condition.  Because these don't necessarily consume the entire list, they</span>
<a name="line-1852"></a><span class='hs-comment'>-- typically employ `foldr` with an operator that is conditionally strict in</span>
<a name="line-1853"></a><span class='hs-comment'>-- its second argument.  Once the termination condition is met the second</span>
<a name="line-1854"></a><span class='hs-comment'>-- argument (tail of the input structure) is ignored.  No result is returned</span>
<a name="line-1855"></a><span class='hs-comment'>-- until that happens.</span>
<a name="line-1856"></a><span class='hs-comment'>--</span>
<a name="line-1857"></a><span class='hs-comment'>-- The key distinguishing feature of these folds is /conditional/ strictness</span>
<a name="line-1858"></a><span class='hs-comment'>-- in the second argument, it is sometimes evaluated and sometimes not.</span>
<a name="line-1859"></a><span class='hs-comment'>--</span>
<a name="line-1860"></a><span class='hs-comment'>-- The simplest (degenerate case) of these is 'null', which determines whether</span>
<a name="line-1861"></a><span class='hs-comment'>-- a structure is empty or not.  This only needs to look at the first element,</span>
<a name="line-1862"></a><span class='hs-comment'>-- and only to the extent of whether it exists or not, and not its value.  In</span>
<a name="line-1863"></a><span class='hs-comment'>-- this case termination is guaranteed, and infinite input structures are fine.</span>
<a name="line-1864"></a><span class='hs-comment'>-- Its default definition is of course in terms of the lazy 'foldr':</span>
<a name="line-1865"></a><span class='hs-comment'>--</span>
<a name="line-1866"></a><span class='hs-comment'>-- &gt; null = foldr (\_ _ -&gt; False) True</span>
<a name="line-1867"></a><span class='hs-comment'>--</span>
<a name="line-1868"></a><span class='hs-comment'>-- A more general example is `any`, which applies a predicate to each input</span>
<a name="line-1869"></a><span class='hs-comment'>-- element in turn until it finds the first one for which the predicate is</span>
<a name="line-1870"></a><span class='hs-comment'>-- true, at which point it returns success.  If, in an infinite input stream</span>
<a name="line-1871"></a><span class='hs-comment'>-- the predicate is false for all the elements, `any` will not terminate,</span>
<a name="line-1872"></a><span class='hs-comment'>-- but since it runs in constant space, it typically won't run out of memory,</span>
<a name="line-1873"></a><span class='hs-comment'>-- it'll just loop forever.</span>
<a name="line-1874"></a>
<a name="line-1875"></a><span class='hs-comment'>--------------</span>
<a name="line-1876"></a>
<a name="line-1877"></a><span class='hs-comment'>-- $shortlist</span>
<a name="line-1878"></a><span class='hs-comment'>--</span>
<a name="line-1879"></a><span class='hs-comment'>-- The full list of short-circuit folds in this module is:</span>
<a name="line-1880"></a><span class='hs-comment'>--</span>
<a name="line-1881"></a><span class='hs-comment'>-- * Boolean predicate folds.</span>
<a name="line-1882"></a><span class='hs-comment'>--   These functions examine elements strictly until a condition is met,</span>
<a name="line-1883"></a><span class='hs-comment'>--   but then return a result ignoring the rest (lazy in the tail).  These</span>
<a name="line-1884"></a><span class='hs-comment'>--   may loop forever given an unbounded input where no elements satisfy the</span>
<a name="line-1885"></a><span class='hs-comment'>--   termination condition.</span>
<a name="line-1886"></a><span class='hs-comment'>--</span>
<a name="line-1887"></a><span class='hs-comment'>--     @</span>
<a name="line-1888"></a><span class='hs-comment'>--     `null`    :: Foldable t =&gt; t a -&gt; Bool</span>
<a name="line-1889"></a><span class='hs-comment'>--     `elem`    :: Foldable t =&gt; Eq a =&gt; a -&gt; t a -&gt; Bool</span>
<a name="line-1890"></a><span class='hs-comment'>--     `notElem` :: (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool</span>
<a name="line-1891"></a><span class='hs-comment'>--     `and`     :: Foldable t =&gt; t Bool -&gt; Bool</span>
<a name="line-1892"></a><span class='hs-comment'>--     `or`      :: Foldable t =&gt; t Bool -&gt; Bool</span>
<a name="line-1893"></a><span class='hs-comment'>--     `find`    :: Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Maybe a</span>
<a name="line-1894"></a><span class='hs-comment'>--     `any`     :: Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool</span>
<a name="line-1895"></a><span class='hs-comment'>--     `all`     :: Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool</span>
<a name="line-1896"></a><span class='hs-comment'>--     @</span>
<a name="line-1897"></a><span class='hs-comment'>--</span>
<a name="line-1898"></a><span class='hs-comment'>-- * Many instances of @('&lt;|&gt;')@ (e.g. the 'Maybe' instance) are conditionally</span>
<a name="line-1899"></a><span class='hs-comment'>--   lazy, and use or don't use their second argument depending on the value</span>
<a name="line-1900"></a><span class='hs-comment'>--   of the first.  These are used with the folds below, which terminate as</span>
<a name="line-1901"></a><span class='hs-comment'>--   early as possible, but otherwise generally keep going.  Some instances</span>
<a name="line-1902"></a><span class='hs-comment'>--   (e.g. for List) are always strict, but the result is lazy in the tail</span>
<a name="line-1903"></a><span class='hs-comment'>--   of the output, so that `asum` for a list of lists is in fact corecursive.</span>
<a name="line-1904"></a><span class='hs-comment'>--   These folds are defined in terms of `foldr`.</span>
<a name="line-1905"></a><span class='hs-comment'>--</span>
<a name="line-1906"></a><span class='hs-comment'>--     @</span>
<a name="line-1907"></a><span class='hs-comment'>--     `asum` :: (Foldable t, Alternative f) =&gt; t (f a) -&gt; f a</span>
<a name="line-1908"></a><span class='hs-comment'>--     `msum` :: (Foldable t, MonadPlus m) =&gt; t (m a) -&gt; m a</span>
<a name="line-1909"></a><span class='hs-comment'>--     @</span>
<a name="line-1910"></a><span class='hs-comment'>--</span>
<a name="line-1911"></a><span class='hs-comment'>-- * Likewise, the @('*&gt;')@ operator in some `Applicative` functors, and @('&gt;&gt;')@</span>
<a name="line-1912"></a><span class='hs-comment'>--   in some monads are conditionally lazy and can /short-circuit/ a chain of</span>
<a name="line-1913"></a><span class='hs-comment'>--   computations.  The below folds will terminate as early as possible, but</span>
<a name="line-1914"></a><span class='hs-comment'>--   even infinite loops can be productive here, when evaluated solely for</span>
<a name="line-1915"></a><span class='hs-comment'>--   their stream of IO side-effects.  See "Data.Traversable#effectful"</span>
<a name="line-1916"></a><span class='hs-comment'>--   for discussion of related functions.</span>
<a name="line-1917"></a><span class='hs-comment'>--</span>
<a name="line-1918"></a><span class='hs-comment'>--     @</span>
<a name="line-1919"></a><span class='hs-comment'>--     `traverse_`  :: (Foldable t, Applicative f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f ()</span>
<a name="line-1920"></a><span class='hs-comment'>--     `for_`       :: (Foldable t, Applicative f) =&gt; t a -&gt; (a -&gt; f b) -&gt; f ()</span>
<a name="line-1921"></a><span class='hs-comment'>--     `sequenceA_` :: (Foldable t, Applicative f) =&gt; t (f a) -&gt; f ()</span>
<a name="line-1922"></a><span class='hs-comment'>--     `mapM_`      :: (Foldable t, Monad m) =&gt; (a -&gt; m b) -&gt; t a -&gt; m ()</span>
<a name="line-1923"></a><span class='hs-comment'>--     `forM_`      :: (Foldable t, Monad m) =&gt; t a -&gt; (a -&gt; m b) -&gt; m ()</span>
<a name="line-1924"></a><span class='hs-comment'>--     `sequence_`  :: (Foldable t, Monad m) =&gt; t (m a) -&gt; m ()</span>
<a name="line-1925"></a><span class='hs-comment'>--     @</span>
<a name="line-1926"></a><span class='hs-comment'>--</span>
<a name="line-1927"></a><span class='hs-comment'>-- * Finally, there's one more special case, `foldlM`:</span>
<a name="line-1928"></a><span class='hs-comment'>--</span>
<a name="line-1929"></a><span class='hs-comment'>--     @`foldlM` :: (Foldable t, Monad m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; t a -&gt; m b@</span>
<a name="line-1930"></a><span class='hs-comment'>--</span>
<a name="line-1931"></a><span class='hs-comment'>--     The sequencing of monadic effects proceeds from left to right.  If at</span>
<a name="line-1932"></a><span class='hs-comment'>--     some step the bind operator @('&gt;&gt;=')@ short-circuits (as with, e.g.,</span>
<a name="line-1933"></a><span class='hs-comment'>--     'mzero' with a 'MonadPlus', or an exception with a 'MonadThrow', etc.),</span>
<a name="line-1934"></a><span class='hs-comment'>--     then the evaluated effects will be from an initial portion of the</span>
<a name="line-1935"></a><span class='hs-comment'>--     element sequence.</span>
<a name="line-1936"></a><span class='hs-comment'>--</span>
<a name="line-1937"></a><span class='hs-comment'>--     &gt;&gt;&gt; :set -XBangPatterns</span>
<a name="line-1938"></a><span class='hs-comment'>--     &gt;&gt;&gt; import Control.Monad</span>
<a name="line-1939"></a><span class='hs-comment'>--     &gt;&gt;&gt; import Control.Monad.Trans.Class</span>
<a name="line-1940"></a><span class='hs-comment'>--     &gt;&gt;&gt; import Control.Monad.Trans.Maybe</span>
<a name="line-1941"></a><span class='hs-comment'>--     &gt;&gt;&gt; import Data.Foldable</span>
<a name="line-1942"></a><span class='hs-comment'>--     &gt;&gt;&gt; let f !_ e = when (e &gt; 3) mzero &gt;&gt; lift (print e)</span>
<a name="line-1943"></a><span class='hs-comment'>--     &gt;&gt;&gt; runMaybeT $ foldlM f () [0..]</span>
<a name="line-1944"></a><span class='hs-comment'>--     0</span>
<a name="line-1945"></a><span class='hs-comment'>--     1</span>
<a name="line-1946"></a><span class='hs-comment'>--     2</span>
<a name="line-1947"></a><span class='hs-comment'>--     3</span>
<a name="line-1948"></a><span class='hs-comment'>--     Nothing</span>
<a name="line-1949"></a><span class='hs-comment'>--</span>
<a name="line-1950"></a><span class='hs-comment'>--     Contrast this with `foldrM`, which sequences monadic effects from right</span>
<a name="line-1951"></a><span class='hs-comment'>--     to left, and therefore diverges when folding an unbounded input</span>
<a name="line-1952"></a><span class='hs-comment'>--     structure without ever having the opportunity to short-circuit.</span>
<a name="line-1953"></a><span class='hs-comment'>--</span>
<a name="line-1954"></a><span class='hs-comment'>--     &gt;&gt;&gt; let f e _ = when (e &gt; 3) mzero &gt;&gt; lift (print e)</span>
<a name="line-1955"></a><span class='hs-comment'>--     &gt;&gt;&gt; runMaybeT $ foldrM f () [0..]</span>
<a name="line-1956"></a><span class='hs-comment'>--     ...hangs...</span>
<a name="line-1957"></a><span class='hs-comment'>--</span>
<a name="line-1958"></a><span class='hs-comment'>--     When the structure is finite `foldrM` performs the monadic effects from</span>
<a name="line-1959"></a><span class='hs-comment'>--     right to left, possibly short-circuiting after processing a tail portion</span>
<a name="line-1960"></a><span class='hs-comment'>--     of the element sequence.</span>
<a name="line-1961"></a><span class='hs-comment'>--</span>
<a name="line-1962"></a><span class='hs-comment'>--     &gt;&gt;&gt; let f e _ = when (e &lt; 3) mzero &gt;&gt; lift (print e)</span>
<a name="line-1963"></a><span class='hs-comment'>--     &gt;&gt;&gt; runMaybeT $ foldrM f () [0..5]</span>
<a name="line-1964"></a><span class='hs-comment'>--     5</span>
<a name="line-1965"></a><span class='hs-comment'>--     4</span>
<a name="line-1966"></a><span class='hs-comment'>--     3</span>
<a name="line-1967"></a><span class='hs-comment'>--     Nothing</span>
<a name="line-1968"></a>
<a name="line-1969"></a><span class='hs-comment'>--------------</span>
<a name="line-1970"></a>
<a name="line-1971"></a><span class='hs-comment'>-- $hybrid</span>
<a name="line-1972"></a><span class='hs-comment'>--</span>
<a name="line-1973"></a><span class='hs-comment'>-- The below folds, are neither strict reductions that produce a final answer</span>
<a name="line-1974"></a><span class='hs-comment'>-- in constant space, nor lazy corecursions, and so have limited applicability.</span>
<a name="line-1975"></a><span class='hs-comment'>-- They do have specialised uses, but are best avoided when in doubt.</span>
<a name="line-1976"></a><span class='hs-comment'>--</span>
<a name="line-1977"></a><span class='hs-comment'>-- @</span>
<a name="line-1978"></a><span class='hs-comment'>-- 'foldr'' :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span>
<a name="line-1979"></a><span class='hs-comment'>-- 'foldl'  :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</span>
<a name="line-1980"></a><span class='hs-comment'>-- 'foldl1' :: Foldable t =&gt; (a -&gt; a -&gt; a) -&gt; t a -&gt; a</span>
<a name="line-1981"></a><span class='hs-comment'>-- 'foldrM' :: (Foldable t, Monad m) =&gt; (a -&gt; b -&gt; m b) -&gt; b -&gt; t a -&gt; m b</span>
<a name="line-1982"></a><span class='hs-comment'>-- @</span>
<a name="line-1983"></a><span class='hs-comment'>--</span>
<a name="line-1984"></a><span class='hs-comment'>-- The lazy left-folds (used corecursively) and 'foldrM' (used to sequence</span>
<a name="line-1985"></a><span class='hs-comment'>-- actions right-to-left) can be performant in structures whose @Foldable@</span>
<a name="line-1986"></a><span class='hs-comment'>-- instances take advantage of efficient right-to-left iteration to compute</span>
<a name="line-1987"></a><span class='hs-comment'>-- lazy left folds outside-in from the rightmost element.</span>
<a name="line-1988"></a><span class='hs-comment'>--</span>
<a name="line-1989"></a><span class='hs-comment'>-- The strict 'foldr'' is the least likely to be useful, structures that</span>
<a name="line-1990"></a><span class='hs-comment'>-- support efficient sequencing /only/ right-to-left are not common.</span>
<a name="line-1991"></a>
<a name="line-1992"></a><span class='hs-comment'>--------------</span>
<a name="line-1993"></a>
<a name="line-1994"></a><span class='hs-comment'>-- $instances</span>
<a name="line-1995"></a><span class='hs-comment'>--</span>
<a name="line-1996"></a><span class='hs-comment'>-- #instances#</span>
<a name="line-1997"></a><span class='hs-comment'>-- For many structures reasonably efficient @Foldable@ instances can be derived</span>
<a name="line-1998"></a><span class='hs-comment'>-- automatically, by enabling the @DeriveFoldable@ GHC extension.  When this</span>
<a name="line-1999"></a><span class='hs-comment'>-- works, it is generally not necessary to define a custom instance by hand.</span>
<a name="line-2000"></a><span class='hs-comment'>-- Though in some cases one may be able to get slightly faster hand-tuned code,</span>
<a name="line-2001"></a><span class='hs-comment'>-- care is required to avoid producing slower code, or code that is not</span>
<a name="line-2002"></a><span class='hs-comment'>-- sufficiently lazy, strict or /lawful/.</span>
<a name="line-2003"></a><span class='hs-comment'>--</span>
<a name="line-2004"></a><span class='hs-comment'>-- The hand-crafted instances can get away with only defining one of 'foldr' or</span>
<a name="line-2005"></a><span class='hs-comment'>-- 'foldMap'.  All the other methods have default definitions in terms of one</span>
<a name="line-2006"></a><span class='hs-comment'>-- of these.  The default definitions have the expected strictness and the</span>
<a name="line-2007"></a><span class='hs-comment'>-- expected asymptotic runtime and space costs, modulo small constant factors.</span>
<a name="line-2008"></a><span class='hs-comment'>-- If you choose to hand-tune, benchmarking is advised to see whether you're</span>
<a name="line-2009"></a><span class='hs-comment'>-- doing better than the default derived implementations, plus careful tests to</span>
<a name="line-2010"></a><span class='hs-comment'>-- ensure that the custom methods are correct.</span>
<a name="line-2011"></a><span class='hs-comment'>--</span>
<a name="line-2012"></a><span class='hs-comment'>-- Below we construct a @Foldable@ instance for a data type representing a</span>
<a name="line-2013"></a><span class='hs-comment'>-- (finite) binary tree with depth-first traversal.</span>
<a name="line-2014"></a><span class='hs-comment'>--</span>
<a name="line-2015"></a><span class='hs-comment'>-- &gt; data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)</span>
<a name="line-2016"></a><span class='hs-comment'>--</span>
<a name="line-2017"></a><span class='hs-comment'>-- a suitable instance would be:</span>
<a name="line-2018"></a><span class='hs-comment'>--</span>
<a name="line-2019"></a><span class='hs-comment'>-- &gt; instance Foldable Tree where</span>
<a name="line-2020"></a><span class='hs-comment'>-- &gt;    foldr f z Empty = z</span>
<a name="line-2021"></a><span class='hs-comment'>-- &gt;    foldr f z (Leaf x) = f x z</span>
<a name="line-2022"></a><span class='hs-comment'>-- &gt;    foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l</span>
<a name="line-2023"></a><span class='hs-comment'>--</span>
<a name="line-2024"></a><span class='hs-comment'>-- The 'Node' case is a right fold of the left subtree whose initial</span>
<a name="line-2025"></a><span class='hs-comment'>-- value is a right fold of the rest of the tree.</span>
<a name="line-2026"></a><span class='hs-comment'>--</span>
<a name="line-2027"></a><span class='hs-comment'>-- For example, when @f@ is @(':')@, all three cases return an immediate value,</span>
<a name="line-2028"></a><span class='hs-comment'>-- respectively @z@ or a /cons cell/ holding @x@ or @l@, with the remainder the</span>
<a name="line-2029"></a><span class='hs-comment'>-- structure, if any, encapsulated in a lazy thunk.  This meets the expected</span>
<a name="line-2030"></a><span class='hs-comment'>-- efficient [corecursive](#corec) behaviour of 'foldr'.</span>
<a name="line-2031"></a><span class='hs-comment'>--</span>
<a name="line-2032"></a><span class='hs-comment'>-- Alternatively, one could define @foldMap@:</span>
<a name="line-2033"></a><span class='hs-comment'>--</span>
<a name="line-2034"></a><span class='hs-comment'>-- &gt; instance Foldable Tree where</span>
<a name="line-2035"></a><span class='hs-comment'>-- &gt;    foldMap f Empty = mempty</span>
<a name="line-2036"></a><span class='hs-comment'>-- &gt;    foldMap f (Leaf x) = f x</span>
<a name="line-2037"></a><span class='hs-comment'>-- &gt;    foldMap f (Node l k r) = foldMap f l &lt;&gt; f k &lt;&gt; foldMap f r</span>
<a name="line-2038"></a><span class='hs-comment'>--</span>
<a name="line-2039"></a><span class='hs-comment'>-- And indeed some efficiency may be gained by directly defining both,</span>
<a name="line-2040"></a><span class='hs-comment'>-- avoiding some indirection in the default definitions that express</span>
<a name="line-2041"></a><span class='hs-comment'>-- one in terms of the other.  If you implement just one, likely 'foldr'</span>
<a name="line-2042"></a><span class='hs-comment'>-- is the better choice.</span>
<a name="line-2043"></a><span class='hs-comment'>--</span>
<a name="line-2044"></a><span class='hs-comment'>-- A binary tree typically (when balanced, or randomly biased) provides equally</span>
<a name="line-2045"></a><span class='hs-comment'>-- efficient access to its left and right subtrees.  This makes it possible to</span>
<a name="line-2046"></a><span class='hs-comment'>-- define a `foldl` optimised for [corecursive](#corec) folds with operators</span>
<a name="line-2047"></a><span class='hs-comment'>-- that are lazy in their first (left) argument.</span>
<a name="line-2048"></a><span class='hs-comment'>--</span>
<a name="line-2049"></a><span class='hs-comment'>-- &gt; instance Foldable Tree where</span>
<a name="line-2050"></a><span class='hs-comment'>-- &gt;    foldr f z Empty = z</span>
<a name="line-2051"></a><span class='hs-comment'>-- &gt;    foldr f z (Leaf x) = f x z</span>
<a name="line-2052"></a><span class='hs-comment'>-- &gt;    foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l</span>
<a name="line-2053"></a><span class='hs-comment'>-- &gt;    --</span>
<a name="line-2054"></a><span class='hs-comment'>-- &gt;    foldMap f Empty = mempty</span>
<a name="line-2055"></a><span class='hs-comment'>-- &gt;    foldMap f (Leaf x) = f x</span>
<a name="line-2056"></a><span class='hs-comment'>-- &gt;    foldMap f (Node l k r) = foldMap f l &lt;&gt; f k &lt;&gt; foldMap f r</span>
<a name="line-2057"></a><span class='hs-comment'>-- &gt;    --</span>
<a name="line-2058"></a><span class='hs-comment'>-- &gt;    foldl f z Empty = z</span>
<a name="line-2059"></a><span class='hs-comment'>-- &gt;    foldl f z (Leaf x) = f z x</span>
<a name="line-2060"></a><span class='hs-comment'>-- &gt;    foldl f z (Node l k r) = foldl f (f (foldl f z l) k) r</span>
<a name="line-2061"></a><span class='hs-comment'>--</span>
<a name="line-2062"></a><span class='hs-comment'>-- Now left-to-right and right-to-left iteration over the structure</span>
<a name="line-2063"></a><span class='hs-comment'>-- elements are equally efficient (note the mirror-order output when</span>
<a name="line-2064"></a><span class='hs-comment'>-- using `foldl`):</span>
<a name="line-2065"></a><span class='hs-comment'>--</span>
<a name="line-2066"></a><span class='hs-comment'>-- &gt;&gt;&gt; foldr (\e acc -&gt; e : acc) [] (Node (Leaf 1) 2 (Leaf 3))</span>
<a name="line-2067"></a><span class='hs-comment'>-- [1,2,3]</span>
<a name="line-2068"></a><span class='hs-comment'>-- &gt;&gt;&gt; foldl (\acc e -&gt; e : acc) [] (Node (Leaf 1) 2 (Leaf 3))</span>
<a name="line-2069"></a><span class='hs-comment'>-- [3,2,1]</span>
<a name="line-2070"></a><span class='hs-comment'>--</span>
<a name="line-2071"></a><span class='hs-comment'>-- We can carry this further, and define more non-default methods...</span>
<a name="line-2072"></a><span class='hs-comment'>--</span>
<a name="line-2073"></a><span class='hs-comment'>-- The structure definition actually admits trees that are unbounded on either</span>
<a name="line-2074"></a><span class='hs-comment'>-- or both sides.  The only fold that can plausibly terminate for a tree</span>
<a name="line-2075"></a><span class='hs-comment'>-- unbounded on both left and right is `null`, when defined as shown below.</span>
<a name="line-2076"></a><span class='hs-comment'>-- The default definition in terms of `foldr` diverges if the tree is unbounded</span>
<a name="line-2077"></a><span class='hs-comment'>-- on the left.  Here we define a variant that avoids travelling down the tree</span>
<a name="line-2078"></a><span class='hs-comment'>-- to find the leftmost element and just examines the root node.</span>
<a name="line-2079"></a><span class='hs-comment'>--</span>
<a name="line-2080"></a><span class='hs-comment'>-- &gt;    null Empty = True</span>
<a name="line-2081"></a><span class='hs-comment'>-- &gt;    null _     = False</span>
<a name="line-2082"></a><span class='hs-comment'>--</span>
<a name="line-2083"></a><span class='hs-comment'>-- This is a sound choice also for finite trees.</span>
<a name="line-2084"></a><span class='hs-comment'>--</span>
<a name="line-2085"></a><span class='hs-comment'>-- In practice, unbounded trees are quite uncommon, and can barely be said to</span>
<a name="line-2086"></a><span class='hs-comment'>-- be @Foldable@.  They would typically employ breadth first traversal, and</span>
<a name="line-2087"></a><span class='hs-comment'>-- would support only corecursive and short-circuit folds (diverge under strict</span>
<a name="line-2088"></a><span class='hs-comment'>-- reduction).</span>
<a name="line-2089"></a><span class='hs-comment'>--</span>
<a name="line-2090"></a><span class='hs-comment'>-- Returning to simpler instances, defined just in terms of `foldr`, it is</span>
<a name="line-2091"></a><span class='hs-comment'>-- somewhat surprising that a fairly efficient /default/ implementation of the</span>
<a name="line-2092"></a><span class='hs-comment'>-- strict 'foldl'' is defined in terms of lazy `foldr` when only the latter is</span>
<a name="line-2093"></a><span class='hs-comment'>-- explicitly provided by the instance.  It may be instructive to take a look</span>
<a name="line-2094"></a><span class='hs-comment'>-- at how this works.</span>
<a name="line-2095"></a>
<a name="line-2096"></a><span class='hs-comment'>--------------</span>
<a name="line-2097"></a>
<a name="line-2098"></a><span class='hs-comment'>-- $strictlazy</span>
<a name="line-2099"></a><span class='hs-comment'>--</span>
<a name="line-2100"></a><span class='hs-comment'>-- #strictlazy#</span>
<a name="line-2101"></a><span class='hs-comment'>--</span>
<a name="line-2102"></a><span class='hs-comment'>-- Sometimes, it is useful for the result of applying 'foldr' to be a</span>
<a name="line-2103"></a><span class='hs-comment'>-- /function/.  This is done by mapping the structure elements to functions</span>
<a name="line-2104"></a><span class='hs-comment'>-- with the same argument and result types.  The per-element functions are then</span>
<a name="line-2105"></a><span class='hs-comment'>-- composed to give the final result.</span>
<a name="line-2106"></a><span class='hs-comment'>--</span>
<a name="line-2107"></a><span class='hs-comment'>-- For example, we can /flip/ the strict left fold 'foldl'' by writing:</span>
<a name="line-2108"></a><span class='hs-comment'>--</span>
<a name="line-2109"></a><span class='hs-comment'>-- &gt; foldl' f z xs = flippedFoldl' f xs z</span>
<a name="line-2110"></a><span class='hs-comment'>--</span>
<a name="line-2111"></a><span class='hs-comment'>-- with the function 'flippedFoldl'' defined as below, with 'seq' used to</span>
<a name="line-2112"></a><span class='hs-comment'>-- ensure the strictness in the accumulator:</span>
<a name="line-2113"></a><span class='hs-comment'>--</span>
<a name="line-2114"></a><span class='hs-comment'>-- &gt; flippedFoldl' f [] z = z</span>
<a name="line-2115"></a><span class='hs-comment'>-- &gt; flippedFoldl' f (x : xs) z = z `seq` flippedFoldl' f xs (f z x)</span>
<a name="line-2116"></a><span class='hs-comment'>--</span>
<a name="line-2117"></a><span class='hs-comment'>-- Rewriting to use lambdas, this is:</span>
<a name="line-2118"></a><span class='hs-comment'>--</span>
<a name="line-2119"></a><span class='hs-comment'>-- &gt; flippedFoldl' f [] = \ b -&gt; b</span>
<a name="line-2120"></a><span class='hs-comment'>-- &gt; flippedFoldl' f (x : xs) = \ b -&gt; b `seq` r (f b x)</span>
<a name="line-2121"></a><span class='hs-comment'>-- &gt;     where r = flippedFoldl' f xs</span>
<a name="line-2122"></a><span class='hs-comment'>--</span>
<a name="line-2123"></a><span class='hs-comment'>-- The above has the form of a right fold, enabling a rewrite to:</span>
<a name="line-2124"></a><span class='hs-comment'>--</span>
<a name="line-2125"></a><span class='hs-comment'>-- &gt; flippedFoldl' f = \ xs -&gt; foldr f' id xs</span>
<a name="line-2126"></a><span class='hs-comment'>-- &gt;     where f' x r = \ b -&gt; b `seq` r (f b x)</span>
<a name="line-2127"></a><span class='hs-comment'>--</span>
<a name="line-2128"></a><span class='hs-comment'>-- We can now unflip this to get 'foldl'':</span>
<a name="line-2129"></a><span class='hs-comment'>--</span>
<a name="line-2130"></a><span class='hs-comment'>-- &gt; foldl' f z = \ xs -&gt; foldr f' id xs z</span>
<a name="line-2131"></a><span class='hs-comment'>-- &gt;           -- \ xs -&gt; flippedFoldl' f xs z</span>
<a name="line-2132"></a><span class='hs-comment'>-- &gt;   where f' x r = \ b -&gt; b `seq` r (f b x)</span>
<a name="line-2133"></a><span class='hs-comment'>--</span>
<a name="line-2134"></a><span class='hs-comment'>-- The function __@foldr f' id xs@__ applied to @z@ is built corecursively, and</span>
<a name="line-2135"></a><span class='hs-comment'>-- its terms are applied to an eagerly evaluated accumulator before further</span>
<a name="line-2136"></a><span class='hs-comment'>-- terms are applied to the result.  As required, this runs in constant space,</span>
<a name="line-2137"></a><span class='hs-comment'>-- and can be optimised to an efficient loop.</span>
<a name="line-2138"></a><span class='hs-comment'>--</span>
<a name="line-2139"></a><span class='hs-comment'>-- (The actual definition of 'foldl'' labels the lambdas in the definition of</span>
<a name="line-2140"></a><span class='hs-comment'>-- __@f'@__ above as /oneShot/, which enables further optimisations).</span>
<a name="line-2141"></a>
<a name="line-2142"></a><span class='hs-comment'>--------------</span>
<a name="line-2143"></a>
<a name="line-2144"></a><span class='hs-comment'>-- $generative</span>
<a name="line-2145"></a><span class='hs-comment'>--</span>
<a name="line-2146"></a><span class='hs-comment'>-- #generative#</span>
<a name="line-2147"></a><span class='hs-comment'>-- So far, we have not discussed /generative recursion/.  Unlike recursive</span>
<a name="line-2148"></a><span class='hs-comment'>-- reduction or corecursion, instead of processing a sequence of elements</span>
<a name="line-2149"></a><span class='hs-comment'>-- already in memory, generative recursion involves producing a possibly</span>
<a name="line-2150"></a><span class='hs-comment'>-- unbounded sequence of values from an initial seed value.  The canonical</span>
<a name="line-2151"></a><span class='hs-comment'>-- example of this is 'Data.List.unfoldr' for Lists, with variants available</span>
<a name="line-2152"></a><span class='hs-comment'>-- for Vectors and various other structures.</span>
<a name="line-2153"></a><span class='hs-comment'>--</span>
<a name="line-2154"></a><span class='hs-comment'>-- A key issue with lists, when used generatively as /iterators/, rather than as</span>
<a name="line-2155"></a><span class='hs-comment'>-- poor-man's containers (see [[1\]](#uselistsnot)), is that such iterators</span>
<a name="line-2156"></a><span class='hs-comment'>-- tend to consume memory when used more than once.  A single traversal of a</span>
<a name="line-2157"></a><span class='hs-comment'>-- list-as-iterator will run in constant space, but as soon as the list is</span>
<a name="line-2158"></a><span class='hs-comment'>-- retained for reuse, its entire element sequence is stored in memory, and the</span>
<a name="line-2159"></a><span class='hs-comment'>-- second traversal reads the copy, rather than regenerates the elements.  It</span>
<a name="line-2160"></a><span class='hs-comment'>-- is sometimes better to recompute the elements rather than memoise the list.</span>
<a name="line-2161"></a><span class='hs-comment'>--</span>
<a name="line-2162"></a><span class='hs-comment'>-- Memoisation happens because the built-in Haskell list __@[]@__ is</span>
<a name="line-2163"></a><span class='hs-comment'>-- represented as __data__, either empty or a /cons-cell/ holding the first</span>
<a name="line-2164"></a><span class='hs-comment'>-- element and the tail of the list.  The @Foldable@ class enables a variant</span>
<a name="line-2165"></a><span class='hs-comment'>-- representation of iterators as /functions/, which take an operator and a</span>
<a name="line-2166"></a><span class='hs-comment'>-- starting accumulator and output a summary result.</span>
<a name="line-2167"></a><span class='hs-comment'>--</span>
<a name="line-2168"></a><span class='hs-comment'>-- The [@fmlist@](https://hackage.haskell.org/package/fmlist) package takes</span>
<a name="line-2169"></a><span class='hs-comment'>-- this approach, by representing a list via its `foldMap` action.</span>
<a name="line-2170"></a><span class='hs-comment'>--</span>
<a name="line-2171"></a><span class='hs-comment'>-- Below we implement an analogous data structure using a representation</span>
<a name="line-2172"></a><span class='hs-comment'>-- based on `foldr`.  This is an example of /Church encoding/</span>
<a name="line-2173"></a><span class='hs-comment'>-- (named after Alonzo Church, inventor of the lambda calculus).</span>
<a name="line-2174"></a><span class='hs-comment'>--</span>
<a name="line-2175"></a><span class='hs-comment'>-- &gt; {-# LANGUAGE RankNTypes #-}</span>
<a name="line-2176"></a><span class='hs-comment'>-- &gt; newtype FRList a = FR { unFR :: forall b. (a -&gt; b -&gt; b) -&gt; b -&gt; b }</span>
<a name="line-2177"></a><span class='hs-comment'>--</span>
<a name="line-2178"></a><span class='hs-comment'>-- The __@unFR@__ field of this type is essentially its `foldr` method</span>
<a name="line-2179"></a><span class='hs-comment'>-- with the list as its first rather than last argument.  Thus we</span>
<a name="line-2180"></a><span class='hs-comment'>-- immediately get a @Foldable@ instance (and a 'toList' function</span>
<a name="line-2181"></a><span class='hs-comment'>-- mapping an __@FRList@__ to a regular list).</span>
<a name="line-2182"></a><span class='hs-comment'>--</span>
<a name="line-2183"></a><span class='hs-comment'>-- &gt; instance Foldable FRList where</span>
<a name="line-2184"></a><span class='hs-comment'>-- &gt;     foldr f z l = unFR l f z</span>
<a name="line-2185"></a><span class='hs-comment'>-- &gt;     -- With older versions of @base@, also define sum, product, ...</span>
<a name="line-2186"></a><span class='hs-comment'>-- &gt;     -- to ensure use of the strict 'foldl''.</span>
<a name="line-2187"></a><span class='hs-comment'>-- &gt;     -- sum = foldl' (+) 0</span>
<a name="line-2188"></a><span class='hs-comment'>-- &gt;     -- ...</span>
<a name="line-2189"></a><span class='hs-comment'>--</span>
<a name="line-2190"></a><span class='hs-comment'>-- We can convert a regular list to an __@FRList@__ with:</span>
<a name="line-2191"></a><span class='hs-comment'>--</span>
<a name="line-2192"></a><span class='hs-comment'>-- &gt; fromList :: [a] -&gt; FRList a</span>
<a name="line-2193"></a><span class='hs-comment'>-- &gt; fromList as = FRList $ \ f z -&gt; foldr f z as</span>
<a name="line-2194"></a><span class='hs-comment'>--</span>
<a name="line-2195"></a><span class='hs-comment'>-- However, reuse of an __@FRList@__ obtained in this way will typically</span>
<a name="line-2196"></a><span class='hs-comment'>-- memoise the underlying element sequence.  Instead, we can define</span>
<a name="line-2197"></a><span class='hs-comment'>-- __@FRList@__ terms directly:</span>
<a name="line-2198"></a><span class='hs-comment'>--</span>
<a name="line-2199"></a><span class='hs-comment'>-- &gt; -- | Immediately return the initial accumulator</span>
<a name="line-2200"></a><span class='hs-comment'>-- &gt; nil :: FRList a</span>
<a name="line-2201"></a><span class='hs-comment'>-- &gt; nil = FRList $ \ _ z -&gt; z</span>
<a name="line-2202"></a><span class='hs-comment'>-- &gt; {-# INLINE nil #-}</span>
<a name="line-2203"></a><span class='hs-comment'>--</span>
<a name="line-2204"></a><span class='hs-comment'>-- &gt; -- | Fold the tail to use as an accumulator with the new initial element</span>
<a name="line-2205"></a><span class='hs-comment'>-- &gt; cons :: a -&gt; FRList a -&gt; FRList a</span>
<a name="line-2206"></a><span class='hs-comment'>-- &gt; cons a l = FRList $ \ f z -&gt; f a (unFR l f z)</span>
<a name="line-2207"></a><span class='hs-comment'>-- &gt; {-# INLINE cons #-}</span>
<a name="line-2208"></a><span class='hs-comment'>--</span>
<a name="line-2209"></a><span class='hs-comment'>-- More crucially, we can also directly define the key building block for</span>
<a name="line-2210"></a><span class='hs-comment'>-- generative recursion:</span>
<a name="line-2211"></a><span class='hs-comment'>--</span>
<a name="line-2212"></a><span class='hs-comment'>-- &gt; -- | Generative recursion, dual to `foldr`.</span>
<a name="line-2213"></a><span class='hs-comment'>-- &gt; unfoldr :: (s -&gt; Maybe (a, s)) -&gt; s -&gt; FRList a</span>
<a name="line-2214"></a><span class='hs-comment'>-- &gt; unfoldr g s0 = FR generate</span>
<a name="line-2215"></a><span class='hs-comment'>-- &gt;   where generate f z = loop s0</span>
<a name="line-2216"></a><span class='hs-comment'>-- &gt;           where loop s | Just (a, t) &lt;- g s = f a (loop t)</span>
<a name="line-2217"></a><span class='hs-comment'>-- &gt;                        | otherwise = z</span>
<a name="line-2218"></a><span class='hs-comment'>-- &gt; {-# INLINE unfoldr #-}</span>
<a name="line-2219"></a><span class='hs-comment'>--</span>
<a name="line-2220"></a><span class='hs-comment'>-- Which can, for example, be specialised to number ranges:</span>
<a name="line-2221"></a><span class='hs-comment'>--</span>
<a name="line-2222"></a><span class='hs-comment'>-- &gt; -- | Generate a range of consecutive integral values.</span>
<a name="line-2223"></a><span class='hs-comment'>-- &gt; range :: (Ord a, Integral a) =&gt; a -&gt; a -&gt; FRList a</span>
<a name="line-2224"></a><span class='hs-comment'>-- &gt; range lo hi =</span>
<a name="line-2225"></a><span class='hs-comment'>-- &gt;     unfoldr (\s -&gt; if s &gt; hi then Nothing else Just (s, s+1)) lo</span>
<a name="line-2226"></a><span class='hs-comment'>-- &gt; {-# INLINE range #-}</span>
<a name="line-2227"></a><span class='hs-comment'>--</span>
<a name="line-2228"></a><span class='hs-comment'>-- The program below, when compiled with optimisation:</span>
<a name="line-2229"></a><span class='hs-comment'>--</span>
<a name="line-2230"></a><span class='hs-comment'>-- &gt; main :: IO ()</span>
<a name="line-2231"></a><span class='hs-comment'>-- &gt; main = do</span>
<a name="line-2232"></a><span class='hs-comment'>-- &gt;     let r :: FRList Int</span>
<a name="line-2233"></a><span class='hs-comment'>-- &gt;         r = range 1 10000000</span>
<a name="line-2234"></a><span class='hs-comment'>-- &gt;      in print (sum r, length r)</span>
<a name="line-2235"></a><span class='hs-comment'>--</span>
<a name="line-2236"></a><span class='hs-comment'>-- produces the expected output with no noticeable garbage-collection, despite</span>
<a name="line-2237"></a><span class='hs-comment'>-- reuse of the __@FRList@__ term __@r@__.</span>
<a name="line-2238"></a><span class='hs-comment'>--</span>
<a name="line-2239"></a><span class='hs-comment'>-- &gt; (50000005000000,10000000)</span>
<a name="line-2240"></a><span class='hs-comment'>-- &gt;     52,120 bytes allocated in the heap</span>
<a name="line-2241"></a><span class='hs-comment'>-- &gt;      3,320 bytes copied during GC</span>
<a name="line-2242"></a><span class='hs-comment'>-- &gt;     44,376 bytes maximum residency (1 sample(s))</span>
<a name="line-2243"></a><span class='hs-comment'>-- &gt;     25,256 bytes maximum slop</span>
<a name="line-2244"></a><span class='hs-comment'>-- &gt;          3 MiB total memory in use (0 MB lost due to fragmentation)</span>
<a name="line-2245"></a><span class='hs-comment'>--</span>
<a name="line-2246"></a><span class='hs-comment'>-- The Weak Head Normal Form of an __@FRList@__ is a lambda abstraction not a</span>
<a name="line-2247"></a><span class='hs-comment'>-- data value, and reuse does not lead to memoisation.  Reuse of the iterator</span>
<a name="line-2248"></a><span class='hs-comment'>-- above is somewhat contrived, when computing multiple folds over a common</span>
<a name="line-2249"></a><span class='hs-comment'>-- list, you should generally traverse a  list only [once](#multipass).  The</span>
<a name="line-2250"></a><span class='hs-comment'>-- goal is to demonstrate that the separate computations of the 'sum' and</span>
<a name="line-2251"></a><span class='hs-comment'>-- 'length' run efficiently in constant space, despite reuse.  This would not</span>
<a name="line-2252"></a><span class='hs-comment'>-- be the case with the list @[1..10000000]@.</span>
<a name="line-2253"></a><span class='hs-comment'>--</span>
<a name="line-2254"></a><span class='hs-comment'>-- This is, however, an artificially simple reduction.  More typically, there</span>
<a name="line-2255"></a><span class='hs-comment'>-- are likely to be some allocations in the inner loop, but the temporary</span>
<a name="line-2256"></a><span class='hs-comment'>-- storage used will be garbage-collected as needed, and overall memory</span>
<a name="line-2257"></a><span class='hs-comment'>-- utilisation will remain modest and will not scale with the size of the list.</span>
<a name="line-2258"></a><span class='hs-comment'>--</span>
<a name="line-2259"></a><span class='hs-comment'>-- If we go back to built-in lists (i.e. __@[]@__), but avoid reuse by</span>
<a name="line-2260"></a><span class='hs-comment'>-- performing reduction in a single pass, as below:</span>
<a name="line-2261"></a><span class='hs-comment'>--</span>
<a name="line-2262"></a><span class='hs-comment'>-- &gt; data PairS a b = P !a !b -- We define a strict pair datatype</span>
<a name="line-2263"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-2264"></a><span class='hs-comment'>-- &gt; main :: IO ()</span>
<a name="line-2265"></a><span class='hs-comment'>-- &gt; main = do</span>
<a name="line-2266"></a><span class='hs-comment'>-- &gt;     let l :: [Int]</span>
<a name="line-2267"></a><span class='hs-comment'>-- &gt;         l = [1..10000000]</span>
<a name="line-2268"></a><span class='hs-comment'>-- &gt;      in print $ average l</span>
<a name="line-2269"></a><span class='hs-comment'>-- &gt;   where</span>
<a name="line-2270"></a><span class='hs-comment'>-- &gt;     sumlen :: PairS Int Int -&gt; Int -&gt; PairS Int Int</span>
<a name="line-2271"></a><span class='hs-comment'>-- &gt;     sumlen (P s l) a = P (s + a) (l + 1)</span>
<a name="line-2272"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-2273"></a><span class='hs-comment'>-- &gt;     average is =</span>
<a name="line-2274"></a><span class='hs-comment'>-- &gt;         let (P s l) = foldl' sumlen (P 0 0) is</span>
<a name="line-2275"></a><span class='hs-comment'>-- &gt;          in (fromIntegral s :: Double) / fromIntegral l</span>
<a name="line-2276"></a><span class='hs-comment'>--</span>
<a name="line-2277"></a><span class='hs-comment'>-- the result is again obtained in constant space:</span>
<a name="line-2278"></a><span class='hs-comment'>--</span>
<a name="line-2279"></a><span class='hs-comment'>-- &gt; 5000000.5</span>
<a name="line-2280"></a><span class='hs-comment'>-- &gt;          102,176 bytes allocated in the heap</span>
<a name="line-2281"></a><span class='hs-comment'>-- &gt;            3,320 bytes copied during GC</span>
<a name="line-2282"></a><span class='hs-comment'>-- &gt;           44,376 bytes maximum residency (1 sample(s))</span>
<a name="line-2283"></a><span class='hs-comment'>-- &gt;           25,256 bytes maximum slop</span>
<a name="line-2284"></a><span class='hs-comment'>-- &gt;                3 MiB total memory in use (0 MB lost due to fragmentation)</span>
<a name="line-2285"></a><span class='hs-comment'>--</span>
<a name="line-2286"></a><span class='hs-comment'>-- (and, in fact, faster than with __@FRList@__ by a small factor).</span>
<a name="line-2287"></a><span class='hs-comment'>--</span>
<a name="line-2288"></a><span class='hs-comment'>-- The __@[]@__ list structure works as an efficient iterator when used</span>
<a name="line-2289"></a><span class='hs-comment'>-- just once.  When space-leaks via list reuse are not a concern, and/or</span>
<a name="line-2290"></a><span class='hs-comment'>-- memoisation is actually desirable, the regular list implementation is</span>
<a name="line-2291"></a><span class='hs-comment'>-- likely to be faster.  This is not a suggestion to replace all your uses of</span>
<a name="line-2292"></a><span class='hs-comment'>-- __@[]@__ with a generative alternative.</span>
<a name="line-2293"></a><span class='hs-comment'>--</span>
<a name="line-2294"></a><span class='hs-comment'>-- The __@FRList@__ type could be further extended with instances of 'Functor',</span>
<a name="line-2295"></a><span class='hs-comment'>-- 'Applicative', 'Monad', 'Alternative', etc., and could then provide a</span>
<a name="line-2296"></a><span class='hs-comment'>-- fully-featured list type, optimised for reuse without space-leaks.  If,</span>
<a name="line-2297"></a><span class='hs-comment'>-- however, all that's required is space-efficient, re-use friendly iteration,</span>
<a name="line-2298"></a><span class='hs-comment'>-- less is perhaps more, and just @Foldable@ may be sufficient.</span>
<a name="line-2299"></a>
<a name="line-2300"></a><span class='hs-comment'>--------------</span>
<a name="line-2301"></a>
<a name="line-2302"></a><span class='hs-comment'>-- $multipass</span>
<a name="line-2303"></a><span class='hs-comment'>--</span>
<a name="line-2304"></a><span class='hs-comment'>-- #multipass#</span>
<a name="line-2305"></a><span class='hs-comment'>-- In applications where you want to compute a composite function of a</span>
<a name="line-2306"></a><span class='hs-comment'>-- structure, which requires more than one aggregate as an input, it is</span>
<a name="line-2307"></a><span class='hs-comment'>-- generally best to compute all the aggregates in a single pass, rather</span>
<a name="line-2308"></a><span class='hs-comment'>-- than to traverse the same structure repeatedly.</span>
<a name="line-2309"></a><span class='hs-comment'>--</span>
<a name="line-2310"></a><span class='hs-comment'>-- The [@foldl@](<a href="http://hackage.haskell.org/package/foldl)">http://hackage.haskell.org/package/foldl)</a> package implements a</span>
<a name="line-2311"></a><span class='hs-comment'>-- robust general framework for dealing with this situation.  If you choose to</span>
<a name="line-2312"></a><span class='hs-comment'>-- to do it yourself, with a bit of care, the simplest cases are not difficult</span>
<a name="line-2313"></a><span class='hs-comment'>-- to handle directly.  You just need to accumulate the individual aggregates</span>
<a name="line-2314"></a><span class='hs-comment'>-- as __strict__ components of a single data type, and then apply a final</span>
<a name="line-2315"></a><span class='hs-comment'>-- transformation to it to extract the composite result.  For example,</span>
<a name="line-2316"></a><span class='hs-comment'>-- computing an average requires computing both the 'sum' and the 'length' of a</span>
<a name="line-2317"></a><span class='hs-comment'>-- (non-empty) structure and dividing the sum by the length:</span>
<a name="line-2318"></a><span class='hs-comment'>--</span>
<a name="line-2319"></a><span class='hs-comment'>-- &gt; import Data.Foldable (foldl')</span>
<a name="line-2320"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-2321"></a><span class='hs-comment'>-- &gt; data PairS a b = P !a !b -- We define a strict pair datatype</span>
<a name="line-2322"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-2323"></a><span class='hs-comment'>-- &gt; -- | Compute sum and length in a single pass, then reduce to the average.</span>
<a name="line-2324"></a><span class='hs-comment'>-- &gt; average :: (Foldable f, Fractional a) =&gt; f a -&gt; a</span>
<a name="line-2325"></a><span class='hs-comment'>-- &gt; average xs =</span>
<a name="line-2326"></a><span class='hs-comment'>-- &gt;     let sumlen (P s l) a = P (s + a) (l + 1 :: Int)</span>
<a name="line-2327"></a><span class='hs-comment'>-- &gt;         (P s l) = foldl' sumlen (P 0 0) xs</span>
<a name="line-2328"></a><span class='hs-comment'>-- &gt;      in s / fromIntegral l</span>
<a name="line-2329"></a><span class='hs-comment'>--</span>
<a name="line-2330"></a><span class='hs-comment'>-- The above example is somewhat contrived, some structures keep track of their</span>
<a name="line-2331"></a><span class='hs-comment'>-- length internally, and can return it in \(\mathcal{O}(1)\) time, so this</span>
<a name="line-2332"></a><span class='hs-comment'>-- particular recipe for averages is not always the most efficient.  In</span>
<a name="line-2333"></a><span class='hs-comment'>-- general, composite aggregate functions of large structures benefit from</span>
<a name="line-2334"></a><span class='hs-comment'>-- single-pass reduction.  This is especially the case when reuse of a list and</span>
<a name="line-2335"></a><span class='hs-comment'>-- memoisation of its elements is thereby avoided,</span>
<a name="line-2336"></a>
<a name="line-2337"></a><span class='hs-comment'>--------------</span>
<a name="line-2338"></a>
<a name="line-2339"></a><span class='hs-comment'>-- $laws</span>
<a name="line-2340"></a><span class='hs-comment'>-- #laws#</span>
<a name="line-2341"></a><span class='hs-comment'>--</span>
<a name="line-2342"></a><span class='hs-comment'>-- The type constructor 'Endo' from "Data.Monoid", associates with each type</span>
<a name="line-2343"></a><span class='hs-comment'>-- __@b@__ the __@newtype@__-encapsulated type of functions mapping __@b@__ to</span>
<a name="line-2344"></a><span class='hs-comment'>-- itself.  Functions from a type to itself are called /endomorphisms/, hence</span>
<a name="line-2345"></a><span class='hs-comment'>-- the name /Endo/.  The type __@Endo b@__ is a 'Monoid' under function</span>
<a name="line-2346"></a><span class='hs-comment'>-- composition:</span>
<a name="line-2347"></a><span class='hs-comment'>--</span>
<a name="line-2348"></a><span class='hs-comment'>-- &gt; newtype Endo b = Endo { appEndo :: b -&gt; b }</span>
<a name="line-2349"></a><span class='hs-comment'>-- &gt; instance Semigroup Endo b where</span>
<a name="line-2350"></a><span class='hs-comment'>-- &gt;     Endo f &lt;&gt; Endo g = Endo (f . g)</span>
<a name="line-2351"></a><span class='hs-comment'>-- &gt; instance Monoid Endo b where</span>
<a name="line-2352"></a><span class='hs-comment'>-- &gt;     mempty = Endo id</span>
<a name="line-2353"></a><span class='hs-comment'>--</span>
<a name="line-2354"></a><span class='hs-comment'>-- For every 'Monoid' m, we also have a 'Dual' monoid __@Dual m@__ which</span>
<a name="line-2355"></a><span class='hs-comment'>-- combines elements in the opposite order:</span>
<a name="line-2356"></a><span class='hs-comment'>--</span>
<a name="line-2357"></a><span class='hs-comment'>-- &gt; newtype Dual m = Dual { getDual :: m }</span>
<a name="line-2358"></a><span class='hs-comment'>-- &gt; instance Semigroup m =&gt; Semigroup Dual m where</span>
<a name="line-2359"></a><span class='hs-comment'>-- &gt;     Dual a &lt;&gt; Dual b = Dual (b &lt;&gt; a)</span>
<a name="line-2360"></a><span class='hs-comment'>-- &gt; instance Monoid m =&gt; Monoid Dual m where</span>
<a name="line-2361"></a><span class='hs-comment'>-- &gt;     mempty = Dual mempty</span>
<a name="line-2362"></a><span class='hs-comment'>--</span>
<a name="line-2363"></a><span class='hs-comment'>-- With the above preliminaries out of the way, 'Foldable' instances are</span>
<a name="line-2364"></a><span class='hs-comment'>-- expected to satisfy the following laws:</span>
<a name="line-2365"></a><span class='hs-comment'>--</span>
<a name="line-2366"></a><span class='hs-comment'>-- The 'foldr' method must be equivalent in value and strictness to replacing</span>
<a name="line-2367"></a><span class='hs-comment'>-- each element __@a@__ of a 'Foldable' structure with __@Endo (f a)@__,</span>
<a name="line-2368"></a><span class='hs-comment'>-- composing these via 'foldMap' and applying the result to the base case</span>
<a name="line-2369"></a><span class='hs-comment'>-- __@z@__:</span>
<a name="line-2370"></a><span class='hs-comment'>--</span>
<a name="line-2371"></a><span class='hs-comment'>-- &gt; foldr f z t = appEndo (foldMap (Endo . f) t ) z</span>
<a name="line-2372"></a><span class='hs-comment'>--</span>
<a name="line-2373"></a><span class='hs-comment'>-- Likewise, the 'foldl' method must be equivalent in value and strictness</span>
<a name="line-2374"></a><span class='hs-comment'>-- to composing the functions __@flip f a@__ in reverse order and applying</span>
<a name="line-2375"></a><span class='hs-comment'>-- the result to the base case:</span>
<a name="line-2376"></a><span class='hs-comment'>--</span>
<a name="line-2377"></a><span class='hs-comment'>-- &gt; foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z</span>
<a name="line-2378"></a><span class='hs-comment'>--</span>
<a name="line-2379"></a><span class='hs-comment'>-- When the elements of the structure are taken from a 'Monoid', the</span>
<a name="line-2380"></a><span class='hs-comment'>-- definition of 'fold' must agree with __@foldMap id@__:</span>
<a name="line-2381"></a><span class='hs-comment'>--</span>
<a name="line-2382"></a><span class='hs-comment'>-- &gt; fold = foldMap id</span>
<a name="line-2383"></a><span class='hs-comment'>--</span>
<a name="line-2384"></a><span class='hs-comment'>-- The 'length' method must agree with a 'foldMap' mapping each element to</span>
<a name="line-2385"></a><span class='hs-comment'>-- __@Sum 1@__ (The 'Sum' type abstracts numbers as a monoid under addition).</span>
<a name="line-2386"></a><span class='hs-comment'>--</span>
<a name="line-2387"></a><span class='hs-comment'>-- &gt; length = getSum . foldMap (Sum . const 1)</span>
<a name="line-2388"></a><span class='hs-comment'>--</span>
<a name="line-2389"></a><span class='hs-comment'>-- @sum@, @product@, @maximum@, and @minimum@ should all be essentially</span>
<a name="line-2390"></a><span class='hs-comment'>-- equivalent to @foldMap@ forms, such as</span>
<a name="line-2391"></a><span class='hs-comment'>--</span>
<a name="line-2392"></a><span class='hs-comment'>-- &gt; sum     = getSum     . foldMap' Sum</span>
<a name="line-2393"></a><span class='hs-comment'>-- &gt; product = getProduct . foldMap' Product</span>
<a name="line-2394"></a><span class='hs-comment'>--</span>
<a name="line-2395"></a><span class='hs-comment'>-- but are generally more efficient when defined more directly as:</span>
<a name="line-2396"></a><span class='hs-comment'>--</span>
<a name="line-2397"></a><span class='hs-comment'>-- &gt; sum = foldl' (+) 0</span>
<a name="line-2398"></a><span class='hs-comment'>-- &gt; product = foldl' (*) 1</span>
<a name="line-2399"></a><span class='hs-comment'>--</span>
<a name="line-2400"></a><span class='hs-comment'>-- If the 'Foldable' structure has a 'Functor' instance, then for every</span>
<a name="line-2401"></a><span class='hs-comment'>-- function __@f@__ mapping the elements into a 'Monoid', it should satisfy:</span>
<a name="line-2402"></a><span class='hs-comment'>--</span>
<a name="line-2403"></a><span class='hs-comment'>-- &gt; foldMap f = fold . fmap f</span>
<a name="line-2404"></a><span class='hs-comment'>--</span>
<a name="line-2405"></a><span class='hs-comment'>-- which implies that</span>
<a name="line-2406"></a><span class='hs-comment'>--</span>
<a name="line-2407"></a><span class='hs-comment'>-- &gt; foldMap f . fmap g = foldMap (f . g)</span>
<a name="line-2408"></a><span class='hs-comment'>--</span>
<a name="line-2409"></a>
<a name="line-2410"></a><span class='hs-comment'>--------------</span>
<a name="line-2411"></a>
<a name="line-2412"></a><span class='hs-comment'>-- $notes</span>
<a name="line-2413"></a><span class='hs-comment'>--</span>
<a name="line-2414"></a><span class='hs-comment'>-- #notes#</span>
<a name="line-2415"></a><span class='hs-comment'>-- Since 'Foldable' does not have 'Functor' as a superclass, it is possible to</span>
<a name="line-2416"></a><span class='hs-comment'>-- define 'Foldable' instances for structures that constrain their element</span>
<a name="line-2417"></a><span class='hs-comment'>-- types.  Therefore, __@Set@__ can be 'Foldable', even though sets keep their</span>
<a name="line-2418"></a><span class='hs-comment'>-- elements in ascending order.  This requires the elements to be comparable,</span>
<a name="line-2419"></a><span class='hs-comment'>-- which precludes defining a 'Functor' instance for @Set@.</span>
<a name="line-2420"></a><span class='hs-comment'>--</span>
<a name="line-2421"></a><span class='hs-comment'>-- The 'Foldable' class makes it possible to use idioms familiar from the @List@</span>
<a name="line-2422"></a><span class='hs-comment'>-- type with container structures that are better suited to the task at hand.</span>
<a name="line-2423"></a><span class='hs-comment'>-- This supports use of more appropriate 'Foldable' data types, such as @Seq@,</span>
<a name="line-2424"></a><span class='hs-comment'>-- @Set@, @NonEmpty@, etc., without requiring new idioms (see</span>
<a name="line-2425"></a><span class='hs-comment'>-- [[1\]](#uselistsnot) for when not to use lists).</span>
<a name="line-2426"></a><span class='hs-comment'>--</span>
<a name="line-2427"></a><span class='hs-comment'>-- The more general methods of the 'Foldable' class are now exported by the</span>
<a name="line-2428"></a><span class='hs-comment'>-- "Prelude" in place of the original List-specific methods (see the</span>
<a name="line-2429"></a><span class='hs-comment'>-- [FTP Proposal](https://wiki.haskell.org/Foldable_Traversable_In_Prelude)).</span>
<a name="line-2430"></a><span class='hs-comment'>-- The List-specific variants are for now still available in "GHC.OldList", but</span>
<a name="line-2431"></a><span class='hs-comment'>-- that module is intended only as a transitional aid, and may be removed in</span>
<a name="line-2432"></a><span class='hs-comment'>-- the future.</span>
<a name="line-2433"></a><span class='hs-comment'>--</span>
<a name="line-2434"></a><span class='hs-comment'>-- Surprises can arise from the @Foldable@ instance of the 2-tuple @(a,)@ which</span>
<a name="line-2435"></a><span class='hs-comment'>-- now behaves as a 1-element @Foldable@ container in its second slot.  In</span>
<a name="line-2436"></a><span class='hs-comment'>-- contexts where a specific monomorphic type is expected, and you want to be</span>
<a name="line-2437"></a><span class='hs-comment'>-- able to rely on type errors to guide refactoring, it may make sense to</span>
<a name="line-2438"></a><span class='hs-comment'>-- define and use less-polymorphic variants of some of the @Foldable@ methods.</span>
<a name="line-2439"></a><span class='hs-comment'>--</span>
<a name="line-2440"></a><span class='hs-comment'>-- Below are two examples showing a definition of a reusable less-polymorphic</span>
<a name="line-2441"></a><span class='hs-comment'>-- 'sum' and a one-off in-line specialisation of 'length':</span>
<a name="line-2442"></a><span class='hs-comment'>--</span>
<a name="line-2443"></a><span class='hs-comment'>-- &gt; {-# LANGUAGE TypeApplications #-}</span>
<a name="line-2444"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-2445"></a><span class='hs-comment'>-- &gt; mySum :: Num a =&gt; [a] -&gt; a</span>
<a name="line-2446"></a><span class='hs-comment'>-- &gt; mySum = sum</span>
<a name="line-2447"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-2448"></a><span class='hs-comment'>-- &gt; type SlowVector a = [a]</span>
<a name="line-2449"></a><span class='hs-comment'>-- &gt; slowLength :: SlowVector -&gt; Int</span>
<a name="line-2450"></a><span class='hs-comment'>-- &gt; slowLength v = length @[] v</span>
<a name="line-2451"></a><span class='hs-comment'>--</span>
<a name="line-2452"></a><span class='hs-comment'>-- In both cases, if the data type to which the function is applied changes</span>
<a name="line-2453"></a><span class='hs-comment'>-- to something other than a list, the call-site will no longer compile until</span>
<a name="line-2454"></a><span class='hs-comment'>-- appropriate changes are made.</span>
<a name="line-2455"></a>
<a name="line-2456"></a><span class='hs-comment'>-- $linear</span>
<a name="line-2457"></a><span class='hs-comment'>--</span>
<a name="line-2458"></a><span class='hs-comment'>-- It is perhaps worth noting that since the __`elem`__ function in the</span>
<a name="line-2459"></a><span class='hs-comment'>-- Foldable class carries only an __`Eq`__ constraint on the element type,</span>
<a name="line-2460"></a><span class='hs-comment'>-- search for the presence or absence of an element in the structure generally</span>
<a name="line-2461"></a><span class='hs-comment'>-- takes \(\mathcal{O}(n)\) time, even for ordered structures like __@Set@__</span>
<a name="line-2462"></a><span class='hs-comment'>-- that are potentially capable of performing the search faster.  (The @member@</span>
<a name="line-2463"></a><span class='hs-comment'>-- function of the @Set@ module carries an `Ord` constraint, and can perform</span>
<a name="line-2464"></a><span class='hs-comment'>-- the search in \(\mathcal{O}(log\ n)\) time).</span>
<a name="line-2465"></a><span class='hs-comment'>--</span>
<a name="line-2466"></a><span class='hs-comment'>-- An alternative to Foldable's __`elem`__ method is required in order to</span>
<a name="line-2467"></a><span class='hs-comment'>-- abstract potentially faster than linear search over general container</span>
<a name="line-2468"></a><span class='hs-comment'>-- structures.  This can be achieved by defining an additional type class (e.g.</span>
<a name="line-2469"></a><span class='hs-comment'>-- @HasMember@ below).  Instances of such a type class (that are also</span>
<a name="line-2470"></a><span class='hs-comment'>-- `Foldable') can employ the `elem` linear search as a last resort, when</span>
<a name="line-2471"></a><span class='hs-comment'>-- faster search is not supported.</span>
<a name="line-2472"></a><span class='hs-comment'>--</span>
<a name="line-2473"></a><span class='hs-comment'>-- &gt; {-# LANGUAGE FlexibleInstances, MultiParamTypeClasses #-}</span>
<a name="line-2474"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-2475"></a><span class='hs-comment'>-- &gt; import qualified Data.Set as Set</span>
<a name="line-2476"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-2477"></a><span class='hs-comment'>-- &gt; class Eq a =&gt; HasMember t a where</span>
<a name="line-2478"></a><span class='hs-comment'>-- &gt;     member :: a -&gt; t a -&gt; Bool</span>
<a name="line-2479"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-2480"></a><span class='hs-comment'>-- &gt; instance Eq a =&gt; HasMember [] a where</span>
<a name="line-2481"></a><span class='hs-comment'>-- &gt;     member = elem</span>
<a name="line-2482"></a><span class='hs-comment'>-- &gt; [...]</span>
<a name="line-2483"></a><span class='hs-comment'>-- &gt; instance Ord a =&gt; HasMember Set.Set a where</span>
<a name="line-2484"></a><span class='hs-comment'>-- &gt;     member = Set.member</span>
<a name="line-2485"></a><span class='hs-comment'>--</span>
<a name="line-2486"></a><span class='hs-comment'>-- The above suggests that 'elem' may be a misfit in the 'Foldable' class.</span>
<a name="line-2487"></a><span class='hs-comment'>-- Alternative design ideas are solicited on GHC's bug tracker via issue</span>
<a name="line-2488"></a><span class='hs-comment'>-- [\#20421](https://gitlab.haskell.org/ghc/ghc/-/issues/20421).</span>
<a name="line-2489"></a><span class='hs-comment'>--</span>
<a name="line-2490"></a><span class='hs-comment'>-- Note that some structure-specific optimisations may of course be possible</span>
<a name="line-2491"></a><span class='hs-comment'>-- directly in the corresponding @Foldable@ instance, e.g. with @Set@ the size</span>
<a name="line-2492"></a><span class='hs-comment'>-- of the set is known in advance, without iterating to count the elements, and</span>
<a name="line-2493"></a><span class='hs-comment'>-- its `length` instance takes advantage of this to return the size directly.</span>
<a name="line-2494"></a>
<a name="line-2495"></a><span class='hs-comment'>--------------</span>
<a name="line-2496"></a>
<a name="line-2497"></a><span class='hs-comment'>-- $also</span>
<a name="line-2498"></a><span class='hs-comment'>--</span>
<a name="line-2499"></a><span class='hs-comment'>--  * [1] #uselistsnot# \"When You Should Use Lists in Haskell (Mostly, You Should Not)\",</span>
<a name="line-2500"></a><span class='hs-comment'>--    by Johannes Waldmann,</span>
<a name="line-2501"></a><span class='hs-comment'>--    in arxiv.org, Programming Languages (cs.PL), at</span>
<a name="line-2502"></a><span class='hs-comment'>--    &lt;https://arxiv.org/abs/1808.08329&gt;.</span>
<a name="line-2503"></a><span class='hs-comment'>--</span>
<a name="line-2504"></a><span class='hs-comment'>--  * [2] \"The Essence of the Iterator Pattern\",</span>
<a name="line-2505"></a><span class='hs-comment'>--    by Jeremy Gibbons and Bruno Oliveira,</span>
<a name="line-2506"></a><span class='hs-comment'>--    in /Mathematically-Structured Functional Programming/, 2006, online at</span>
<a name="line-2507"></a><span class='hs-comment'>--    &lt;<a href="http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator">http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator</a>&gt;.</span>
<a name="line-2508"></a><span class='hs-comment'>--</span>
<a name="line-2509"></a><span class='hs-comment'>--  * [3] \"A tutorial on the universality and expressiveness of fold\",</span>
<a name="line-2510"></a><span class='hs-comment'>--    by Graham Hutton, J\. Functional Programming 9 (4): 355–372, July 1999,</span>
<a name="line-2511"></a><span class='hs-comment'>--    online at &lt;<a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">http://www.cs.nott.ac.uk/~pszgmh/fold.pdf</a>&gt;.</span>
</pre></body>
</html>
