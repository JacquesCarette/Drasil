-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Build System SubPackage
--   
--   Please see the README on GitHub at
--   <a>https://github.com/JacquesCarette/Drasil#readme</a>
@package drasil-code-base
@version 0.1.9.0

module Language.Drasil.Code.Expr

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product).
data VVVBinOp
Cross :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
AddI :: AssocArithOper
AddRe :: AssocArithOper
MulI :: AssocArithOper
MulRe :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | Expression language where all terms also denote a term in GOOL (i.e.
--   translation is total and meaning preserving).
data CodeExpr

-- | Brings literals into the expression language.
[Lit] :: Literal -> CodeExpr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [CodeExpr] -> CodeExpr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [CodeExpr] -> CodeExpr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> CodeExpr

-- | A function call accepts a list of parameters and a list of named
--   parameters. For example
--   
--   <ul>
--   <li>F(x) is (FCall F [x] []).</li>
--   <li>F(x,y) would be (FCall F [x,y]).</li>
--   <li>F(x,n=y) would be (FCall F [x] [(n,y)]).</li>
--   </ul>
[FCall] :: UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Actor creation given <a>UID</a>, parameters, and named parameters.
[New] :: UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Message an actor:
--   
--   <ul>
--   <li>1st <a>UID</a> is the actor,</li>
--   <li>2nd <a>UID</a> is the method.</li>
--   </ul>
[Message] :: UID -> UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Access a field of an actor:
--   
--   <ul>
--   <li>1st <a>UID</a> is the actor,</li>
--   <li>2nd <a>UID</a> is the field.</li>
--   </ul>
[Field] :: UID -> UID -> CodeExpr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(CodeExpr, CodeExpr)] -> CodeExpr

-- | Represents a matrix of expressions.
[Matrix] :: [[CodeExpr]] -> CodeExpr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> CodeExpr -> CodeExpr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Operators are generalized arithmetic operators over a
--   <tt>DomainDesc</tt> of an <tt>Expr</tt>. Could be called BigOp. ex:
--   Summation is represented via <tt>Add</tt> over a discrete domain.
[Operator] :: AssocArithOper -> DiscreteDomainDesc CodeExpr CodeExpr -> CodeExpr -> CodeExpr

-- | The expression is an element of a space. IsIn :: Expr -&gt; Space
--   -&gt; Expr | A different kind of <tt>IsIn</tt>. A <a>UID</a> is an
--   element of an interval.
[RealI] :: UID -> RealInterval CodeExpr CodeExpr -> CodeExpr
instance GHC.Classes.Eq Language.Drasil.Code.Expr.UFuncVN
instance GHC.Classes.Eq Language.Drasil.Code.Expr.UFuncVV
instance GHC.Classes.Eq Language.Drasil.Code.Expr.UFuncB
instance GHC.Classes.Eq Language.Drasil.Code.Expr.UFunc
instance GHC.Classes.Eq Language.Drasil.Code.Expr.AssocBoolOper
instance GHC.Classes.Eq Language.Drasil.Code.Expr.AssocArithOper
instance GHC.Classes.Eq Language.Drasil.Code.Expr.VVNBinOp
instance GHC.Classes.Eq Language.Drasil.Code.Expr.VVVBinOp
instance GHC.Classes.Eq Language.Drasil.Code.Expr.OrdBinOp
instance GHC.Classes.Eq Language.Drasil.Code.Expr.LABinOp
instance GHC.Classes.Eq Language.Drasil.Code.Expr.BoolBinOp
instance GHC.Classes.Eq Language.Drasil.Code.Expr.EqBinOp
instance GHC.Classes.Eq Language.Drasil.Code.Expr.ArithBinOp
instance Language.Drasil.Literal.Class.LiteralC Language.Drasil.Code.Expr.CodeExpr

module Language.Drasil.Code.Expr.Convert

-- | Render an algebraic expression into our code expression language.
expr :: Expr -> CodeExpr

-- | Convert <tt>RealInterval</tt> <tt>Expr</tt> <tt>Expr</tt>s into
--   <tt>RealInterval</tt> <a>CodeExpr</a> <a>CodeExpr</a>s.
realInterval :: RealInterval Expr Expr -> RealInterval CodeExpr CodeExpr

-- | Convert constrained expressions (<tt>ConstraintE</tt>) into
--   <tt>Constraint''CodeExpr</tt>s.
constraint :: ConstraintE -> Constraint CodeExpr
class CanGenCode e
toCodeExpr :: CanGenCode e => e -> CodeExpr
instance Language.Drasil.Code.Expr.Convert.CanGenCode Language.Drasil.Literal.Lang.Literal
instance Language.Drasil.Code.Expr.Convert.CanGenCode Language.Drasil.Expr.Lang.Expr

module Language.Drasil.Code.Expr.Extract

-- | Get dependencies from an equation.
eDep :: CodeExpr -> [UID]

-- | Get dependencies from an equation, without functions.
eDep' :: CodeExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>eNames</a>).
eNamesRI :: RealInterval CodeExpr CodeExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names without functions (similar to <a>eNames'</a>).
eNamesRI' :: RealInterval CodeExpr CodeExpr -> [UID]


-- | Defines chunk types for use in code generation.
module Language.Drasil.Chunk.CodeBase

-- | A <a>CodeIdea</a> must include some code and its name.
class CodeIdea c

-- | Name of the idea.
codeName :: CodeIdea c => c -> String

-- | Code chunk associated with the idea.
codeChunk :: CodeIdea c => c -> CodeChunk

-- | A <a>DefiningCodeExpr</a> must have it's underlying chunk defined in
--   the CodeExpr language.
class CodeIdea c => DefiningCodeExpr c
codeExpr :: DefiningCodeExpr c => Lens' c CodeExpr

-- | Convert the program name to an abbreviated <a>String</a> without any
--   special characters.
programName :: CommonIdea c => c -> String

-- | Used when a function name needs to be distinguishable from a variable
--   name.
funcPrefix :: String

-- | Details if a piece of code is meant to be a variable or a function.
data VarOrFunc
Var :: VarOrFunc
Func :: VarOrFunc

-- | Basic chunk representation in the code generation context. Contains a
--   QuantityDict and the kind of code (variable or function).
data CodeChunk
CodeC :: QuantityDict -> VarOrFunc -> CodeChunk
[_qc] :: CodeChunk -> QuantityDict
[kind] :: CodeChunk -> VarOrFunc
qc :: Lens' CodeChunk QuantityDict

-- | Chunk representing a variable. The <tt>obv</tt> field represents the
--   object containing this variable, if it is an object field.
data CodeVarChunk
CodeVC :: CodeChunk -> Maybe CodeChunk -> CodeVarChunk
[_ccv] :: CodeVarChunk -> CodeChunk
[_obv] :: CodeVarChunk -> Maybe CodeChunk
obv :: Lens' CodeVarChunk (Maybe CodeChunk)
ccv :: Lens' CodeVarChunk CodeChunk

-- | Chunk representing a function.
newtype CodeFuncChunk
CodeFC :: CodeChunk -> CodeFuncChunk
[_ccf] :: CodeFuncChunk -> CodeChunk
ccf :: Iso' CodeFuncChunk CodeChunk

-- | Construct a <a>CodeVarChunk</a> from a <a>Quantity</a>.
quantvar :: (Quantity c, MayHaveUnit c) => c -> CodeVarChunk

-- | Construct a <a>CodeFuncChunk</a> from a <a>Quantity</a>.
quantfunc :: (Quantity c, MayHaveUnit c) => c -> CodeFuncChunk

-- | Get a list of <a>CodeChunk</a>s from an equation.
codevars :: CodeExpr -> ChunkDB -> [CodeVarChunk]

-- | Get a list of <a>CodeChunk</a>s from an equation (no functions).
codevars' :: CodeExpr -> ChunkDB -> [CodeVarChunk]

-- | Make a <a>CodeVarChunk</a> from a <a>UID</a> in the <a>ChunkDB</a>.
varResolve :: ChunkDB -> UID -> CodeVarChunk

-- | Make a <a>CodeFuncChunk</a> from a <a>UID</a> in the <a>ChunkDB</a>.
funcResolve :: ChunkDB -> UID -> CodeFuncChunk
listToArray :: CodeVarChunk -> CodeVarChunk
instance Language.Drasil.UID.HasUID Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.Space.HasSpace Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.Symbol.HasSymbol Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.Classes.Callable Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.UID.HasUID Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance Language.Drasil.Space.HasSpace Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance Language.Drasil.Symbol.HasSymbol Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance Language.Drasil.UID.HasUID Language.Drasil.Chunk.CodeBase.CodeChunk
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.CodeBase.CodeChunk
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.CodeBase.CodeChunk
instance Language.Drasil.Space.HasSpace Language.Drasil.Chunk.CodeBase.CodeChunk
instance Language.Drasil.Symbol.HasSymbol Language.Drasil.Chunk.CodeBase.CodeChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.CodeBase.CodeChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.CodeBase.CodeChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.CodeBase.CodeChunk

module Language.Drasil.Code.Expr.Precedence

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | eprec - <a>Expression</a> precedence.
eprec :: CodeExpr -> Int


-- | Re-exporting modules
module Language.Drasil.Code.Expr.Development

-- | Expression language where all terms also denote a term in GOOL (i.e.
--   translation is total and meaning preserving).
data CodeExpr

-- | Brings literals into the expression language.
[Lit] :: Literal -> CodeExpr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [CodeExpr] -> CodeExpr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [CodeExpr] -> CodeExpr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> CodeExpr

-- | A function call accepts a list of parameters and a list of named
--   parameters. For example
--   
--   <ul>
--   <li>F(x) is (FCall F [x] []).</li>
--   <li>F(x,y) would be (FCall F [x,y]).</li>
--   <li>F(x,n=y) would be (FCall F [x] [(n,y)]).</li>
--   </ul>
[FCall] :: UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Actor creation given <a>UID</a>, parameters, and named parameters.
[New] :: UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Message an actor:
--   
--   <ul>
--   <li>1st <a>UID</a> is the actor,</li>
--   <li>2nd <a>UID</a> is the method.</li>
--   </ul>
[Message] :: UID -> UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Access a field of an actor:
--   
--   <ul>
--   <li>1st <a>UID</a> is the actor,</li>
--   <li>2nd <a>UID</a> is the field.</li>
--   </ul>
[Field] :: UID -> UID -> CodeExpr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(CodeExpr, CodeExpr)] -> CodeExpr

-- | Represents a matrix of expressions.
[Matrix] :: [[CodeExpr]] -> CodeExpr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> CodeExpr -> CodeExpr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Operators are generalized arithmetic operators over a
--   <tt>DomainDesc</tt> of an <tt>Expr</tt>. Could be called BigOp. ex:
--   Summation is represented via <tt>Add</tt> over a discrete domain.
[Operator] :: AssocArithOper -> DiscreteDomainDesc CodeExpr CodeExpr -> CodeExpr -> CodeExpr

-- | The expression is an element of a space. IsIn :: Expr -&gt; Space
--   -&gt; Expr | A different kind of <tt>IsIn</tt>. A <a>UID</a> is an
--   element of an interval.
[RealI] :: UID -> RealInterval CodeExpr CodeExpr -> CodeExpr

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product).
data VVVBinOp
Cross :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
AddI :: AssocArithOper
AddRe :: AssocArithOper
MulI :: AssocArithOper
MulRe :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | Get dependencies from an equation.
eDep :: CodeExpr -> [UID]

-- | Get dependencies from an equation, without functions.
eDep' :: CodeExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>eNames</a>).
eNamesRI :: RealInterval CodeExpr CodeExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names without functions (similar to <a>eNames'</a>).
eNamesRI' :: RealInterval CodeExpr CodeExpr -> [UID]

-- | eprec - <a>Expression</a> precedence.
eprec :: CodeExpr -> Int

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | Render an algebraic expression into our code expression language.
expr :: Expr -> CodeExpr

-- | Convert <tt>RealInterval</tt> <tt>Expr</tt> <tt>Expr</tt>s into
--   <tt>RealInterval</tt> <a>CodeExpr</a> <a>CodeExpr</a>s.
realInterval :: RealInterval Expr Expr -> RealInterval CodeExpr CodeExpr

-- | Convert constrained expressions (<tt>ConstraintE</tt>) into
--   <tt>Constraint''CodeExpr</tt>s.
constraint :: ConstraintE -> Constraint CodeExpr


-- | Defines constructors for <a>CodeExpr</a>s often used in relation to
--   code generation.
module Language.Drasil.CodeExpr

-- | Expression language where all terms also denote a term in GOOL (i.e.
--   translation is total and meaning preserving).
data CodeExpr

-- | Smart constructor for chunk symbols.
sy :: (HasUID u, HasSymbol u) => u -> CodeExpr
str :: LiteralC r => String -> r
int :: LiteralC r => Integer -> r
dbl :: LiteralC r => Double -> r
exactDbl :: LiteralC r => Integer -> r

-- | Smart constructor for matrices.
matrix :: [[CodeExpr]] -> CodeExpr

-- | Smart constructor for fractions.
frac :: Integer -> Integer -> CodeExpr

-- | Smart constructor for rational expressions (only in 1/x form).
recip_ :: CodeExpr -> CodeExpr

-- | Smart constructor for taking the absolute value of an expression.
abs_ :: CodeExpr -> CodeExpr

-- | Smart constructor for negating an expression.
neg :: CodeExpr -> CodeExpr

-- | Smart constructor to take the log of an expression.
log :: CodeExpr -> CodeExpr

-- | Smart constructor to take the ln of an expression.
ln :: CodeExpr -> CodeExpr

-- | Smart constructor to take the square root of an expression.
sqrt :: CodeExpr -> CodeExpr

-- | Smart constructor to apply sin to an expression.
sin :: CodeExpr -> CodeExpr

-- | Smart constructor to apply cos to an expression.
cos :: CodeExpr -> CodeExpr

-- | Smart constructor to apply tan to an expression.
tan :: CodeExpr -> CodeExpr

-- | Smart constructor to apply sec to an expression.
sec :: CodeExpr -> CodeExpr

-- | Smart constructor to apply csc to an expression.
csc :: CodeExpr -> CodeExpr

-- | Smart constructor to apply cot to an expression.
cot :: CodeExpr -> CodeExpr

-- | Smart constructor to apply arcsin to an expression.
arcsin :: CodeExpr -> CodeExpr

-- | Smart constructor to apply arccos to an expression.
arccos :: CodeExpr -> CodeExpr

-- | Smart constructor to apply arctan to an expression.
arctan :: CodeExpr -> CodeExpr

-- | Smart constructor for the exponential (base e) function.
exp :: CodeExpr -> CodeExpr

-- | Smart constructor for calculating the dimension of a vector.
dim :: CodeExpr -> CodeExpr

-- | Smart constructor for calculating the normal form of a vector.
norm :: CodeExpr -> CodeExpr

-- | Smart constructor for applying logical negation to an expression.
not_ :: CodeExpr -> CodeExpr

-- | Smart constructor for the boolean <i>and</i> operator.
($&&) :: CodeExpr -> CodeExpr -> CodeExpr

-- | Smart constructor for subtracting two expressions.
($-) :: CodeExpr -> CodeExpr -> CodeExpr

-- | Smart constructor for dividing two expressions.
($/) :: CodeExpr -> CodeExpr -> CodeExpr

-- | Smart constructor for rasing the first expression to the power of the
--   second.
($^) :: CodeExpr -> CodeExpr -> CodeExpr

-- | Smart constructor to show that one expression implies the other
--   (conditional operator).
($=>) :: CodeExpr -> CodeExpr -> CodeExpr

-- | Smart constructor to show that an expression exists if and only if
--   another expression exists (biconditional operator).
($<=>) :: CodeExpr -> CodeExpr -> CodeExpr

-- | Smart constructor for equating two expressions.
($=) :: CodeExpr -> CodeExpr -> CodeExpr

-- | Smart constructor for showing that two expressions are not equal.
($!=) :: CodeExpr -> CodeExpr -> CodeExpr

-- | Less than.
($<) :: CodeExpr -> CodeExpr -> CodeExpr

-- | Greater than.
($>) :: CodeExpr -> CodeExpr -> CodeExpr

-- | Less than or equal to.
($<=) :: CodeExpr -> CodeExpr -> CodeExpr

-- | Greater than or equal to.
($>=) :: CodeExpr -> CodeExpr -> CodeExpr

-- | Add two expressions (Integers).
addI :: CodeExpr -> CodeExpr -> CodeExpr

-- | Add two expressions (Real numbers).
addRe :: CodeExpr -> CodeExpr -> CodeExpr

-- | Multiply two expressions (Integers).
mulI :: CodeExpr -> CodeExpr -> CodeExpr

-- | Multiply two expressions (Real numbers).
mulRe :: CodeExpr -> CodeExpr -> CodeExpr

-- | Smart constructor for indexing.
idx :: CodeExpr -> CodeExpr -> CodeExpr

-- | Constructs a CodeExpr for actor creation (constructor call)
new :: (Callable f, HasUID f, CodeIdea f) => f -> [CodeExpr] -> CodeExpr

-- | Constructs a CodeExpr for actor creation (constructor call) that uses
--   named arguments
newWithNamedArgs :: (Callable f, HasUID f, CodeIdea f, HasUID a, IsArgumentName a) => f -> [CodeExpr] -> [(a, CodeExpr)] -> CodeExpr

-- | Constructs a CodeExpr for actor messaging (method call)
message :: (Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c) => c -> f -> [CodeExpr] -> CodeExpr

-- | Constructs a CodeExpr for actor messaging (method call) that uses
--   named arguments
msgWithNamedArgs :: (Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c, HasUID a, IsArgumentName a) => c -> f -> [CodeExpr] -> [(a, CodeExpr)] -> CodeExpr

-- | Constructs a CodeExpr representing the field of an actor
field :: CodeVarChunk -> CodeVarChunk -> CodeExpr

-- | Applies a given function with a list of parameters.
apply :: (HasUID f, HasSymbol f) => f -> [CodeExpr] -> CodeExpr

-- | Similar to <a>apply</a>, but converts second argument into
--   <tt>Symbol</tt>s.
apply1 :: (HasUID f, HasSymbol f, HasUID a, HasSymbol a) => f -> a -> CodeExpr

-- | Similar to <a>apply</a>, but the applied function takes two parameters
--   (which are both <tt>Symbol</tt>s).
apply2 :: (HasUID f, HasSymbol f, HasUID a, HasSymbol a, HasUID b, HasSymbol b) => f -> a -> b -> CodeExpr

-- | Similar to <a>apply</a>, but takes a relation to apply to
--   <a>FCall</a>.
applyWithNamedArgs :: (HasUID f, HasSymbol f, HasUID a, IsArgumentName a) => f -> [CodeExpr] -> [(a, CodeExpr)] -> CodeExpr

-- | Render an algebraic expression into our code expression language.
expr :: Expr -> CodeExpr
