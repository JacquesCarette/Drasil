\chapter{Introduction}
% The following is a working draft. All changes will be summarized at the top.

% --- Begin copied content from introduction.tex ---


Documentation is good\cite{Hyman1990, Kotula2000, Thimbleby1986, Parnas2010, 
ParnasAndClements1986,
ParnasEtAl1994, Roache1998, CarverEtAl2007, Kelly2007, Kelly2015, 
AckroydEtAl2008, EasterbrookAndJohns2009, Kelly2013, SandersAndKelly2008, 
MatthewsEtAl2008, HattonAndRoberts1994, Knuth1984, Ramsey1994, 
AlMatiiAndBoujarwah2002, JohnsonAndJohnson1997, 
FritzsonGunnarssonAndJirstrand2002,
ShumAndCook1993, PieterseKourieAndBoake2004, Simonis2003, SchulteEtAl2012,
Leisch2002, LenthEtAl2007, Lenth2009, FlattEtAl2009, SmithEtAl2015SQJ,
SmithEtAl2015-SS-TR, SmithEtAl2013, SmithKoothoorAndNedialkov2014, 
SmithAndKoothoor2016, SmithAndYu2009}, yet it is not often prioritized on 
software projects. 


In this thesis, we use the command \sf{} to refer to any artifact produced
during software development that conveys knowledge: source code, requirements, 
design documents, test cases, or user manuals.

Code and other software artifacts (\sfs{}) say the same thing, but to
different audiences (ie. developers, maintainers, regulators, or end users); 
if they did not, they would be describing different systems.
Using this thesis as an example, it is written for an audience familiar with 
classical software engineering, including those who have experience with 
requirements documents, design documents, and the challenges of maintaining 
large, long-lived software systems. The examples and case studies are drawn 
from scientific computing, but the pain points and solutions discussed are 
broadly relevant.

Speaking broadly about \sfs{}, let us consider a few different documents. A 
software requirements document is a human-readable abstraction of \textit{what} 
the software is supposed to do. Whereas a design document is a human-readable 
version of \textit{how} the software is supposed to fulfill its requirements. 
The source code itself is a computer-readable list of instructions combining 
\textit{what} must be done and, in many languages, \textit{how} that is to be 
accomplished. Importantly, this multiplicity of views is not limited to 
separate \sfs{}; even within a single artifact the same information may appear 
in multiple forms. For example, a requirements document may include natural 
language descriptions, mathematical equations, and other relationships 
expressed in a multitude of ways (tables, graphs, diagrams, etc.).

\begin{table}[h]
\centering
\caption{The same information as natural language, equation, and code}
\label{tab:proj-views}
\begin{tabular}{|p{0.3\linewidth}|p{0.22\linewidth}|p{0.48\linewidth}|}
\hline
\textbf{\rule{0pt}{4.5ex}Description} & 
\textbf{Equation} & 
\textbf{Code (Python)} \\
\hline
\vspace{1.5ex} $P_b$ is the Probability of Breakage &
\vspace{1.5ex} $P_b = 1 - e^-B$ &
\begin{minipage}[t]{\linewidth}
\begin{lstlisting}[language=Python,basicstyle=\ttfamily\footnotesize]
def func_P_b(B):
    return 1.0 - math.exp(-B)
\end{lstlisting}
\end{minipage} \\
\hline
\end{tabular}
\end{table}

Table~\ref{tab:proj-views} shows how the same information (the definition of 
$P_b$) can be represented in several different views: as a natural language 
description, equation, and code definition. We aim to take advantage of the 
inherent redundancy across these views to distill a single source of 
information, thus removing the need to manually duplicate information across 
\sfs{}. This example illustrates a broader challenge: when the same knowledge 
must be expressed in multiple forms for different audiences or purposes, the 
effort to keep these representations consistent becomes significant.

Manually writing and maintaining a full range of software artifacts (ie.
multiple documents for different audiences plus the source code) is
redundant and tedious. Factor in deadlines, changing requirements, and other
common issues faced during development and you have a perfect storm for
inter-artifact syncronization issues.

How can we avoid having our artifacts fall out of sync with each other?
Some would argue ``just write code!" And that is exactly what a number of other
approaches have tried. Documentation generators like Doxygen, Javadoc, Pandoc,
and more take a code-centric view of the problem. Typically, they work by having
natural-language descriptions and/or explanations written as specially delimited
comments in the code which are later automatically compiled into a
human-readable document.

While these approaches definitely have their place and can come in quite handy,
they do not solve the underlying redundancy problem. The developers are still
forced to manually write descriptions of systems in both code and comments.
They also do not generate all software artifacts - commonly they are used to
generate only API documentation targeted towards developers or user manuals.

If we can truly understand the differences and commonalities between 
software artifacts, we can develop tools to capitalize on them and streamline 
the process of creating and maintaining software artifacts. For that we first 
need to break down common artifacts to develop an understanding of their 
contents, intended audience, and how they differ whether on intra- or 
inter-project scales.

We propose a new framework, Drasil, alongside a knowledge-centric view of
software, to help take advantage of inherent redundancy while reducing manual 
duplication and synchronization problems. Our approach looks at what underlies 
the problems we solve using software and capturing that ``common" or ``core" 
knowledge. We then use that knowledge to generate our software artifacts, thus 
gaining the benefits inherent to the generation process: lack of manual 
duplication, one source to maintain, and 'free' traceability of information.

\section{Problem Statement and Motivation}
Despite the recognized value of documentation and software artifacts (\sfs{}), 
the process of creating and maintaining them is fraught with redundancy, 
tedium, and potential risks of inconsistency. As software evolves, artifacts 
(requirements documents, design documents, source code, etc.) often fall out of 
sync, leading to errors, increased maintenance costs, and reduced trust in 
documentation. This thesis addresses the challenge: \emph{How can we 
systematically reduce unnecessary redundancy and improve consistency across 
software artifacts, especially in domains where correctness and traceability 
are critical?}

The root of the problem lies in the fact that the same knowledge must be
expressed in multiple forms for different audiences and purposes. Each artifact
is typically maintained separately, requiring manual updates whenever changes
occur. This manual process is error-prone and time-consuming, and the effort
required to keep all artifacts synchronized grows rapidly as projects become
more complex or requirements change more frequently.

Existing approaches, such as documentation generators and code-centric tools,
alleviate some of the burden but do not eliminate the underlying redundancy.
They often focus on generating a limited subset of artifacts (such as API
documentation) and still require developers to duplicate information in code
and comments. As a result, inconsistencies persist, and the benefits of
automation are only partially realized.

The consequences of these challenges are particularly acute in scientific
computing and other domains where correctness, traceability, and regulatory
compliance are essential. In such contexts, even minor inconsistencies can
undermine confidence in the software and its documentation, potentially
leading to costly errors or rework.

Motivated by these issues, this thesis seeks to develop a knowledge-centric
approach that captures the core information underlying a system and uses it to
generate all relevant \sfs{}. By reducing manual duplication and
synchronization effort, we aim to improve consistency, maintainability, and
traceability across the software lifecycle.

\section{The mundane and why it matters}

What we are doing is not big and flashy; instead, it is focused on the tedium
we deal with in our day-to-day lives as software engineers. We are focused on
improving the development experience holistically. The small annoyances can be
more frustrating than solving larger problems. For example, the feeling of
hours spent banging heads against walls for an off-by-one error or a typo that 
somehow snuck past review, versus the sublime joy of finding a novel, 
interesting, scalable, and maintainable solution to a problem.

These little pain points, including having to manually update artifacts after
modifying code, especially in regulated industries, accumulate over time and
can have a significant impact on productivity and morale. While each instance
may seem minor, together they represent a substantial barrier to efficient and
reliable software development, particularly in domains where correctness and
traceability are essential.

Drasil is our approach to address these everyday frustrations by systematically
reducing manual duplication and synchronization effort. By capturing core
knowledge explicitly and generating artifacts from a single source, Drasil
helps ensure that changes propagate consistently and automatically across all
relevant documents and code. This approach not only reduces the risk of
inconsistencies, but also supports practices such as continuous integration and
refactoring, keeping artifacts in a steady-state of consistency.

The value of this approach is most apparent in the small details: the hours
saved by not having to update documentation by hand, the confidence that comes
from knowing all artifacts are synchronized, and the ability to trace the
origin of any piece of information. These improvements may not be as
immediately dramatic as solving a major technical challenge, but they
accumulate to create a more reliable, maintainable, and satisfying development
experience. In this way, Drasil demonstrates that addressing the mundane is not
only worthwhile, but essential for advancing the practice of software
engineering.

\section{Scope}
\label{sec:scope}
We are well aware of the ambitious nature of attempting to solve the problem of
manual duplication and unnecessary redundancy across all possible software
systems. Frankly, it would be highly impractical to attempt to solve such a
broad spectrum of problems. Each software domain poses its own challenges,
alongside specific benefits and drawbacks. 

Our work on Drasil is most relevant to software that is well-understood and 
undergoes frequent change (maintenance). Good candidates for development using
Drasil are long-lived (10+ years) software projects with artifacts of interest
to multiple stakeholders. With that in mind, we have decided to focus on
scientific computing (SC) software. Specifically, we are looking at software 
that follows the pattern \emph{input $\rightarrow$ process $\rightarrow$ 
output}.

SC software has a strong fundamental underpinning of well-understood concepts.
It also has the benefit of seldomly changing, and when it does, existing models
are not necessarily invalidated. For example, rigid-body problems in physics are
well-understood and the underlying modeling equations are unlikely to change.
However, should they change, the current models will likely remain as good
approximations under a specific set of assumptions. For instance, who hasn't
heard `assume each body is a sphere' during a physics lecture?

SC software could also benefit from buy-in to good software development 
practices as many SC software developers put the emphasis on science and not 
development~\citep{Kelly2007}. Rather than following rigid, process-heavy 
approaches deemed unfavourable~\citep{CarverEtAl2007}, developers of SC 
software choose to use knowledge acquisition driven~\citep{Kelly2015}, 
agile~\citep{Segal2005, CarverEtAl2007, AckroydEtAl2008, 
EasterbrookAndJohns2009}, or amethododical~\citep{Kelly2013} processes instead.

\section{Roadmap}

The remainder of this thesis is organized as follows:
\begin{itemize}
    \item \textbf{Chapter~\ref{c:background}: Background} reviews the 
    literature on software artifacts, redundancy, reuse, literate programming, 
    and generative programming.
    \item \textbf{Chapter~\ref{c:process}: Our Process} details the methods 
    used to analyze \sfs{}, identify redundancy, and motivate the 
    knowledge-centric approach.
    \item \textbf{Chapter~\ref{c:drasil}: The Drasil Framework} presents the 
    design, architecture, and implementation of Drasil, including its 
    knowledge representation and artifact generation capabilities.
    \item \textbf{Chapter~\ref{c:results}: Results} presents observations
    and analysis from reimplementing existing case studies using Drasil,
    highlighting practical benefits.
    \item \textbf{Chapter~\ref{c:discussion}: Discussion} interprets the 
    results, explores the implications of the knowledge-centric approach, and
    discusses limitations and challenges encountered.
    \item \textbf{Chapter~\ref{c:conclusion}: Conclusion} summarizes the 
    findings, contributions, and implications of this work and outlines 
    potential extensions, open questions, and directions for further research.
\end{itemize}

\section{Contributions}

The main contributions of this thesis are:

\begin{itemize}
    \item \textbf{Systematic analysis of redundancy and inconsistency in 
    software artifacts.} Through detailed breakdowns of \sfs{} across multiple 
    scientific computing case studies, this work exposes patterns and sources 
    of unnecessary duplication and inconsistency that plague traditional 
    artifact-centric workflows.

    \item \textbf{Operationalization of knowledge-centric artifact generation.}
    The thesis develops and formalizes a process for capturing, organizing,
    and projecting domain knowledge, operationalizing software engineering
    principles to enable automated generation of diverse artifacts from a
    single source of truth.

    \item \textbf{Design and implementation of the Drasil framework.}
    Drasil is presented as a novel, extensible framework for knowledge-centric
    software artifact generation. Its architecture includes robust mechanisms
    for knowledge capture (chunks), projection (recipes), and rendering 
    (multi-format output), supporting traceability and maintainability by 
    construction.

    \item \textbf{Demonstration of Drasil's effectiveness via reimplementation 
    of case studies.} The thesis documents the reimplementation of several 
    scientific computing systems using Drasil, showing that local changes to 
    domain knowledge propagate automatically and consistently across all 
    generated artifacts. This approach reduces manual effort, increases error 
    visibility, and supports rapid adaptation and software family evolution.

    \item \textbf{Empirical observations on consistency, traceability, and 
    reproducibility.} Through case study analysis and artifact comparison, the 
    thesis provides evidence that Drasil enforces consistency by construction, 
    improves traceability through explicit provenance, and supports 
    reproducibility via deterministic artifact generation.

    \item \textbf{Identification and clarification of tacit knowledge and 
    implicit assumptions.} By forcing explicit encoding of all domain 
    knowledge, Drasil surfaces hidden assumptions and semantic inconsistencies, 
    enabling their correction and documentation across all artifacts.

    \item \textbf{Framework for rapid generation and maintenance of software 
    families.} The single-source approach and recipe DSL enable efficient 
    creation of software family variants, minimizing duplication and ensuring 
    consistency across related products.

    \item \textbf{Lessons learned and guidance for future research.}
    The thesis distills practical lessons from iterative development,
    onboarding, and refinement, highlighting the importance of centralized
    knowledge, improved authoring tools, and formal validation. It outlines
    open questions and directions for extending Drasil to new domains and
    improving usability. \ds{Is this too much?}

    \item \textbf{Advancing the value of addressing everyday software 
    engineering pain points.} By focusing on the ``mundane'' sources of tedium 
    and error in artifact maintenance, the thesis demonstrates that holistic 
    improvements to development workflows can yield substantial benefits for 
    reliability, maintainability, and developer experience.
\end{itemize}

Drasil allows developers to focus on the system being built as a whole rather than the individual artifacts. We can still produce a ``rational design"~\cite{ParnasAndClements1986} without the explicit tedium of manually keeping everything in sync.

\textit{Note:} While the core techniques and framework were developed by the author, Drasil's ongoing development and case study evolution are collaborative efforts by the Drasil team. This thesis focuses on the author's initial, original contributions and foundational work.