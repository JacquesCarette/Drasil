-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Database SubPackage
--   
--   Please see the README on GitHub at
--   <a>https://github.com/JacquesCarette/Drasil#readme</a>
@package drasil-database
@version 0.1.1.0


-- | Re-export database types and functions to simplify external use.
module Drasil.Database

-- | A piece of reusable knowledge, with an internal identifier
--   (<a>UID</a>), possibly dependant on other chunks.
data Chunk

-- | Constraint for anything that may be considered a valid chunk type.
type IsChunk a = (HasUID a, HasChunkRefs a, Typeable a)

-- | The majority of chunks will relate other chunks in some way. In other
--   words, the majority of our chunks *depend* on others.
--   <a>HasChunkRefs</a> is meant as a way to capture what things a chunk
--   *directly* refers to (i.e., depends on directly).
class HasChunkRefs a
chunkRefs :: HasChunkRefs a => a -> Set UID

-- | Create a <a>Chunk</a>, ensuring that <a>Chunk</a>s are never placed
--   within <a>Chunk</a>s.
mkChunk :: IsChunk a => a -> Chunk

-- | <a>Open</a> chunks, casting them to a specific type.
unChunk :: Typeable a => Chunk -> Maybe a

-- | Ask a <a>Chunk</a> for the type of data it codifies.
chunkType :: Chunk -> TypeRep

-- | Drasil's knowledge database.
data ChunkDB

-- | An empty <a>ChunkDB</a>.
empty :: ChunkDB

-- | Create a <a>ChunkDB</a> from a list of chunks. This will insert all
--   chunks into the database from the list, from left to right.
fromList :: IsChunk a => [a] -> ChunkDB

-- | Query the <a>ChunkDB</a> for all registered chunks (by their
--   <a>UID</a>s).
registered :: ChunkDB -> [UID]

-- | Enumerate all types registered in the <a>ChunkDB</a>.
typesRegistered :: ChunkDB -> [TypeRep]

-- | Get the number of chunks registered in the <a>ChunkDB</a>.
size :: ChunkDB -> Int

-- | Check if a <a>UID</a> is registered in the <a>ChunkDB</a>.
isRegistered :: UID -> ChunkDB -> Bool

-- | Filter the <a>ChunkDB</a> for chunks that are not needed by any other
--   chunks. These are the only chunks that can safely be removed from the
--   database, though we do not include this functionality.
findUnused :: ChunkDB -> [UID]

-- | Find a chunk by its <a>UID</a> in the <a>ChunkDB</a>.
find :: Typeable a => UID -> ChunkDB -> Maybe a

-- | Find a chunk by its <a>UID</a> in the <a>ChunkDB</a>, throwing a hard
--   error if it is not found.
findOrErr :: forall a. Typeable a => UID -> ChunkDB -> a

-- | Find all chunks of a specific type in the <a>ChunkDB</a>.
findAll :: forall a. IsChunk a => ChunkDB -> [a]

-- | Find all chunks of a specific type in the <a>ChunkDB</a>, returning
--   their <a>UID</a>s rather than the chunks themselves.
findAll' :: TypeRep -> ChunkDB -> [UID]

-- | Find all chunks that depend on a specific one.
dependants :: UID -> ChunkDB -> Maybe [UID]

-- | Find all chunks that depend on a specific one, throwing a hard error
--   if the dependency chunk is not found.
dependantsOrErr :: UID -> ChunkDB -> [UID]

-- | Find the type of a chunk by its <a>UID</a>.
findTypeOf :: UID -> ChunkDB -> Maybe TypeRep

-- | Insert a chunk into the <a>ChunkDB</a> if it is sensible to do so
--   (i.e., does not depend on itself, is not a <a>ChunkDB</a>, and does
--   not overwrite another chunk).
insert :: IsChunk a => a -> ChunkDB -> ChunkDB

-- | Insert a list of chunks into a <a>ChunkDB</a>.
insertAll :: IsChunk a => [a] -> ChunkDB -> ChunkDB

-- | Insert 11 lists of <i>unique</i> chunk types into a <a>ChunkDB</a>,
--   assuming the input <a>ChunkDB</a> does not already contain any of the
--   chunks from the chunk lists.
insertAllOutOfOrder11 :: (IsChunk a, IsChunk b, IsChunk c, IsChunk d, IsChunk e, IsChunk f, IsChunk g, IsChunk h, IsChunk i, IsChunk j, IsChunk k) => ChunkDB -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h] -> [i] -> [j] -> [k] -> ChunkDB
type ChunkType = String

-- | A dumped representation of a <a>ChunkDB</a>, mapping chunk types
--   (<a>String</a>s) to lists of <a>UID</a>s.
type DumpedChunkDB = Map ChunkType [UID]
dumpChunkDB :: ChunkDB -> DumpedChunkDB

-- | Declares that a type is a chunk type; Generates an instance of
--   <a>HasChunkRefs</a>.
declareHasChunkRefs :: Name -> Q [Dec]

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class () => Generic a

-- | A datatype whose instances are defined generically, using the
--   <a>Generic</a> representation. <a>Generically1</a> is a higher-kinded
--   version of <a>Generically</a> that uses <a>Generic1</a>.
--   
--   Generic instances can be derived via <tt><a>Generically</a> A</tt>
--   using <tt>-XDerivingVia</tt>.
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric      #-}
--   {-# LANGUAGE DerivingStrategies #-}
--   {-# LANGUAGE DerivingVia        #-}
--   
--   import GHC.Generics (Generic)
--   
--   data V4 a = V4 a a a a
--     deriving stock Generic
--   
--     deriving (Semigroup, Monoid)
--     via Generically (V4 a)
--   </pre>
--   
--   This corresponds to <a>Semigroup</a> and <a>Monoid</a> instances
--   defined by pointwise lifting:
--   
--   <pre>
--   instance Semigroup a =&gt; Semigroup (V4 a) where
--     (&lt;&gt;) :: V4 a -&gt; V4 a -&gt; V4 a
--     V4 a1 b1 c1 d1 &lt;&gt; V4 a2 b2 c2 d2 =
--       V4 (a1 &lt;&gt; a2) (b1 &lt;&gt; b2) (c1 &lt;&gt; c2) (d1 &lt;&gt; d2)
--   
--   instance Monoid a =&gt; Monoid (V4 a) where
--     mempty :: V4 a
--     mempty = V4 mempty mempty mempty mempty
--   </pre>
--   
--   Historically this required modifying the type class to include generic
--   method definitions (<tt>-XDefaultSignatures</tt>) and deriving it with
--   the <tt>anyclass</tt> strategy (<tt>-XDeriveAnyClass</tt>). Having a
--   /via type/ like <a>Generically</a> decouples the instance from the
--   type class.
newtype () => Generically a
Generically :: a -> Generically a

-- | A <tt>UID</tt> is a 'unique identifier' for things that we will put
--   into our database of information. We use a newtype wrapper to make
--   sure we are only using <a>UID</a>s where desired.
data UID

-- | The most basic item: having a unique identifier key, a <a>UID</a>.
class HasUID c

-- | The <i>unique</i> id of the chunk (for internal Drasil use only).
uid :: HasUID c => Getter c UID

-- | Smart constructor for <a>UID</a>s from raw <a>Value</a>s.
mkUid :: String -> UID

-- | Nest a <a>UID</a> under a namespace.
nsUid :: String -> UID -> UID

-- | Append a suffix to a thing with a <a>UID</a> and get the resulting
--   <a>UID</a>.
(+++) :: HasUID a => a -> String -> UID

-- | Append a suffix to a <a>UID</a>.
(+++.) :: UID -> String -> UID

-- | Merge the <a>UID</a>s of two chunks through simple concatenation.
(+++!) :: (HasUID a, HasUID b) => a -> b -> UID

-- | Get something's <a>UID</a> as a <a>Value</a>.
showUID :: HasUID a => a -> String

-- | A reference to another chunk through its <a>UID</a>, with a type
--   variable to retain information about the original chunk's type, useful
--   for type-safe dereferencing.
data UIDRef typ

-- | Create a <a>UIDRef</a> to a chunk.
hide :: IsChunk t => t -> UIDRef t

-- | Find a chunk by a <a>UIDRef</a>.
unhide :: IsChunk t => UIDRef t -> ChunkDB -> Maybe t

-- | Find a chunk by a <a>UIDRef</a>, erroring if not found.
unhideOrErr :: IsChunk t => UIDRef t -> ChunkDB -> t

-- | A variant of <a>UIDRef</a> without type information about the chunk
--   being referred to, effectively treating chunks as being "unityped."
data UnitypedUIDRef

-- | Create a <a>UnitypedUIDRef</a> to a chunk.
hideUni :: IsChunk t => t -> UnitypedUIDRef

-- | Find a chunk by its <a>UnitypedUIDRef</a>.
unhideUni :: IsChunk t => UnitypedUIDRef -> ChunkDB -> Maybe t

-- | Find a chunk by its <a>UnitypedUIDRef</a>, erroring if not found.
unhideUniOrErr :: IsChunk t => UnitypedUIDRef -> ChunkDB -> t
