\chapter{Software Automation}
From the Industrial Revolution (1760-1840) to the mass production of automobiles that we have today, human beings have never lacked innovations to improve the process. In the Industrial Revolution, we start to use machines to replace human labour. Today, we have been building assembly lines and robots in the automobile industry to reach a scale of massive production. Hardware automation has been relatively successful in the past one hundred years, and they have been producing mass products for people at a relatively low cost. With the success story of automating hardware, could software be the next target for automation? Nowadays, software is used every day in our daily life. Most software still requires a human being to write it. Programmers usually write software in a specific language and produce other byproducts, like documentation, during development. Whether in an enterprise or research institution, manually creating software is prone to errors and is not as efficient as a code generator. In the long term, a stable code generator usually beats programmers in performance. They will eventually bring the cost down because of the labour cost reduction. Perhaps this is why human beings consistently seek to automate work. 

With fairly well-understood knowledge of software, creating a comprehensive system to produce software is not impossible. Can you imagine that programmers no longer programming in the future world? In the future world, code generators will generate software. There will be a role called ``code alchemist'' who is responsible for writing the recipe for the code generator. The recipe will indicate what kind of software people want. In other words, the recipe is also a software requirement document that the code generator can understand. The recipe can exist in the form of a high-end programming language. Once the code generator receives the recipe, it will automatically produce software artifacts, including code, requirements and documentation. The code generator exists in the form of a compiler. The ``generate everything'' could be revolutionary. The Drasil framework provides a proof of concept and initial steps in the direction of a generate all things approach.
