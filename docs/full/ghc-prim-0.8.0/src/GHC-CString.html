<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/CString.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE MagicHash, NoImplicitPrelude, BangPatterns, UnliftedFFITypes #-}</span>
<a name="line-2"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-3"></a><span class='hs-comment'>-- |</span>
<a name="line-4"></a><span class='hs-comment'>-- Module      :  GHC.CString</span>
<a name="line-5"></a><span class='hs-comment'>-- Copyright   :  (c) The University of Glasgow 2011</span>
<a name="line-6"></a><span class='hs-comment'>-- License     :  see libraries/ghc-prim/LICENSE</span>
<a name="line-7"></a><span class='hs-comment'>--</span>
<a name="line-8"></a><span class='hs-comment'>-- Maintainer  :  cvs-ghc@haskell.org</span>
<a name="line-9"></a><span class='hs-comment'>-- Stability   :  internal</span>
<a name="line-10"></a><span class='hs-comment'>-- Portability :  non-portable (GHC Extensions)</span>
<a name="line-11"></a><span class='hs-comment'>--</span>
<a name="line-12"></a><span class='hs-comment'>-- GHC C strings definitions (previously in GHC.Base).</span>
<a name="line-13"></a><span class='hs-comment'>-- Use GHC.Exts from the base package instead of importing this</span>
<a name="line-14"></a><span class='hs-comment'>-- module directly.</span>
<a name="line-15"></a><span class='hs-comment'>--</span>
<a name="line-16"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-17"></a>
<a name="line-18"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.CString</span> <span class='hs-layout'>(</span>
<a name="line-19"></a>        <span class='hs-comment'>-- * Ascii variants</span>
<a name="line-20"></a>        <span class='hs-varid'>unpackCString</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-varid'>unpackAppendCString</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-varid'>unpackFoldrCString</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span>
<a name="line-21"></a>        <span class='hs-varid'>cstringLength</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span>
<a name="line-22"></a>
<a name="line-23"></a>        <span class='hs-comment'>-- * Utf variants</span>
<a name="line-24"></a>        <span class='hs-varid'>unpackCStringUtf8</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-varid'>unpackAppendCStringUtf8</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-varid'>unpackFoldrCStringUtf8</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span>
<a name="line-25"></a>
<a name="line-26"></a>        <span class='hs-comment'>-- * Other</span>
<a name="line-27"></a>        <span class='hs-varid'>unpackNBytes</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span>
<a name="line-28"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-29"></a>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-conid'>One</span><span class='hs-layout'>)</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prim</span>
<a name="line-32"></a>
<a name="line-33"></a><span class='hs-comment'>{-
<a name="line-34"></a>Note [String literals in GHC]
<a name="line-35"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-36"></a>String literals get quite a bit of special handling in GHC.  This Note
<a name="line-37"></a>summarises the moving parts.
<a name="line-38"></a>
<a name="line-39"></a>* Desugaring: see GHC.HsToCore.Match.Literal.dsLit, which in
<a name="line-40"></a>  turn calls GHC.Core.Make.mkStringExprFS.
<a name="line-41"></a>
<a name="line-42"></a>  The desugarer desugars the Haskell literal "foo" into Core
<a name="line-43"></a>     GHC.CString.unpackCString# "foo"#
<a name="line-44"></a>  where "foo"# is primitive string literal (of type Addr#).
<a name="line-45"></a>
<a name="line-46"></a>  When the string cannot be encoded as a C string, we use UTF8:
<a name="line-47"></a>     GHC.CString.unpackCStringUtf8# "foo"#
<a name="line-48"></a>
<a name="line-49"></a>* The library module ghc-prim:GHC.CString has a bunch of functions that
<a name="line-50"></a>  work over primitive strings, including GHC.CString.unpackCString#
<a name="line-51"></a>
<a name="line-52"></a>* GHC.Core.Op.ConstantFold has some RULES that optimise certain string
<a name="line-53"></a>  operations on literal strings. For example:
<a name="line-54"></a>
<a name="line-55"></a>    + Constant folding the desugared form of ("foo" ++ "bar")
<a name="line-56"></a>      into ("foobar")
<a name="line-57"></a>    + Comparing strings
<a name="line-58"></a>    + and more
<a name="line-59"></a>
<a name="line-60"></a>* GHC.Base has a number of regular rules for String literals.
<a name="line-61"></a>
<a name="line-62"></a>  + a rule "eqString": (==) @String = eqString
<a name="line-63"></a>    where GHC.Base.eqString :: String -&gt; String -&gt; Bool
<a name="line-64"></a>
<a name="line-65"></a>    ConstantFold has a RULE for eqString on literals:
<a name="line-66"></a>     eqString (Lit "foo"#) (Lit "bar"#) --&gt; False
<a name="line-67"></a>
<a name="line-68"></a>    This allows compile time evaluation of things like "foo" == "bar"
<a name="line-69"></a>
<a name="line-70"></a>  + A bunch of rules to promote fusion:
<a name="line-71"></a>
<a name="line-72"></a>    "unpack"       [~1] forall a   . unpackCString# a             = build (unpackFoldrCString# a)
<a name="line-73"></a>    "unpack-list"  [1]  forall a   . unpackFoldrCString# a (:) [] = unpackCString# a
<a name="line-74"></a>    "unpack-append"     forall a n . unpackFoldrCString# a (:) n  = unpackAppendCString# a n
<a name="line-75"></a>
<a name="line-76"></a>    And UTF8 variants of these rules.
<a name="line-77"></a>
<a name="line-78"></a>* We allow primitive (unlifted) literal strings to be top-level
<a name="line-79"></a>  bindings, breaking out usual rule.  See GHC.Core
<a name="line-80"></a>  Note [Core top-level string literals]
<a name="line-81"></a>
<a name="line-82"></a>* TODO: There is work on a special code-gen path for top-level boxed strings
<a name="line-83"></a>     str :: [Char]
<a name="line-84"></a>     str = unpackCString# "foo"#
<a name="line-85"></a>  so that they can all share a common code pointer
<a name="line-86"></a>
<a name="line-87"></a>  There is a WIP MR on gitlab for this: !3012
<a name="line-88"></a>
<a name="line-89"></a>-}</span>
<a name="line-90"></a>
<a name="line-91"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-92"></a><span class='hs-comment'>-- Unpacking C strings</span>
<a name="line-93"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-94"></a>
<a name="line-95"></a><span class='hs-comment'>-- This code is needed for virtually all programs, since it's used for</span>
<a name="line-96"></a><span class='hs-comment'>-- unpacking the strings of error messages.</span>
<a name="line-97"></a>
<a name="line-98"></a><span class='hs-comment'>-- Used to be in GHC.Base, but was moved to ghc-prim because the new generics</span>
<a name="line-99"></a><span class='hs-comment'>-- stuff uses Strings in the representation, so to give representations for</span>
<a name="line-100"></a><span class='hs-comment'>-- ghc-prim types we need unpackCString#</span>
<a name="line-101"></a>
<a name="line-102"></a><span class='hs-comment'>{- Note [Inlining unpackCString#]
<a name="line-103"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-104"></a>There's really no point in ever inlining things like unpackCString# as the loop
<a name="line-105"></a>doesn't specialise in an interesting way and we can't deforest the list
<a name="line-106"></a>constructors (we'd want to use unpackFoldrCString# for this). Moreover, it's
<a name="line-107"></a>pretty small, so there's a danger that it'll be inlined at every literal, which
<a name="line-108"></a>is a waste.
<a name="line-109"></a>
<a name="line-110"></a>Moreover, inlining early may interfere with a variety of rules that are supposed
<a name="line-111"></a>to match unpackCString#,
<a name="line-112"></a>
<a name="line-113"></a> * BuiltInRules in GHC.Core.Opt.ConstantFold; e.g.
<a name="line-114"></a>       eqString (unpackCString# (Lit s1)) (unpackCString# (Lit s2)
<a name="line-115"></a>          = s1 == s2
<a name="line-116"></a>
<a name="line-117"></a> * unpacking rules; e.g. in GHC.Base,
<a name="line-118"></a>       unpackCString# a
<a name="line-119"></a>          = build (unpackFoldrCString# a)
<a name="line-120"></a>
<a name="line-121"></a> * stream fusion rules; e.g. in the `text` library,
<a name="line-122"></a>       unstream (S.map safe (S.streamList (GHC.unpackCString# a)))
<a name="line-123"></a>          = unpackCString# a
<a name="line-124"></a>
<a name="line-125"></a>Moreover, we want to make it CONLIKE, so that:
<a name="line-126"></a>
<a name="line-127"></a>* the rules in GHC.Core.Opt.ConstantFold will fire when the string is let-bound.
<a name="line-128"></a>  E.g. the eqString rule in GHC.Core.Opt.ConstantFold
<a name="line-129"></a>   eqString (unpackCString# (Lit s1)) (unpackCString# (Lit s2) = s1==s2
<a name="line-130"></a>
<a name="line-131"></a>* exprIsConApp_maybe will see the string when we have
<a name="line-132"></a>     let x = unpackCString# "foo"#
<a name="line-133"></a>     ...(case x of algs)...
<a name="line-134"></a>
<a name="line-135"></a>All of this goes for unpackCStringUtf8# too.
<a name="line-136"></a>-}</span>
<a name="line-137"></a>
<a name="line-138"></a><span class='hs-comment'>{- Note [Inlining of unpackFoldrCString]
<a name="line-139"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-140"></a>
<a name="line-141"></a>Usually the unpack-list rule turns unpackFoldrCString# into unpackCString#
<a name="line-142"></a>It also has a BuiltInRule in PrelRules.hs:
<a name="line-143"></a>     unpackFoldrCString# "foo" c (unpackFoldrCString# "baz" c n)
<a name="line-144"></a>       =  unpackFoldrCString# "foobaz" c n
<a name="line-145"></a>
<a name="line-146"></a>We use NOINLINE [0] on the grounds that, unlike
<a name="line-147"></a>unpackCString#, there *is* some point in inlining
<a name="line-148"></a>unpackFoldrCString#, because we get better code for the
<a name="line-149"></a>higher-order function call.
<a name="line-150"></a>
<a name="line-151"></a>This can cause a code size increase but it was minimal
<a name="line-152"></a>when looking at nofib.
<a name="line-153"></a>
<a name="line-154"></a>This is especially important for elem which then results in an
<a name="line-155"></a>allocation free loop.
<a name="line-156"></a>
<a name="line-157"></a>  Note [unpackCString# iterating over addr]
<a name="line-158"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-159"></a>
<a name="line-160"></a>When unpacking unpackCString# and friends repeatedly return a cons cell
<a name="line-161"></a>containing:
<a name="line-162"></a>* The current character we just unpacked.
<a name="line-163"></a>* A thunk to unpack the rest of the string.
<a name="line-164"></a>
<a name="line-165"></a>In order to minimize the size of the thunk we do not index of
<a name="line-166"></a>the start of the string, offsetting into it, but instead increment
<a name="line-167"></a>the addr and always use offset 0#.
<a name="line-168"></a>
<a name="line-169"></a>This works since these two expressions will read from the same address.
<a name="line-170"></a>* `indexCharOffAddr# a i`
<a name="line-171"></a>* `indexCharOffAddr (a `plusAddr#` i) 0#`
<a name="line-172"></a>
<a name="line-173"></a>This way we avoid the need for the thunks to close over both the start of
<a name="line-174"></a>the string and the current offset, saving a word for each character unpacked.
<a name="line-175"></a>
<a name="line-176"></a>This has the additional advantage the we can guarantee that only the
<a name="line-177"></a>increment will happen in the loop.
<a name="line-178"></a>
<a name="line-179"></a>-}</span>
<a name="line-180"></a>
<a name="line-181"></a><a name="unpackCString"></a><span class='hs-definition'>unpackCString</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<a name="line-182"></a><span class='hs-comment'>{-# NOINLINE CONLIKE unpackCString# #-}</span>
<a name="line-183"></a><span class='hs-definition'>unpackCString</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr</span>
<a name="line-184"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>ch</span> <span class='hs-varop'>`</span><span class='hs-varid'>eqChar</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-chr'>'\0'</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-185"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>True</span>                         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-varid'>ch</span> <span class='hs-conop'>:</span> <span class='hs-varid'>unpackCString</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>addr</span> <span class='hs-varop'>`</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-186"></a>      <span class='hs-keyword'>where</span>
<a name="line-187"></a>        <span class='hs-comment'>-- See Note [unpackCString# iterating over addr]</span>
<a name="line-188"></a>        <span class='hs-varop'>!</span><span class='hs-varid'>ch</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>indexCharOffAddr</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-189"></a>
<a name="line-190"></a>
<a name="line-191"></a><a name="unpackAppendCString"></a><span class='hs-definition'>unpackAppendCString</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<a name="line-192"></a><span class='hs-comment'>{-# NOINLINE unpackAppendCString# #-}</span>
<a name="line-193"></a>     <span class='hs-comment'>-- See the NOINLINE note on unpackCString#</span>
<a name="line-194"></a><span class='hs-definition'>unpackAppendCString</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr</span> <span class='hs-varid'>rest</span>
<a name="line-195"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>ch</span> <span class='hs-varop'>`</span><span class='hs-varid'>eqChar</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-chr'>'\0'</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rest</span>
<a name="line-196"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>True</span>                         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-varid'>ch</span> <span class='hs-conop'>:</span> <span class='hs-varid'>unpackAppendCString</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>addr</span> <span class='hs-varop'>`</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varid'>rest</span>
<a name="line-197"></a>      <span class='hs-keyword'>where</span>
<a name="line-198"></a>        <span class='hs-comment'>-- See Note [unpackCString# iterating over addr]</span>
<a name="line-199"></a>        <span class='hs-varop'>!</span><span class='hs-varid'>ch</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>indexCharOffAddr</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-200"></a>
<a name="line-201"></a><a name="unpackFoldrCString"></a><span class='hs-comment'>-- Usually the unpack-list rule turns unpackFoldrCString# into unpackCString#.</span>
<a name="line-202"></a><span class='hs-comment'>-- See Note [String literals in GHC] for more details.</span>
<a name="line-203"></a><span class='hs-comment'>-- See [Inlining of unpackFoldrCString]</span>
<a name="line-204"></a><span class='hs-comment'>{-# NOINLINE[0] unpackFoldrCString# #-}</span>
<a name="line-205"></a><span class='hs-definition'>unpackFoldrCString</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Char</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-206"></a><span class='hs-definition'>unpackFoldrCString</span><span class='hs-cpp'>#</span> <span class='hs-varid'>str</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z_init</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>str</span> <span class='hs-varid'>z_init</span>
<a name="line-207"></a>  <span class='hs-keyword'>where</span>
<a name="line-208"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>addr</span> <span class='hs-varid'>z</span>
<a name="line-209"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>ch</span> <span class='hs-varop'>`</span><span class='hs-varid'>eqChar</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-chr'>'\0'</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>z</span>
<a name="line-210"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>True</span>                         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-varid'>ch</span> <span class='hs-varop'>`f`</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>addr</span> <span class='hs-varop'>`</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varid'>z</span>
<a name="line-211"></a>      <span class='hs-keyword'>where</span>
<a name="line-212"></a>        <span class='hs-comment'>-- See Note [unpackCString# iterating over addr]</span>
<a name="line-213"></a>        <span class='hs-varop'>!</span><span class='hs-varid'>ch</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>indexCharOffAddr</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-214"></a>
<a name="line-215"></a><a name="unpackCStringUtf8"></a><span class='hs-comment'>-- There's really no point in inlining this for the same reasons as</span>
<a name="line-216"></a><span class='hs-comment'>-- unpackCString. See Note [Inlining unpackCString#] above for details.</span>
<a name="line-217"></a><span class='hs-definition'>unpackCStringUtf8</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<a name="line-218"></a><span class='hs-comment'>{-# NOINLINE CONLIKE unpackCStringUtf8# #-}</span>
<a name="line-219"></a><span class='hs-definition'>unpackCStringUtf8</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr</span>
<a name="line-220"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>ch</span> <span class='hs-varop'>`</span><span class='hs-varid'>eqChar</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-chr'>'\0'</span><span class='hs-cpp'>#</span>  <span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-221"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>True</span> <span class='hs-keyglyph'>=</span>
<a name="line-222"></a>        <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>byte_count</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getByteCount</span> <span class='hs-varid'>ch</span>
<a name="line-223"></a>            <span class='hs-varop'>!</span><span class='hs-varid'>utf_ch</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unpackUtf8Char</span><span class='hs-cpp'>#</span> <span class='hs-varid'>byte_count</span> <span class='hs-varid'>ch</span> <span class='hs-varid'>addr</span>
<a name="line-224"></a>            <span class='hs-varop'>!</span><span class='hs-varid'>addr'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addr</span> <span class='hs-varop'>`plusBytes`</span> <span class='hs-varid'>byte_count</span>
<a name="line-225"></a>        <span class='hs-keyword'>in</span>  <span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-varid'>utf_ch</span> <span class='hs-conop'>:</span> <span class='hs-varid'>unpackCStringUtf8</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr'</span>
<a name="line-226"></a>      <span class='hs-keyword'>where</span>
<a name="line-227"></a>        <span class='hs-comment'>-- See Note [unpackCString# iterating over addr]</span>
<a name="line-228"></a>        <span class='hs-varop'>!</span><span class='hs-varid'>ch</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>indexCharOffAddr</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-229"></a>
<a name="line-230"></a>
<a name="line-231"></a><a name="unpackAppendCStringUtf8"></a><span class='hs-definition'>unpackAppendCStringUtf8</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<a name="line-232"></a><span class='hs-comment'>{-# NOINLINE unpackAppendCStringUtf8# #-}</span>
<a name="line-233"></a>     <span class='hs-comment'>-- See the NOINLINE note on unpackCString#</span>
<a name="line-234"></a><span class='hs-definition'>unpackAppendCStringUtf8</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr</span> <span class='hs-varid'>rest</span>
<a name="line-235"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>ch</span> <span class='hs-varop'>`</span><span class='hs-varid'>eqChar</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-chr'>'\0'</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rest</span>
<a name="line-236"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>True</span> <span class='hs-keyglyph'>=</span>
<a name="line-237"></a>        <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>byte_count</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getByteCount</span> <span class='hs-varid'>ch</span>
<a name="line-238"></a>            <span class='hs-varop'>!</span><span class='hs-varid'>utf_ch</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unpackUtf8Char</span><span class='hs-cpp'>#</span> <span class='hs-varid'>byte_count</span> <span class='hs-varid'>ch</span> <span class='hs-varid'>addr</span>
<a name="line-239"></a>            <span class='hs-varop'>!</span><span class='hs-varid'>addr'</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>addr</span> <span class='hs-varop'>`plusBytes`</span> <span class='hs-varid'>byte_count</span><span class='hs-layout'>)</span>
<a name="line-240"></a>        <span class='hs-keyword'>in</span>  <span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-varid'>utf_ch</span> <span class='hs-conop'>:</span> <span class='hs-varid'>unpackAppendCStringUtf8</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr'</span> <span class='hs-varid'>rest</span>
<a name="line-241"></a>      <span class='hs-keyword'>where</span>
<a name="line-242"></a>        <span class='hs-comment'>-- See Note [unpackCString# iterating over addr]</span>
<a name="line-243"></a>        <span class='hs-varop'>!</span><span class='hs-varid'>ch</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>indexCharOffAddr</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-244"></a>
<a name="line-245"></a><a name="unpackFoldrCStringUtf8"></a><span class='hs-comment'>-- See Note [Inlining of unpackFoldrCString]</span>
<a name="line-246"></a><span class='hs-comment'>{-# NOINLINE[0] unpackFoldrCStringUtf8# #-}</span>
<a name="line-247"></a><span class='hs-definition'>unpackFoldrCStringUtf8</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Char</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-248"></a><span class='hs-definition'>unpackFoldrCStringUtf8</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr_init</span> <span class='hs-varid'>f</span> <span class='hs-varid'>z_init</span>
<a name="line-249"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>addr_init</span> <span class='hs-varid'>z_init</span>
<a name="line-250"></a>  <span class='hs-keyword'>where</span>
<a name="line-251"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>addr</span> <span class='hs-varid'>z</span>
<a name="line-252"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>ch</span> <span class='hs-varop'>`</span><span class='hs-varid'>eqChar</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-chr'>'\0'</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>z</span>
<a name="line-253"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>True</span> <span class='hs-keyglyph'>=</span>
<a name="line-254"></a>          <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>byte_count</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getByteCount</span> <span class='hs-varid'>ch</span>
<a name="line-255"></a>              <span class='hs-varop'>!</span><span class='hs-varid'>utf_ch</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unpackUtf8Char</span><span class='hs-cpp'>#</span> <span class='hs-varid'>byte_count</span> <span class='hs-varid'>ch</span> <span class='hs-varid'>addr</span>
<a name="line-256"></a>              <span class='hs-varop'>!</span><span class='hs-varid'>addr'</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>addr</span> <span class='hs-varop'>`plusBytes`</span> <span class='hs-varid'>byte_count</span><span class='hs-layout'>)</span>
<a name="line-257"></a>          <span class='hs-keyword'>in</span> <span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-varid'>utf_ch</span> <span class='hs-varop'>`f`</span> <span class='hs-varid'>go</span> <span class='hs-varid'>addr'</span> <span class='hs-varid'>z</span>
<a name="line-258"></a>      <span class='hs-keyword'>where</span>
<a name="line-259"></a>        <span class='hs-comment'>-- See Note [unpackCString# iterating over addr]</span>
<a name="line-260"></a>        <span class='hs-varop'>!</span><span class='hs-varid'>ch</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>indexCharOffAddr</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-261"></a>
<a name="line-262"></a><a name="unpackNBytes"></a><span class='hs-comment'>-- There's really no point in inlining this for the same reasons as</span>
<a name="line-263"></a><span class='hs-comment'>-- unpackCString. See Note [Inlining unpackCString#] above for details.</span>
<a name="line-264"></a><span class='hs-definition'>unpackNBytes</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<a name="line-265"></a><span class='hs-comment'>{-# NOINLINE unpackNBytes# #-}</span>
<a name="line-266"></a><span class='hs-definition'>unpackNBytes</span><span class='hs-cpp'>#</span> <span class='hs-sel'>_addr</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-267"></a><span class='hs-definition'>unpackNBytes</span><span class='hs-cpp'>#</span>  <span class='hs-varid'>addr</span> <span class='hs-varid'>len</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unpack</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>(</span><span class='hs-varid'>len</span><span class='hs-cpp'>#</span> <span class='hs-varop'>-#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-268"></a>    <span class='hs-keyword'>where</span>
<a name="line-269"></a>     <span class='hs-varid'>unpack</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<a name="line-270"></a>     <span class='hs-varid'>unpack</span> <span class='hs-varid'>acc</span> <span class='hs-varid'>i</span><span class='hs-cpp'>#</span>
<a name="line-271"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-cpp'>#</span> <span class='hs-varop'>&lt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>acc</span>
<a name="line-272"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>True</span>                <span class='hs-keyglyph'>=</span>
<a name="line-273"></a>         <span class='hs-keyword'>case</span> <span class='hs-varid'>indexCharOffAddr</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr</span> <span class='hs-varid'>i</span><span class='hs-cpp'>#</span> <span class='hs-keyword'>of</span>
<a name="line-274"></a>            <span class='hs-varid'>ch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unpack</span> <span class='hs-layout'>(</span><span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-varid'>ch</span> <span class='hs-conop'>:</span> <span class='hs-varid'>acc</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-cpp'>#</span> <span class='hs-varop'>-#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-275"></a>
<a name="line-276"></a><span class='hs-comment'>-- The return type is not correct here. We really want CSize,</span>
<a name="line-277"></a><span class='hs-comment'>-- but that type is defined in base. However, CSize should always</span>
<a name="line-278"></a><span class='hs-comment'>-- match the size of a machine word (I hope), so this is probably</span>
<a name="line-279"></a><span class='hs-comment'>-- alright on all platforms that GHC supports.</span>
<a name="line-280"></a><span class='hs-keyword'>foreign</span> <span class='hs-keyword'>import</span> <span class='hs-keyword'>ccall</span> <span class='hs-keyword'>unsafe</span> <span class='hs-str'>"strlen"</span> <span class='hs-varid'>c_strlen</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-281"></a>
<a name="line-282"></a><a name="cstringLength"></a><span class='hs-comment'>-- | Compute the length of a NUL-terminated string. This address</span>
<a name="line-283"></a><span class='hs-comment'>-- must refer to immutable memory. GHC includes a built-in rule for</span>
<a name="line-284"></a><span class='hs-comment'>-- constant folding when the argument is a statically-known literal.</span>
<a name="line-285"></a><span class='hs-comment'>-- That is, a core-to-core pass reduces the expression</span>
<a name="line-286"></a><span class='hs-comment'>-- @cstringLength# "hello"#@ to the constant @5#@.</span>
<a name="line-287"></a><span class='hs-definition'>cstringLength</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-288"></a><span class='hs-comment'>{-# INLINE[0] cstringLength# #-}</span>
<a name="line-289"></a><span class='hs-definition'>cstringLength</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>c_strlen</span>
<a name="line-290"></a>
<a name="line-291"></a>
<a name="line-292"></a><span class='hs-comment'>------------------------------</span>
<a name="line-293"></a><span class='hs-comment'>--- UTF8 decoding utilities</span>
<a name="line-294"></a><span class='hs-comment'>------------------------------</span>
<a name="line-295"></a><span class='hs-comment'>--</span>
<a name="line-296"></a><span class='hs-comment'>-- These functions make explicit the logic that was originally</span>
<a name="line-297"></a><span class='hs-comment'>-- part of unpackCStringUtf8. Since we want the same support for ascii</span>
<a name="line-298"></a><span class='hs-comment'>-- and non-ascii a variety of functions needs the same logic. Instead</span>
<a name="line-299"></a><span class='hs-comment'>-- of C&amp;P'in the decoding logic all over we have it here once, and then</span>
<a name="line-300"></a><span class='hs-comment'>-- force GHC to inline it.</span>
<a name="line-301"></a><span class='hs-comment'>--</span>
<a name="line-302"></a><span class='hs-comment'>-- All the overhead of the Bytes argument and calls goes away once all is</span>
<a name="line-303"></a><span class='hs-comment'>-- said and done. And what remains is readable code in Haskell land and</span>
<a name="line-304"></a><span class='hs-comment'>-- performant code in the resulting binary.</span>
<a name="line-305"></a>
<a name="line-306"></a><a name="Bytes"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Bytes</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>One</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Two</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Three</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Four</span>
<a name="line-307"></a>
<a name="line-308"></a><a name="getByteCount"></a><span class='hs-comment'>{-# INLINE getByteCount #-}</span>
<a name="line-309"></a><span class='hs-definition'>getByteCount</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Char</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bytes</span>
<a name="line-310"></a><span class='hs-definition'>getByteCount</span> <span class='hs-varid'>ch</span>
<a name="line-311"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>ch</span> <span class='hs-varop'>`</span><span class='hs-varid'>leChar</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-chr'>'\x7F'</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>One</span>
<a name="line-312"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>ch</span> <span class='hs-varop'>`</span><span class='hs-varid'>leChar</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-chr'>'\xDF'</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Two</span>
<a name="line-313"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>ch</span> <span class='hs-varop'>`</span><span class='hs-varid'>leChar</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-chr'>'\xEF'</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Three</span>
<a name="line-314"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>True</span>                           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Four</span>
<a name="line-315"></a>
<a name="line-316"></a><a name="plusBytes"></a><span class='hs-comment'>{-# INLINE plusBytes #-}</span>
<a name="line-317"></a><span class='hs-definition'>plusBytes</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bytes</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span>
<a name="line-318"></a><span class='hs-definition'>plusBytes</span> <span class='hs-varid'>addr</span> <span class='hs-varid'>bytes</span> <span class='hs-keyglyph'>=</span>
<a name="line-319"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>bytes</span> <span class='hs-keyword'>of</span>
<a name="line-320"></a>    <span class='hs-conid'>One</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addr</span> <span class='hs-varop'>`</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span>
<a name="line-321"></a>    <span class='hs-conid'>Two</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addr</span> <span class='hs-varop'>`</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>2</span><span class='hs-cpp'>#</span>
<a name="line-322"></a>    <span class='hs-conid'>Three</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addr</span> <span class='hs-varop'>`</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>3</span><span class='hs-cpp'>#</span>
<a name="line-323"></a>    <span class='hs-conid'>Four</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addr</span> <span class='hs-varop'>`</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>4</span><span class='hs-cpp'>#</span>
<a name="line-324"></a>
<a name="line-325"></a><a name="unpackUtf8Char"></a><span class='hs-comment'>-- | Take the current address, read unicode char of the given size.</span>
<a name="line-326"></a><span class='hs-comment'>-- We obviously want the number of bytes, but we have to read one</span>
<a name="line-327"></a><span class='hs-comment'>-- byte to determine the number of bytes for the current codepoint</span>
<a name="line-328"></a><span class='hs-comment'>-- so we might as well reuse it and avoid a read.</span>
<a name="line-329"></a><span class='hs-comment'>--</span>
<a name="line-330"></a><span class='hs-comment'>-- Side Note: We don't dare to decode all 4 possibilities at once.</span>
<a name="line-331"></a><span class='hs-comment'>-- Reading past the end of the addr might trigger an exception.</span>
<a name="line-332"></a><span class='hs-comment'>-- For this reason we really have to check the width first and only</span>
<a name="line-333"></a><span class='hs-comment'>-- decode after.</span>
<a name="line-334"></a><span class='hs-comment'>{-# INLINE unpackUtf8Char# #-}</span>
<a name="line-335"></a><span class='hs-definition'>unpackUtf8Char</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bytes</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Char</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Char</span><span class='hs-cpp'>#</span>
<a name="line-336"></a><span class='hs-definition'>unpackUtf8Char</span><span class='hs-cpp'>#</span> <span class='hs-varid'>bytes</span> <span class='hs-varid'>ch</span> <span class='hs-varid'>addr</span> <span class='hs-keyglyph'>=</span>
<a name="line-337"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>bytes</span> <span class='hs-keyword'>of</span>
<a name="line-338"></a>    <span class='hs-conid'>One</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ch</span>
<a name="line-339"></a>    <span class='hs-conid'>Two</span> <span class='hs-keyglyph'>-&gt;</span>   <span class='hs-layout'>(</span><span class='hs-varid'>chr</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>ord</span><span class='hs-cpp'>#</span> <span class='hs-varid'>ch</span>                                           <span class='hs-varop'>-#</span> <span class='hs-num'>0xC0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span>  <span class='hs-num'>6</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>+#</span>
<a name="line-340"></a>                     <span class='hs-layout'>(</span><span class='hs-varid'>ord</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>indexCharOffAddr</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>addr</span> <span class='hs-varop'>`</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>-#</span> <span class='hs-num'>0x80</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-341"></a>    <span class='hs-conid'>Three</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>chr</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>ord</span><span class='hs-cpp'>#</span> <span class='hs-varid'>ch</span>                                           <span class='hs-varop'>-#</span> <span class='hs-num'>0xE0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>12</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>+#</span>
<a name="line-342"></a>                    <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>ord</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>indexCharOffAddr</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>addr</span> <span class='hs-varop'>`</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>-#</span> <span class='hs-num'>0x80</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span>  <span class='hs-num'>6</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>+#</span>
<a name="line-343"></a>                     <span class='hs-layout'>(</span><span class='hs-varid'>ord</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>indexCharOffAddr</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>addr</span> <span class='hs-varop'>`</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>2</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>-#</span> <span class='hs-num'>0x80</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-344"></a>    <span class='hs-conid'>Four</span> <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-layout'>(</span><span class='hs-varid'>chr</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>ord</span><span class='hs-cpp'>#</span> <span class='hs-varid'>ch</span>                                           <span class='hs-varop'>-#</span> <span class='hs-num'>0xF0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>18</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>+#</span>
<a name="line-345"></a>                    <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>ord</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>indexCharOffAddr</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>addr</span> <span class='hs-varop'>`</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>-#</span> <span class='hs-num'>0x80</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>12</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>+#</span>
<a name="line-346"></a>                    <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>ord</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>indexCharOffAddr</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>addr</span> <span class='hs-varop'>`</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>2</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>-#</span> <span class='hs-num'>0x80</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span>  <span class='hs-num'>6</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>+#</span>
<a name="line-347"></a>                     <span class='hs-layout'>(</span><span class='hs-varid'>ord</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>indexCharOffAddr</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>addr</span> <span class='hs-varop'>`</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-num'>3</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>-#</span> <span class='hs-num'>0x80</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre></body>
</html>
