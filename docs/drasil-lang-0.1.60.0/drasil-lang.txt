-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Language SubPackage
--   
--   Please see the README on GitHub at
--   <a>https://github.com/JacquesCarette/Drasil#readme</a>
@package drasil-lang
@version 0.1.60.0


-- | Alphabet of capital/lowercase English letters as symbols.
module Language.Drasil.ShortHands

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cA :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cB :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cC :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cD :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cE :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cF :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cG :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cH :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cI :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cJ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cK :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cL :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cM :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cN :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cO :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cP :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cQ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cR :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cS :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cT :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cU :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cV :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cW :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cX :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cY :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cZ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lA :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lB :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lC :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lD :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lE :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lF :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lG :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lH :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lI :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lJ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lK :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lL :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lM :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lN :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lO :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lP :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lQ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lR :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lS :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lT :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lU :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lV :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lW :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lX :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lY :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lZ :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lAlpha :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cAlpha :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lBeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cBeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lGamma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cGamma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lDelta :: Symbol

-- | <tt>Δ</tt> is often used as a decoration on top of a symbol. For
--   example, <tt>Δx</tt> and <tt>Δy</tt> represent the change in x and the
--   change in y. The variable defined here represents delta as its own
--   independent symbol and should not be used to represent "the change in"
--   something.
--   
--   Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cDelta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lEpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
vEpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cEpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lZeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cZeta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lEta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cEta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lTheta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cTheta :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lIota :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cIota :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lKappa :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cKappa :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lLambda :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cLambda :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lMu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cMu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lNu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cNu :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lXi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cXi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lOmicron :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cOmicron :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cPi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lRho :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cRho :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lSigma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cSigma :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lTau :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cTau :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lUpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cUpsilon :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPhi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
vPhi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cPhi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lChi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cChi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPsi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cPsi :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lOmega :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
cOmega :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lNabla :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lEll :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lPosInf :: Symbol

-- | Short forms of various variable names. c means <i>capital</i>; l means
--   <i>lowercase</i>.
lNegInf :: Symbol


-- | Re-export display-related functions and types to simplify external
--   use.
module Language.Drasil.Display

-- | Decorations on symbols/characters such as hats or Vector
--   representations (determines bolding, italics, etc).
data Decoration

-- | Places a <tt>^</tt> on top of a symbol.
Hat :: Decoration

-- | Makes a symbol bold.
Vector :: Decoration

-- | Appends a <tt>'</tt> to a symbol.
Prime :: Decoration

-- | Prepends a <tt>Δ</tt> to a symbol.
Delta :: Decoration

-- | Places <tt>||</tt> before and after a symbol.
Magnitude :: Decoration

-- | A <a>Symbol</a> is actually going to be a graphical description of
--   what gets rendered as a (unique) symbol. This is actually NOT based on
--   semantics at all, but just a description of how things look.
--   
--   Symbols can be:
--   
--   <ul>
--   <li><tt><a>Variable</a></tt> (string such as "x" that represent a
--   value that can vary)</li>
--   <li><tt><a>Label</a></tt> (strings such as "max" or "target" that
--   represent a single idea)</li>
--   <li><tt><a>Symbol</a></tt> characters (ex. unicode)</li>
--   <li><tt>Decorated</tt> symbols using <a>Atop</a></li>
--   <li><tt>Concatenations</tt> of symbols, including subscripts and
--   superscripts</li>
--   <li><tt><a>Empty</a></tt>! (this is to give this a monoid-like
--   flavour)</li>
--   </ul>
data Symbol

-- | Basic variable name creation.
Variable :: String -> Symbol

-- | For when symbols need more context, but we don't want to add a new
--   variable name. For example, <tt>v_f</tt> may be encoded as <tt>Concat
--   [variable "v", label "f"]</tt>.
Label :: String -> Symbol

-- | For using numbers in Symbols.
Integ :: Int -> Symbol

-- | For now, special characters are the degree and partial differentiation
--   symbols. These should eventually move elsewhere and the <a>Symbol</a>
--   type removed.
Special :: Special -> Symbol

-- | Used to decorate symbols. For things like vectors (which need to be
--   bold), primes, magnitudes, etc. See <a>Decoration</a> for more
--   details.
Atop :: Decoration -> Symbol -> Symbol

-- | Order of Symbols: upleft lowleft upright lowright base. Ex:
--   
--   <pre>
--   Corners [1]   [2]   [3]   [4]   [5]
--   </pre>
--   
--   <pre>
--   Visually:  [1]   [3]
--   
--                 [5]
--   
--              [2]   [4]
--   </pre>
Corners :: [Symbol] -> [Symbol] -> [Symbol] -> [Symbol] -> Symbol -> Symbol

-- | Concatentation of two symbols: <tt>[s1, s2] -&gt; s1s2</tt>
Concat :: [Symbol] -> Symbol

-- | Placeholder for when a symbol is not needed.
Empty :: Symbol

-- | The default compare function that sorts all the lower case symbols
--   after the upper case ones.
--   
--   Comparation is used twice for each <tt>Atomic</tt> case, once for
--   making sure they are the same letter, once for case sensitive. As far
--   as this comparison is considered, <tt>Δ</tt> is a "decoration" and
--   ignored unless the compared symbols are the exact same, in which case
--   it is ordered after the undecorated symbol.
--   
--   Superscripts and subscripts are ordered after the base symbols
--   (because they add additional context to a symbol). For example:
--   `v_f^{AB}` (expressed in LaTeX notation for clarity), where
--   <tt>v_f</tt> is a final velocity, and the `^{AB}` adds context that it
--   is the final velocity between points <tt>A</tt> and <tt>B</tt>. In
--   these cases, the sorting of `v_f^{AB}` should be following
--   <tt>v_f</tt> as it is logical to place it with its parent concept.
compsy :: Symbol -> Symbol -> Ordering

module Language.Drasil.Literal.Development
data Literal
[Int] :: Integer -> Literal
[Str] :: String -> Literal
[Dbl] :: Double -> Literal
[ExactDbl] :: Integer -> Literal
[Perc] :: Integer -> Integer -> Literal


-- | Re-export functions and types related to <a>ModelExpr</a>
module Language.Drasil.ModelExpr.Development

-- | Expression language where all terms are supposed to have a meaning,
--   but that meaning may not be that of a definite value. For example,
--   specification expressions, especially with quantifiers, belong here.
data ModelExpr

-- | Brings a literal into the expression language.
[Lit] :: Literal -> ModelExpr

-- | Introduce Space values into the expression language.
[Spc] :: Space -> ModelExpr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [ModelExpr] -> ModelExpr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [ModelExpr] -> ModelExpr

-- | Derivative syntax is: Type (<a>Part</a>ial or <a>Total</a>) -&gt;
--   principal part of change -&gt; with respect to For example: Deriv Part
--   y x1 would be (dy/dx1).
[Deriv] :: Integer -> DerivType -> ModelExpr -> UID -> ModelExpr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> ModelExpr

-- | Function applications.
[FCall] :: UID -> [ModelExpr] -> ModelExpr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(ModelExpr, ModelExpr)] -> ModelExpr

-- | Represents a matrix of expressions.
[Matrix] :: [[ModelExpr]] -> ModelExpr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> ModelExpr -> ModelExpr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> ModelExpr -> ModelExpr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Space-related binary operations.
[SpaceBinaryOp] :: SpaceBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Statement-related binary operations.
[StatBinaryOp] :: StatBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Binary operator for <tt>Number x Vector -&gt; Vector</tt> operations
--   (scaling).
[NVVBinaryOp] :: NVVBinOp -> ModelExpr -> ModelExpr -> ModelExpr

-- | Operators are generalized arithmetic operators over a
--   <a>DomainDesc</a> of an <tt>Expr</tt>. Could be called BigOp. ex:
--   Summation is represented via <a>Add</a> over a discrete domain.
[Operator] :: AssocArithOper -> DomainDesc t ModelExpr ModelExpr -> ModelExpr -> ModelExpr

-- | A different kind of <a>IsIn</a>. A <a>UID</a> is an element of an
--   interval.
[RealI] :: UID -> RealInterval ModelExpr ModelExpr -> ModelExpr

-- | Universal quantification
[ForAll] :: UID -> Space -> ModelExpr -> ModelExpr

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Value -&gt; Space -&gt; Bool</tt> operators.
data SpaceBinOp
IsIn :: SpaceBinOp

-- | Statements involving 2 arguments.
data StatBinOp
Defines :: StatBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product, vector addition, subtraction).
data VVVBinOp
Cross :: VVVBinOp
VAdd :: VVVBinOp
VSub :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | <tt>Number x Vector -&gt; Vector</tt> binary operations (scaling).
data NVVBinOp
Scale :: NVVBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
Add :: AssocArithOper
Mul :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper
Equivalence :: AssocBoolOper

-- | Determines the type of the derivative (either a partial derivative or
--   a total derivative).
data DerivType
Part :: DerivType
Total :: DerivType

-- | For case expressions (either complete or incomplete).
data Completeness
Complete :: Completeness
Incomplete :: Completeness
expr :: Expr -> ModelExpr

-- | Get dependencies from an equation.
meDep :: ModelExpr -> [UID]

-- | eprec - <a>ModelExpr</a> precedence.
mePrec :: ModelExpr -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int


-- | Developing the expression language in Drasil. Re-export many things to
--   simplify external use.
module Language.Drasil.Development
class NounPhrase n

-- | Retrieves singular form of term. Ex. "the quick brown fox".
phraseNP :: NounPhrase n => n -> Sentence

-- | Retrieves plural form of term. Ex. "the quick brown foxes".
pluralNP :: NounPhrase n => n -> PluralForm

-- | This is to collect <i>symbolic</i> <a>UID</a>s that are printed out as
--   a <tt>Symbol</tt>.
sdep :: Sentence -> [UID]
shortdep :: Sentence -> [UID]

-- | Generic traverse of all positions that could lead to <i>reference</i>
--   <a>UID</a>s from <a>Sentence</a>s.
lnames :: Sentence -> [UID]

-- | Get <i>reference</i> <a>UID</a>s from <a>Sentence</a>s.
lnames' :: [Sentence] -> [UID]

-- | Grabs the UID from something that has a UID and displays it as a
--   String.
showUID :: HasUID a => a -> String

module Language.Drasil.Expr.Development

-- | Expression language where all terms are supposed to be 'well
--   understood' (i.e., have a definite meaning). Right now, this coincides
--   with "having a definite value", but should not be restricted to that.
data Expr

-- | Brings a literal into the expression language.
[Lit] :: Literal -> Expr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [Expr] -> Expr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [Expr] -> Expr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> Expr

-- | Function applications.
[FCall] :: UID -> [Expr] -> Expr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(Expr, Relation)] -> Expr

-- | Represents a matrix of expressions.
[Matrix] :: [[Expr]] -> Expr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> Expr -> Expr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> Expr -> Expr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> Expr -> Expr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> Expr -> Expr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> Expr -> Expr -> Expr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> Expr -> Expr -> Expr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> Expr -> Expr -> Expr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> Expr -> Expr -> Expr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> Expr -> Expr -> Expr

-- | Binary operator for <tt>Expr x Vector -&gt; Vector</tt> operations
--   (scaling).
[NVVBinaryOp] :: NVVBinOp -> Expr -> Expr -> Expr

-- | Operators are generalized arithmetic operators over a
--   <tt>DomainDesc</tt> of an <a>Expr</a>. Could be called BigOp. ex:
--   Summation is represented via <a>Add</a> over a discrete domain.
[Operator] :: AssocArithOper -> DiscreteDomainDesc Expr Expr -> Expr -> Expr

-- | A different kind of <tt>IsIn</tt>. A <a>UID</a> is an element of an
--   interval.
[RealI] :: UID -> RealInterval Expr Expr -> Expr

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product, addition, subtraction).
data VVVBinOp
Cross :: VVVBinOp
VAdd :: VVVBinOp
VSub :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | <tt>Number x Vector -&gt; Vector</tt> binary operations (scaling).
data NVVBinOp
Scale :: NVVBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
Add :: AssocArithOper
Mul :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper

-- | For case expressions (either complete or incomplete).
data Completeness
Complete :: Completeness
Incomplete :: Completeness

-- | A relation is just an expression (<a>Expr</a>).
type Relation = Expr

-- | Get dependencies from an equation.
eDep :: Expr -> [UID]

-- | Generic traverse of all expressions that could lead to names.
eNames :: Expr -> [UID]

-- | Generic traverse of all positions that could lead to <a>eNames</a>
--   without functions. FIXME : this should really be done via post-facto
--   filtering, but right now the information needed to do this is not
--   available!
eNames' :: Expr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>eNames</a>).
eNamesRI :: RealInterval Expr Expr -> [UID]

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | eprec - <a>Expression</a> precedence.
eprec :: Expr -> Int


-- | Defines various sentence level combinators that may be based in
--   English and not necessarily have a conceptual link. See the
--   <a>Wiki</a> for more information. There are also <tt>C</tt> variants
--   to each combinator to denote those meant for use at the start of a
--   sentence (capitalizes the first word). This module should be used as a
--   qualified import (usually as <tt>S</tt>), as many function names clash
--   with those in Concepts.hs and NounPhrase.hs.
module Language.Drasil.Sentence.Combinators

-- | Inserts the word "and" between two Sentences.
and_ :: Sentence -> Sentence -> Sentence

-- | Inserts the words "and its" between two Sentences.
andIts :: Sentence -> Sentence -> Sentence

-- | Inserts the words "and the" between two Sentences.
andThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "from the" between two Sentences.
fromThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "in the" between two Sentences.
inThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "on the" between two Sentences.
onThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "to the" between two Sentences.
toThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "is the" between two Sentences.
isThe :: Sentence -> Sentence -> Sentence

-- | Inserts the words "of the" between two Sentences.
ofThe :: Sentence -> Sentence -> Sentence

-- | Same as <a>ofThe</a>, but inserts "the" at the beginning of the
--   Sentence.
the_ofThe :: Sentence -> Sentence -> Sentence

-- | Same as <a>the_ofThe</a>, except first "the" is capitalized.
the_ofTheC :: Sentence -> Sentence -> Sentence

-- | Prepends "the" and inserts "of a given" between two Sentences.
the_ofGiv :: Sentence -> Sentence -> Sentence

-- | Same as <tt>ofGiv</tt>, except first "the" is capitalized.
the_ofGivC :: Sentence -> Sentence -> Sentence

-- | Prepends "The" and inserts "is expected to have" between two
--   Sentences.
the_isExpctdToHvC :: Sentence -> Sentence -> Sentence

-- | Similar to <a>for</a>, but used for titles and first <a>NamedIdea</a>
--   is pluralized.
forTPS :: (NamedIdea c, NamedIdea d) => c -> d -> Sentence

-- | Similar to <tt>forTTPS</tt>, but both <a>NamedIdea</a>s are
--   pluralized.
forTPP :: (NamedIdea c, NamedIdea d) => c -> d -> Sentence

-- | Inserts the word "for" between two Sentences.
for :: Sentence -> Sentence -> Sentence

-- | Similar to <a>for</a>, but both terms are <a>titleize</a>d.
forT :: (NamedIdea c, NamedIdea d) => c -> d -> Sentence

-- | Similar to <tt>forTT</tt>, but takes two arguments (for capitalization
--   or pluralization) to apply to the two terms respectively.
forGen :: (c -> Sentence) -> (d -> Sentence) -> c -> d -> Sentence

-- | Inserts the word "of" between two Sentences.
of_ :: Sentence -> Sentence -> Sentence

-- | Inserts the words "of a" between two Sentences.
ofA :: Sentence -> Sentence -> Sentence

-- | Inserts the word "or" between two Sentences.
or_ :: Sentence -> Sentence -> Sentence

-- | Inserts the word "are" between two Sentences.
are :: Sentence -> Sentence -> Sentence

-- | Inserts the word "in" between two Sentences.
in_ :: Sentence -> Sentence -> Sentence

-- | Inserts the word "is" between two Sentences.
is :: Sentence -> Sentence -> Sentence

-- | Inserts the words "defined as" between two Sentences.
defnAs :: Sentence -> Sentence -> Sentence

-- | Inserts the words "denotes the" between two Sentences.
denotes :: Sentence -> Sentence -> Sentence

-- | Inserts the word "versus" between two Sentences.
versus :: Sentence -> Sentence -> Sentence

-- | Inserts the words "with respect to" between two Sentences.
wrt :: Sentence -> Sentence -> Sentence


-- | Defines various NounPhrase-level combinators. These hold more
--   information than those of the Sentence level but may not necessarily
--   have a conceptual link. See the <a>Wiki</a> for more information and
--   details about the naming process for combinators. A summary of the
--   function naming scheme is as follows:
--   
--   <ul>
--   <li>Combinators that conflict with haskell-native functions have an
--   underscore appended.</li>
--   <li>Default plural case for combinators will be first term singular,
--   second term plural.</li>
--   <li><tt>P</tt> and <tt>S</tt> denote the plural case of the combinator
--   when it does not follow the above default.</li>
--   <li><tt>Gen</tt> denotes the general function case.</li>
--   </ul>
--   
--   This module should be used as a qualified import (usually as
--   <tt>NP</tt>), as many function names clash with those in Concepts.hs
--   and Sentence.hs.
module Language.Drasil.NounPhrase.Combinators

-- | Helper function that places a <a>String</a> in between two <a>NP</a>s.
--   Plural case is <tt>(phraseNP t1) +:+ S s +:+ (pluralNP t2)</tt>.
insertString :: String -> NP -> NP -> NP

-- | Helper function that prepends a <a>String</a> to a <a>NP</a>.
prependString :: String -> NP -> NP

-- | Helper function that places a <a>Sentence</a> in between two
--   <a>NP</a>s. Plural case is <tt>(phraseNP t1) +:+ s +:+ (pluralNP
--   t2)</tt>.
insertSent :: Sentence -> NP -> NP -> NP

-- | Helper function that prepends a <a>Sentence</a> to a <a>NP</a>.
prependSent :: Sentence -> NP -> NP

-- | Prepends "the" to a <a>NP</a>.
the :: NP -> NP

-- | Similar to <a>the</a>, but accepts a function that determines the
--   plural case.
theGen :: (NP -> Sentence) -> NP -> NP

-- | Prepends "a" to a <a>NP</a>.
a_ :: NP -> NP

-- | Similar to <tt>a</tt>, but accepts a function that determines the
--   plural case.
a_Gen :: (NP -> Sentence) -> NP -> NP

-- | Inserts "and" between two <a>NP</a>s. Plural case is <tt>(phraseNP t1)
--   +:+ "and" +:+ (pluralNP t2)</tt>.
and_ :: NP -> NP -> NP

-- | Same as <a>and_</a>, but plural case is now <tt>(pluralNP t1)
--   <a>and_</a> (phraseNP t2)</tt>.
and_PS :: NP -> NP -> NP

-- | Same as <a>and_</a>, but takes two functions for the plural case.
and_Gen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Same as <a>and_</a>, but takes two functions for the singular case and
--   two for the plural case.
and_GenGen :: (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "and the" between two <a>NP</a>s. Plural case is <tt>(phraseNP
--   t1) +:+ "and the" +:+ (pluralNP t2)</tt>.
andThe :: NP -> NP -> NP

-- | Inserts "of the" between two <a>NP</a>s. Plural case is <tt>(phraseNP
--   t1) +:+ "of the" +:+ (pluralNP t2)</tt>.
ofThe :: NP -> NP -> NP

-- | Similar to <a>ofThe</a>, but the plural case is now <tt>(pluralNP t1)
--   <a>ofThe</a> (phraseNP t2)</tt>.
ofThePS :: NP -> NP -> NP

-- | Similar to <a>ofThe</a>, but accepts two functions for the plural
--   case.
ofTheGen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "in the" between two <a>NP</a>s. Plural case is <tt>(phraseNP
--   t1) +:+ "in the" +:+ (pluralNP t2)</tt>.
inThe :: NP -> NP -> NP

-- | Similar to <a>ofThe</a>, but the plural case is now <tt>(pluralNP t1)
--   <a>inThe</a> (phraseNP t2)</tt>.
inThePS :: NP -> NP -> NP

-- | Similar to <a>ofThe</a>, but accepts two functions for the plural
--   case.
inTheGen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Prepends "the" and inserts "of the". Plural case is <tt>"the" +:+
--   (phraseNP t1) +:+ "of the" +:+ (pluralNP t2)</tt>.
the_ofThe :: NP -> NP -> NP

-- | Similar to <a>the_ofThe</a>, but the plural case is now <tt> S "the"
--   +:+ (pluralNP t1) <a>ofThe</a> (phraseNP t2)</tt>.
the_ofThePS :: NP -> NP -> NP

-- | Similar to <tt>the_ofThe'</tt>, but takes two functions for the plural
--   case.
the_ofTheGen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "for" between two <a>NP</a>s. Plural case is <tt>(phraseNP t1)
--   +:+ "for" +:+ (pluralNP t2)</tt>.
for :: NP -> NP -> NP

-- | Same as <a>for</a>, but plural case is now <tt>(pluralNP t1)
--   <a>for</a> (phraseNP t2)</tt>.
forPS :: NP -> NP -> NP

-- | Same as <tt>for'</tt>, but takes two functions for the plural case.
forGen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "of" between two <a>NP</a>s. Plural case is <tt>(phraseNP t1)
--   +:+ "of" +:+ (pluralNP t2)</tt>.
of_ :: NP -> NP -> NP

-- | Same as <a>of_</a>, but plural case is now <tt>(pluralNP t1)
--   <a>of_</a> (phraseNP t2)</tt>.
of_PS :: NP -> NP -> NP

-- | Same as <a>of_</a>, but takes two functions for the plural case.
of_Gen :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Same as <a>of_</a>, but takes two functions for the singular case and
--   two for the plural case.
of_GenGen :: (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Inserts "with" between two <a>NP</a>s. Plural case is <tt>(phraseNP
--   t1) +:+ "with" +:+ (pluralNP t2)</tt>.
with :: NP -> NP -> NP


-- | Defines various chunk combinators. The full naming scheme can be found
--   in the <a>Wiki</a>. For convenience, here is a summary:
--   
--   <ul>
--   <li>Combinators that conflict with haskell-native functions have an
--   underscore appended.</li>
--   <li>Default plural case for combinators will be first term singular,
--   second term plural.</li>
--   <li><tt>P</tt> and <tt>S</tt> denote the plural case of the combinator
--   when it does not follow the above default.</li>
--   <li><tt>Gen</tt> denotes the general function case.</li>
--   <li>Although this should eventually be phased out, <tt>T</tt> denotes
--   a combinator meant for use with titles.</li>
--   <li><tt>NI</tt> and <tt>NP</tt> denote whether something must be a
--   part of the <a>NamedIdea</a> or <a>NounPhrase</a> class.</li>
--   </ul>
module Language.Drasil.Chunk.Concept.NamedCombinators

-- | Prepends "the" to a <a>NamedIdea</a>.
the :: NamedIdea t => t -> NP

-- | A customizable version of <a>the</a>. The given function is applied to
--   both singular and plural cases.
theGen :: (t -> Sentence) -> t -> NP

-- | Prepends "a" to a <a>NamedIdea</a> (similar to <a>the</a>).
a_ :: NamedIdea c => c -> NP

-- | Customizable version of <tt>a</tt>.
a_Gen :: (c -> Sentence) -> c -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "and" between their terms. Plural case is <tt>(phrase t1) "and"
--   (plural t2)</tt>.
and_ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "and" between their terms. Plural case is <tt>(plural t1) "and"
--   (phrase t2)</tt>.
and_PS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "and" between their terms. Plural case is <tt>(plural t1) "and"
--   (plural t2)</tt>.
and_PP :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Customizable <a>and_</a> combinator (takes two title case
--   capitalization rules and two <tt>NamedIdeas</tt>).
and_TGen :: (NamedIdea c, NamedIdea d) => (c -> Sentence) -> (d -> Sentence) -> c -> d -> NP

-- | Customizable <a>and_</a> combinator. Both plural and singular cases
--   are dermined by the two given functions
and_Gen :: (c -> Sentence) -> (d -> Sentence) -> c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "and its" between their terms. Plural case is <tt>(phrase t1) "and
--   its" (plural t2)</tt>.
andIts :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "and the" between their terms. Plural case is <tt>(phrase t1) "and
--   the" (plural t2)</tt>.
andThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "of" between their terms. Plural case is <tt>(phrase t1) "of" (plural
--   t2)</tt>.
of_ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a> but second argument is a <a>NounPhrase</a>.
of_NINP :: (NamedIdea c, NounPhrase d) => c -> d -> NP

-- | Same as <a>of_</a> but first argument is a <a>NounPhrase</a> and
--   plural case is <tt>(plural t1) "of" (phrase t2)</tt>.
of_PSNPNI :: (NounPhrase c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a>, except plural case is <tt>(plural t1) "of" (phrase
--   t2)</tt>.
of_PS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_PS</a>, except combining <a>Sentence</a> piece is "of
--   a".
ofA :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>ofA</a>, except phrase case is <tt>(plural t1) "of a"
--   (phrase t2)</tt>.
ofAPS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a>, except combining <a>Sentence</a> piece is "of
--   the". Plural case is <tt>(phrase t1) <a>ofThe</a> (plural t2)</tt>.
ofThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>ofThe</a>, except plural case is <tt>(plural t1)
--   <a>ofThe</a> (phrase t2)</tt>.
ofThePS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>ofThe</a>, except prepends "the".
the_ofThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>the_ofThe</a>, except plural case is <tt>(plural t1)
--   <a>the_ofThe</a> (phrase t2)</tt>
the_ofThePS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>of_</a>, except combining Sentence piece is "on the".
onThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>onThe</a>, except plural case is (plural t1) S.onThe
--   (phrase t2)
onThePS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>onThe</a>, except plural case is (plural t1) S.onThe
--   (plural t2)
onThePP :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "in the" between their terms. Plural case is <tt>(phrase t1) "in the"
--   (plural t2)</tt>.
inThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "in the" between their terms. Plural case is <tt>(plural t1) "in the"
--   (phrase t2)</tt>.
inThePS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "in the" between their terms. Plural case is <tt>(plural t1) "in the"
--   (plural t2)</tt>.
inThePP :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "is the" between their terms. Plural case is <tt>(phrase t1) "is the"
--   (plural t2)</tt>.
isThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "to the" between their terms. Plural case is <tt>(phrase t1) "to the"
--   (plural t2)</tt>.
toThe :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "for" between their terms. Plural case is <tt>(phrase t1) "for"
--   (plural t2)</tt>.
for :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Similar to <a>for</a>, but takes two functions that determine the
--   <tt>titleCase</tt>.
forTGen :: (NamedIdea c, Idea d) => (c -> Sentence) -> (d -> Sentence) -> c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "in" between their terms. Plural case is <tt>(phrase t1) "in" (plural
--   t2)</tt>.
in_ :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Same as <a>in_</a>, except plural case is <tt>(plural t1) "in" (phrase
--   t2)</tt>.
in_PS :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the words
--   "in a" between their terms. Plural case is <tt>(phrase t1) "in a"
--   (plural t2)</tt>.
inA :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Creates a <a>NP</a> by combining two <a>NamedIdea</a>s with the word
--   "is" between their terms. Plural case is <tt>(phrase t1) "is" (plural
--   t2)</tt>.
is :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Case with "T1s with T2", as opposed to "T1 with T2", i.e. singular
--   case is <tt>(plural t1) "with" (phrase t2)</tt> while the plural case
--   pluralizes the first.
with :: (NamedIdea c, NamedIdea d) => c -> d -> NP

-- | Combinator for combining two <tt>NamedIdeas</tt>s into a
--   <a>IdeaDict</a>. Plural case only makes second term plural. See
--   <a>compoundPhrase</a> for more on plural behaviour. <i>Does not
--   preserve abbreviations</i>.
compoundNC :: (NamedIdea a, NamedIdea b) => a -> b -> IdeaDict

-- | Similar to <a>compoundNC</a> but both terms are pluralized for plural
--   case.
compoundNCPP :: (NamedIdea a, NamedIdea b) => a -> b -> IdeaDict

-- | Similar to <a>compoundNC</a>, except plural cases are customizable.
compoundNCGen :: (NamedIdea a, NamedIdea b) => (NP -> Sentence) -> (NP -> Sentence) -> a -> b -> IdeaDict

-- | Similar to <a>compoundNC</a>, except for plural case, where first
--   parameter gets pluralized while second one stays singular.
compoundNCPS :: IdeaDict -> IdeaDict -> IdeaDict

-- | Similar to <a>compoundNCGenP</a> but sets first parameter function to
--   plural.
compoundNCPSPP :: IdeaDict -> IdeaDict -> IdeaDict

-- | Similar to <a>compoundNC</a>, but takes a function that is applied to
--   the first term (eg. <tt>short</tt> or <a>plural</a>).
compoundNCGenP :: (NamedIdea a, NamedIdea b) => (NP -> Sentence) -> a -> b -> IdeaDict

-- | Helper function that combines a <a>NamedIdea</a> and a <a>NP</a>
--   without any words in between. Plural case is <tt>(phrase t1) +:+
--   (pluralNP t2)</tt>.
combineNINP :: NamedIdea c => c -> NP -> NP

-- | Similar to <a>combineNINP</a> but takes in a <a>NP</a> first and a
--   <a>NamedIdea</a> second.
combineNPNI :: NamedIdea c => NP -> c -> NP

-- | Similar to <a>combineNINP</a> but takes two <a>NamedIdea</a>s.
combineNINI :: (NamedIdea c, NamedIdea d) => c -> d -> NP


-- | Re-exporting modules
module Language.Drasil.CodeExpr.Development

-- | Expression language where all terms also denote a term in GOOL (i.e.
--   translation is total and meaning preserving).
data CodeExpr

-- | Brings literals into the expression language.
[Lit] :: Literal -> CodeExpr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [CodeExpr] -> CodeExpr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [CodeExpr] -> CodeExpr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> CodeExpr

-- | A function call accepts a list of parameters and a list of named
--   parameters. For example
--   
--   <ul>
--   <li>F(x) is (FCall F [x] []).</li>
--   <li>F(x,y) would be (FCall F [x,y]).</li>
--   <li>F(x,n=y) would be (FCall F [x] [(n,y)]).</li>
--   </ul>
[FCall] :: UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Actor creation given <a>UID</a>, parameters, and named parameters.
[New] :: UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Message an actor:
--   
--   <ul>
--   <li>1st <a>UID</a> is the actor,</li>
--   <li>2nd <a>UID</a> is the method.</li>
--   </ul>
[Message] :: UID -> UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Access a field of an actor:
--   
--   <ul>
--   <li>1st <a>UID</a> is the actor,</li>
--   <li>2nd <a>UID</a> is the field.</li>
--   </ul>
[Field] :: UID -> UID -> CodeExpr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(CodeExpr, CodeExpr)] -> CodeExpr

-- | Represents a matrix of expressions.
[Matrix] :: [[CodeExpr]] -> CodeExpr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> CodeExpr -> CodeExpr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Number x Vector -&gt; Vector</tt> operations
--   (scaling).
[NVVBinaryOp] :: NVVBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Operators are generalized arithmetic operators over a
--   <tt>DomainDesc</tt> of an <tt>Expr</tt>. Could be called BigOp. ex:
--   Summation is represented via <a>Add</a> over a discrete domain.
[Operator] :: AssocArithOper -> DiscreteDomainDesc CodeExpr CodeExpr -> CodeExpr -> CodeExpr

-- | The expression is an element of a space. IsIn :: Expr -&gt; Space
--   -&gt; Expr | A different kind of <tt>IsIn</tt>. A <a>UID</a> is an
--   element of an interval.
[RealI] :: UID -> RealInterval CodeExpr CodeExpr -> CodeExpr

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product, vector addition, vector sub).
data VVVBinOp
Cross :: VVVBinOp
VAdd :: VVVBinOp
VSub :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | <tt>Number x Vector -&gt; Vector</tt> binary operations (scaling).
data NVVBinOp
Scale :: NVVBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
Add :: AssocArithOper
Mul :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN
class CodeExprC r

-- | Constructs a CodeExpr for actor creation (constructor call)
new :: (CodeExprC r, Callable f, HasUID f, CodeIdea f) => f -> [r] -> r

-- | Constructs a CodeExpr for actor creation (constructor call) that uses
--   named arguments
newWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr for actor messaging (method call)
msg :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c) => c -> f -> [r] -> r

-- | Constructs a CodeExpr for actor messaging (method call) that uses
--   named arguments
msgWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c, HasUID a, IsArgumentName a) => c -> f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr representing the field of an actor
field :: CodeExprC r => CodeVarChunk -> CodeVarChunk -> r

-- | Similar to <a>apply</a>, but takes a relation to apply to
--   <a>FCall</a>.
applyWithNamedArgs :: (CodeExprC r, HasUID f, HasSymbol f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Get dependencies from an equation.
eDep :: CodeExpr -> [UID]

-- | Get dependencies from an equation, without functions.
eDep' :: CodeExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>eNames</a>).
eNamesRI :: RealInterval CodeExpr CodeExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names without functions (similar to <a>eNames'</a>).
eNamesRI' :: RealInterval CodeExpr CodeExpr -> [UID]

-- | eprec - <a>Expression</a> precedence.
eprec :: CodeExpr -> Int

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | Render an algebraic expression into our code expression language.
expr :: Expr -> CodeExpr

-- | Convert <a>RealInterval</a> <tt>Expr</tt> <tt>Expr</tt>s into
--   <a>RealInterval</a> <a>CodeExpr</a> <a>CodeExpr</a>s.
realInterval :: RealInterval Expr Expr -> RealInterval CodeExpr CodeExpr

-- | Convert constrained expressions (<a>ConstraintE</a>) into
--   <tt>Constraint''CodeExpr</tt>s.
constraint :: ConstraintE -> Constraint CodeExpr
class CanGenCode e
toCodeExpr :: CanGenCode e => e -> CodeExpr


-- | Re-export CodeExpr constructors.
module Language.Drasil.CodeExpr

-- | Expression language where all terms also denote a term in GOOL (i.e.
--   translation is total and meaning preserving).
data CodeExpr
class CodeExprC r

-- | Constructs a CodeExpr for actor creation (constructor call)
new :: (CodeExprC r, Callable f, HasUID f, CodeIdea f) => f -> [r] -> r

-- | Constructs a CodeExpr for actor creation (constructor call) that uses
--   named arguments
newWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr for actor messaging (method call)
msg :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c) => c -> f -> [r] -> r

-- | Constructs a CodeExpr for actor messaging (method call) that uses
--   named arguments
msgWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c, HasUID a, IsArgumentName a) => c -> f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr representing the field of an actor
field :: CodeExprC r => CodeVarChunk -> CodeVarChunk -> r

-- | Similar to <a>apply</a>, but takes a relation to apply to
--   <a>FCall</a>.
applyWithNamedArgs :: (CodeExprC r, HasUID f, HasSymbol f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r
class ExprC r
lit :: ExprC r => Literal -> r
($=) :: ExprC r => r -> r -> r
($!=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>=) :: ExprC r => r -> r -> r

-- | Smart constructor for the dot product of two equations.
($.) :: ExprC r => r -> r -> r

-- | Add two expressions.
($+) :: ExprC r => r -> r -> r

-- | Multiply two expressions.
($*) :: ExprC r => r -> r -> r
($-) :: ExprC r => r -> r -> r
($/) :: ExprC r => r -> r -> r
($^) :: ExprC r => r -> r -> r
($=>) :: ExprC r => r -> r -> r
($<=>) :: ExprC r => r -> r -> r
($&&) :: ExprC r => r -> r -> r
($||) :: ExprC r => r -> r -> r

-- | Smart constructor for taking the absolute value of an expression.
abs_ :: ExprC r => r -> r

-- | Smart constructor for negating an expression.
neg :: ExprC r => r -> r

-- | Smart constructor to take the log of an expression.
log :: ExprC r => r -> r

-- | Smart constructor to take the ln of an expression.
ln :: ExprC r => r -> r

-- | Smart constructor to take the square root of an expression.
sqrt :: ExprC r => r -> r

-- | Smart constructor to apply sin to an expression.
sin :: ExprC r => r -> r

-- | Smart constructor to apply cos to an expression.
cos :: ExprC r => r -> r

-- | Smart constructor to apply tan to an expression.
tan :: ExprC r => r -> r

-- | Smart constructor to apply sec to an expression.
sec :: ExprC r => r -> r

-- | Smart constructor to apply csc to an expression.
csc :: ExprC r => r -> r

-- | Smart constructor to apply cot to an expression.
cot :: ExprC r => r -> r

-- | Smart constructor to apply arcsin to an expression.
arcsin :: ExprC r => r -> r

-- | Smart constructor to apply arccos to an expression.
arccos :: ExprC r => r -> r

-- | Smart constructor to apply arctan to an expression.
arctan :: ExprC r => r -> r

-- | Smart constructor for the exponential (base e) function.
exp :: ExprC r => r -> r

-- | Smart constructor for calculating the dimension of a vector.
dim :: ExprC r => r -> r

-- | Smart constructor for calculating the normal form of a vector.
norm :: ExprC r => r -> r

-- | Smart constructor for negating vectors.
negVec :: ExprC r => r -> r

-- | Smart constructor for applying logical negation to an expression.
not_ :: ExprC r => r -> r

-- | Smart constructor for indexing.
idx :: ExprC r => r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defint :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defsum :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defprod :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for 'real interval' membership.
realInterval :: (ExprC r, HasUID c) => c -> RealInterval r r -> r

-- | Euclidean function : takes a vector and returns the sqrt of the
--   sum-of-squares.
euclidean :: ExprC r => [r] -> r

-- | Smart constructor to cross product two expressions.
cross :: ExprC r => r -> r -> r

-- | Smart constructor for vector scaling
vScale :: ExprC r => r -> r -> r

-- | Vector Addition
vAdd :: ExprC r => r -> r -> r

-- | Vector Subtraction
vSub :: ExprC r => r -> r -> r

-- | Smart constructor for case statements with a complete set of cases.
completeCase :: ExprC r => [(r, r)] -> r

-- | Smart constructor for case statements with an incomplete set of cases.
incompleteCase :: ExprC r => [(r, r)] -> r

-- | Create a matrix.
matrix :: ExprC r => [[r]] -> r

-- | Applies a given function with a list of parameters.
apply :: (ExprC r, HasUID f, HasSymbol f) => f -> [r] -> r

-- | Create an <a>Expr</a> from a <a>Symbol</a>ic Chunk.
sy :: (ExprC r, HasUID c, HasSymbol c) => c -> r
infixr 4 $=
infixr 9 $&&
infixl 7 $/
infixr 8 $^
infixr 9 $||
class LiteralC r
int :: LiteralC r => Integer -> r
str :: LiteralC r => String -> r
dbl :: LiteralC r => Double -> r
exactDbl :: LiteralC r => Integer -> r
perc :: LiteralC r => Integer -> Integer -> r

-- | Render an algebraic expression into our code expression language.
expr :: Expr -> CodeExpr


-- | The Drasil language, including expressions, chunks, sentences,
--   references, classes, datatypes, and generally useful functions.
--   Re-exports modules to simplify external use.
module Language.Drasil

-- | Expression language where all terms are supposed to be 'well
--   understood' (i.e., have a definite meaning). Right now, this coincides
--   with "having a definite value", but should not be restricted to that.
data Expr
class ExprC r
lit :: ExprC r => Literal -> r
($=) :: ExprC r => r -> r -> r
($!=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>=) :: ExprC r => r -> r -> r

-- | Smart constructor for the dot product of two equations.
($.) :: ExprC r => r -> r -> r

-- | Add two expressions.
($+) :: ExprC r => r -> r -> r

-- | Multiply two expressions.
($*) :: ExprC r => r -> r -> r
($-) :: ExprC r => r -> r -> r
($/) :: ExprC r => r -> r -> r
($^) :: ExprC r => r -> r -> r
($=>) :: ExprC r => r -> r -> r
($<=>) :: ExprC r => r -> r -> r
($&&) :: ExprC r => r -> r -> r
($||) :: ExprC r => r -> r -> r

-- | Smart constructor for taking the absolute value of an expression.
abs_ :: ExprC r => r -> r

-- | Smart constructor for negating an expression.
neg :: ExprC r => r -> r

-- | Smart constructor to take the log of an expression.
log :: ExprC r => r -> r

-- | Smart constructor to take the ln of an expression.
ln :: ExprC r => r -> r

-- | Smart constructor to take the square root of an expression.
sqrt :: ExprC r => r -> r

-- | Smart constructor to apply sin to an expression.
sin :: ExprC r => r -> r

-- | Smart constructor to apply cos to an expression.
cos :: ExprC r => r -> r

-- | Smart constructor to apply tan to an expression.
tan :: ExprC r => r -> r

-- | Smart constructor to apply sec to an expression.
sec :: ExprC r => r -> r

-- | Smart constructor to apply csc to an expression.
csc :: ExprC r => r -> r

-- | Smart constructor to apply cot to an expression.
cot :: ExprC r => r -> r

-- | Smart constructor to apply arcsin to an expression.
arcsin :: ExprC r => r -> r

-- | Smart constructor to apply arccos to an expression.
arccos :: ExprC r => r -> r

-- | Smart constructor to apply arctan to an expression.
arctan :: ExprC r => r -> r

-- | Smart constructor for the exponential (base e) function.
exp :: ExprC r => r -> r

-- | Smart constructor for calculating the dimension of a vector.
dim :: ExprC r => r -> r

-- | Smart constructor for calculating the normal form of a vector.
norm :: ExprC r => r -> r

-- | Smart constructor for negating vectors.
negVec :: ExprC r => r -> r

-- | Smart constructor for applying logical negation to an expression.
not_ :: ExprC r => r -> r

-- | Smart constructor for indexing.
idx :: ExprC r => r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defint :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defsum :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defprod :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for 'real interval' membership.
realInterval :: (ExprC r, HasUID c) => c -> RealInterval r r -> r

-- | Euclidean function : takes a vector and returns the sqrt of the
--   sum-of-squares.
euclidean :: ExprC r => [r] -> r

-- | Smart constructor to cross product two expressions.
cross :: ExprC r => r -> r -> r

-- | Smart constructor for vector scaling
vScale :: ExprC r => r -> r -> r

-- | Vector Addition
vAdd :: ExprC r => r -> r -> r

-- | Vector Subtraction
vSub :: ExprC r => r -> r -> r

-- | Smart constructor for case statements with a complete set of cases.
completeCase :: ExprC r => [(r, r)] -> r

-- | Smart constructor for case statements with an incomplete set of cases.
incompleteCase :: ExprC r => [(r, r)] -> r

-- | Create a matrix.
matrix :: ExprC r => [[r]] -> r

-- | Applies a given function with a list of parameters.
apply :: (ExprC r, HasUID f, HasSymbol f) => f -> [r] -> r

-- | Create an <a>Expr</a> from a <a>Symbol</a>ic Chunk.
sy :: (ExprC r, HasUID c, HasSymbol c) => c -> r
infixr 4 $=
infixr 9 $&&
infixl 7 $/
infixr 8 $^
infixr 9 $||

-- | Smart constructor for fractions.
frac :: (ExprC r, LiteralC r) => Integer -> Integer -> r

-- | Smart constructor for rational expressions (only in 1/x form).
recip_ :: (ExprC r, LiteralC r) => r -> r

-- | Smart constructor to square a function.
square :: (ExprC r, LiteralC r) => r -> r

-- | Smart constructor to half a function exactly.
half :: (ExprC r, LiteralC r) => r -> r

-- | 1/2, as an expression.
oneHalf :: (ExprC r, LiteralC r) => r

-- | 1/3rd, as an expression.
oneThird :: (ExprC r, LiteralC r) => r

-- | Similar to <a>apply</a>, but converts second argument into
--   <a>Symbol</a>s.
apply1 :: (ExprC r, HasUID f, HasSymbol f, HasUID a, HasSymbol a) => f -> a -> r

-- | Similar to <a>apply</a>, but the applied function takes two parameters
--   (which are both <a>Symbol</a>s).
apply2 :: (ExprC r, HasUID f, HasSymbol f, HasUID a, HasSymbol a, HasUID b, HasSymbol b) => f -> a -> b -> r

-- | Create a two-by-two matrix from four given values. For example:
--   
--   <pre>
--   &gt;&gt;&gt; m2x2 1 2 3 4
--   [ [1,2],
--     [3,4] ]
--   </pre>
m2x2 :: ExprC r => r -> r -> r -> r -> r

-- | Create a 2D vector (a matrix with two rows, one column). First
--   argument is placed above the second.
vec2D :: ExprC r => r -> r -> r

-- | Creates a diagonal two-by-two matrix. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dgnl2x2 1 2
--   [ [1, 0],
--     [0, 2] ]
--   </pre>
dgnl2x2 :: (ExprC r, LiteralC r) => r -> r -> r

-- | Create a row vector
rowVec :: ExprC r => [r] -> r

-- | Create a column vector
columnVec :: ExprC r => [r] -> r

-- | For case expressions (either complete or incomplete).
data Completeness

-- | A relation is just an expression (<a>Expr</a>).
type Relation = Expr
data Literal
class LiteralC r
int :: LiteralC r => Integer -> r
str :: LiteralC r => String -> r
dbl :: LiteralC r => Double -> r
exactDbl :: LiteralC r => Integer -> r
perc :: LiteralC r => Integer -> Integer -> r

-- | Expression language where all terms are supposed to have a meaning,
--   but that meaning may not be that of a definite value. For example,
--   specification expressions, especially with quantifiers, belong here.
data ModelExpr

-- | Determines the type of the derivative (either a partial derivative or
--   a total derivative).
data DerivType
class ModelExprC r

-- | Gets the derivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
deriv :: (ModelExprC r, HasUID c, HasSymbol c) => r -> c -> r

-- | Gets the derivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
pderiv :: (ModelExprC r, HasUID c, HasSymbol c) => r -> c -> r

-- | Gets the nthderivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
nthderiv :: (ModelExprC r, HasUID c, HasSymbol c) => Integer -> r -> c -> r

-- | Gets the nthderivative of an <a>ModelExpr</a> with respect to a
--   <a>Symbol</a>.
nthpderiv :: (ModelExprC r, HasUID c, HasSymbol c) => Integer -> r -> c -> r

-- | One expression is "defined" by another.
defines :: ModelExprC r => r -> r -> r

-- | Space literals.
space :: ModelExprC r => Space -> r

-- | Check if a value belongs to a Space.
isIn :: ModelExprC r => r -> Space -> r

-- | Binary associative <a>Equivalence</a>.
equiv :: ModelExprC r => [r] -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
intAll :: ModelExprC r => Symbol -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
sumAll :: ModelExprC r => Symbol -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over all Real numbers.
prodAll :: ModelExprC r => Symbol -> r -> r

-- | Expression language where all terms also denote a term in GOOL (i.e.
--   translation is total and meaning preserving).
data CodeExpr
class CodeExprC r

-- | Constructs a CodeExpr for actor creation (constructor call)
new :: (CodeExprC r, Callable f, HasUID f, CodeIdea f) => f -> [r] -> r

-- | Constructs a CodeExpr for actor creation (constructor call) that uses
--   named arguments
newWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr for actor messaging (method call)
msg :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c) => c -> f -> [r] -> r

-- | Constructs a CodeExpr for actor messaging (method call) that uses
--   named arguments
msgWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c, HasUID a, IsArgumentName a) => c -> f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr representing the field of an actor
field :: CodeExprC r => CodeVarChunk -> CodeVarChunk -> r

-- | Similar to <a>apply</a>, but takes a relation to apply to
--   <a>FCall</a>.
applyWithNamedArgs :: (CodeExprC r, HasUID f, HasSymbol f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Special characters include partial derivatives and the degree circle.
data Special
Circle :: Special

-- | Class for rendering special characters.
class RenderSpecial r
special :: RenderSpecial r => Special -> r

-- | The most basic item: having a unique identifier key, here a UID.
class HasUID c

-- | Provides a <i>unique</i> id for internal Drasil use.
uid :: HasUID c => Lens' c UID

-- | A HasSymbol is anything which has a <a>Symbol</a>.
class HasSymbol c

-- | Provides the <a>Symbol</a> for a particular stage of generation.
symbol :: HasSymbol c => c -> Stage -> Symbol

-- | A NamedIdea is a <a>term</a> that we've identified (has a <a>UID</a>)
--   as being worthy of naming.
class HasUID c => NamedIdea c

-- | Lens to the term (a noun phrase).
term :: NamedIdea c => Lens' c NP

-- | An <a>Idea</a> is the combination of a <a>NamedIdea</a> and a
--   <tt>CommonIdea</tt>. In other words, it <i>may</i> have an
--   acronym/abbreviation.
class NamedIdea c => Idea c

-- | Gets the acronym/abbreviation.
getA :: Idea c => c -> Maybe String

-- | CommonIdea is a <a>NamedIdea</a> with the additional constraint that
--   it <b>must</b> have an abbreviation.
class NamedIdea c => CommonIdea c

-- | Introduces abrv which necessarily provides an abbreviation.
abrv :: CommonIdea c => c -> String

-- | Defines a chunk.
class Definition c

-- | Provides (a <tt>Lens</tt> to) the definition for a chunk.
defn :: Definition c => Lens' c Sentence

-- | Some concepts have a domain (related information encoded in
--   <a>UID</a>s to other chunks).
class ConceptDomain c

-- | Provides Getter for the concept domain tags for a chunk
--   
--   <i>cdom</i> should be exported for use by the Drasil framework, but
--   should not be exported beyond that.
cdom :: ConceptDomain c => c -> [UID]

-- | Concepts are <a>Idea</a>s with definitions and domains.
type Concept c = (Idea c, Definition c, ConceptDomain c)

-- | HasSpace is anything which has a <a>Space</a>.
class HasSpace c

-- | Provides a <a>Getter</a> to the <a>Space</a>.
typ :: HasSpace c => Getter c Space

-- | Some chunks store a unit symbol.
class HasUnitSymbol u

-- | Provides the ability to hold a unit symbol (<a>USymb</a>).
usymb :: HasUnitSymbol u => u -> USymb

-- | A Quantity is an <a>Idea</a> with a <tt>Space</tt> and a
--   <tt>Symbol</tt>. In theory, it should also restrict to being a part of
--   <tt>MayHaveUnit</tt>, but that causes all sorts of import cycles (or
--   lots of orphans).
class (Idea c, HasSpace c, HasSymbol c) => Quantity c

-- | A <a>Quantity</a> that could have a reasonable value.
class HasReasVal c

-- | Provides a <tt>Lens</tt> to the possible reasonable value.
reasVal :: HasReasVal c => Lens' c (Maybe Expr)

-- | The Constrained class is a <a>Quantity</a> that has value constraints.
--   It does not enforce <a>Quantity</a> at this point.
class Constrained c

-- | Provides a <tt>Lens</tt> to the <tt>Constraint</tt>s.
constraints :: Constrained c => Lens' c [ConstraintE]

-- | Records any additional notes needed to avoid losing information
class HasAdditionalNotes c

-- | Provides a <tt>Lens</tt> to the notes.
getNotes :: HasAdditionalNotes c => Lens' c [Sentence]

-- | A class that might have a <a>Derivation</a>.
class MayHaveDerivation c

-- | Provides a <tt>Lens</tt> to a possible derivation.
derivations :: MayHaveDerivation c => Lens' c (Maybe Derivation)

-- | Units are <a>Idea</a>s with a <a>Definition</a> which store a unit
--   symbol. They must also be explicitly declared to be instances of
--   IsUnit.
class (Idea u, Definition u, HasUnitSymbol u) => IsUnit u

-- | Holds units as a list of <a>UID</a>.
getUnits :: IsUnit u => u -> [UID]
class DefiningExpr c

-- | Provides a <tt>Lens</tt> to the expression. TODO: Well, technically,
--   <tt>e</tt> doesn't need to be an "expression" of any sorts. It just
--   needs to be _something_, and it would have approximately have same
--   meaning.
defnExpr :: DefiningExpr c => Lens' (c e) e

-- | Data that can be expressed using <a>ModelExpr</a>.
class Express c
express :: Express c => c -> ModelExpr

-- | Members must have a reference address.
class HasRefAddress b

-- | Provides the ability to hold a reference address.
getRefAdd :: HasRefAddress b => b -> LblType

-- | Members of this class have the ability to be referenced.
class (HasUID s, HasRefAddress s) => Referable s

-- | The referencing address (what we're linking to). Only visible in the
--   source (tex/html).
refAdd :: Referable s => s -> String

-- | Alternate form of reference.
renderRef :: Referable s => s -> LblType

-- | A class that contains a list of <a>Reference</a>s.
class HasReference c

-- | Provides a <tt>Lens</tt> to the <a>Reference</a>s.
getReferences :: HasReference c => Lens' c [Reference]

-- | Some chunks can be called like functions.
class (HasSymbol c) => Callable c

-- | Members must have a named argument.
class (HasSymbol c) => IsArgumentName c

-- | A <tt>UID</tt> is a 'unique identifier' for things that we will put
--   into our database of information. We use a newtype wrapper to make
--   sure we are only using <a>UID</a>s where desired.
data UID

-- | Smart constructor for making a <a>UID</a> from a <a>Value</a>.
mkUid :: String -> UID

-- | Nest UID under a namespace
nsUid :: String -> UID -> UID

-- | For when we need to modify a UID. We first take the base chunk's UID
--   and then append a suffix to it.
(+++) :: HasUID a => a -> String -> UID

-- | For when we need to append something to a UID.
(+++.) :: UID -> String -> UID
(+++!) :: (HasUID a, HasUID b) => a -> b -> UID

-- | <a>IdeaDict</a> constructor, takes a <a>String</a> for its <a>UID</a>
--   and a term.
nc :: String -> NP -> IdeaDict

-- | Similar to <a>nc</a>, but takes in the <a>UID</a> in the form of a
--   <a>UID</a> rather than a <a>String</a>.
ncUID :: UID -> NP -> IdeaDict

-- | <a>IdeaDict</a> is the canonical dictionary associated to an
--   <a>Idea</a>. Contains a <a>UID</a> and a term that could have an
--   abbreviation (<a>Maybe</a> <a>String</a>).
--   
--   Ex. The project name "Double Pendulum" may have the abbreviation
--   <a>DblPend</a>.
data IdeaDict

-- | <a>IdeaDict</a> constructor, takes a <a>UID</a>, <a>NP</a>, and an
--   abbreviation in the form of <a>Maybe</a> <a>String</a>.
mkIdea :: String -> NP -> Maybe String -> IdeaDict

-- | Historical name: nw comes from 'named wrapped' from when
--   <a>NamedIdea</a> exported <a>getA</a> (now in <a>Idea</a>). But there
--   are no more wrappers, instead we have explicit dictionaries. Unwraps
--   an <a>Idea</a> and places its <a>UID</a> and <a>NP</a> into an
--   <a>IdeaDict</a> with <a>Nothing</a> for an abbreviation.
nw :: Idea c => c -> IdeaDict

-- | A <a>CodeIdea</a> must include some code and its name.
class CodeIdea c

-- | Name of the idea.
codeName :: CodeIdea c => c -> String

-- | Code chunk associated with the idea.
codeChunk :: CodeIdea c => c -> CodeChunk

-- | Basic chunk representation in the code generation context. Contains a
--   QuantityDict and the kind of code (variable or function).
data CodeChunk
CodeC :: QuantityDict -> VarOrFunc -> CodeChunk
[_qc] :: CodeChunk -> QuantityDict
[kind] :: CodeChunk -> VarOrFunc

-- | Chunk representing a variable. The <tt>obv</tt> field represents the
--   object containing this variable, if it is an object field.
data CodeVarChunk
CodeVC :: CodeChunk -> Maybe CodeChunk -> CodeVarChunk
[_ccv] :: CodeVarChunk -> CodeChunk
[_obv] :: CodeVarChunk -> Maybe CodeChunk

-- | Chunk representing a function.
newtype CodeFuncChunk
CodeFC :: CodeChunk -> CodeFuncChunk
[_ccf] :: CodeFuncChunk -> CodeChunk

-- | Details if a piece of code is meant to be a variable or a function.
data VarOrFunc
Var :: VarOrFunc
Func :: VarOrFunc
obv :: Lens' CodeVarChunk (Maybe CodeChunk)
qc :: Lens' CodeChunk QuantityDict
ccf :: Iso' CodeFuncChunk CodeChunk
ccv :: Lens' CodeVarChunk CodeChunk
listToArray :: CodeVarChunk -> CodeVarChunk

-- | Convert an abbreviation into one deemed 'code-friendly', removing
--   spaces, and replacing special characters with underscores.
--   
--   FIXME: This should NOT be treated as a <tt>getter</tt>, but something
--   we cache local to something that has a 'program name'.
programName :: CommonIdea c => c -> String

-- | Used when a function name needs to be distinguishable from a variable
--   name.
funcPrefix :: String

-- | A <a>DefiningCodeExpr</a> must have it's underlying chunk defined in
--   the CodeExpr language.
class CodeIdea c => DefiningCodeExpr c
codeExpr :: DefiningCodeExpr c => Lens' c CodeExpr

-- | The common idea (with <tt>NounPhrase</tt>) data type. It must have a
--   <a>UID</a>, <tt>NounPhrase</tt> for its term, an abbreviation
--   (<a>String</a>), and a domain ([<a>UID</a>]). It is similar to
--   <a>IdeaDict</a> and <a>IdeaDict</a> in the sense that these are for
--   things worth naming, but this type also carries an abbreviation and
--   related domains of knowledge.
--   
--   Ex. The term "Operating System" has the abbreviation <a>OS</a> and
--   comes from the domain of computer science.
data CI

-- | The commonIdea smart constructor requires a chunk id (<a>String</a>),
--   a term (<a>NP</a>), an abbreviation (<a>String</a>), and a domain
--   ([<a>UID</a>]).
commonIdea :: String -> NP -> String -> [UID] -> CI

-- | Get abbreviation in <a>Sentence</a> form from a <a>CI</a>.
getAcc :: CI -> Sentence

-- | Similar to <a>commonIdea</a>, but takes a list of <a>IdeaDict</a>
--   (often a domain).
commonIdeaWithDict :: String -> NP -> String -> [IdeaDict] -> CI

-- | Prepends the abbreviation from a <a>CommonIdea</a> to a <a>String</a>.
prependAbrv :: CommonIdea c => c -> String -> String

-- | The ConceptChunk datatype records a concept that contains an idea
--   (<a>IdeaDict</a>), a definition (<a>Sentence</a>), and an associated
--   domain of knowledge ([<a>UID</a>]).
--   
--   Ex. The concept of <a>Accuracy</a> may be defined as the quality or
--   state of being correct or precise.
data ConceptChunk

-- | Contains a <a>ConceptChunk</a>, reference address, and a
--   <a>ShortName</a>. It is a concept that can be referred to, or rather,
--   a instance of where a concept is applied. Often used in Goal
--   Statements, Assumptions, Requirements, etc.
--   
--   Ex. Something like the assumption that gravity is 9.81 m/s. When we
--   write our equations, we can then link this assumption so that we do
--   not have to explicitly define that assumption when needed to verify
--   our work.
data ConceptInstance

-- | Check if something has one domain. Throws an error if there is more
--   than one.
sDom :: [UID] -> UID

-- | Smart constructor for creating concept chunks given a <tt>UID</tt>,
--   <tt>NounPhrase</tt> (<a>NP</a>) and definition (as a <a>String</a>).
--   
--   Concept domain tagging is not yet implemented in this constructor.
dcc :: String -> NP -> String -> ConceptChunk

-- | Similar to <a>dcc</a>, except the definition takes a <a>Sentence</a>.
dccWDS :: String -> NP -> Sentence -> ConceptChunk

-- | Constructor for projecting an idea into a <a>ConceptChunk</a>. Takes
--   the definition of the <a>ConceptChunk</a> as a <a>String</a>. Does not
--   allow concept domain tagging.
cc :: Idea c => c -> String -> ConceptChunk

-- | Same as <a>cc</a>, except definition is a <a>Sentence</a>.
cc' :: Idea c => c -> Sentence -> ConceptChunk

-- | Similar to <a>cc'</a>, but allows explicit domain tagging.
ccs :: (Idea c, Concept d) => c -> Sentence -> [d] -> ConceptChunk

-- | For projecting out to the <a>ConceptChunk</a> data-type.
cw :: Concept c => c -> ConceptChunk

-- | Constructor for a <a>ConceptInstance</a>. Takes in the Reference
--   Address (<a>String</a>), a definition (<a>Sentence</a>), a short name
--   (<a>String</a>), and a domain (for explicit tagging).
cic :: Concept c => String -> Sentence -> String -> c -> ConceptInstance

-- | For a concept (<a>ConceptChunk</a>) that also has a <tt>Relation</tt>
--   (<a>ModelExpr</a>) attached.
--   
--   Ex. We can describe a pendulum arm and then apply an associated
--   equation so that we know its behaviour.
data RelationConcept

-- | Create a <a>RelationConcept</a> from a given <tt>UID</tt>, term
--   (<a>NP</a>), definition (<a>Sentence</a>), and <tt>Relation</tt>.
makeRC :: Express e => String -> NP -> Sentence -> e -> RelationConcept

-- | Create a new <a>RelationConcept</a> from an old <a>Concept</a>. Takes
--   a <a>Concept</a>, new <tt>UID</tt> and relation.
addRelToCC :: (Express e, Concept c) => c -> String -> e -> RelationConcept

-- | Describe the structural content of a system of linear ODEs with six
--   necessary fields
data DifferentialModel
SystemOfLinearODEs :: UnitalChunk -> ConstrConcept -> [[Expr]] -> [Unknown] -> [Expr] -> ConceptChunk -> DifferentialModel

-- | independent variable, often time
[_indepVar] :: DifferentialModel -> UnitalChunk

-- | dependent variable
[_depVar] :: DifferentialModel -> ConstrConcept

-- | coefficients matrix
[_coefficients] :: DifferentialModel -> [[Expr]]

-- | unknowns column vector (orders)
[_unknowns] :: DifferentialModel -> [Unknown]

-- | constant column vector
[_dmConstants] :: DifferentialModel -> [Expr]

-- | meta data
[_dmconc] :: DifferentialModel -> ConceptChunk

-- | Acceptable format for ODE solvers, represent the structure of X' = AX
--   + B X' is a column vector of first-order unknowns
data ODESolverFormat
X' :: [[Expr]] -> [Integer] -> [Expr] -> ODESolverFormat

-- | represent A, the coefficient matrix with identity matrix
[coeffVects] :: ODESolverFormat -> [[Expr]]

-- | combing with the dependent variable. it represents X, the unknown
--   column vector after reduce the highest order.
[unknownVect] :: ODESolverFormat -> [Integer]

-- | represent B, the constant column vector with identity matrix
[constantVect] :: ODESolverFormat -> [Expr]

-- | Information for solving an initial value problem
data InitialValueProblem
IVP :: Expr -> Expr -> [Expr] -> InitialValueProblem

-- | initial time
[initTime] :: InitialValueProblem -> Expr

-- | end time
[finalTime] :: InitialValueProblem -> Expr

-- | initial values
[initValues] :: InitialValueProblem -> [Expr]

-- | Operation connect the dependent variable and the order
($^^) :: ConstrConcept -> Integer -> Unknown

-- | Operation represent multiple
($**) :: Expr -> Unknown -> Term

-- | Operation represent plus (collection Terms)
($++) :: [Term] -> Term -> LHS

-- | Construct an ODESolverFormat for solving the ODE.
makeAODESolverFormat :: DifferentialModel -> ODESolverFormat
makeAIVP :: Expr -> Expr -> [Expr] -> InitialValueProblem

-- | Form well-formatted ODE equations which the ODE solvers can solve.
formEquations :: [[Expr]] -> [Unknown] -> [Expr] -> ConstrConcept -> [Expr]

-- | Create a <a>DifferentialModel</a> by giving a independent variable, a
--   dependent variable a canonical matrix form, and conceptChuck.
makeASystemDE :: UnitalChunk -> ConstrConcept -> [[Expr]] -> [Unknown] -> [Expr] -> String -> NP -> Sentence -> DifferentialModel

-- | Create a <a>DifferentialModel</a> by the input language
makeASingleDE :: UnitalChunk -> ConstrConcept -> LHS -> Expr -> String -> NP -> Sentence -> DifferentialModel

-- | QuantityDict is a combination of an <a>IdeaDict</a> with a quantity.
--   Contains an <a>IdeaDict</a>, <a>Space</a>, a function from
--   <a>Stage</a> -&gt; <a>Symbol</a>, and <a>Maybe</a> a <a>UnitDefn</a>.
--   
--   Ex. A pendulum arm does not necessarily have to be defined as a
--   concept before we assign a space (Real numbers), a symbol (l), or
--   units (cm, m, etc.).
data QuantityDict
class DefinesQuantity d
defLhs :: DefinesQuantity d => Getter d QuantityDict

-- | Smart constructor for a <a>QuantityDict</a> from another
--   <a>Quantity</a> with units.
qw :: (Quantity q, MayHaveUnit q) => q -> QuantityDict

-- | Make a <a>QuantityDict</a> from a <a>UID</a>, <a>NP</a>,
--   <a>Symbol</a>, <a>Space</a>, <a>Maybe</a> <a>UnitDefn</a>, and an
--   abbreviation (<a>Maybe</a> <a>String</a>).
mkQuant :: String -> NP -> Symbol -> Space -> Maybe UnitDefn -> Maybe String -> QuantityDict

-- | Similar to <a>mkQuant</a>, but the abbreviation is moved to the third
--   argument (<a>Maybe</a> <a>String</a>), and the <a>Symbol</a> is now
--   dependent on <a>Stage</a>.
mkQuant' :: String -> NP -> Maybe String -> Space -> (Stage -> Symbol) -> Maybe UnitDefn -> QuantityDict

-- | Makes a <a>QuantityDict</a> from an <a>Idea</a>, <a>Symbol</a>, and
--   <a>Space</a>. <a>Symbol</a> is implementation-only.
codeVC :: Idea c => c -> Symbol -> Space -> QuantityDict

-- | Makes a variable that is implementation-only.
implVar :: String -> NP -> Space -> Symbol -> QuantityDict

-- | Similar to <a>implVar</a> but allows specification of abbreviation and
--   unit.
implVar' :: String -> NP -> Maybe String -> Space -> Symbol -> Maybe UnitDefn -> QuantityDict

-- | Similar to <a>implVar</a> but takes in a <a>UID</a> rather than a
--   <a>String</a>.
implVarUID :: UID -> NP -> Space -> Symbol -> QuantityDict

-- | Similar to <a>implVar'</a> but takes in a <a>UID</a> rather than a
--   <a>String</a>.
implVarUID' :: UID -> NP -> Maybe String -> Space -> Symbol -> Maybe UnitDefn -> QuantityDict

-- | Creates a <a>QuantityDict</a> from a <a>UID</a>, term (<a>NP</a>),
--   <a>Symbol</a>, and <a>Space</a>.
vc :: String -> NP -> Symbol -> Space -> QuantityDict

-- | Creates a <a>QuantityDict</a> from an <a>Idea</a>, <a>Symbol</a>, and
--   <a>Space</a>.
vc'' :: Idea c => c -> Symbol -> Space -> QuantityDict

-- | Similar to <a>vc</a>, but creates a <a>QuantityDict</a> from something
--   that knows about <a>Stage</a>s.
vcSt :: String -> NP -> (Stage -> Symbol) -> Space -> QuantityDict

-- | Creates a <a>QuantityDict</a> from a <a>UID</a>, term (<a>NP</a>),
--   <a>Symbol</a>, <a>Space</a>, and unit (<a>UnitDefn</a>).
vcUnit :: String -> NP -> Symbol -> Space -> UnitDefn -> QuantityDict
data QDefinition e

-- | Create a <a>QDefinition</a> with a <a>UID</a> (as a <a>Space</a>),
--   term (<a>NP</a>), definition (<a>Sentence</a>), <a>Symbol</a>,
--   <a>Space</a>, unit, and defining expression.
fromEqn :: IsUnit u => String -> NP -> Sentence -> Symbol -> Space -> u -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but has no units.
fromEqn' :: String -> NP -> Sentence -> Symbol -> Space -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but symbol depends on stage.
fromEqnSt :: IsUnit u => UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> u -> e -> QDefinition e

-- | Same as <a>fromEqn</a>, but symbol depends on stage and has no units.
fromEqnSt' :: UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> e -> QDefinition e

-- | Same as <a>fromEqnSt'</a>, but takes a <a>Space</a> instead of a
--   <a>UID</a>.
fromEqnSt'' :: String -> NP -> Sentence -> (Stage -> Symbol) -> Space -> e -> QDefinition e

-- | Wrapper for fromEqnSt and fromEqnSt'
mkQDefSt :: UID -> NP -> Sentence -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> e -> QDefinition e

-- | Used to help make <a>QDefinition</a>s when <a>UID</a>, term, and
--   <a>Symbol</a> come from the same source.
mkQuantDef :: (Quantity c, MayHaveUnit c) => c -> e -> QDefinition e

-- | Used to help make <a>QDefinition</a>s when <a>UID</a> and
--   <a>Symbol</a> come from the same source, with the term separate.
mkQuantDef' :: (Quantity c, MayHaveUnit c) => c -> NP -> e -> QDefinition e

-- | Smart constructor for QDefinitions. Requires a quantity and its
--   defining equation.
ec :: (Quantity c, MayHaveUnit c) => c -> e -> QDefinition e

-- | Create a <a>QDefinition</a> function with a symbol, name, term, list
--   of inputs, resultant units, and a defining Expr
mkFuncDef :: (HasUID f, HasSymbol f, HasSpace f, HasUID i, HasSymbol i, HasSpace i, IsUnit u) => f -> NP -> Sentence -> u -> [i] -> e -> QDefinition e

-- | Create a <a>QDefinition</a> function with a symbol, name, term, list
--   of inputs, and a defining Expr
mkFuncDef' :: (HasUID f, HasSymbol f, HasSpace f, HasUID i, HasSymbol i, HasSpace i) => f -> NP -> Sentence -> [i] -> e -> QDefinition e

-- | Create a <a>QDefinition</a> functions using a symbol, list of inputs,
--   and a defining Expr
mkFuncDefByQ :: (Quantity c, MayHaveUnit c, HasSpace c, Quantity i, HasSpace i) => c -> [i] -> e -> QDefinition e

-- | A Unitary is a <a>Quantity</a> that <b>must</b> have a unit.
class (Quantity c) => Unitary c
unit :: Unitary c => c -> UnitDefn

-- | UnitaryChunks are for ideas with quantities that must have units.
--   Contains a <a>QuantityDict</a> and a <a>UnitDefn</a>.
--   
--   Ex. A pendulum arm is an idea associated with a symbol (l) and units
--   (cm, m, etc.).
data UnitaryChunk

-- | Builds the <a>QuantityDict</a> part from the <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, and <a>Space</a>. Assumes there's no
--   abbreviation.
unitary :: IsUnit u => String -> NP -> Symbol -> u -> Space -> UnitaryChunk

-- | Same as <a>unitary</a> but with a <a>Symbol</a> that changes based on
--   the <a>Stage</a>.
unitary' :: IsUnit u => String -> NP -> (Stage -> Symbol) -> u -> Space -> UnitaryChunk

-- | Makes a <a>UnitaryChunk</a> from a quantity with a unit.
mkUnitary :: (Unitary u, MayHaveUnit u) => u -> UnitaryChunk

-- | Helper for getting the unit's <a>Symbol</a> from a chunk, as opposed
--   to the symbols of the chunk itself.
unit_symb :: Unitary c => c -> USymb

-- | DefinedQuantityDict is the combination of a <a>Concept</a> and a
--   <a>Quantity</a>. Contains a <a>ConceptChunk</a>, a <a>Symbol</a>
--   dependent on <a>Stage</a>, a <a>Space</a>, and maybe a
--   <a>UnitDefn</a>. Used when we want to assign a quantity to a concept.
--   Includes the space, symbol, and units for that quantity.
--   
--   Ex. A pendulum arm can be defined as a concept with a symbol (l),
--   space (Real numbers), and units (cm, m, etc.).
data DefinedQuantityDict

-- | Smart constructor that creates a DefinedQuantityDict with a
--   <a>ConceptChunk</a>, a <a>Symbol</a> independent of <a>Stage</a>, a
--   <a>Space</a>, and a unit.
dqd :: IsUnit u => ConceptChunk -> Symbol -> Space -> u -> DefinedQuantityDict

-- | Similar to <a>dqd</a>, but the <a>Symbol</a> is now dependent on the
--   <a>Stage</a>.
dqd' :: ConceptChunk -> (Stage -> Symbol) -> Space -> Maybe UnitDefn -> DefinedQuantityDict

-- | Similar to <a>dqd</a>, but without any units.
dqdNoUnit :: ConceptChunk -> Symbol -> Space -> DefinedQuantityDict

-- | When we want to merge a quantity and a concept. This is suspicious.
dqdQd :: (Quantity c, MayHaveUnit c) => c -> ConceptChunk -> DefinedQuantityDict

-- | When the input already has all the necessary information. A
--   <tt>projection</tt> operator from some a type with instances of listed
--   classes to a <a>DefinedQuantityDict</a>.
dqdWr :: (Quantity c, Concept c, MayHaveUnit c) => c -> DefinedQuantityDict

-- | Similar to a <a>DefinedQuantityDict</a>, UnitalChunks are concepts
--   with quantities that must have a unit definition. Contains
--   <a>DefinedQuantityDict</a>s and a <a>UnitDefn</a>.
--   
--   Ex. A pendulum arm is a tangible object with a symbol (l) and units
--   (cm, m, etc.).
data UnitalChunk
UC :: DefinedQuantityDict -> UnitDefn -> UnitalChunk
[_defq'] :: UnitalChunk -> DefinedQuantityDict
[_uni] :: UnitalChunk -> UnitDefn

-- | Used to create a <a>UnitalChunk</a> from a <a>Concept</a>,
--   <a>Symbol</a>, and <tt>Unit</tt>.
uc :: (Concept c, IsUnit u) => c -> Symbol -> Space -> u -> UnitalChunk

-- | Similar to <a>uc</a>, except it builds the <a>Concept</a> portion of
--   the <a>UnitalChunk</a> from a given <tt>UID</tt>, term, and definition
--   (as a <a>Sentence</a>) which are its first three arguments.
uc' :: IsUnit u => String -> NP -> Sentence -> Symbol -> Space -> u -> UnitalChunk

-- | Similar to <a>uc</a>, but <a>Symbol</a> is dependent on the
--   <a>Stage</a>.
ucStaged :: (Concept c, IsUnit u) => c -> (Stage -> Symbol) -> Space -> u -> UnitalChunk

-- | Similar to <a>uc'</a>, but <a>Symbol</a> is dependent on the
--   <a>Stage</a>.
ucStaged' :: IsUnit u => String -> NP -> Sentence -> (Stage -> Symbol) -> Space -> u -> UnitalChunk

-- | Attach units to a chunk that has a symbol and definition.
ucuc :: (Quantity c, Concept c, MayHaveUnit c) => c -> UnitDefn -> UnitalChunk

-- | Constructs a UnitalChunk from a <a>Concept</a> with <tt>Units</tt>.
ucw :: (Unitary c, Concept c, MayHaveUnit c) => c -> UnitalChunk

-- | For defining units. It has a <a>ConceptChunk</a> (that defines what
--   kind of unit it is), a unit symbol, maybe another (when it is a
--   synonym), perhaps a definition, and a list of <a>UID</a> of the units
--   that make up the definition.
--   
--   Ex. Meter is a unit of length defined by the symbol (m).
data UnitDefn
UD :: ConceptChunk -> UnitSymbol -> [UID] -> UnitDefn
[_vc] :: UnitDefn -> ConceptChunk
[_cas] :: UnitDefn -> UnitSymbol
[_cu] :: UnitDefn -> [UID]

-- | Generates a default unit symbol.
fromUDefn :: UDefn -> USymb

-- | Helper for fundamental unit concept chunk creation. Uses the same
--   <a>String</a> for the identifier, term, and definition.
unitCon :: String -> ConceptChunk

-- | Create a derived unit chunk from a concept and a unit equation.
makeDerU :: ConceptChunk -> UnitEquation -> UnitDefn

-- | Combinator for raising a unit to a power.
(^:) :: UnitDefn -> Integer -> UnitEquation

-- | Combinator for dividing one unit by another.
(/:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying two units together.
(*:) :: UnitDefn -> UnitDefn -> UnitEquation

-- | Combinator for multiplying a unit and a symbol.
(*$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for dividing a unit and a symbol.
(/$) :: UnitDefn -> UnitEquation -> UnitEquation

-- | Combinator for mulitiplying two unit equations.
(^$) :: UnitEquation -> UnitEquation -> UnitEquation

-- | Smart constructor for new derived units from existing units.
newUnit :: String -> UnitEquation -> UnitDefn

-- | Combinator for scaling one unit by some number.
scale :: IsUnit s => Double -> s -> UDefn

-- | Combinator for shifting one unit by some number.
shift :: IsUnit s => Double -> s -> UDefn

-- | Uses self-plural term.
--   
--   Create a derived unit chunk from a <a>UID</a>, term (<a>String</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Uses term that pluralizes by adding "s" to the end.
--   
--   Create a derived unit chunk from a <a>UID</a>, term (<a>String</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC' :: String -> String -> String -> Symbol -> UDefn -> UnitDefn

-- | Create a derived unit chunk from a <a>UID</a>, term (<a>NP</a>),
--   definition, <a>Symbol</a>, and unit equation.
derUC'' :: String -> NP -> String -> Symbol -> UDefn -> UnitDefn

-- | Smart constructor for a "fundamental" unit.
fund :: String -> String -> String -> UnitDefn

-- | Variant of the <a>fund</a>, useful for degree.
fund' :: String -> String -> Symbol -> UnitDefn

-- | We don't want an Ord on units, but this still allows us to compare
--   them.
compUnitDefn :: UnitDefn -> UnitDefn -> Ordering

-- | Create a <tt>SI_Unit</tt> with two <a>Symbol</a> representations. The
--   created <a>NP</a> is self-plural.
derCUC :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Similar to <a>derCUC</a>, but the created <a>NP</a> has the
--   <tt>AddS</tt> plural rule.
derCUC' :: String -> String -> String -> Symbol -> UnitEquation -> UnitDefn

-- | Create a derived unit chunk from a <a>UID</a>, term (<a>NP</a>),
--   definition, <a>Symbol</a>, and unit equation.
derCUC'' :: String -> NP -> String -> Symbol -> UnitEquation -> UnitDefn

-- | For allowing lists to mix together chunks that are units by projecting
--   them into a <a>UnitDefn</a>. For now, this only works on
--   <a>UnitDefn</a>s.
unitWrapper :: IsUnit u => u -> UnitDefn

-- | Get a list of <a>UID</a> of the units that make up the
--   <a>UnitEquation</a>.
getCu :: UnitEquation -> [UID]

-- | Types may contain a unit (<a>UnitDefn</a>).
class MayHaveUnit u
getUnit :: MayHaveUnit u => u -> Maybe UnitDefn

-- | The reason behind the constraint's existence.
data ConstraintReason
Physical :: ConstraintReason
Software :: ConstraintReason

-- | Holds constraints. May occur between an interval of <a>Expr</a>, a
--   list of <a>Double</a>s, or a list of <a>String</a>s.
data Constraint a

-- | By default, physical and software constraints are ranges.
[Range] :: ConstraintReason -> RealInterval a a -> Constraint a

-- | Type synonym for <a>ConstraintE</a>
type ConstraintE = Constraint Expr

-- | Smart constructor for range of <a>Physical</a> constraints between two
--   given expressions.
physc :: RealInterval Expr Expr -> ConstraintE

-- | Smart constructor for range of <a>Software</a> constraints between two
--   given expressions.
sfwrc :: RealInterval Expr Expr -> ConstraintE

-- | Helpful for filtering for Physical constraints. True if constraint is
--   <a>Physical</a>.
isPhysC :: Constraint e -> Bool

-- | Helpful for filtering for Software constraints. True if constraint is
--   <a>Software</a>.
isSfwrC :: Constraint e -> Bool

-- | ConstrainedChunks are symbolic quantities (<a>QuantityDict</a>) with
--   <tt>Constraint</tt>s and maybe a typical value (<a>Maybe</a>
--   <a>Expr</a>).
--   
--   Ex. Measuring the length of a pendulum would have some reasonable
--   value (between 1 cm and 2 m) and the constraint that the length cannot
--   be a negative value.
data ConstrainedChunk
ConstrainedChunk :: QuantityDict -> [ConstraintE] -> Maybe Expr -> ConstrainedChunk
[_qd] :: ConstrainedChunk -> QuantityDict
[_constr] :: ConstrainedChunk -> [ConstraintE]
[_reasV] :: ConstrainedChunk -> Maybe Expr

-- | ConstrConcepts are conceptual symbolic quantities
--   (<a>DefinedQuantityDict</a>) with <tt>Constraint</tt>s and maybe a
--   reasonable value (no units!). Similar to <a>ConstrainedChunk</a> but
--   includes a definition and domain.
--   
--   Ex. Measuring the length of a pendulum arm could be a concept that has
--   some reasonable value (between 1 cm and 2 m) and the constraint that
--   the length cannot be a negative value.
data ConstrConcept
ConstrConcept :: DefinedQuantityDict -> [ConstraintE] -> Maybe Expr -> ConstrConcept
[_defq] :: ConstrConcept -> DefinedQuantityDict
[_constr'] :: ConstrConcept -> [ConstraintE]
[_reasV'] :: ConstrConcept -> Maybe Expr

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, unit, <a>Space</a>, <tt>Constraint</tt>s,
--   and an <a>Expr</a>.
cuc :: IsUnit u => String -> NP -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> ConstrainedChunk

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, <a>Space</a>, <tt>Constraint</tt>s, and a
--   <a>Maybe</a> <a>Expr</a> (Similar to <a>cuc</a> but no units).
cvc :: String -> NP -> Symbol -> Space -> [ConstraintE] -> Maybe Expr -> ConstrainedChunk

-- | Creates a <a>ConstrConcept</a> with a quantitative concept, a list of
--   <tt>Constraint</tt>s and an <a>Expr</a>.
constrained' :: (Concept c, MayHaveUnit c, Quantity c) => c -> [ConstraintE] -> Expr -> ConstrConcept

-- | Creates a constrained unitary chunk from a <tt>UID</tt>, term
--   (<a>NP</a>), description (<a>String</a>), <a>Symbol</a>, unit,
--   <a>Space</a>, <tt>Constraint</tt>s, and an <a>Expr</a>.
cuc' :: IsUnit u => String -> NP -> String -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to <a>cuc'</a>, but <a>Symbol</a> is dependent on
--   <a>Stage</a>.
cuc'' :: IsUnit u => String -> NP -> String -> (Stage -> Symbol) -> u -> Space -> [ConstraintE] -> Expr -> ConstrConcept

-- | Similar to <a>constrained'</a>, but defaults <a>Maybe</a> <a>Expr</a>
--   to <a>Nothing</a>.
constrainedNRV' :: (Concept c, MayHaveUnit c, Quantity c) => c -> [ConstraintE] -> ConstrConcept

-- | Creates a new ConstrainedChunk from either a <a>ConstrainedChunk</a>,
--   <a>ConstrConcept</a>, <tt>UncertainChunk</tt>, or an <tt>UncertQ</tt>.
cnstrw :: (Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> ConstrainedChunk

-- | Similar to <a>cnstrw</a>, but types must also have a <a>Concept</a>.
cnstrw' :: (Quantity c, Concept c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> ConstrConcept

-- | UncertainChunk is a symbolic quantity with constraints, a typical
--   value, and an uncertainty. Contains a <a>ConstrainedChunk</a> and an
--   <a>Uncertainty</a>.
--   
--   Ex. Measuring the length of a pendulum arm may be recorded with an
--   uncertainty value.
data UncertainChunk
UCh :: ConstrainedChunk -> Uncertainty -> UncertainChunk
[_conc] :: UncertainChunk -> ConstrainedChunk
[_unc'] :: UncertainChunk -> Uncertainty

-- | UncertQs are conceptual symbolic quantities with constraints and an
--   <a>Uncertainty</a>. Contains a <a>ConstrConcept</a> and an
--   <a>Uncertainty</a>.
--   
--   Ex. Measuring the length of a pendulum arm may be recorded with an
--   uncertainty value.
data UncertQ

-- | Smart constructor that requires a <a>Quantity</a>, a percentage, and a
--   typical value with an <a>Uncertainty</a>.
uq :: (Quantity c, Constrained c, Concept c, HasReasVal c, MayHaveUnit c) => c -> Uncertainty -> UncertQ

-- | Uncertainty quantity (<a>uq</a>) but with a constraint.
uqc :: IsUnit u => String -> NP -> String -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertQ

-- | Uncertainty quantity constraint (<a>uqc</a>) without a description.
uqcND :: IsUnit u => String -> NP -> Symbol -> u -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertQ

-- | Smart constructor that can project to an <a>UncertainChunk</a> (also
--   given an <a>Uncertainty</a>).
uncrtnChunk :: (Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> Uncertainty -> UncertainChunk

-- | Creates an uncertain variable chunk. Takes <tt>UID</tt>, term
--   (<a>NP</a>), <a>Symbol</a>, <a>Space</a>, <tt>Constrains</tt>,
--   <a>Expr</a>, and <a>Uncertainty</a>.
uvc :: String -> NP -> Symbol -> Space -> [ConstraintE] -> Expr -> Uncertainty -> UncertainChunk

-- | Projection function into an <a>UncertainChunk</a> from <a>UncertQ</a>
--   or an <a>UncertainChunk</a>.
uncrtnw :: (HasUncertainty c, Quantity c, Constrained c, HasReasVal c, MayHaveUnit c) => c -> UncertainChunk

-- | Something that may contain an uncertainty value and a precision value.
data Uncertainty

-- | Smart constructor for values with uncertainty.
uncty :: Double -> Maybe Int -> Uncertainty

-- | HasUncertainty is just a chunk with some uncertainty associated to it.
--   This uncertainty is represented as a decimal value between 0 and 1
--   (percentage).
class HasUncertainty c

-- | Provides the <tt>Lens</tt> to an <a>Uncertainty</a>.
unc :: HasUncertainty c => Lens' c Uncertainty

-- | The default uncertainty is set to 0.1.
defaultUncrt :: Uncertainty

-- | Accessor for uncertainty value from something that has an uncertainty.
uncVal :: HasUncertainty x => x -> Double

-- | Accessor for precision value from something that has an uncertainty.
uncPrec :: HasUncertainty x => x -> Maybe Int

-- | Smart constructor for exact values (no uncertainty).
exact :: Uncertainty

-- | Retrieves the <a>String</a> contained in a <a>LblType</a>.
getAdd :: LblType -> String

-- | Prepends a <a>String</a> to an <a>IRefProg</a>.
prepend :: String -> IRefProg

-- | Applying different pieces of information for a reference. An RP is a
--   decorated internal reference. Citation is a citation. URI is for URLs
--   and other external links.
data LblType
RP :: IRefProg -> String -> LblType
Citation :: String -> LblType
URI :: String -> LblType

-- | Created for different forms of references. Used in <a>LblType</a>.
data IRefProg

-- | Deferred lookup; done later. Used for domains in a
--   <tt>ConceptInstance</tt>.
Deferred :: UID -> IRefProg

-- | Lifts a <a>String</a> into a <tt>RefProg</tt>.
RS :: String -> IRefProg

-- | Concatenates with two subprograms.
RConcat :: IRefProg -> IRefProg -> IRefProg

-- | The <tt>Symbol</tt> to insert the <tt>ShortName</tt> directly.
Name :: IRefProg

-- | A Reference contains the identifier (<a>UID</a>), a reference address
--   (<a>LblType</a>), a human-readable shortname (<a>ShortName</a>), and
--   any extra information about the reference (<a>RefInfo</a>).
data Reference
Reference :: UID -> LblType -> ShortName -> Reference

-- | Projector function that creates a <a>Reference</a> from something
--   <tt>Referable</tt>.
ref :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Reference

-- | Takes the reference <a>UID</a> and wraps it into a <a>Sentence</a>.
refS :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence

-- | Takes a <a>Reference</a> with a name to be displayed and wraps it into
--   a <a>Sentence</a>. Does not overwrite the shortname contained in the
--   reference, but will only display as the given <a>Sentence</a>.
namedRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence -> Sentence

-- | Takes a <a>Reference</a> with additional display info. Uses the
--   internal shortname for its display name.
complexRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> RefInfo -> Sentence

-- | Takes a <a>Reference</a> with a name to be displayed and any
--   additional information and wraps it into a <a>Sentence</a>. Does not
--   overwrite the shortname contained in the reference, but will only
--   display as the given <a>Sentence</a> along with the given
--   <a>RefInfo</a>.
namedComplexRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> Sentence -> RefInfo -> Sentence

-- | For holding a <a>Reference</a> that is decorated with extra
--   information (ex. page numbers, equation sources, etc.).
data DecRef

-- | For creating a decorated reference (<a>DecRef</a>) with extra
--   reference information (<a>RefInfo</a>).
dRefInfo :: (HasUID r, HasRefAddress r, HasShortName r) => r -> RefInfo -> DecRef

-- | Same as <a>ref</a>, but for <a>DecRef</a> instead of <a>Reference</a>.
dRef :: (HasUID r, HasRefAddress r, HasShortName r) => r -> DecRef

-- | A class that contains a list of decorated references (<a>DecRef</a>s).
class HasDecRef c

-- | Provides a <tt>Lens</tt> to the <a>DecRef</a>s.
getDecRefs :: HasDecRef c => Lens' c [DecRef]

-- | A <a>String</a> that should contain no spaces.
type EntryID = String

-- | All citations require a unique identifier used by the Drasil chunk. We
--   will re-use the <a>UID</a> part as an EntryID (<a>String</a>) used for
--   creating reference links. Finally we will have the reference
--   information (<a>CitationKind</a>, <a>CiteField</a>s, and a
--   <a>ShortName</a>).
--   
--   Ex. A reference to a thesis paper like Koothoor's "Document driven
--   approach to certifying scientific computing software" would include
--   the affiliated university, publishing year, and city.
data Citation

-- | A list of <a>Citation</a>s.
type BibRef = [Citation]

-- | Some documents, as well as some pieces of knowledge, have citations.
class HasCitation c

-- | Provides a <tt>Lens</tt> to the citations.
getCitations :: HasCitation c => Lens' c [Citation]

-- | <tt>Citation</tt>s should have a fields (<a>CiteField</a>).
class HasFields c

-- | Provides a <tt>Lens</tt> to <a>CiteField</a>s.
getFields :: HasFields c => Lens' c [CiteField]
citeID :: Lens' Citation UID
citeKind :: Lens' Citation CitationKind

-- | Article citation requires author(s), title, journal, year. Optional
--   fields can be: volume, number, pages, month, and note. Implicitly uses
--   the EntryID as the chunk id.
cArticle :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by author.
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk id.
cBookA :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Book citation by editor.
--   
--   Book citation requires author or editor, title, publisher, year.
--   Optional fields can be volume or number, series, address, edition,
--   month, and note. Implicitly uses the EntryID as the chunk id.
cBookE :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Booklet citation requires title. Optional fields can be author, how
--   published, address, month, year, note. Implicitly uses the EntryID as
--   the chunk id.
cBooklet :: String -> [CiteField] -> String -> Citation

-- | InBook citation by author.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id. This smart constructor includes both chapter
--   and page numbers.
cInBookACP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InBook citation by editor.
--   
--   InBook citation requires author or editor, title, chapter and/or
--   pages, publisher, year. Optional fields can be volume or number,
--   series, type, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id. This smart constructor includes both chapter
--   and page numbers.
cInBookECP :: People -> String -> Int -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookACP</a>.
--   
--   InBook citation excluding page numbers.
cInBookAC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookECP</a>.
--   
--   InBook citation excluding page numbers.
cInBookEC :: People -> String -> Int -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookACP</a>.
--   
--   InBook citation excluding chapter.
cInBookAP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | Otherwise identical to <a>cInBookECP</a>.
--   
--   InBook citation excluding chapter.
cInBookEP :: People -> String -> [Int] -> String -> Int -> [CiteField] -> String -> Citation

-- | InCollection citation requires author, title, bookTitle, publisher,
--   year. Optional fields can be editor, volume or number, series, type,
--   chapter, pages, address, edition, month, and note. Implicitly uses the
--   EntryID as the chunk id.
cInCollection :: People -> String -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | InProceedings citation requires author, title, bookTitle, year.
--   Optional fields can be editor, volume or number, series, pages,
--   address, month, organization, publisher, and note. Implicitly uses the
--   EntryID as the chunk id.
cInProceedings :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Manual (technical documentation) citation requires title. Optional
--   fields can be author, organization, address, edition, month, year, and
--   note. Implicitly uses the EntryID as the chunk id.
cManual :: String -> [CiteField] -> String -> Citation

-- | Master's Thesis citation requires author, title, school, and year.
--   Optional fields can be type, address, month, and note. Implicitly uses
--   the EntryID as the chunk id.
cMThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Misc citation requires nothing. Optional fields can be author, title,
--   howpublished, month, year, and note. Implicitly uses the EntryID as
--   the chunk id.
cMisc :: [CiteField] -> String -> Citation

-- | PhD Thesis citation requires author, title, school, and year. Optional
--   fields can be type, address, month, and note. Implicitly uses the
--   EntryID as the chunk id.
cPhDThesis :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Proceedings citation requires title and year. Optional fields can be
--   editor, volume or number, series, address, publisher, note, month, and
--   organization. Implicitly uses the EntryID as the chunk id.
cProceedings :: String -> Int -> [CiteField] -> String -> Citation

-- | Technical Report citation requires author, title, institution, and
--   year. Optional fields can be type, number, address, month, and note.
--   Implicitly uses the EntryID as the chunk id.
cTechReport :: People -> String -> String -> Int -> [CiteField] -> String -> Citation

-- | Unpublished citation requires author, title, and note. Optional fields
--   can be month and year. Implicitly uses the EntryID as the chunk id.
cUnpublished :: People -> String -> String -> [CiteField] -> String -> Citation

-- | Custom type for months (abbreviated).
data Month
Jan :: Month
Feb :: Month
Mar :: Month
Apr :: Month
May :: Month
Jun :: Month
Jul :: Month
Aug :: Month
Sep :: Month
Oct :: Month
Nov :: Month
Dec :: Month

-- | Fields used in citations.
data CiteField
Address :: String -> CiteField
Author :: People -> CiteField

-- | Used for <a>InCollection</a> references only.
BookTitle :: String -> CiteField
Chapter :: Int -> CiteField
Edition :: Int -> CiteField
Editor :: People -> CiteField

-- | Can be published via URL or something else.
HowPublished :: HP -> CiteField
Institution :: String -> CiteField
Journal :: String -> CiteField
Month :: Month -> CiteField
Note :: String -> CiteField
Number :: Int -> CiteField
Organization :: String -> CiteField

-- | Range of pages (ex1. 1-32; ex2. 7,31,52-55).
Pages :: [Int] -> CiteField
Publisher :: String -> CiteField
School :: String -> CiteField
Series :: String -> CiteField
Title :: String -> CiteField

-- | BibTeX "type" field.
Type :: String -> CiteField
Volume :: Int -> CiteField
Year :: Int -> CiteField

-- | How something is published. Necessary for URLs to work properly.
data HP
URL :: String -> HP
Verb :: String -> HP

-- | External references come in many flavours. Articles, Books, etc. (we
--   are using the types available in Bibtex).
data CitationKind
Article :: CitationKind
Book :: CitationKind
Booklet :: CitationKind
InBook :: CitationKind
InCollection :: CitationKind
InProceedings :: CitationKind
Manual :: CitationKind
MThesis :: CitationKind
Misc :: CitationKind
PhDThesis :: CitationKind
Proceedings :: CitationKind
TechReport :: CitationKind
Unpublished :: CitationKind

-- | Smart field constructor for a <a>CiteField</a>.
author :: People -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
editor :: People -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
address :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
bookTitle :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
howPublished :: String -> CiteField

-- | URL version of <a>howPublished</a>.
--   
--   Smart field constructor for a <a>CiteField</a>.
howPublishedU :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
institution :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
journal :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
note :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
organization :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
publisher :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
school :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
series :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
title :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
typeField :: String -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
chapter :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
edition :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
number :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
volume :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
year :: Int -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
pages :: [Int] -> CiteField

-- | Smart field constructor for a <a>CiteField</a>.
month :: Month -> CiteField

-- | People is a synonymn for many <a>Person</a>s.
type People = [Person]

-- | A person can have a given name, middle name(s), and surname, as well
--   as the naming convention they use.
data Person

-- | Constructor for a person using Western naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   given name, surname.
person :: String -> String -> Person

-- | Members of this class must have a name.
class HasName p

-- | Gets the name of a <a>Person</a>. Adds a dot after any initials.
name :: HasName n => n -> String

-- | Constructor for a person using Eastern naming conventions. Used for a
--   person with only a given name and surname. Arguments are in the order:
--   surname, given name.
person' :: String -> String -> Person

-- | Constructor for a person using Western naming conventions. Similar to
--   the <a>person</a> constructor, except the middle argument is a list of
--   middle names.
personWM :: String -> [String] -> String -> Person

-- | Constructor for a person using Eastern naming conventions. Similar to
--   the <a>person'</a> constructor, except the middle argument is a list
--   of middle names.
personWM' :: String -> [String] -> String -> Person

-- | Constructor for a person with a mononym (only one name).
mononym :: String -> Person

-- | Provides the ability to hold a name.
nameStr :: HasName p => p -> String

-- | Gets a <a>Person</a>'s name in the form: Last, First Middle.
rendPersLFM :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, F. M.
rendPersLFM' :: Person -> String

-- | Gets a <a>Person</a>'s name in the form: Last, First M.
rendPersLFM'' :: Person -> String

-- | Orderes different groups of <a>Person</a>s. If two lists are the same
--   up to a point, the citation with more <a>Person</a>s will go last.
comparePeople :: [Person] -> [Person] -> Ordering

-- | For writing <a>Sentence</a>s via combining smaller elements.
--   <a>Sentence</a>s are made up of some known vocabulary of things:
--   
--   <ul>
--   <li>units (their visual representation)</li>
--   <li>words (via <a>String</a>s)</li>
--   <li>special characters</li>
--   <li>accented letters</li>
--   <li>references to specific layout objects</li>
--   </ul>
data Sentence

-- | Ch looks up the term for a given <a>UID</a> and displays the term with
--   a given <a>SentenceStyle</a> and <tt>CapitalizationRule</tt>. This
--   allows Sentences to hold plural forms of <tt>NounPhrase</tt>s and
--   <tt>NamedIdea</tt>s.
[Ch] :: SentenceStyle -> TermCapitalization -> UID -> Sentence

-- | A branch of Ch dedicated to SymbolStyle only.
[SyCh] :: UID -> Sentence

-- | Converts a unit symbol into a usable Sentence form.
[Sy] :: USymb -> Sentence

-- | Constructor for <a>String</a>s, used often for descriptions in Chunks.
[S] :: String -> Sentence

-- | Converts the graphical representation of a symbol into a usable
--   Sentence form.
[P] :: Symbol -> Sentence

-- | Lifts an expression into a Sentence.
[E] :: ModelExpr -> Sentence

-- | Takes a <a>UID</a> to a reference, a display name (<a>Sentence</a>),
--   and any additional reference display information (<a>RefInfo</a>).
--   Resolves the reference later (similar to Ch).
[Ref] :: UID -> Sentence -> RefInfo -> Sentence

-- | Adds quotation marks around a Sentence.
[Quote] :: Sentence -> Sentence

-- | Used for a % symbol.
[Percent] :: Sentence

-- | Direct concatenation of two Sentences (no implicit spaces!).
[:+:] :: Sentence -> Sentence -> Sentence

-- | Empty Sentence.
[EmptyS] :: Sentence
infixr 5 :+:

-- | Used in <a>Ch</a> constructor to determine the state of a term (can
--   record whether something is in plural form, a singular term, or in
--   short form).
data SentenceStyle
PluralTerm :: SentenceStyle
TermStyle :: SentenceStyle
ShortStyle :: SentenceStyle

-- | Used in <a>Ch</a> constructor to determine the capitalization of a
--   term. CapF is for capitalizing the first word from the <a>UID</a> of
--   the given term. CapW is for capitalizing all words from the <a>UID</a>
--   of the given term. Mirrors <tt>CapFirst</tt> and <tt>CapWords</tt>
--   from <tt>CapitalizationRule</tt>.
data TermCapitalization
CapF :: TermCapitalization
CapW :: TermCapitalization
NoCap :: TermCapitalization

-- | Holds any extra information needed for a <tt>Reference</tt>, be it an
--   equation, pages, a note, or nothing.
data RefInfo
None :: RefInfo
Equation :: [Int] -> RefInfo
Page :: [Int] -> RefInfo
RefNote :: String -> RefInfo

-- | Helper for concatenating two <a>Sentence</a>s with a space between
--   them.
(+:+) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two <a>Sentence</a>s using <a>+:+</a> and
--   appends a period.
(+:+.) :: Sentence -> Sentence -> Sentence

-- | Helper which concatenates two sentences using <a>+:+</a> and appends a
--   colon.
(+:) :: Sentence -> Sentence -> Sentence

-- | Helper which appends a period to the end of a <a>Sentence</a> (used
--   often as a post-fix operator).
(!.) :: Sentence -> Sentence

-- | Capitalizes a Sentence.
capSent :: Sentence -> Sentence

-- | Helper which creates a Header with size s of the <a>Sentence</a>.
headSent :: Int -> Sentence -> Sentence

-- | Gets a symbol and places it in a <a>Sentence</a>.
ch :: (HasUID c, HasSymbol c) => c -> Sentence
eS :: ModelExpr -> Sentence
eS' :: Express t => t -> Sentence

-- | Helper for concatenating two <a>Sentence</a>s with a comma and space
--   between them.
sC :: Sentence -> Sentence -> Sentence

-- | Helper for concatenating two <a>Sentence</a>s with a space-surrounded
--   dash between them.
sDash :: Sentence -> Sentence -> Sentence

-- | Helper for wrapping <a>Sentence</a>s in parentheses.
sParen :: Sentence -> Sentence
class NounPhrase n

-- | Retrieves singular form of term. Ex. "the quick brown fox".
phraseNP :: NounPhrase n => n -> Sentence

-- | Retrieves plural form of term. Ex. "the quick brown foxes".
pluralNP :: NounPhrase n => n -> PluralForm

-- | Retrieves the singular form and applies a captalization rule (usually
--   capitalizes the first word) to produce a <a>Sentence</a>. Ex. "The
--   quick brown fox".
sentenceCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization

-- | Retrieves the singular form and applies a captalization rule (usually
--   capitalizes all words) to produce a <a>Sentence</a>. Ex. "The Quick
--   Brown Fox".
titleCase :: NounPhrase n => n -> (NP -> Sentence) -> Capitalization

-- | For nouns and <tt>NounPhrase</tt>s. May be constructed from a proper
--   noun, common noun, or phrase (<a>Sentence</a>) and their respective
--   pluralization and capitalization rules.
data NP

-- | Self plural.
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn :: String -> NP

-- | Plural form simply adds "s" (ex. Henderson -&gt; Hendersons).
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn' :: String -> NP

-- | Plural form adds "e".
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn'' :: String -> NP

-- | Plural form adds "es" (ex. Bush -&gt; Bushes).
--   
--   Constructs a Proper Noun, it is always capitalized as written.
pn''' :: String -> NP

-- | Constructs a <a>ProperNoun</a> with a custom plural rule (using
--   <a>IrregPlur</a> from <a>PluralRule</a>). First argument is the String
--   representing the noun, second is the rule.
pnIrr :: String -> PluralRule -> NP

-- | Self plural.
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn :: String -> NP

-- | Plural form simply adds "s" (ex. dog -&gt; dogs).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn' :: String -> NP

-- | Plural form adds "e" (ex. formula -&gt; formulae).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn'' :: String -> NP

-- | Plural form adds "es" (ex. bush -&gt; bushes).
--   
--   Constructs a common noun which capitalizes the first letter of the
--   first word at the beginning of a sentence.
cn''' :: String -> NP

-- | Constructs a common noun that allows you to specify the pluralization
--   rule (as in <a>pnIrr</a>).
cnIP :: String -> PluralRule -> NP

-- | Common noun that allows you to specify both the pluralization rule and
--   the capitalization rule for sentence case (if the noun is used at the
--   beginning of a sentence).
cnIrr :: String -> PluralRule -> CapitalizationRule -> NP

-- | Constructs a common noun that pluralizes by dropping the last letter
--   and adding an "ies" ending (ex. body -&gt; bodies).
cnIES :: String -> NP

-- | Construct a common noun that pluralizes by dropping the last two
--   letters and adding an "ices" ending (ex. matrix -&gt; matrices).
cnICES :: String -> NP

-- | Constructs a common noun that pluralizes by dropping the last two
--   letters and adding "es" (ex. analysis -&gt; analyses).
cnIS :: String -> NP

-- | Constructs a common noun that pluralizes by dropping the last two
--   letters and adding "a" (ex. datum -&gt; data).
cnUM :: String -> NP

-- | Creates a <a>NP</a> with a given singular and plural form (as
--   <a>String</a>s) that capitalizes the first letter of the first word
--   for sentence case.
nounPhrase :: String -> PluralString -> NP

-- | Similar to <a>nounPhrase</a>, but takes a specified capitalization
--   rule for the sentence case.
nounPhrase' :: String -> PluralString -> CapitalizationRule -> NP

-- | Capitalization rules.
data CapitalizationRule

-- | Capitalize the first letter of the first word only.
CapFirst :: CapitalizationRule

-- | Capitalize the first letter of each word.
CapWords :: CapitalizationRule

-- | Replace the noun phrase with the given <a>Sentence</a>. Used for
--   custom capitalization.
Replace :: Sentence -> CapitalizationRule

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
atStartNP :: NounPhrase n => n -> Capitalization

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase.
atStartNP' :: NounPhrase n => n -> Capitalization

-- | Pluralization rules.
data PluralRule

-- | Add "s" to the end of the noun phrase.
AddS :: PluralRule

-- | Add "e" to the end of the noun phrase.
AddE :: PluralRule

-- | Add "es" to the end of the noun phrase.
AddES :: PluralRule

-- | The noun phrase is already plural.
SelfPlur :: PluralRule

-- | Apply the given function to the noun phrase to get the plural.
IrregPlur :: (String -> String) -> PluralRule

-- | Combine two noun phrases. The singular form becomes <tt>phrase</tt>
--   from t1 followed by <tt>phrase</tt> of t2. The plural becomes
--   <tt>phrase</tt> of t1 followed by <tt>plural</tt> of t2. Uses standard
--   <a>CapFirst</a> sentence case and <a>CapWords</a> title case. For
--   example: <tt>compoundPhrase system constraint</tt> will have singular
--   form "system constraint" and plural "system constraints".
compoundPhrase :: (NounPhrase a, NounPhrase b) => a -> b -> NP

-- | Similar to <a>compoundPhrase</a>, but the sentence case is the same as
--   the title case (<a>CapWords</a>).
compoundPhrase' :: NP -> NP -> NP

-- | Similar to <a>compoundPhrase'</a>, but accepts two functions that will
--   be used to construct the plural form. For example,
--   <tt>compoundPhrase'' plural phrase system constraint</tt> would have
--   the plural form "systems constraint".
compoundPhrase'' :: (NP -> Sentence) -> (NP -> Sentence) -> NP -> NP -> NP

-- | Similar to <a>compoundPhrase</a>, but used when you need a special
--   function applied to the first term of both singular and pluralcases
--   (eg. short or plural).
compoundPhrase''' :: (NP -> Sentence) -> NP -> NP -> NP

-- | Similar to <a>compoundPhrase</a>, but pluralizes the first <a>NP</a>
--   for both singular and plural cases.
compoundPhraseP1 :: NP -> NP -> NP

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP :: NounPhrase n => n -> Capitalization

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase.
titleizeNP' :: NounPhrase n => n -> Capitalization

-- | Custom noun phrase constructor that takes a singular form
--   (<a>Sentence</a>), plural form (<a>Sentence</a>), sentence case
--   capitalization rule, and title case capitalization rule.
nounPhrase'' :: Sentence -> PluralForm -> CapitalizationRule -> CapitalizationRule -> NP

-- | For things that should not be pluralized (or are self-plural). Works
--   like <a>nounPhrase</a>, but with only the first argument.
nounPhraseSP :: String -> NP

-- | Similar to nounPhrase, except it only accepts one <a>Sentence</a>.
--   Used for Requirements, Assumptions, LikelyChanges, etc. to allow for
--   referencing. Plural case is just <a>AddS</a>.
nounPhraseSent :: Sentence -> NP

-- | Helper for common pattern of introducing the title-case version of a
--   noun phrase (from an Idea) followed by its abbreviation in
--   parentheses.
introduceAbb :: Idea n => n -> Sentence

-- | Helper for getting the phrase from a <a>NamedIdea</a> using it's UID.
phrase :: NamedIdea n => n -> Sentence

-- | Helper for getting the plural of a phrase from a <a>NamedIdea</a>.
plural :: NamedIdea n => n -> Sentence

-- | Singular possesive function
--   
--   Helper for getting the possesive cases from the term of a
--   <a>NamedIdea</a>.
phrasePoss :: NamedIdea n => n -> Sentence

-- | Plural possesive function
--   
--   Helper for getting the possesive cases from the term of a
--   <a>NamedIdea</a>.
pluralPoss :: NamedIdea n => n -> Sentence

-- | Singular sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   <a>NamedIdea</a>.
atStart :: NamedIdea n => n -> Sentence

-- | Plural sentence case.
--   
--   Helper function for getting the sentence case of a noun phrase from a
--   <a>NamedIdea</a>.
atStart' :: NamedIdea n => n -> Sentence

-- | Singular title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   <a>NamedIdea</a>.
titleize :: NamedIdea n => n -> Sentence

-- | Plural title case.
--   
--   Helper function for getting the title case of a noun phrase from a
--   <a>NamedIdea</a>.
titleize' :: NamedIdea n => n -> Sentence

-- | Get short form (if it exists), else get term of an <a>Idea</a>.
short :: Idea c => c -> Sentence

-- | Used for holding the short form of a name (as a <a>Sentence</a> with a
--   wrapper).
data ShortName

-- | Smart constructor for making a <a>Sentence</a> into a
--   <a>ShortName</a>.
shortname' :: Sentence -> ShortName

-- | Pulls the short form (as a <a>Sentence</a>) out of a <a>ShortName</a>.
getSentSN :: ShortName -> Sentence

-- | A <a>ShortName</a> is the text to be displayed for a link.
--   
--   Used for referencing within a document that can include symbols and
--   whatnot if required. Visible in the typeset documents (pdf).
class HasShortName s
shortname :: HasShortName s => s -> ShortName

-- | Derivations are an ordered list of sentences and expressions. They are
--   rendered in order as paragraphs and equation blocks to display the
--   derivation.
data Derivation
Derivation :: Sentence -> [Sentence] -> Derivation

-- | Smart constructor for creating a <a>Derivation</a>.
mkDeriv :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but prepends "Detailed derivation of" to
--   the header.
mkDerivName :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but without a header <a>Sentence</a>.
mkDerivNoHeader :: [Sentence] -> Derivation

-- | Type that helps determine enumeration method. Can use either numbers,
--   uppercase letters, or lowercase letters.
data EnumType
Numb :: EnumType
Upper :: EnumType
Lower :: EnumType

-- | Type to help wrap a sentence with parenthesis or to add a period at
--   the end.
data WrapType
Parens :: WrapType
Period :: WrapType

-- | Type to help separate words with commas or semicolons.
data SepType
Comma :: SepType
SemiCol :: SepType

-- | Type to help fold differently between listed items, or if there are
--   options (ex. using "and" or "or" at the end of a list of words).
data FoldType
List :: FoldType
Options :: FoldType

-- | Helper for formatting a list of constraints.
foldConstraints :: Quantity c => c -> [ConstraintE] -> Sentence

-- | Creates a list of elements with "enumerators" in "wrappers" using
--   foldlList.
foldlEnumList :: EnumType -> WrapType -> SepType -> FoldType -> [Sentence] -> Sentence

-- | Creates a list of elements separated by a "separator", ending with
--   "and" or "or".
foldlList :: SepType -> FoldType -> [Sentence] -> Sentence

-- | Fold sentences then turns into content using <a>foldlSent</a>.
foldlSP :: [Sentence] -> Contents

-- | Same as <a>foldlSP</a> but uses <a>foldlSent_</a>.
foldlSP_ :: [Sentence] -> Contents

-- | Same as <a>foldlSP</a> but uses <a>foldlSentCol</a>.
foldlSPCol :: [Sentence] -> Contents

-- | Partial function application of <a>foldle</a> for sentences
--   specifically. Folds with spaces and adds a period (".") at the end.
foldlSent :: [Sentence] -> Sentence

-- | <a>foldlSent</a> but does not add a period.
foldlSent_ :: [Sentence] -> Sentence

-- | <a>foldlSent</a> but ends with colon.
foldlSentCol :: [Sentence] -> Sentence

-- | Folds a list of elements separated by commas, including the last
--   element.
foldlsC :: [Sentence] -> Sentence

-- | Parses a list of integers into a nice sentence (ie. S "1, 4-7, and
--   13").
foldNums :: String -> [Int] -> Sentence

-- | Parses a list of integers into a list of strings (ie. ["1", "4-7",
--   "13"]).
numList :: String -> [Int] -> [String]

-- | A Document has a Title (<a>Sentence</a>), Author(s) (<a>Sentence</a>),
--   and <a>Section</a>s which hold the contents of the document.
data Document
Document :: Title -> Author -> ShowTableOfContents -> [Section] -> Document
Notebook :: Title -> Author -> [Section] -> Document

-- | Determines whether or not the table of contents appears on the
--   generated artifacts.
data ShowTableOfContents
ToC :: ShowTableOfContents
NoToC :: ShowTableOfContents

-- | Types of definitions (general, instance, theory, or data).
data DType
General :: DType
Instance :: DType
Theory :: DType
Data :: DType

-- | Sections have a title (<a>Sentence</a>), a list of contents
--   (<a>SecCons</a>) and a shortname (<a>Reference</a>).
data Section
Section :: Title -> [SecCons] -> Reference -> Section
[tle] :: Section -> Title
[cons] :: Section -> [SecCons]
[_lab] :: Section -> Reference

-- | Contents may be labelled or unlabelled.
data Contents
UlC :: UnlabelledContent -> Contents
LlC :: LabelledContent -> Contents

-- | Section Contents are split into subsections or contents, where
--   contents are standard layout objects (see <a>Contents</a>).
data SecCons
Sub :: Section -> SecCons
Con :: Contents -> SecCons

-- | Denotes the different possible types that can be used as a list.
data ListType

-- | Bulleted list.
Bullet :: [(ItemType, Maybe String)] -> ListType

-- | Enumerated list.
Numeric :: [(ItemType, Maybe String)] -> ListType

-- | Simple list with items denoted by <tt>:</tt>. Renders as "Title: Item"
Simple :: [ListTuple] -> ListType

-- | Descriptive list, renders as "<b>Title: Item</b>" (see
--   <a>ListTuple</a>).
Desc :: [ListTuple] -> ListType

-- | Renders a list of "<tt><a>Title</a></tt> is the <tt>Item</tt>".
Definitions :: [ListTuple] -> ListType

-- | Denotes how something should behave in a list (<a>ListType</a>).
data ItemType

-- | Standard singular item.
Flat :: Sentence -> ItemType

-- | Nest a list (<a>ListType</a>) as an item.
Nested :: Header -> ListType -> ItemType
type ListTuple = (Title, ItemType, Maybe String) " Formats as Title: Item. For use in lists."

-- | Contains a <a>Reference</a> and <a>RawContent</a>.
data LabelledContent
LblC :: Reference -> RawContent -> LabelledContent
[_ref] :: LabelledContent -> Reference
[_ctype] :: LabelledContent -> RawContent

-- | Only contains <a>RawContent</a>.
newtype UnlabelledContent
UnlblC :: RawContent -> UnlabelledContent
[_cntnts] :: UnlabelledContent -> RawContent

-- | Smart constructor for retrieving the contents (<a>Section</a>s) from a
--   <a>Document</a>.
extractSection :: Document -> [Section]

-- | Smart constructor that wraps <a>UnlabelledContent</a> into
--   <a>Contents</a>.
mkParagraph :: Sentence -> Contents

-- | Smart constructor similar to <a>llcc</a>, but takes in
--   <a>RawContent</a> first.
mkRawLC :: RawContent -> Reference -> LabelledContent

-- | Manually removes the first section of a document (table of contents
--   section). temp fix for Notebook (see if we need this in notebook
--   later)
checkToC :: Document -> Document

-- | Smart constructor for labelled content chunks.
llcc :: Reference -> RawContent -> LabelledContent

-- | Smart constructor for unlabelled content chunks (no <a>Reference</a>).
ulcc :: RawContent -> UnlabelledContent

-- | Smart constructor for creating <a>Section</a>s with a title
--   (<a>Sentence</a>), introductory contents (ie. paragraphs, tables,
--   etc.), a list of subsections, and a shortname (<a>Reference</a>).
section :: Sentence -> [Contents] -> [Section] -> Reference -> Section

-- | <a>Figure</a> smart constructor with a <a>Lbl</a> and a
--   <a>Filepath</a>. Assumes 100% of page width as max width.
fig :: Lbl -> Filepath -> RawContent

-- | <a>Figure</a> smart constructor that allows for customized max widths.
figWithWidth :: Lbl -> Filepath -> MaxWidthPercent -> RawContent

-- | MaxWidthPercent should be kept in the range 1-100. Values outside this
--   range may have unexpected results. Used for specifying max figure
--   width as <tt>pagewidth*MaxWidthPercent/100</tt>.
type MaxWidthPercent = Float

-- | Members of this class must have <a>RawContent</a>.
class HasContents c

-- | Provides a <tt>Lens</tt> to the <a>RawContent</a>.
accessContents :: HasContents c => Lens' c RawContent

-- | Types of layout objects we deal with explicitly.
data RawContent

-- | table has: header-row, data(rows), label/caption, and a bool that
--   determines whether or not to show label.
Table :: [Sentence] -> [[Sentence]] -> Title -> Bool -> RawContent

-- | Paragraphs are just sentences.
Paragraph :: Sentence -> RawContent

-- | Block of Equations holds an expression.
EqnBlock :: ModelExpr -> RawContent

-- | Grants the ability to label a group of <a>RawContent</a>.
DerivBlock :: Sentence -> [RawContent] -> RawContent

-- | For enumerated lists.
Enumeration :: ListType -> RawContent

-- | Defines something with a type, identifier, and <a>Contents</a>.
Defini :: DType -> [(Identifier, [Contents])] -> RawContent

-- | For creating figures in a document. Should use relative file path.
Figure :: Lbl -> Filepath -> MaxWidthPercent -> RawContent

-- | Grants the ability to reference something.
Bib :: BibRef -> RawContent

-- | Contain a graph with coordinates (<a>Sentence</a>s), maybe a width and
--   height, and a label (<a>Sentence</a>).
Graph :: [(Sentence, Sentence)] -> Maybe Width -> Maybe Height -> Lbl -> RawContent

-- | Block for codes TODO: Fill this one in.
CodeBlock :: CodeExpr -> RawContent

-- | Smart constructor that wraps <a>LabelledContent</a> into
--   <a>Contents</a>.
mkFig :: Reference -> RawContent -> Contents

-- | Create a reference for a table. Takes in the name of a table (which
--   will also be used for its shortname).
makeTabRef :: String -> Reference

-- | Create a reference for a figure. Takes in the name of a figure (which
--   will also be used for its shortname).
makeFigRef :: String -> Reference

-- | Create a reference for a section. Takes in the name of a section and a
--   shortname for the section.
makeSecRef :: String -> Sentence -> Reference

-- | Create a reference for a equation. Takes in the name of the equation
--   (which will also be used for its shortname).
makeEqnRef :: String -> Reference

-- | Create a reference for a <a>URI</a>. Takes in a <a>UID</a> (as a
--   <a>String</a>), a reference address, and a shortname.
makeURI :: String -> String -> ShortName -> Reference

-- | Variants of <a>makeTabRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeTabRef' :: UID -> Reference

-- | Variants of <a>makeFigRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeFigRef' :: UID -> Reference

-- | Variants of <a>makeSecRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeSecRef' :: UID -> Sentence -> Reference

-- | Variants of <a>makeEqnRef</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeEqnRef' :: UID -> Reference

-- | Variants of <a>makeURI</a> that takes a <a>UID</a> instead of a
--   <a>String</a>.
makeURI' :: UID -> String -> ShortName -> Reference

-- | Creates a bulleted list.
enumBullet :: Reference -> [Sentence] -> LabelledContent

-- | Same as <a>enumBullet</a> but unlabelled.
enumBulletU :: [Sentence] -> Contents

-- | Currently Unused. Creates a simple bulleted list that labels things
--   with a title and number:
--   
--   <ul>
--   <li>lb - Reference,</li>
--   <li>s - start index for the enumeration,</li>
--   <li>t - title of the list,</li>
--   <li>l - list to be enumerated.</li>
--   </ul>
--   
--   For example, if we want to create a list of data definitions, we could
--   call the function as follows:
--   
--   <pre>
--   enumSimple _ 2 (S "DD") [def1, def2, ...]
--   </pre>
--   
--   And the resulting <a>LabelledContent</a> would be rendered as:
--   
--   <ul>
--   <li>DD2: def1</li>
--   <li>DD3: def2</li>
--   <li>DD4: def3 ...</li>
--   </ul>
enumSimple :: Reference -> Integer -> Sentence -> [Sentence] -> LabelledContent

-- | Same as <a>enumSimple</a> but unlabelled.
enumSimpleU :: Integer -> Sentence -> [Sentence] -> Contents

-- | Convenience function for transforming referable concepts into a
--   bulleted list. Used in drasil-docLang in making the assumptions,
--   goals, and requirements sections. Output is of the kind <tt>Concept
--   Name: definition of concept</tt>.
mkEnumSimpleD :: (Referable c, HasShortName c, Definition c) => [c] -> [Contents]

-- | Displays a given expression and attaches a <a>Reference</a> to it.
lbldExpr :: ModelExpr -> Reference -> LabelledContent

-- | Same as <tt>eqUnR</tt> except content is unlabelled (does not attach a
--   <a>Reference</a>).
unlbldExpr :: ModelExpr -> Contents

-- | Unlabelled code expression
unlbldCode :: CodeExpr -> Contents

-- | Output is of the form "<tt>reference - sentence</tt>".
chgsStart :: (HasShortName x, Referable x) => x -> Sentence -> Sentence

-- | Takes a <a>HasSymbol</a> that is also <a>Referable</a> and outputs as
--   a <a>Sentence</a>: "<tt>symbol</tt> is defined in <tt>reference</tt>."
definedIn :: (Referable r, HasShortName r, DefinesQuantity r) => r -> Sentence

-- | Same as <a>definedIn</a>, but allows for additional information to be
--   appended to the <a>Sentence</a>.
definedIn' :: (Referable r, HasShortName r, DefinesQuantity r) => r -> Sentence -> Sentence

-- | Takes a <a>Referable</a> and outputs as a <a>Sentence</a> "defined in
--   <tt>reference</tt>" (no <a>HasSymbol</a>).
definedIn'' :: (Referable r, HasShortName r) => r -> Sentence

-- | Takes a <a>Symbol</a> and its <tt>Reference</tt> (does not append a
--   period at the end!). Outputs as "<tt>symbol</tt> is defined in
--   <tt>source</tt>".
definedIn''' :: (HasSymbol q, HasUID q, Referable r, HasShortName r) => q -> r -> Sentence

-- | Takes an expression and a <a>Referable</a> and outputs as a Sentence
--   "expression (source)".
eqnWSource :: (Referable r, HasShortName r) => ModelExpr -> r -> Sentence

-- | Takes a <a>Referable</a> source and a <a>UnitalChunk</a> and outputs
--   as a <a>Sentence</a>: "From <tt>source</tt> we can replace
--   <tt>symbol</tt>:".
fromReplace :: (Referable r, HasShortName r) => r -> UnitalChunk -> Sentence

-- | Wraps "from <tt>reference</tt>" in parentheses.
fromSource :: (Referable r, HasShortName r) => r -> Sentence

-- | Similar to <a>fromSource</a> but takes a list of references instead of
--   one.
fromSources :: (Referable r, HasShortName r) => [r] -> Sentence

-- | Takes an amount as a <a>Sentence</a> and appends a unit to it.
fmtU :: MayHaveUnit a => Sentence -> a -> Sentence

-- | Appends "following <tt>reference</tt>" to the end of a
--   <a>Sentence</a>.
follows :: (Referable r, HasShortName r) => Sentence -> r -> Sentence

-- | Takes a list and a <a>Section</a>, then generates a list of that
--   section's reference to match the length of the list.
makeListRef :: [a] -> Section -> [Sentence]

-- | Converts input to a <a>Sentence</a> and appends %.
addPercent :: Show a => a -> Sentence

-- | Produces a <a>Sentence</a> that displays the constraints in a set {}.
displayStrConstrntsAsSet :: Quantity a => a -> [String] -> Sentence

-- | Produces a <a>Sentence</a> that displays the constraints in a set {}.
displayDblConstrntsAsSet :: Quantity a => a -> [Double] -> Sentence

-- | Prepends the word <a>Equation</a> to an <a>Int</a>.
eqN :: Int -> Sentence

-- | Uses an <a>Either</a> type to check if a <a>String</a> is valid -
--   <a>Left</a> with error message if there is an invalid <a>Char</a> in
--   <a>String</a>, else <a>Right</a> with <a>String</a>.
checkValidStr :: String -> String -> Either String String

-- | Used when you want to say a term followed by its symbol. ex. "...using
--   the Force F in...".
getTandS :: Quantity a => a -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeChanged :: Sentence -> Sentence -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeExpanded :: Sentence -> Sentence -> Sentence

-- | Helper functions for making likely change statements. Uses form
--   <tt><a>likelyFrame</a> parameter1 _ parameter2</tt>.
maybeWOVerb :: Sentence -> Sentence -> Sentence

-- | Returns the <a>Sentence</a> "<tt>(<a>titleize</a> aNamedIdea)</tt>
--   Showing the Connections Between <tt>contents</tt>".
showingCxnBw :: NamedIdea c => c -> Sentence -> Sentence

-- | Takes a list of <a>Referable</a>s and <a>Symbol</a>s and outputs as a
--   Sentence "By substituting <tt>symbols</tt>, this can be written as:".
substitute :: (Referable r, HasShortName r, DefinesQuantity r) => [r] -> Sentence

-- | Extracts the typical uncertainty to be displayed from something that
--   has an uncertainty.
typUncr :: HasUncertainty c => c -> Sentence

-- | Returns the <a>Sentence</a> "The <tt>chunk</tt> under consideration is
--   <tt>chunkDefinition</tt>".
underConsidertn :: ConceptChunk -> Sentence

-- | Get a unit symbol if there is one.
unwrap :: Maybe UnitDefn -> Sentence

-- | Apply a binary function to the terms of two named ideas, instead of to
--   the named ideas themselves. Ex. <tt>fterms compoundPhrase t1 t2</tt>
--   instead of <tt>compoundPhrase (t1 ^. term) (t2 ^. term)</tt>.
fterms :: (NamedIdea c, NamedIdea d) => (NP -> NP -> t) -> c -> d -> t

-- | Applies <a>Bullet</a> and <a>Flat</a> to a list.
bulletFlat :: [Sentence] -> ListType

-- | Applies <a>Bullet</a>s and headers to a <a>Nested</a> <a>ListType</a>.
--   The first argument is the headers of the <a>Nested</a> lists.
bulletNested :: [Sentence] -> [ListType] -> ListType

-- | Makes <a>Sentence</a>s from an item and its reference. Takes the title
--   of reference as a <a>String</a> and a <a>Sentence</a> containing the
--   full reference. Wraps the full reference in parenthesis.
itemRefToSent :: String -> Sentence -> Sentence

-- | Makes a traceability matrix from a list of row titles, a list of rows
--   of "checked" columns, and a list of columns.
makeTMatrix :: Eq a => [Sentence] -> [[a]] -> [a] -> [[Sentence]]

-- | Zip helper function enumerates abbreviations and zips it with list of
--   <a>ItemType</a>:
--   
--   <ul>
--   <li>s - the number from which the enumeration should start from
--   (<a>Integer</a>),</li>
--   <li>t - the title of the list (<a>Sentence</a>),</li>
--   <li>l - the list to be enumerated ([<a>Sentence</a>]).</li>
--   </ul>
mkEnumAbbrevList :: Integer -> Sentence -> [Sentence] -> [(Sentence, ItemType)]

-- | Helper for making a table from a columns.
mkTableFromColumns :: [(Sentence, [Sentence])] -> ([Sentence], [[Sentence]])

-- | Converts lists of simple <a>ItemType</a>s into a list which may be
--   used in <tt>Contents</tt> but is not directly referable.
noRefs :: [ItemType] -> [(ItemType, Maybe String)]

-- | Create a list in the pattern of "The __ are refined to the __". Note:
--   Order matters!
refineChain :: NamedIdea c => [(c, Section)] -> Sentence

-- | Sorts a list of <tt>HasSymbols</tt> by <a>Symbol</a>.
sortBySymbol :: HasSymbol a => [a] -> [a]

-- | Sorts a tuple list of <tt>HasSymbols</tt> by first Symbol in the
--   tuple.
sortBySymbolTuple :: HasSymbol a => [(a, b)] -> [(a, b)]

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term -
--   termDefinition</tt>".
tAndDOnly :: Concept s => s -> ItemType

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term (abbreviation) -
--   termDefinition</tt>".
tAndDWAcc :: Concept s => s -> ItemType

-- | Helpful combinators for making <a>Sentence</a>s into Terminologies
--   with Definitions. Returns of the form: "<tt>term (symbol) -
--   termDefinition</tt>".
tAndDWSym :: (Concept s, Quantity a) => s -> a -> ItemType

-- | Distributes a list of Sentences by prepending individual Sentences
--   once to an existing list of Sentences.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; zipSentList [S "Hi", S "Hey", S "Hi"] [[S "Hello"], [S "World"], [S "Hello", S "World"]]
--   [[S "Hi", S "Hello"], [S "Hey", S "World"], [S "Hi", S "Hello", S "World"]]
--   </pre>
zipSentList :: [[Sentence]] -> [Sentence] -> [[Sentence]] -> [[Sentence]]

-- | The difference kinds of spaces that may exist. This type holds
--   numerical spaces (such as the set of integers, rationals, etc.), a
--   space for booleans, a space for characters, dimensional spaces
--   (vectors, arrays, etc.), a space for Actors, discrete sets (both for
--   numbers and strings), and a void space.
data Space
Integer :: Space
Rational :: Space
Real :: Space
Natural :: Space
Boolean :: Space
Char :: Space
String :: Space
Vect :: Space -> Space
Matrix :: Int -> Int -> Space -> Space
Array :: Space -> Space
Actor :: String -> Space
DiscreteD :: [Double] -> Space
DiscreteS :: [String] -> Space
Function :: NonEmpty Primitive -> Primitive -> Space
Void :: Space

-- | A RealInterval is a subset of <a>Space</a> (as a <a>Space</a>). These
--   come in different flavours. For now, we embed <tt>Expr</tt> for the
--   bounds, but that will change as well.
data RealInterval a b
[Bounded] :: (Inclusive, a) -> (Inclusive, b) -> RealInterval a b
[UpTo] :: (Inclusive, a) -> RealInterval a b
[UpFrom] :: (Inclusive, b) -> RealInterval a b

-- | Inclusive or exclusive bounds.
data Inclusive
Inc :: Inclusive
Exc :: Inclusive

-- | Describes the domain of a <a>Symbol</a> given a topology. Can be
--   bounded or encase all of the domain.
data DomainDesc (tplgy :: RTopology) a b
[BoundedDD] :: Symbol -> RTopology -> a -> b -> DomainDesc 'Discrete a b
[AllDD] :: Symbol -> RTopology -> DomainDesc 'Continuous a b

-- | Topology of a subset of reals.
data RTopology
Continuous :: RTopology
Discrete :: RTopology
type ContinuousDomainDesc a b = DomainDesc 'Continuous a b
type DiscreteDomainDesc a b = DomainDesc 'Discrete a b

-- | Gets the name of an <a>Actor</a>.
getActorName :: Space -> String

-- | Gets the inner <a>Space</a> of a vector.
getInnerSpace :: Space -> Space
mkFunction :: [Primitive] -> Primitive -> Space
type Primitive = Space

-- | Decorations on symbols/characters such as hats or Vector
--   representations (determines bolding, italics, etc).
data Decoration

-- | A <a>Symbol</a> is actually going to be a graphical description of
--   what gets rendered as a (unique) symbol. This is actually NOT based on
--   semantics at all, but just a description of how things look.
--   
--   Symbols can be:
--   
--   <ul>
--   <li><tt><a>Variable</a></tt> (string such as "x" that represent a
--   value that can vary)</li>
--   <li><tt><a>Label</a></tt> (strings such as "max" or "target" that
--   represent a single idea)</li>
--   <li><tt><a>Symbol</a></tt> characters (ex. unicode)</li>
--   <li><tt>Decorated</tt> symbols using <a>Atop</a></li>
--   <li><tt>Concatenations</tt> of symbols, including subscripts and
--   superscripts</li>
--   <li><tt><a>Empty</a></tt>! (this is to give this a monoid-like
--   flavour)</li>
--   </ul>
data Symbol

-- | Language of units (how to build them up into a unit symbol). Of the
--   form (<a>Symbol</a> ^ <a>Integer</a>). The <a>Integer</a> may be
--   negative, but should not be zero.
newtype USymb
US :: [(Symbol, Integer)] -> USymb

-- | Create a table body (not including header row) by applying the given
--   functions to the column elements of the table rows (in order). The
--   first argument is a list of functions to be applied (one per column).
--   This essentially creates the rows. The second argument is a list of
--   elements apply the functions to.
--   
--   For example, <tt>mkTable [id, *5] [1,2,3]</tt> should produce a table:
--   
--   <pre>
--   | 1 |  5 |
--   | 2 | 10 |
--   | 3 | 15 |
--   </pre>
mkTable :: [a -> b] -> [a] -> [[b]]

-- | Stages are what part of the development process we are in. There are
--   currently two: 1) The Equational stage (should be called
--   Specification) 2) The Implemenation stage
--   
--   The point is that information may be rendered differently depending at
--   what stage we're at. Being able to talk about stages lets us also
--   attach different display information.
data Stage
Equational :: Stage
Implementation :: Stage

-- | Helper function for getting a symbol in the Equational Stage.
eqSymb :: HasSymbol q => q -> Symbol

-- | Helper function for getting a symbol in the Implementation Stage.
codeSymb :: HasSymbol q => q -> Symbol

-- | Finds if a <a>Stage</a> symbol is real or Empty. True if real.
hasStageSymbol :: HasSymbol q => q -> Stage -> Bool

-- | Helper for creating a symbol with Unicode in it.
autoStage :: Symbol -> Stage -> Symbol

-- | Helper for creating a symbol with a hat ("^") atop it.
hat :: Symbol -> Symbol

-- | Helper for creating a Vector symbol.
prime :: Symbol -> Symbol

-- | Helper for creating a symbol that depends on the stage.
staged :: Symbol -> Symbol -> Stage -> Symbol

-- | Helper for creating a symbol with a subscript to the right. Arguments:
--   Base symbol, then subscripted symbol.
sub :: Symbol -> Symbol -> Symbol

-- | Helper for a common case of subscript, with a string Arguments: Base
--   symbol, then subscript <a>String</a>.
subStr :: Symbol -> String -> Symbol

-- | Helper for creating a symbol with a superscript to the right.
--   Arguments: Base symbol, then superscripted symbol.
sup :: Symbol -> Symbol -> Symbol

-- | Helper for autoStage that applies unicodeString to all <a>Symbol</a>s
--   with <a>String</a>s.
unicodeConv :: Symbol -> Symbol

-- | Helper for creating a symbol with a superscript on the left side of
--   the symbol. Arguments: Base symbol, then superscripted symbol.
upperLeft :: Symbol -> Symbol -> Symbol

-- | Helper for creating a Vector symbol.
vec :: Symbol -> Symbol

-- | Label smart constructor, requires non-empty labels
label :: String -> Symbol

-- | Variable smart constructor, requires non-empty variables
variable :: String -> Symbol

-- | Commonly used type for QDefinitions containing Literals.
type ConstQDef = QDefinition Literal

-- | Commonly used type for QDefinitions containing Exprs.
type SimpleQDef = QDefinition Expr

-- | Commonly used type for QDefinitions containing ModelExprs.
type ModelQDef = QDefinition ModelExpr

-- | Commonly used type for polymorphic Exprs.
type PExpr = forall r. (ExprC r, LiteralC r) => r

-- | We can only type check <a>UID</a>s within a type context relating
--   <a>UID</a>s to types since they don't carry any type information.
type TypingContext t = Map UID t
type TypeError = String

-- | Look for a known type of a specific <a>UID</a>.
inferFromContext :: TypingContext t -> UID -> Either t TypeError

-- | Build a bidirectional type checker for your expression language, e,
--   with respect to a specific type universe, t.
class (Eq t, Show t) => Typed e t

-- | Given a typing context and an expression, infer a unique type or
--   explain what went awry.
infer :: Typed e t => TypingContext t -> e -> Either t TypeError

-- | Given a typing context, an expression, and an expected type, check if
--   the expression can satisfy the expectation.
check :: Typed e t => TypingContext t -> e -> t -> Either t TypeError

-- | For all containers, c, which contain typed expressions, e, against a
--   specific type universe, t, expose all expressions and relations that
--   need to be type-checked.
class Typed e t => RequiresChecking c e t

-- | All things that need type checking.
requiredChecks :: RequiresChecking c e t => c -> [(e, t)]

-- | A temporary, hacky, indentation function. It should be removed when we
--   switch to using something else for error messages, which can be later
--   formatted nicely.
temporaryIndent :: String -> String -> String
