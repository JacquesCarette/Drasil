<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE DeriveFoldable #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE NoImplicitPrelude #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE StandaloneDeriving #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE Trustworthy #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE TypeOperators #-}</span><span>
</span><span id="line-8"></span><span>
</span><span id="line-9"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- Module      :  Data.Foldable</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- Copyright   :  Ross Paterson 2005</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- License     :  BSD-style (see the LICENSE file in the distribution)</span><span>
</span><span id="line-14"></span><span class="hs-comment">--</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- Maintainer  :  libraries@haskell.org</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- Stability   :  experimental</span><span>
</span><span id="line-17"></span><span class="hs-comment">-- Portability :  portable</span><span>
</span><span id="line-18"></span><span class="hs-comment">--</span><span>
</span><span id="line-19"></span><span class="hs-comment">-- Class of data structures that can be folded to a summary value.</span><span>
</span><span id="line-20"></span><span class="hs-comment">--</span><span>
</span><span id="line-21"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-22"></span><span>
</span><span id="line-23"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Data.Foldable</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-24"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier">Foldable</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-25"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Special biased folds</span></span><span>
</span><span id="line-26"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#foldrM"><span class="hs-identifier">foldrM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#foldlM"><span class="hs-identifier">foldlM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Folding actions</span></span><span>
</span><span id="line-29"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Applicative actions</span></span><span>
</span><span id="line-30"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#traverse_"><span class="hs-identifier">traverse_</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#for_"><span class="hs-identifier">for_</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#sequenceA_"><span class="hs-identifier">sequenceA_</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#asum"><span class="hs-identifier">asum</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-34"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Monadic actions</span></span><span>
</span><span id="line-35"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#mapM_"><span class="hs-identifier">mapM_</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-36"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#forM_"><span class="hs-identifier">forM_</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-37"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#sequence_"><span class="hs-identifier">sequence_</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-38"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#msum"><span class="hs-identifier">msum</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-39"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Specialized folds</span></span><span>
</span><span id="line-40"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#concat"><span class="hs-identifier">concat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-41"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#concatMap"><span class="hs-identifier">concatMap</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-42"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#and"><span class="hs-identifier">and</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-43"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#or"><span class="hs-identifier">or</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-44"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#any"><span class="hs-identifier">any</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-45"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#all"><span class="hs-identifier">all</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-46"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#maximumBy"><span class="hs-identifier">maximumBy</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-47"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#minimumBy"><span class="hs-identifier">minimumBy</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-48"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Searches</span></span><span>
</span><span id="line-49"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#notElem"><span class="hs-identifier">notElem</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-50"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#find"><span class="hs-identifier">find</span></a></span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Overview</span></span><span>
</span><span id="line-53"></span><span>    </span><span class="annot"><span class="hs-comment">-- $overview</span></span><span>
</span><span id="line-54"></span><span>
</span><span id="line-55"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Expectation of efficient left-to-right iteration</span></span><span>
</span><span id="line-56"></span><span>    </span><span class="annot"><span class="hs-comment">-- $chirality</span></span><span>
</span><span id="line-57"></span><span>
</span><span id="line-58"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Recursive and corecursive reduction</span></span><span>
</span><span id="line-59"></span><span>    </span><span class="annot"><span class="hs-comment">-- $reduction</span></span><span>
</span><span id="line-60"></span><span>
</span><span id="line-61"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** Strict recursive folds</span></span><span>
</span><span id="line-62"></span><span>    </span><span class="annot"><span class="hs-comment">-- $strict</span></span><span>
</span><span id="line-63"></span><span>
</span><span id="line-64"></span><span>    </span><span class="annot"><span class="hs-comment">-- **** List of strict functions</span></span><span>
</span><span id="line-65"></span><span>    </span><span class="annot"><span class="hs-comment">-- $strictlist</span></span><span>
</span><span id="line-66"></span><span>
</span><span id="line-67"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** Lazy corecursive folds</span></span><span>
</span><span id="line-68"></span><span>    </span><span class="annot"><span class="hs-comment">-- $lazy</span></span><span>
</span><span id="line-69"></span><span>
</span><span id="line-70"></span><span>    </span><span class="annot"><span class="hs-comment">-- **** List of lazy functions</span></span><span>
</span><span id="line-71"></span><span>    </span><span class="annot"><span class="hs-comment">-- $lazylist</span></span><span>
</span><span id="line-72"></span><span>
</span><span id="line-73"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** Short-circuit folds</span></span><span>
</span><span id="line-74"></span><span>    </span><span class="annot"><span class="hs-comment">-- $shortcircuit</span></span><span>
</span><span id="line-75"></span><span>
</span><span id="line-76"></span><span>    </span><span class="annot"><span class="hs-comment">-- **** List of short-circuit functions</span></span><span>
</span><span id="line-77"></span><span>    </span><span class="annot"><span class="hs-comment">-- $shortlist</span></span><span>
</span><span id="line-78"></span><span>
</span><span id="line-79"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** Hybrid folds</span></span><span>
</span><span id="line-80"></span><span>    </span><span class="annot"><span class="hs-comment">-- $hybrid</span></span><span>
</span><span id="line-81"></span><span>
</span><span id="line-82"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Generative Recursion</span></span><span>
</span><span id="line-83"></span><span>    </span><span class="annot"><span class="hs-comment">-- $generative</span></span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Avoiding multi-pass folds</span></span><span>
</span><span id="line-86"></span><span>    </span><span class="annot"><span class="hs-comment">-- $multipass</span></span><span>
</span><span id="line-87"></span><span>
</span><span id="line-88"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Defining instances</span></span><span>
</span><span id="line-89"></span><span>    </span><span class="annot"><span class="hs-comment">-- $instances</span></span><span>
</span><span id="line-90"></span><span>
</span><span id="line-91"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** Being strict by being lazy</span></span><span>
</span><span id="line-92"></span><span>    </span><span class="annot"><span class="hs-comment">-- $strictlazy</span></span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Laws</span></span><span>
</span><span id="line-95"></span><span>    </span><span class="annot"><span class="hs-comment">-- $laws</span></span><span>
</span><span id="line-96"></span><span>
</span><span id="line-97"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Notes</span></span><span>
</span><span id="line-98"></span><span>    </span><span class="annot"><span class="hs-comment">-- $notes</span></span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Generally linear-time `elem`</span></span><span>
</span><span id="line-101"></span><span>    </span><span class="annot"><span class="hs-comment">-- $linear</span></span><span>
</span><span id="line-102"></span><span>
</span><span id="line-103"></span><span>    </span><span class="annot"><span class="hs-comment">-- * See also</span></span><span>
</span><span id="line-104"></span><span>    </span><span class="annot"><span class="hs-comment">-- $also</span></span><span>
</span><span id="line-105"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-106"></span><span>
</span><span id="line-107"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Bool.html"><span class="hs-identifier">Data.Bool</span></a></span><span>
</span><span id="line-108"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Either.html"><span class="hs-identifier">Data.Either</span></a></span><span>
</span><span id="line-109"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Eq.html"><span class="hs-identifier">Data.Eq</span></a></span><span>
</span><span id="line-110"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Functor.Utils.html"><span class="hs-identifier">Data.Functor.Utils</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Functor.Utils.html#Max"><span class="hs-identifier">Max</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Utils.html#Min"><span class="hs-identifier">Min</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Utils.html#%23."><span class="hs-operator">(#.)</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-111"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="GHC.List.html"><span class="hs-identifier">GHC.List</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">List</span></span><span>
</span><span id="line-112"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Maybe.html"><span class="hs-identifier">Data.Maybe</span></a></span><span>
</span><span id="line-113"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Monoid.html"><span class="hs-identifier">Data.Monoid</span></a></span><span>
</span><span id="line-114"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Ord.html"><span class="hs-identifier">Data.Ord</span></a></span><span>
</span><span id="line-115"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Proxy.html"><span class="hs-identifier">Data.Proxy</span></a></span><span>
</span><span id="line-116"></span><span>
</span><span id="line-117"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Arr.html"><span class="hs-identifier">GHC.Arr</span></a></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Arr.html#Array"><span class="hs-identifier">Array</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Arr.html#elems"><span class="hs-identifier">elems</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Arr.html#numElements"><span class="hs-identifier">numElements</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-118"></span><span>                  </span><span class="annot"><a href="GHC.Arr.html#foldlElems"><span class="hs-identifier">foldlElems</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Arr.html#foldrElems"><span class="hs-identifier">foldrElems</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-119"></span><span>                  </span><span class="annot"><a href="GHC.Arr.html#foldlElems%27"><span class="hs-identifier">foldlElems'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Arr.html#foldrElems%27"><span class="hs-identifier">foldrElems'</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-120"></span><span>                  </span><span class="annot"><a href="GHC.Arr.html#foldl1Elems"><span class="hs-identifier">foldl1Elems</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Arr.html#foldr1Elems"><span class="hs-identifier">foldr1Elems</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-121"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Base.html"><span class="hs-identifier">GHC.Base</span></a></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Base.html#foldr"><span class="hs-identifier">foldr</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-122"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Generics.html"><span class="hs-identifier">GHC.Generics</span></a></span><span>
</span><span id="line-123"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Tuple.html#"><span class="hs-identifier">GHC.Tuple</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Tuple.html#Solo"><span class="hs-identifier">Solo</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-124"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Num.html"><span class="hs-identifier">GHC.Num</span></a></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Num.html#Num"><span class="hs-identifier">Num</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-125"></span><span>
</span><span id="line-126"></span><span class="hs-comment">-- $setup</span><span>
</span><span id="line-127"></span><span class="hs-comment">-- &gt;&gt;&gt; :set -XDeriveFoldable</span><span>
</span><span id="line-128"></span><span class="hs-comment">-- &gt;&gt;&gt; import Prelude</span><span>
</span><span id="line-129"></span><span class="hs-comment">-- &gt;&gt;&gt; import Data.Monoid (Product (..), Sum (..))</span><span>
</span><span id="line-130"></span><span class="hs-comment">-- &gt;&gt;&gt; data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a) deriving (Show, Foldable)</span><span>
</span><span id="line-131"></span><span>
</span><span id="line-132"></span><span class="hs-keyword">infix</span><span>  </span><span class="hs-number">4</span><span> </span><span class="annot"><a href="Data.Foldable.html#elem"><span class="hs-operator hs-type">`elem`</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Foldable.html#notElem"><span class="hs-operator hs-type">`notElem`</span></a></span><span>
</span><span id="line-133"></span><span>
</span><span id="line-134"></span><span class="hs-comment">-- XXX: Missing haddock feature.  Links to anchors in other modules</span><span>
</span><span id="line-135"></span><span class="hs-comment">-- don't have a sensible way to name the link within the module itself.</span><span>
</span><span id="line-136"></span><span class="hs-comment">-- Thus, the below &quot;Data.Foldable#overview&quot; works well when shown as</span><span>
</span><span id="line-137"></span><span class="hs-comment">-- @Data.Foldable@ from other modules, but in the home module it should</span><span>
</span><span id="line-138"></span><span class="hs-comment">-- be possible to specify alternative link text. :-(</span><span>
</span><span id="line-139"></span><span>
</span><span id="line-140"></span><span class="hs-comment">-- | The Foldable class represents data structures that can be reduced to a</span><span>
</span><span id="line-141"></span><span class="hs-comment">-- summary value one element at a time.  Strict left-associative folds are a</span><span>
</span><span id="line-142"></span><span class="hs-comment">-- good fit for space-efficient reduction, while lazy right-associative folds</span><span>
</span><span id="line-143"></span><span class="hs-comment">-- are a good fit for corecursive iteration, or for folds that short-circuit</span><span>
</span><span id="line-144"></span><span class="hs-comment">-- after processing an initial subsequence of the structure's elements.</span><span>
</span><span id="line-145"></span><span class="hs-comment">--</span><span>
</span><span id="line-146"></span><span class="hs-comment">-- Instances can be derived automatically by enabling the @DeriveFoldable@</span><span>
</span><span id="line-147"></span><span class="hs-comment">-- extension.  For example, a derived instance for a binary tree might be:</span><span>
</span><span id="line-148"></span><span class="hs-comment">--</span><span>
</span><span id="line-149"></span><span class="hs-comment">-- &gt; {-# LANGUAGE DeriveFoldable #-}</span><span>
</span><span id="line-150"></span><span class="hs-comment">-- &gt; data Tree a = Empty</span><span>
</span><span id="line-151"></span><span class="hs-comment">-- &gt;             | Leaf a</span><span>
</span><span id="line-152"></span><span class="hs-comment">-- &gt;             | Node (Tree a) a (Tree a)</span><span>
</span><span id="line-153"></span><span class="hs-comment">-- &gt;     deriving Foldable</span><span>
</span><span id="line-154"></span><span class="hs-comment">--</span><span>
</span><span id="line-155"></span><span class="hs-comment">-- A more detailed description can be found in the __Overview__ section of</span><span>
</span><span id="line-156"></span><span class="hs-comment">-- &quot;Data.Foldable#overview&quot;.</span><span>
</span><span id="line-157"></span><span class="hs-comment">--</span><span>
</span><span id="line-158"></span><span class="hs-comment">-- For the class laws see the __Laws__ section of &quot;Data.Foldable#laws&quot;.</span><span>
</span><span id="line-159"></span><span class="hs-comment">--</span><span>
</span><span id="line-160"></span><span class="hs-keyword">class</span><span> </span><span id="Foldable"><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-var">Foldable</span></a></span></span><span> </span><span id="local-6989586621679577723"><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-161"></span><span>    </span><span class="hs-pragma">{-# MINIMAL</span><span> </span><span class="annot"><a href="Data.Foldable.html#foldMap"><span class="hs-pragma hs-type">foldMap</span></a></span><span> </span><span class="hs-pragma">|</span><span> </span><span class="annot"><a href="Data.Foldable.html#foldr"><span class="hs-pragma hs-type">foldr</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-162"></span><span>
</span><span id="line-163"></span><span>    </span><span class="hs-comment">-- | Given a structure with elements whose type is a 'Monoid', combine them</span><span>
</span><span id="line-164"></span><span>    </span><span class="hs-comment">-- via the monoid's @('&lt;&gt;')@ operator.  This fold is right-associative and</span><span>
</span><span id="line-165"></span><span>    </span><span class="hs-comment">-- lazy in the accumulator.  When you need a strict left-associative fold,</span><span>
</span><span id="line-166"></span><span>    </span><span class="hs-comment">-- use 'foldMap'' instead, with 'id' as the map.</span><span>
</span><span id="line-167"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-168"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-169"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-170"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-171"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-172"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; fold [[1, 2, 3], [4, 5], [6], []]</span><span>
</span><span id="line-173"></span><span>    </span><span class="hs-comment">-- [1,2,3,4,5,6]</span><span>
</span><span id="line-174"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-175"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; fold $ Node (Leaf (Sum 1)) (Sum 3) (Leaf (Sum 5))</span><span>
</span><span id="line-176"></span><span>    </span><span class="hs-comment">-- Sum {getSum = 9}</span><span>
</span><span id="line-177"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-178"></span><span>    </span><span class="hs-comment">-- Folds of unbounded structures do not terminate when the monoid's</span><span>
</span><span id="line-179"></span><span>    </span><span class="hs-comment">-- @('&lt;&gt;')@ operator is strict:</span><span>
</span><span id="line-180"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-181"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; fold (repeat Nothing)</span><span>
</span><span id="line-182"></span><span>    </span><span class="hs-comment">-- * Hangs forever *</span><span>
</span><span id="line-183"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-184"></span><span>    </span><span class="hs-comment">-- Lazy corecursive folds of unbounded structures are fine:</span><span>
</span><span id="line-185"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-186"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; take 12 $ fold $ map (\i -&gt; [i..i+2]) [0..]</span><span>
</span><span id="line-187"></span><span>    </span><span class="hs-comment">-- [0,1,2,1,2,3,2,3,4,3,4,5]</span><span>
</span><span id="line-188"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; sum $ take 4000000 $ fold $ map (\i -&gt; [i..i+2]) [0..]</span><span>
</span><span id="line-189"></span><span>    </span><span class="hs-comment">-- 2666668666666</span><span>
</span><span id="line-190"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-191"></span><span>    </span><span id="fold"><span class="annot"><a href="Data.Foldable.html#fold"><span class="hs-identifier hs-type">fold</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679577724"><span class="annot"><a href="GHC.Base.html#Monoid"><span class="hs-identifier hs-type">Monoid</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577724"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577724"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577724"><span class="hs-identifier hs-type">m</span></a></span></span><span>
</span><span id="line-192"></span><span>    </span><span id="local-6989586621679576498"><span class="annot"><a href="Data.Foldable.html#fold"><span class="hs-identifier hs-var hs-var">fold</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var">foldMap</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; a
</span><a href="GHC.Base.html#id"><span class="hs-identifier hs-var">id</span></a></span></span><span>
</span><span id="line-193"></span><span>
</span><span id="line-194"></span><span>    </span><span class="hs-comment">-- | Map each element of the structure into a monoid, and combine the</span><span>
</span><span id="line-195"></span><span>    </span><span class="hs-comment">-- results with @('&lt;&gt;')@.  This fold is right-associative and lazy in the</span><span>
</span><span id="line-196"></span><span>    </span><span class="hs-comment">-- accumulator.  For strict left-associative folds consider 'foldMap''</span><span>
</span><span id="line-197"></span><span>    </span><span class="hs-comment">-- instead.</span><span>
</span><span id="line-198"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-199"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-200"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-201"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-202"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-203"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldMap Sum [1, 3, 5]</span><span>
</span><span id="line-204"></span><span>    </span><span class="hs-comment">-- Sum {getSum = 9}</span><span>
</span><span id="line-205"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-206"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldMap Product [1, 3, 5]</span><span>
</span><span id="line-207"></span><span>    </span><span class="hs-comment">-- Product {getProduct = 15}</span><span>
</span><span id="line-208"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-209"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldMap (replicate 3) [1, 2, 3]</span><span>
</span><span id="line-210"></span><span>    </span><span class="hs-comment">-- [1,1,1,2,2,2,3,3,3]</span><span>
</span><span id="line-211"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-212"></span><span>    </span><span class="hs-comment">-- When a Monoid's @('&lt;&gt;')@ is lazy in its second argument, 'foldMap' can</span><span>
</span><span id="line-213"></span><span>    </span><span class="hs-comment">-- return a result even from an unbounded structure.  For example, lazy</span><span>
</span><span id="line-214"></span><span>    </span><span class="hs-comment">-- accumulation enables &quot;Data.ByteString.Builder&quot; to efficiently serialise</span><span>
</span><span id="line-215"></span><span>    </span><span class="hs-comment">-- large data structures and produce the output incrementally:</span><span>
</span><span id="line-216"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-217"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; import qualified Data.ByteString.Lazy as L</span><span>
</span><span id="line-218"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; import qualified Data.ByteString.Builder as B</span><span>
</span><span id="line-219"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; let bld :: Int -&gt; B.Builder; bld i = B.intDec i &lt;&gt; B.word8 0x20</span><span>
</span><span id="line-220"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; let lbs = B.toLazyByteString $ foldMap bld [0..]</span><span>
</span><span id="line-221"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; L.take 64 lbs</span><span>
</span><span id="line-222"></span><span>    </span><span class="hs-comment">-- &quot;0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24&quot;</span><span>
</span><span id="line-223"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-224"></span><span>    </span><span id="foldMap"><span class="annot"><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-type">foldMap</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679577720"><span id="local-6989586621679577721"><span class="annot"><a href="GHC.Base.html#Monoid"><span class="hs-identifier hs-type">Monoid</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577721"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577720"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577721"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577720"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577721"><span class="hs-identifier hs-type">m</span></a></span></span></span><span>
</span><span id="line-225"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#foldMap"><span class="hs-pragma hs-type">foldMap</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-226"></span><span>    </span><span class="hs-comment">-- This INLINE allows more list functions to fuse.  See #9848.</span><span>
</span><span id="line-227"></span><span>    </span><span id="local-6989586621679576493"><span class="annot"><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var hs-var">foldMap</span></a></span><span> </span><span id="local-6989586621679576488"><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679576488"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Monoid a =&gt; a -&gt; a -&gt; a
</span><a href="GHC.Base.html#mappend"><span class="hs-identifier hs-var">mappend</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679576488"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a. Monoid a =&gt; a
</span><a href="GHC.Base.html#mempty"><span class="hs-identifier hs-var">mempty</span></a></span></span><span>
</span><span id="line-228"></span><span>
</span><span id="line-229"></span><span>    </span><span class="hs-comment">-- | A left-associative variant of 'foldMap' that is strict in the</span><span>
</span><span id="line-230"></span><span>    </span><span class="hs-comment">-- accumulator.  Use this method for strict reduction when partial</span><span>
</span><span id="line-231"></span><span>    </span><span class="hs-comment">-- results are merged via @('&lt;&gt;')@.</span><span>
</span><span id="line-232"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-233"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-234"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-235"></span><span>    </span><span class="hs-comment">-- Define a 'Monoid' over finite bit strings under 'xor'.  Use it to</span><span>
</span><span id="line-236"></span><span>    </span><span class="hs-comment">-- strictly compute the `xor` of a list of 'Int' values.</span><span>
</span><span id="line-237"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-238"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; :set -XGeneralizedNewtypeDeriving</span><span>
</span><span id="line-239"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; import Data.Bits (Bits, FiniteBits, xor, zeroBits)</span><span>
</span><span id="line-240"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; import Data.Foldable (foldMap')</span><span>
</span><span id="line-241"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; import Numeric (showHex)</span><span>
</span><span id="line-242"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt;</span><span>
</span><span id="line-243"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; newtype X a = X a deriving (Eq, Bounded, Enum, Bits, FiniteBits)</span><span>
</span><span id="line-244"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; instance Bits a =&gt; Semigroup (X a) where X a &lt;&gt; X b = X (a `xor` b)</span><span>
</span><span id="line-245"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; instance Bits a =&gt; Monoid    (X a) where mempty     = X zeroBits</span><span>
</span><span id="line-246"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt;</span><span>
</span><span id="line-247"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; let bits :: [Int]; bits = [0xcafe, 0xfeed, 0xdeaf, 0xbeef, 0x5411]</span><span>
</span><span id="line-248"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; (\ (X a) -&gt; showString &quot;0x&quot; . showHex a $ &quot;&quot;) $ foldMap' X bits</span><span>
</span><span id="line-249"></span><span>    </span><span class="hs-comment">-- &quot;0x42&quot;</span><span>
</span><span id="line-250"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-251"></span><span>    </span><span class="hs-comment">-- @since 4.13.0.0</span><span>
</span><span id="line-252"></span><span>    </span><span id="foldMap%27"><span class="annot"><a href="Data.Foldable.html#foldMap%27"><span class="hs-identifier hs-type">foldMap'</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679577633"><span id="local-6989586621679577634"><span class="annot"><a href="GHC.Base.html#Monoid"><span class="hs-identifier hs-type">Monoid</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577634"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577633"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577634"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577633"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577634"><span class="hs-identifier hs-type">m</span></a></span></span></span><span>
</span><span id="line-253"></span><span>    </span><span id="local-6989586621679576485"><span class="annot"><a href="Data.Foldable.html#foldMap%27"><span class="hs-identifier hs-var hs-var">foldMap'</span></a></span><span> </span><span id="local-6989586621679576478"><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679576478"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldl%27"><span class="hs-identifier hs-var">foldl'</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679576476"><span class="annot"><span class="annottext">m
</span><a href="#local-6989586621679576476"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span id="local-6989586621679576475"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576475"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m
</span><a href="#local-6989586621679576476"><span class="hs-identifier hs-var">acc</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><a href="GHC.Base.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679576478"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576475"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a. Monoid a =&gt; a
</span><a href="GHC.Base.html#mempty"><span class="hs-identifier hs-var">mempty</span></a></span></span><span>
</span><span id="line-254"></span><span>
</span><span id="line-255"></span><span>    </span><span class="hs-comment">-- | Right-associative fold of a structure, lazy in the accumulator.</span><span>
</span><span id="line-256"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-257"></span><span>    </span><span class="hs-comment">-- In the case of lists, 'foldr', when applied to a binary operator, a</span><span>
</span><span id="line-258"></span><span>    </span><span class="hs-comment">-- starting value (typically the right-identity of the operator), and a</span><span>
</span><span id="line-259"></span><span>    </span><span class="hs-comment">-- list, reduces the list using the binary operator, from right to left:</span><span>
</span><span id="line-260"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-261"></span><span>    </span><span class="hs-comment">-- &gt; foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)</span><span>
</span><span id="line-262"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-263"></span><span>    </span><span class="hs-comment">-- Note that since the head of the resulting expression is produced by an</span><span>
</span><span id="line-264"></span><span>    </span><span class="hs-comment">-- application of the operator to the first element of the list, given an</span><span>
</span><span id="line-265"></span><span>    </span><span class="hs-comment">-- operator lazy in its right argument, 'foldr' can produce a terminating</span><span>
</span><span id="line-266"></span><span>    </span><span class="hs-comment">-- expression from an unbounded list.</span><span>
</span><span id="line-267"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-268"></span><span>    </span><span class="hs-comment">-- For a general 'Foldable' structure this should be semantically identical</span><span>
</span><span id="line-269"></span><span>    </span><span class="hs-comment">-- to,</span><span>
</span><span id="line-270"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-271"></span><span>    </span><span class="hs-comment">-- @foldr f z = 'List.foldr' f z . 'toList'@</span><span>
</span><span id="line-272"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-273"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-274"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-275"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-276"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-277"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldr (||) False [False, True, False]</span><span>
</span><span id="line-278"></span><span>    </span><span class="hs-comment">-- True</span><span>
</span><span id="line-279"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-280"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldr (||) False []</span><span>
</span><span id="line-281"></span><span>    </span><span class="hs-comment">-- False</span><span>
</span><span id="line-282"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-283"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) &quot;foo&quot; ['a', 'b', 'c', 'd']</span><span>
</span><span id="line-284"></span><span>    </span><span class="hs-comment">-- &quot;foodcba&quot;</span><span>
</span><span id="line-285"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-286"></span><span>    </span><span class="hs-comment">-- ===== Infinite structures</span><span>
</span><span id="line-287"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-288"></span><span>    </span><span class="hs-comment">-- &#9888;&#65039; Applying 'foldr' to infinite structures usually doesn't terminate.</span><span>
</span><span id="line-289"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-290"></span><span>    </span><span class="hs-comment">-- It may still terminate under one of the following conditions:</span><span>
</span><span id="line-291"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-292"></span><span>    </span><span class="hs-comment">-- * the folding function is short-circuiting</span><span>
</span><span id="line-293"></span><span>    </span><span class="hs-comment">-- * the folding function is lazy on its second argument</span><span>
</span><span id="line-294"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-295"></span><span>    </span><span class="hs-comment">-- ====== Short-circuiting</span><span>
</span><span id="line-296"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-297"></span><span>    </span><span class="hs-comment">-- @('||')@ short-circuits on 'True' values, so the following terminates</span><span>
</span><span id="line-298"></span><span>    </span><span class="hs-comment">-- because there is a 'True' value finitely far from the left side:</span><span>
</span><span id="line-299"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-300"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldr (||) False (True : repeat False)</span><span>
</span><span id="line-301"></span><span>    </span><span class="hs-comment">-- True</span><span>
</span><span id="line-302"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-303"></span><span>    </span><span class="hs-comment">-- But the following doesn't terminate:</span><span>
</span><span id="line-304"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-305"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])</span><span>
</span><span id="line-306"></span><span>    </span><span class="hs-comment">-- * Hangs forever *</span><span>
</span><span id="line-307"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-308"></span><span>    </span><span class="hs-comment">-- ====== Laziness in the second argument</span><span>
</span><span id="line-309"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-310"></span><span>    </span><span class="hs-comment">-- Applying 'foldr' to infinite structures terminates when the operator is</span><span>
</span><span id="line-311"></span><span>    </span><span class="hs-comment">-- lazy in its second argument (the initial accumulator is never used in</span><span>
</span><span id="line-312"></span><span>    </span><span class="hs-comment">-- this case, and so could be left 'undefined', but @[]@ is more clear):</span><span>
</span><span id="line-313"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-314"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)</span><span>
</span><span id="line-315"></span><span>    </span><span class="hs-comment">-- [1,4,7,10,13]</span><span>
</span><span id="line-316"></span><span>    </span><span id="foldr"><span class="annot"><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-type">foldr</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679577715"><span id="local-6989586621679577716"><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577716"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577715"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577715"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577715"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577716"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577715"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-317"></span><span>    </span><span id="local-6989586621679576474"><span class="annot"><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var hs-var">foldr</span></a></span><span> </span><span id="local-6989586621679576469"><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576469"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679576468"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576468"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span id="local-6989586621679576467"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679576467"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Endo a -&gt; a -&gt; a
</span><a href="Data.Semigroup.Internal.html#appEndo"><span class="hs-identifier hs-var">appEndo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var">foldMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. (a -&gt; a) -&gt; Endo a
</span><a href="Data.Semigroup.Internal.html#Endo"><span class="hs-identifier hs-var">Endo</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576469"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679576467"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576468"><span class="hs-identifier hs-var">z</span></a></span></span><span>
</span><span id="line-318"></span><span>
</span><span id="line-319"></span><span>    </span><span class="hs-comment">-- | Right-associative fold of a structure, strict in the accumulator.</span><span>
</span><span id="line-320"></span><span>    </span><span class="hs-comment">-- This is rarely what you want.</span><span>
</span><span id="line-321"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-322"></span><span>    </span><span class="hs-comment">-- @since 4.6.0.0</span><span>
</span><span id="line-323"></span><span>    </span><span id="foldr%27"><span class="annot"><a href="Data.Foldable.html#foldr%27"><span class="hs-identifier hs-type">foldr'</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679577631"><span id="local-6989586621679577632"><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577632"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577631"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577631"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577631"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577632"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577631"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-324"></span><span>    </span><span id="local-6989586621679576463"><span class="annot"><a href="Data.Foldable.html#foldr%27"><span class="hs-identifier hs-var hs-var">foldr'</span></a></span><span> </span><span id="local-6989586621679576461"><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576461"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679576460"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576460"><span class="hs-identifier hs-var">z0</span></a></span></span><span> </span><span id="local-6989586621679576459"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679576459"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldl"><span class="hs-identifier hs-var">foldl</span></a></span><span> </span><span class="annot"><span class="annottext">forall {b}. (b -&gt; b) -&gt; a -&gt; b -&gt; b
</span><a href="#local-6989586621679576457"><span class="hs-identifier hs-var">f'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; a
</span><a href="GHC.Base.html#id"><span class="hs-identifier hs-var">id</span></a></span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679576459"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576460"><span class="hs-identifier hs-var">z0</span></a></span><span>
</span><span id="line-325"></span><span>      </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679576457"><span class="annot"><span class="annottext">f' :: (b -&gt; b) -&gt; a -&gt; b -&gt; b
</span><a href="#local-6989586621679576457"><span class="hs-identifier hs-var hs-var">f'</span></a></span></span><span> </span><span id="local-6989586621679576456"><span class="annot"><span class="annottext">b -&gt; b
</span><a href="#local-6989586621679576456"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679576455"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576455"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679576454"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576454"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b -&gt; b
</span><a href="#local-6989586621679576456"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576461"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576455"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576454"><span class="hs-identifier hs-var">z</span></a></span></span><span>
</span><span id="line-326"></span><span>
</span><span id="line-327"></span><span>    </span><span class="hs-comment">-- | Left-associative fold of a structure, lazy in the accumulator.  This</span><span>
</span><span id="line-328"></span><span>    </span><span class="hs-comment">-- is rarely what you want, but can work well for structures with efficient</span><span>
</span><span id="line-329"></span><span>    </span><span class="hs-comment">-- right-to-left sequencing and an operator that is lazy in its left</span><span>
</span><span id="line-330"></span><span>    </span><span class="hs-comment">-- argument.</span><span>
</span><span id="line-331"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-332"></span><span>    </span><span class="hs-comment">-- In the case of lists, 'foldl', when applied to a binary operator, a</span><span>
</span><span id="line-333"></span><span>    </span><span class="hs-comment">-- starting value (typically the left-identity of the operator), and a</span><span>
</span><span id="line-334"></span><span>    </span><span class="hs-comment">-- list, reduces the list using the binary operator, from left to right:</span><span>
</span><span id="line-335"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-336"></span><span>    </span><span class="hs-comment">-- &gt; foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn</span><span>
</span><span id="line-337"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-338"></span><span>    </span><span class="hs-comment">-- Note that to produce the outermost application of the operator the</span><span>
</span><span id="line-339"></span><span>    </span><span class="hs-comment">-- entire input list must be traversed.  Like all left-associative folds,</span><span>
</span><span id="line-340"></span><span>    </span><span class="hs-comment">-- 'foldl' will diverge if given an infinite list.</span><span>
</span><span id="line-341"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-342"></span><span>    </span><span class="hs-comment">-- If you want an efficient strict left-fold, you probably want to use</span><span>
</span><span id="line-343"></span><span>    </span><span class="hs-comment">-- 'foldl'' instead of 'foldl'.  The reason for this is that the latter</span><span>
</span><span id="line-344"></span><span>    </span><span class="hs-comment">-- does not force the /inner/ results (e.g. @z \`f\` x1@ in the above</span><span>
</span><span id="line-345"></span><span>    </span><span class="hs-comment">-- example) before applying them to the operator (e.g. to @(\`f\` x2)@).</span><span>
</span><span id="line-346"></span><span>    </span><span class="hs-comment">-- This results in a thunk chain \(\mathcal{O}(n)\) elements long, which</span><span>
</span><span id="line-347"></span><span>    </span><span class="hs-comment">-- then must be evaluated from the outside-in.</span><span>
</span><span id="line-348"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-349"></span><span>    </span><span class="hs-comment">-- For a general 'Foldable' structure this should be semantically identical</span><span>
</span><span id="line-350"></span><span>    </span><span class="hs-comment">-- to:</span><span>
</span><span id="line-351"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-352"></span><span>    </span><span class="hs-comment">-- @foldl f z = 'List.foldl' f z . 'toList'@</span><span>
</span><span id="line-353"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-354"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-355"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-356"></span><span>    </span><span class="hs-comment">-- The first example is a strict fold, which in practice is best performed</span><span>
</span><span id="line-357"></span><span>    </span><span class="hs-comment">-- with 'foldl''.</span><span>
</span><span id="line-358"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-359"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]</span><span>
</span><span id="line-360"></span><span>    </span><span class="hs-comment">-- 52</span><span>
</span><span id="line-361"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-362"></span><span>    </span><span class="hs-comment">-- Though the result below is lazy, the input is reversed before prepending</span><span>
</span><span id="line-363"></span><span>    </span><span class="hs-comment">-- it to the initial accumulator, so corecursion begins only after traversing</span><span>
</span><span id="line-364"></span><span>    </span><span class="hs-comment">-- the entire input string.</span><span>
</span><span id="line-365"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-366"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) &quot;abcd&quot; &quot;efgh&quot;</span><span>
</span><span id="line-367"></span><span>    </span><span class="hs-comment">-- &quot;hgfeabcd&quot;</span><span>
</span><span id="line-368"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-369"></span><span>    </span><span class="hs-comment">-- A left fold of a structure that is infinite on the right cannot</span><span>
</span><span id="line-370"></span><span>    </span><span class="hs-comment">-- terminate, even when for any finite input the fold just returns the</span><span>
</span><span id="line-371"></span><span>    </span><span class="hs-comment">-- initial accumulator:</span><span>
</span><span id="line-372"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-373"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1</span><span>
</span><span id="line-374"></span><span>    </span><span class="hs-comment">-- * Hangs forever *</span><span>
</span><span id="line-375"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-376"></span><span>    </span><span class="hs-comment">-- WARNING: When it comes to lists, you always want to use either 'foldl'' or 'foldr' instead.</span><span>
</span><span id="line-377"></span><span>    </span><span id="foldl"><span class="annot"><a href="Data.Foldable.html#foldl"><span class="hs-identifier hs-type">foldl</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679576451"><span id="local-6989586621679576452"><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679576452"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679576451"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679576452"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679576452"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679576451"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679576452"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-378"></span><span>    </span><span id="local-6989586621679576450"><span class="annot"><a href="Data.Foldable.html#foldl"><span class="hs-identifier hs-var hs-var">foldl</span></a></span><span> </span><span id="local-6989586621679576445"><span class="annot"><span class="annottext">b -&gt; a -&gt; b
</span><a href="#local-6989586621679576445"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679576444"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576444"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span id="local-6989586621679576443"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679576443"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Endo a -&gt; a -&gt; a
</span><a href="Data.Semigroup.Internal.html#appEndo"><span class="hs-identifier hs-var">appEndo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Dual a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getDual"><span class="hs-identifier hs-var">getDual</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var">foldMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Dual a
</span><a href="Data.Semigroup.Internal.html#Dual"><span class="hs-identifier hs-var">Dual</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; a) -&gt; Endo a
</span><a href="Data.Semigroup.Internal.html#Endo"><span class="hs-identifier hs-var">Endo</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><a href="GHC.Base.html#flip"><span class="hs-identifier hs-var">flip</span></a></span><span> </span><span class="annot"><span class="annottext">b -&gt; a -&gt; b
</span><a href="#local-6989586621679576445"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679576443"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576444"><span class="hs-identifier hs-var">z</span></a></span></span><span>
</span><span id="line-379"></span><span>    </span><span class="hs-comment">-- There's no point mucking around with coercions here,</span><span>
</span><span id="line-380"></span><span>    </span><span class="hs-comment">-- because flip forces us to build a new function anyway.</span><span>
</span><span id="line-381"></span><span>
</span><span id="line-382"></span><span>    </span><span class="hs-comment">-- | Left-associative fold of a structure but with strict application of</span><span>
</span><span id="line-383"></span><span>    </span><span class="hs-comment">-- the operator.</span><span>
</span><span id="line-384"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-385"></span><span>    </span><span class="hs-comment">-- This ensures that each step of the fold is forced to Weak Head Normal</span><span>
</span><span id="line-386"></span><span>    </span><span class="hs-comment">-- Form before being applied, avoiding the collection of thunks that would</span><span>
</span><span id="line-387"></span><span>    </span><span class="hs-comment">-- otherwise occur.  This is often what you want to strictly reduce a</span><span>
</span><span id="line-388"></span><span>    </span><span class="hs-comment">-- finite structure to a single strict result (e.g. 'sum').</span><span>
</span><span id="line-389"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-390"></span><span>    </span><span class="hs-comment">-- For a general 'Foldable' structure this should be semantically identical</span><span>
</span><span id="line-391"></span><span>    </span><span class="hs-comment">-- to,</span><span>
</span><span id="line-392"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-393"></span><span>    </span><span class="hs-comment">-- @foldl' f z = 'List.foldl'' f z . 'toList'@</span><span>
</span><span id="line-394"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-395"></span><span>    </span><span class="hs-comment">-- @since 4.6.0.0</span><span>
</span><span id="line-396"></span><span>    </span><span id="foldl%27"><span class="annot"><a href="Data.Foldable.html#foldl%27"><span class="hs-identifier hs-type">foldl'</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679577707"><span id="local-6989586621679577708"><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577708"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577707"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577708"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577708"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577707"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577708"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-397"></span><span>    </span><span id="local-6989586621679576439"><span class="annot"><a href="Data.Foldable.html#foldl%27"><span class="hs-identifier hs-var hs-var">foldl'</span></a></span><span> </span><span id="local-6989586621679576437"><span class="annot"><span class="annottext">b -&gt; a -&gt; b
</span><a href="#local-6989586621679576437"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679576436"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576436"><span class="hs-identifier hs-var">z0</span></a></span></span><span> </span><span id="local-6989586621679576435"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679576435"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="annot"><span class="annottext">forall {b}. a -&gt; (b -&gt; b) -&gt; b -&gt; b
</span><a href="#local-6989586621679576434"><span class="hs-identifier hs-var">f'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; a
</span><a href="GHC.Base.html#id"><span class="hs-identifier hs-var">id</span></a></span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679576435"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576436"><span class="hs-identifier hs-var">z0</span></a></span><span>
</span><span id="line-398"></span><span>      </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679576434"><span class="annot"><span class="annottext">f' :: a -&gt; (b -&gt; b) -&gt; b -&gt; b
</span><a href="#local-6989586621679576434"><span class="hs-identifier hs-var hs-var">f'</span></a></span></span><span> </span><span id="local-6989586621679576433"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576433"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679576432"><span class="annot"><span class="annottext">b -&gt; b
</span><a href="#local-6989586621679576432"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679576431"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576431"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b -&gt; b
</span><a href="#local-6989586621679576432"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">b -&gt; a -&gt; b
</span><a href="#local-6989586621679576437"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576431"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576433"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-399"></span><span>
</span><span id="line-400"></span><span>    </span><span class="hs-comment">-- | A variant of 'foldr' that has no base case,</span><span>
</span><span id="line-401"></span><span>    </span><span class="hs-comment">-- and thus may only be applied to non-empty structures.</span><span>
</span><span id="line-402"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-403"></span><span>    </span><span class="hs-comment">-- This function is non-total and will raise a runtime exception if the</span><span>
</span><span id="line-404"></span><span>    </span><span class="hs-comment">-- structure happens to be empty.</span><span>
</span><span id="line-405"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-406"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-407"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-408"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-409"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-410"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldr1 (+) [1..4]</span><span>
</span><span id="line-411"></span><span>    </span><span class="hs-comment">-- 10</span><span>
</span><span id="line-412"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-413"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldr1 (+) []</span><span>
</span><span id="line-414"></span><span>    </span><span class="hs-comment">-- Exception: Prelude.foldr1: empty list</span><span>
</span><span id="line-415"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-416"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldr1 (+) Nothing</span><span>
</span><span id="line-417"></span><span>    </span><span class="hs-comment">-- *** Exception: foldr1: empty structure</span><span>
</span><span id="line-418"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-419"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldr1 (-) [1..4]</span><span>
</span><span id="line-420"></span><span>    </span><span class="hs-comment">-- -2</span><span>
</span><span id="line-421"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-422"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]</span><span>
</span><span id="line-423"></span><span>    </span><span class="hs-comment">-- False</span><span>
</span><span id="line-424"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-425"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldr1 (||) [False, False, True, True]</span><span>
</span><span id="line-426"></span><span>    </span><span class="hs-comment">-- True</span><span>
</span><span id="line-427"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-428"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldr1 (+) [1..]</span><span>
</span><span id="line-429"></span><span>    </span><span class="hs-comment">-- * Hangs forever *</span><span>
</span><span id="line-430"></span><span>    </span><span id="foldr1"><span class="annot"><a href="Data.Foldable.html#foldr1"><span class="hs-identifier hs-type">foldr1</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679577679"><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577679"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577679"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577679"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577679"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577679"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-431"></span><span>    </span><span id="local-6989586621679576429"><span class="annot"><a href="Data.Foldable.html#foldr1"><span class="hs-identifier hs-var hs-var">foldr1</span></a></span><span> </span><span id="local-6989586621679576427"><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><a href="#local-6989586621679576427"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679576426"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679576426"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a -&gt; a
</span><a href="Data.Maybe.html#fromMaybe"><span class="hs-identifier hs-var">fromMaybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. [Char] -&gt; a
</span><a href="GHC.Err.html#errorWithoutStackTrace"><span class="hs-identifier hs-var">errorWithoutStackTrace</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;foldr1: empty structure&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-432"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe a -&gt; Maybe a
</span><a href="#local-6989586621679576423"><span class="hs-identifier hs-var">mf</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><a href="GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679576426"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-433"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-434"></span><span>        </span><span id="local-6989586621679576423"><span class="annot"><span class="annottext">mf :: a -&gt; Maybe a -&gt; Maybe a
</span><a href="#local-6989586621679576423"><span class="hs-identifier hs-var hs-var">mf</span></a></span></span><span> </span><span id="local-6989586621679576422"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576422"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679576421"><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679576421"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679576421"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-435"></span><span>                         </span><span class="annot"><span class="annottext">Maybe a
</span><a href="GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576422"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-436"></span><span>                         </span><span class="annot"><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679576420"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576420"><span class="hs-identifier hs-var">y</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><a href="#local-6989586621679576427"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576422"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576420"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-437"></span><span>
</span><span id="line-438"></span><span>    </span><span class="hs-comment">-- | A variant of 'foldl' that has no base case,</span><span>
</span><span id="line-439"></span><span>    </span><span class="hs-comment">-- and thus may only be applied to non-empty structures.</span><span>
</span><span id="line-440"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-441"></span><span>    </span><span class="hs-comment">-- This function is non-total and will raise a runtime exception if the</span><span>
</span><span id="line-442"></span><span>    </span><span class="hs-comment">-- structure happens to be empty.</span><span>
</span><span id="line-443"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-444"></span><span>    </span><span class="hs-comment">-- @'foldl1' f = 'List.foldl1' f . 'toList'@</span><span>
</span><span id="line-445"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-446"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-447"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-448"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-449"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-450"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldl1 (+) [1..4]</span><span>
</span><span id="line-451"></span><span>    </span><span class="hs-comment">-- 10</span><span>
</span><span id="line-452"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-453"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldl1 (+) []</span><span>
</span><span id="line-454"></span><span>    </span><span class="hs-comment">-- *** Exception: Prelude.foldl1: empty list</span><span>
</span><span id="line-455"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-456"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldl1 (+) Nothing</span><span>
</span><span id="line-457"></span><span>    </span><span class="hs-comment">-- *** Exception: foldl1: empty structure</span><span>
</span><span id="line-458"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-459"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldl1 (-) [1..4]</span><span>
</span><span id="line-460"></span><span>    </span><span class="hs-comment">-- -8</span><span>
</span><span id="line-461"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-462"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]</span><span>
</span><span id="line-463"></span><span>    </span><span class="hs-comment">-- False</span><span>
</span><span id="line-464"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-465"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldl1 (||) [False, False, True, True]</span><span>
</span><span id="line-466"></span><span>    </span><span class="hs-comment">-- True</span><span>
</span><span id="line-467"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-468"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; foldl1 (+) [1..]</span><span>
</span><span id="line-469"></span><span>    </span><span class="hs-comment">-- * Hangs forever *</span><span>
</span><span id="line-470"></span><span>    </span><span id="foldl1"><span class="annot"><a href="Data.Foldable.html#foldl1"><span class="hs-identifier hs-type">foldl1</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679577635"><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577635"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577635"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577635"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577635"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577635"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-471"></span><span>    </span><span id="local-6989586621679576418"><span class="annot"><a href="Data.Foldable.html#foldl1"><span class="hs-identifier hs-var hs-var">foldl1</span></a></span><span> </span><span id="local-6989586621679576416"><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><a href="#local-6989586621679576416"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679576415"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679576415"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a -&gt; a
</span><a href="Data.Maybe.html#fromMaybe"><span class="hs-identifier hs-var">fromMaybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. [Char] -&gt; a
</span><a href="GHC.Err.html#errorWithoutStackTrace"><span class="hs-identifier hs-var">errorWithoutStackTrace</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;foldl1: empty structure&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-472"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldl"><span class="hs-identifier hs-var">foldl</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe a -&gt; a -&gt; Maybe a
</span><a href="#local-6989586621679576414"><span class="hs-identifier hs-var">mf</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><a href="GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679576415"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-473"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-474"></span><span>        </span><span id="local-6989586621679576414"><span class="annot"><span class="annottext">mf :: Maybe a -&gt; a -&gt; Maybe a
</span><a href="#local-6989586621679576414"><span class="hs-identifier hs-var hs-var">mf</span></a></span></span><span> </span><span id="local-6989586621679576413"><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679576413"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679576412"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576412"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679576413"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-475"></span><span>                         </span><span class="annot"><span class="annottext">Maybe a
</span><a href="GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576412"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-476"></span><span>                         </span><span class="annot"><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679576411"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576411"><span class="hs-identifier hs-var">x</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><a href="#local-6989586621679576416"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576411"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576412"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-477"></span><span>
</span><span id="line-478"></span><span>    </span><span class="hs-comment">-- | List of elements of a structure, from left to right.  If the entire</span><span>
</span><span id="line-479"></span><span>    </span><span class="hs-comment">-- list is intended to be reduced via a fold, just fold the structure</span><span>
</span><span id="line-480"></span><span>    </span><span class="hs-comment">-- directly bypassing the list.</span><span>
</span><span id="line-481"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-482"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-483"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-484"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-485"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-486"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; toList Nothing</span><span>
</span><span id="line-487"></span><span>    </span><span class="hs-comment">-- []</span><span>
</span><span id="line-488"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-489"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; toList (Just 42)</span><span>
</span><span id="line-490"></span><span>    </span><span class="hs-comment">-- [42]</span><span>
</span><span id="line-491"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-492"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; toList (Left &quot;foo&quot;)</span><span>
</span><span id="line-493"></span><span>    </span><span class="hs-comment">-- []</span><span>
</span><span id="line-494"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-495"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; toList (Node (Leaf 5) 17 (Node Empty 12 (Leaf 8)))</span><span>
</span><span id="line-496"></span><span>    </span><span class="hs-comment">-- [5,17,12,8]</span><span>
</span><span id="line-497"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-498"></span><span>    </span><span class="hs-comment">-- For lists, 'toList' is the identity:</span><span>
</span><span id="line-499"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-500"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; toList [1, 2, 3]</span><span>
</span><span id="line-501"></span><span>    </span><span class="hs-comment">-- [1,2,3]</span><span>
</span><span id="line-502"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-503"></span><span>    </span><span class="hs-comment">-- @since 4.8.0.0</span><span>
</span><span id="line-504"></span><span>    </span><span id="toList"><span class="annot"><a href="Data.Foldable.html#toList"><span class="hs-identifier hs-type">toList</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679577672"><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577672"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679577672"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-505"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#toList"><span class="hs-pragma hs-type">toList</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-506"></span><span>    </span><span id="local-6989586621679576409"><span class="annot"><a href="Data.Foldable.html#toList"><span class="hs-identifier hs-var hs-var">toList</span></a></span><span> </span><span id="local-6989586621679576408"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679576408"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. (forall b. (a -&gt; b -&gt; b) -&gt; b -&gt; b) -&gt; [a]
</span><a href="GHC.Base.html#build"><span class="hs-identifier hs-var">build</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679576406"><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576406"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679576405"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576405"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576406"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576405"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679576408"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-507"></span><span>
</span><span id="line-508"></span><span>    </span><span class="hs-comment">-- | Test whether the structure is empty.  The default implementation is</span><span>
</span><span id="line-509"></span><span>    </span><span class="hs-comment">-- Left-associative and lazy in both the initial element and the</span><span>
</span><span id="line-510"></span><span>    </span><span class="hs-comment">-- accumulator.  Thus optimised for structures where the first element can</span><span>
</span><span id="line-511"></span><span>    </span><span class="hs-comment">-- be accessed in constant time.  Structures where this is not the case</span><span>
</span><span id="line-512"></span><span>    </span><span class="hs-comment">-- should have a non-default implementation.</span><span>
</span><span id="line-513"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-514"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-515"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-516"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-517"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-518"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; null []</span><span>
</span><span id="line-519"></span><span>    </span><span class="hs-comment">-- True</span><span>
</span><span id="line-520"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-521"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; null [1]</span><span>
</span><span id="line-522"></span><span>    </span><span class="hs-comment">-- False</span><span>
</span><span id="line-523"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-524"></span><span>    </span><span class="hs-comment">-- 'null' is expected to terminate even for infinite structures.</span><span>
</span><span id="line-525"></span><span>    </span><span class="hs-comment">-- The default implementation terminates provided the structure</span><span>
</span><span id="line-526"></span><span>    </span><span class="hs-comment">-- is bounded on the left (there is a leftmost element).</span><span>
</span><span id="line-527"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-528"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; null [1..]</span><span>
</span><span id="line-529"></span><span>    </span><span class="hs-comment">-- False</span><span>
</span><span id="line-530"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-531"></span><span>    </span><span class="hs-comment">-- @since 4.8.0.0</span><span>
</span><span id="line-532"></span><span>    </span><span id="null"><span class="annot"><a href="Data.Foldable.html#null"><span class="hs-identifier hs-type">null</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679577667"><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577667"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span></span><span>
</span><span id="line-533"></span><span>    </span><span id="local-6989586621679576403"><span class="annot"><a href="Data.Foldable.html#null"><span class="hs-identifier hs-var hs-var">null</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#True"><span class="hs-identifier hs-var">True</span></a></span></span><span>
</span><span id="line-534"></span><span>
</span><span id="line-535"></span><span>    </span><span class="hs-comment">-- | Returns the size/length of a finite structure as an 'Int'.  The</span><span>
</span><span id="line-536"></span><span>    </span><span class="hs-comment">-- default implementation just counts elements starting with the leftmost.</span><span>
</span><span id="line-537"></span><span>    </span><span class="hs-comment">-- Instances for structures that can compute the element count faster</span><span>
</span><span id="line-538"></span><span>    </span><span class="hs-comment">-- than via element-by-element counting, should provide a specialised</span><span>
</span><span id="line-539"></span><span>    </span><span class="hs-comment">-- implementation.</span><span>
</span><span id="line-540"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-541"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-542"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-543"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-544"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-545"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; length []</span><span>
</span><span id="line-546"></span><span>    </span><span class="hs-comment">-- 0</span><span>
</span><span id="line-547"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-548"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; length ['a', 'b', 'c']</span><span>
</span><span id="line-549"></span><span>    </span><span class="hs-comment">-- 3</span><span>
</span><span id="line-550"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; length [1..]</span><span>
</span><span id="line-551"></span><span>    </span><span class="hs-comment">-- * Hangs forever *</span><span>
</span><span id="line-552"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-553"></span><span>    </span><span class="hs-comment">-- @since 4.8.0.0</span><span>
</span><span id="line-554"></span><span>    </span><span id="length"><span class="annot"><a href="Data.Foldable.html#length"><span class="hs-identifier hs-type">length</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679577665"><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577665"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Int"><span class="hs-identifier hs-type">Int</span></a></span></span><span>
</span><span id="line-555"></span><span>    </span><span id="local-6989586621679576400"><span class="annot"><a href="Data.Foldable.html#length"><span class="hs-identifier hs-var hs-var">length</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldl%27"><span class="hs-identifier hs-var">foldl'</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679576394"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679576394"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679576394"><span class="hs-identifier hs-var">c</span></a></span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><a href="GHC.Num.html#%2B"><span class="hs-operator hs-var">+</span></a></span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span></span><span>
</span><span id="line-556"></span><span>
</span><span id="line-557"></span><span>    </span><span class="hs-comment">-- | Does the element occur in the structure?</span><span>
</span><span id="line-558"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-559"></span><span>    </span><span class="hs-comment">-- Note: 'elem' is often used in infix form.</span><span>
</span><span id="line-560"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-561"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-562"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-563"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-564"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-565"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; 3 `elem` []</span><span>
</span><span id="line-566"></span><span>    </span><span class="hs-comment">-- False</span><span>
</span><span id="line-567"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-568"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; 3 `elem` [1,2]</span><span>
</span><span id="line-569"></span><span>    </span><span class="hs-comment">-- False</span><span>
</span><span id="line-570"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-571"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]</span><span>
</span><span id="line-572"></span><span>    </span><span class="hs-comment">-- True</span><span>
</span><span id="line-573"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-574"></span><span>    </span><span class="hs-comment">-- For infinite structures, the default implementation of 'elem'</span><span>
</span><span id="line-575"></span><span>    </span><span class="hs-comment">-- terminates if the sought-after value exists at a finite distance</span><span>
</span><span id="line-576"></span><span>    </span><span class="hs-comment">-- from the left side of the structure:</span><span>
</span><span id="line-577"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-578"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; 3 `elem` [1..]</span><span>
</span><span id="line-579"></span><span>    </span><span class="hs-comment">-- True</span><span>
</span><span id="line-580"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-581"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])</span><span>
</span><span id="line-582"></span><span>    </span><span class="hs-comment">-- * Hangs forever *</span><span>
</span><span id="line-583"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-584"></span><span>    </span><span class="hs-comment">-- @since 4.8.0.0</span><span>
</span><span id="line-585"></span><span>    </span><span id="elem"><span class="annot"><a href="Data.Foldable.html#elem"><span class="hs-identifier hs-type">elem</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679577662"><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Classes.html#Eq"><span class="hs-identifier hs-type">Eq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577662"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577662"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577662"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span></span><span>
</span><span id="line-586"></span><span>    </span><span id="local-6989586621679576392"><span class="annot"><a href="Data.Foldable.html#elem"><span class="hs-identifier hs-var hs-var">elem</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><a href="Data.Foldable.html#any"><span class="hs-identifier hs-var">any</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Classes.html#%3D%3D"><span class="hs-operator hs-var">(==)</span></a></span></span><span>
</span><span id="line-587"></span><span>
</span><span id="line-588"></span><span>    </span><span class="hs-comment">-- | The largest element of a non-empty structure.</span><span>
</span><span id="line-589"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-590"></span><span>    </span><span class="hs-comment">-- This function is non-total and will raise a runtime exception if the</span><span>
</span><span id="line-591"></span><span>    </span><span class="hs-comment">-- structure happens to be empty.  A structure that supports random access</span><span>
</span><span id="line-592"></span><span>    </span><span class="hs-comment">-- and maintains its elements in order should provide a specialised</span><span>
</span><span id="line-593"></span><span>    </span><span class="hs-comment">-- implementation to return the maximum in faster than linear time.</span><span>
</span><span id="line-594"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-595"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-596"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-597"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-598"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-599"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; maximum [1..10]</span><span>
</span><span id="line-600"></span><span>    </span><span class="hs-comment">-- 10</span><span>
</span><span id="line-601"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-602"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; maximum []</span><span>
</span><span id="line-603"></span><span>    </span><span class="hs-comment">-- *** Exception: Prelude.maximum: empty list</span><span>
</span><span id="line-604"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-605"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; maximum Nothing</span><span>
</span><span id="line-606"></span><span>    </span><span class="hs-comment">-- *** Exception: maximum: empty structure</span><span>
</span><span id="line-607"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-608"></span><span>    </span><span class="hs-comment">-- WARNING: This function is partial for possibly-empty structures like lists.</span><span>
</span><span id="line-609"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-610"></span><span>    </span><span class="hs-comment">-- @since 4.8.0.0</span><span>
</span><span id="line-611"></span><span>    </span><span id="maximum"><span class="annot"><a href="Data.Foldable.html#maximum"><span class="hs-identifier hs-type">maximum</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679577657"><span class="annot"><a href="#local-6989586621679577657"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Classes.html#Ord"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577657"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577657"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577657"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-612"></span><span>    </span><span id="local-6989586621679576387"><span class="annot"><a href="Data.Foldable.html#maximum"><span class="hs-identifier hs-var hs-var">maximum</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a -&gt; a
</span><a href="Data.Maybe.html#fromMaybe"><span class="hs-identifier hs-var">fromMaybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. [Char] -&gt; a
</span><a href="GHC.Err.html#errorWithoutStackTrace"><span class="hs-identifier hs-var">errorWithoutStackTrace</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;maximum: empty structure&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span>
</span><span id="line-613"></span><span>       </span><span class="annot"><span class="annottext">forall a. Max a -&gt; Maybe a
</span><a href="Data.Functor.Utils.html#getMax"><span class="hs-identifier hs-var">getMax</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap%27"><span class="hs-identifier hs-var">foldMap'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; Max a
</span><a href="Data.Functor.Utils.html#Max"><span class="hs-identifier hs-var">Max</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679577657"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577657"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span>
</span><span id="line-614"></span><span>    </span><span class="hs-pragma">{-# INLINEABLE</span><span> </span><span class="annot"><a href="Data.Foldable.html#maximum"><span class="hs-pragma hs-type">maximum</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-615"></span><span>
</span><span id="line-616"></span><span>    </span><span class="hs-comment">-- | The least element of a non-empty structure.</span><span>
</span><span id="line-617"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-618"></span><span>    </span><span class="hs-comment">-- This function is non-total and will raise a runtime exception if the</span><span>
</span><span id="line-619"></span><span>    </span><span class="hs-comment">-- structure happens to be empty.  A structure that supports random access</span><span>
</span><span id="line-620"></span><span>    </span><span class="hs-comment">-- and maintains its elements in order should provide a specialised</span><span>
</span><span id="line-621"></span><span>    </span><span class="hs-comment">-- implementation to return the minimum in faster than linear time.</span><span>
</span><span id="line-622"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-623"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-624"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-625"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-626"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-627"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; minimum [1..10]</span><span>
</span><span id="line-628"></span><span>    </span><span class="hs-comment">-- 1</span><span>
</span><span id="line-629"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-630"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; minimum []</span><span>
</span><span id="line-631"></span><span>    </span><span class="hs-comment">-- *** Exception: Prelude.minimum: empty list</span><span>
</span><span id="line-632"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-633"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; minimum Nothing</span><span>
</span><span id="line-634"></span><span>    </span><span class="hs-comment">-- *** Exception: minimum: empty structure</span><span>
</span><span id="line-635"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-636"></span><span>    </span><span class="hs-comment">-- WARNING: This function is partial for possibly-empty structures like lists.</span><span>
</span><span id="line-637"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-638"></span><span>    </span><span class="hs-comment">-- @since 4.8.0.0</span><span>
</span><span id="line-639"></span><span>    </span><span id="minimum"><span class="annot"><a href="Data.Foldable.html#minimum"><span class="hs-identifier hs-type">minimum</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679577636"><span class="annot"><a href="#local-6989586621679577636"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Classes.html#Ord"><span class="hs-identifier hs-type">Ord</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577636"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577636"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577636"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-640"></span><span>    </span><span id="local-6989586621679576378"><span class="annot"><a href="Data.Foldable.html#minimum"><span class="hs-identifier hs-var hs-var">minimum</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a -&gt; a
</span><a href="Data.Maybe.html#fromMaybe"><span class="hs-identifier hs-var">fromMaybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. [Char] -&gt; a
</span><a href="GHC.Err.html#errorWithoutStackTrace"><span class="hs-identifier hs-var">errorWithoutStackTrace</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;minimum: empty structure&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span>
</span><span id="line-641"></span><span>       </span><span class="annot"><span class="annottext">forall a. Min a -&gt; Maybe a
</span><a href="Data.Functor.Utils.html#getMin"><span class="hs-identifier hs-var">getMin</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap%27"><span class="hs-identifier hs-var">foldMap'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; Min a
</span><a href="Data.Functor.Utils.html#Min"><span class="hs-identifier hs-var">Min</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679577636"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577636"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span>
</span><span id="line-642"></span><span>    </span><span class="hs-pragma">{-# INLINEABLE</span><span> </span><span class="annot"><a href="Data.Foldable.html#minimum"><span class="hs-pragma hs-type">minimum</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-643"></span><span>
</span><span id="line-644"></span><span>    </span><span class="hs-comment">-- | The 'sum' function computes the sum of the numbers of a structure.</span><span>
</span><span id="line-645"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-646"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-647"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-648"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-649"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-650"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; sum []</span><span>
</span><span id="line-651"></span><span>    </span><span class="hs-comment">-- 0</span><span>
</span><span id="line-652"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-653"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; sum [42]</span><span>
</span><span id="line-654"></span><span>    </span><span class="hs-comment">-- 42</span><span>
</span><span id="line-655"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-656"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; sum [1..10]</span><span>
</span><span id="line-657"></span><span>    </span><span class="hs-comment">-- 55</span><span>
</span><span id="line-658"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-659"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; sum [4.1, 2.0, 1.7]</span><span>
</span><span id="line-660"></span><span>    </span><span class="hs-comment">-- 7.8</span><span>
</span><span id="line-661"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-662"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; sum [1..]</span><span>
</span><span id="line-663"></span><span>    </span><span class="hs-comment">-- * Hangs forever *</span><span>
</span><span id="line-664"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-665"></span><span>    </span><span class="hs-comment">-- @since 4.8.0.0</span><span>
</span><span id="line-666"></span><span>    </span><span id="sum"><span class="annot"><a href="Data.Foldable.html#sum"><span class="hs-identifier hs-type">sum</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679577646"><span class="annot"><a href="GHC.Num.html#Num"><span class="hs-identifier hs-type">Num</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577646"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577646"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577646"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-667"></span><span>    </span><span id="local-6989586621679576369"><span class="annot"><a href="Data.Foldable.html#sum"><span class="hs-identifier hs-var hs-var">sum</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Sum a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getSum"><span class="hs-identifier hs-var">getSum</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap%27"><span class="hs-identifier hs-var">foldMap'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Sum a
</span><a href="Data.Semigroup.Internal.html#Sum"><span class="hs-identifier hs-var">Sum</span></a></span></span><span>
</span><span id="line-668"></span><span>    </span><span class="hs-pragma">{-# INLINEABLE</span><span> </span><span class="annot"><a href="Data.Foldable.html#sum"><span class="hs-pragma hs-type">sum</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-669"></span><span>
</span><span id="line-670"></span><span>    </span><span class="hs-comment">-- | The 'product' function computes the product of the numbers of a</span><span>
</span><span id="line-671"></span><span>    </span><span class="hs-comment">-- structure.</span><span>
</span><span id="line-672"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-673"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-674"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-675"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-676"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-677"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; product []</span><span>
</span><span id="line-678"></span><span>    </span><span class="hs-comment">-- 1</span><span>
</span><span id="line-679"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-680"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; product [42]</span><span>
</span><span id="line-681"></span><span>    </span><span class="hs-comment">-- 42</span><span>
</span><span id="line-682"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-683"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; product [1..10]</span><span>
</span><span id="line-684"></span><span>    </span><span class="hs-comment">-- 3628800</span><span>
</span><span id="line-685"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-686"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; product [4.1, 2.0, 1.7]</span><span>
</span><span id="line-687"></span><span>    </span><span class="hs-comment">-- 13.939999999999998</span><span>
</span><span id="line-688"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-689"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; product [1..]</span><span>
</span><span id="line-690"></span><span>    </span><span class="hs-comment">-- * Hangs forever *</span><span>
</span><span id="line-691"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-692"></span><span>    </span><span class="hs-comment">-- @since 4.8.0.0</span><span>
</span><span id="line-693"></span><span>    </span><span id="product"><span class="annot"><a href="Data.Foldable.html#product"><span class="hs-identifier hs-type">product</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679577637"><span class="annot"><a href="GHC.Num.html#Num"><span class="hs-identifier hs-type">Num</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577637"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577723"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577637"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577637"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-694"></span><span>    </span><span id="local-6989586621679576360"><span class="annot"><a href="Data.Foldable.html#product"><span class="hs-identifier hs-var hs-var">product</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Product a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getProduct"><span class="hs-identifier hs-var">getProduct</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap%27"><span class="hs-identifier hs-var">foldMap'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Product a
</span><a href="Data.Semigroup.Internal.html#Product"><span class="hs-identifier hs-var">Product</span></a></span></span><span>
</span><span id="line-695"></span><span>    </span><span class="hs-pragma">{-# INLINEABLE</span><span> </span><span class="annot"><a href="Data.Foldable.html#product"><span class="hs-pragma hs-type">product</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-696"></span><span>
</span><span id="line-697"></span><span class="hs-comment">-- instances for Prelude types</span><span>
</span><span id="line-698"></span><span>
</span><span id="line-699"></span><span class="hs-comment">-- | @since 2.01</span><span>
</span><span id="line-700"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679576322"><span id="local-6989586621679576324"><span id="local-6989586621679576326"><span id="local-6989586621679576328"><span id="local-6989586621679576330"><span id="local-6989586621679576332"><span id="local-6989586621679576334"><span id="local-6989586621679576336"><span id="local-6989586621679576338"><span id="local-6989586621679576340"><span id="local-6989586621679576342"><span id="local-6989586621679576345"><span id="local-6989586621679576348"><span id="local-6989586621679576351"><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-701"></span><span>    </span><span id="local-6989586621679576318"><span class="annot"><span class="annottext">foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Maybe a -&gt; m
</span><a href="#local-6989586621679576318"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><a href="Data.Maybe.html#maybe"><span class="hs-identifier hs-var">maybe</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Monoid a =&gt; a
</span><a href="GHC.Base.html#mempty"><span class="hs-identifier hs-var">mempty</span></a></span><span>
</span><span id="line-702"></span><span>
</span><span id="line-703"></span><span>    </span><span id="local-6989586621679576316"><span class="annot"><span class="annottext">foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Maybe a -&gt; b
</span><a href="#local-6989586621679576316"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679576315"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576315"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576315"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-704"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span id="local-6989586621679576314"><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576314"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679576313"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576313"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679576312"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576312"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576314"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576312"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576313"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-705"></span><span>
</span><span id="line-706"></span><span>    </span><span id="local-6989586621679576311"><span class="annot"><span class="annottext">foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Maybe a -&gt; b
</span><a href="#local-6989586621679576311"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl</span></a></span></span><span> </span><span class="annot"><span class="annottext">b -&gt; a -&gt; b
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679576310"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576310"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576310"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-707"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#foldl"><span class="hs-identifier hs-var">foldl</span></a></span><span> </span><span id="local-6989586621679576309"><span class="annot"><span class="annottext">b -&gt; a -&gt; b
</span><a href="#local-6989586621679576309"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679576308"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576308"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679576307"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576307"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b -&gt; a -&gt; b
</span><a href="#local-6989586621679576309"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576308"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576307"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-708"></span><span>
</span><span id="line-709"></span><span class="hs-comment">-- | @since 2.01</span><span>
</span><span id="line-710"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679576298"><span id="local-6989586621679576301"><span id="local-6989586621679576303"><span id="local-6989586621679576305"><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-711"></span><span>    </span><span id="local-6989586621679576283"><span class="annot"><span class="annottext">elem :: forall a. Eq a =&gt; a -&gt; [a] -&gt; Bool
</span><a href="#local-6989586621679576283"><span class="hs-identifier hs-var hs-var hs-var hs-var">elem</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; [a] -&gt; Bool
</span><a href="GHC.List.html#elem"><span class="hs-identifier hs-var">List.elem</span></a></span><span>
</span><span id="line-712"></span><span>    </span><span id="local-6989586621679576281"><span class="annot"><span class="annottext">foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
</span><a href="#local-6989586621679576281"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
</span><a href="GHC.List.html#foldl"><span class="hs-identifier hs-var">List.foldl</span></a></span><span>
</span><span id="line-713"></span><span>    </span><span id="local-6989586621679576279"><span class="annot"><span class="annottext">foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
</span><a href="#local-6989586621679576279"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl'</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
</span><a href="GHC.List.html#foldl%27"><span class="hs-identifier hs-var">List.foldl'</span></a></span><span>
</span><span id="line-714"></span><span>    </span><span id="local-6989586621679576277"><span class="annot"><span class="annottext">foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; [a] -&gt; a
</span><a href="#local-6989586621679576277"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl1</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; a -&gt; a) -&gt; [a] -&gt; a
</span><a href="GHC.List.html#foldl1"><span class="hs-identifier hs-var">List.foldl1</span></a></span><span>
</span><span id="line-715"></span><span>    </span><span id="local-6989586621679576275"><span class="annot"><span class="annottext">foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
</span><a href="#local-6989586621679576275"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
</span><a href="GHC.Base.html#foldr"><span class="hs-identifier hs-var">List.foldr</span></a></span><span>
</span><span id="line-716"></span><span>    </span><span id="local-6989586621679576274"><span class="annot"><span class="annottext">foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; [a] -&gt; a
</span><a href="#local-6989586621679576274"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr1</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; a -&gt; a) -&gt; [a] -&gt; a
</span><a href="GHC.List.html#foldr1"><span class="hs-identifier hs-var">List.foldr1</span></a></span><span>
</span><span id="line-717"></span><span>    </span><span id="local-6989586621679576272"><span class="annot"><span class="annottext">length :: forall a. [a] -&gt; Int
</span><a href="#local-6989586621679576272"><span class="hs-identifier hs-var hs-var hs-var hs-var">length</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; Int
</span><a href="GHC.List.html#length"><span class="hs-identifier hs-var">List.length</span></a></span><span>
</span><span id="line-718"></span><span>    </span><span id="local-6989586621679576268"><span class="annot"><span class="annottext">maximum :: forall a. Ord a =&gt; [a] -&gt; a
</span><a href="#local-6989586621679576268"><span class="hs-identifier hs-var hs-var hs-var hs-var">maximum</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; [a] -&gt; a
</span><a href="GHC.List.html#maximum"><span class="hs-identifier hs-var">List.maximum</span></a></span><span>
</span><span id="line-719"></span><span>    </span><span id="local-6989586621679576264"><span class="annot"><span class="annottext">minimum :: forall a. Ord a =&gt; [a] -&gt; a
</span><a href="#local-6989586621679576264"><span class="hs-identifier hs-var hs-var hs-var hs-var">minimum</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; [a] -&gt; a
</span><a href="GHC.List.html#minimum"><span class="hs-identifier hs-var">List.minimum</span></a></span><span>
</span><span id="line-720"></span><span>    </span><span id="local-6989586621679576262"><span class="annot"><span class="annottext">null :: forall a. [a] -&gt; Bool
</span><a href="#local-6989586621679576262"><span class="hs-identifier hs-var hs-var hs-var hs-var">null</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; Bool
</span><a href="GHC.List.html#null"><span class="hs-identifier hs-var">List.null</span></a></span><span>
</span><span id="line-721"></span><span>    </span><span id="local-6989586621679576258"><span class="annot"><span class="annottext">product :: forall a. Num a =&gt; [a] -&gt; a
</span><a href="#local-6989586621679576258"><span class="hs-identifier hs-var hs-var hs-var hs-var">product</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; [a] -&gt; a
</span><a href="GHC.List.html#product"><span class="hs-identifier hs-var">List.product</span></a></span><span>
</span><span id="line-722"></span><span>    </span><span id="local-6989586621679576254"><span class="annot"><span class="annottext">sum :: forall a. Num a =&gt; [a] -&gt; a
</span><a href="#local-6989586621679576254"><span class="hs-identifier hs-var hs-var hs-var hs-var">sum</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; [a] -&gt; a
</span><a href="GHC.List.html#sum"><span class="hs-identifier hs-var">List.sum</span></a></span><span>
</span><span id="line-723"></span><span>    </span><span id="local-6989586621679576252"><span class="annot"><span class="annottext">toList :: forall a. [a] -&gt; [a]
</span><a href="#local-6989586621679576252"><span class="hs-identifier hs-var hs-var hs-var hs-var">toList</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; a
</span><a href="GHC.Base.html#id"><span class="hs-identifier hs-var">id</span></a></span><span>
</span><span id="line-724"></span><span>
</span><span id="line-725"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-726"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679576225"><span id="local-6989586621679576227"><span id="local-6989586621679576229"><span id="local-6989586621679576231"><span id="local-6989586621679576233"><span id="local-6989586621679576235"><span id="local-6989586621679576237"><span id="local-6989586621679576242"><span id="local-6989586621679576245"><span id="local-6989586621679576248"><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="GHC.Base.html#NonEmpty"><span class="hs-identifier hs-type">NonEmpty</span></a></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-727"></span><span>  </span><span id="local-6989586621679576224"><span class="annot"><span class="annottext">foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; NonEmpty a -&gt; b
</span><a href="#local-6989586621679576224"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr</span></a></span></span><span> </span><span id="local-6989586621679576223"><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576223"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679576222"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576222"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span id="local-6989586621679576221"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576221"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="annot"><a href="GHC.Base.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679576220"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679576220"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576223"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576221"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
</span><a href="GHC.Base.html#foldr"><span class="hs-identifier hs-var">List.foldr</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576223"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576222"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679576220"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-728"></span><span>  </span><span id="local-6989586621679576219"><span class="annot"><span class="annottext">foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; NonEmpty a -&gt; b
</span><a href="#local-6989586621679576219"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl</span></a></span></span><span> </span><span id="local-6989586621679576218"><span class="annot"><span class="annottext">b -&gt; a -&gt; b
</span><a href="#local-6989586621679576218"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679576217"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576217"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679576216"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576216"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="annot"><a href="GHC.Base.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679576215"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679576215"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
</span><a href="GHC.List.html#foldl"><span class="hs-identifier hs-var">List.foldl</span></a></span><span> </span><span class="annot"><span class="annottext">b -&gt; a -&gt; b
</span><a href="#local-6989586621679576218"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">b -&gt; a -&gt; b
</span><a href="#local-6989586621679576218"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576217"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576216"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679576215"><span class="hs-keyword hs-var">as</span></a></span><span>
</span><span id="line-729"></span><span>  </span><span id="local-6989586621679576214"><span class="annot"><span class="annottext">foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; NonEmpty a -&gt; a
</span><a href="#local-6989586621679576214"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl1</span></a></span></span><span> </span><span id="local-6989586621679576213"><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><a href="#local-6989586621679576213"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679576212"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576212"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="annot"><a href="GHC.Base.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679576211"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679576211"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
</span><a href="GHC.List.html#foldl"><span class="hs-identifier hs-var">List.foldl</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><a href="#local-6989586621679576213"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576212"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679576211"><span class="hs-keyword hs-var">as</span></a></span><span>
</span><span id="line-730"></span><span>
</span><span id="line-731"></span><span>  </span><span class="hs-comment">-- GHC isn't clever enough to transform the default definition</span><span>
</span><span id="line-732"></span><span>  </span><span class="hs-comment">-- into anything like this, so we'd end up shuffling a bunch of</span><span>
</span><span id="line-733"></span><span>  </span><span class="hs-comment">-- Maybes around.</span><span>
</span><span id="line-734"></span><span>  </span><span id="local-6989586621679576209"><span class="annot"><span class="annottext">foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; NonEmpty a -&gt; a
</span><a href="#local-6989586621679576209"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr1</span></a></span></span><span> </span><span id="local-6989586621679576208"><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><a href="#local-6989586621679576208"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679576207"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576207"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><a href="GHC.Base.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679576206"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679576206"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="annot"><span class="annottext">forall {t}. t -&gt; (t -&gt; a) -&gt; a -&gt; a
</span><a href="#local-6989586621679576205"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; a
</span><a href="GHC.Base.html#id"><span class="hs-identifier hs-var">id</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679576206"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576207"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-735"></span><span>    </span><span class="hs-keyword">where</span><span>
</span><span id="line-736"></span><span>      </span><span id="local-6989586621679576205"><span class="annot"><span class="annottext">go :: t -&gt; (t -&gt; a) -&gt; a -&gt; a
</span><a href="#local-6989586621679576205"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679576204"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679576204"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679576203"><span class="annot"><span class="annottext">t -&gt; a
</span><a href="#local-6989586621679576203"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621679576202"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576202"><span class="hs-identifier hs-var">prev</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><a href="#local-6989586621679576208"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576202"><span class="hs-identifier hs-var">prev</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t -&gt; a
</span><a href="#local-6989586621679576203"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679576204"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-737"></span><span>
</span><span id="line-738"></span><span>  </span><span class="hs-comment">-- We used to say</span><span>
</span><span id="line-739"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-740"></span><span>  </span><span class="hs-comment">--   length (_ :| as) = 1 + length as</span><span>
</span><span id="line-741"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-742"></span><span>  </span><span class="hs-comment">-- but the default definition is better, counting from 1.</span><span>
</span><span id="line-743"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-744"></span><span>  </span><span class="hs-comment">-- The default definition also works great for null and foldl'.</span><span>
</span><span id="line-745"></span><span>  </span><span class="hs-comment">-- As usual for cons lists, foldr' is basically hopeless.</span><span>
</span><span id="line-746"></span><span>
</span><span id="line-747"></span><span>  </span><span id="local-6989586621679576197"><span class="annot"><span class="annottext">foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; NonEmpty a -&gt; m
</span><a href="#local-6989586621679576197"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap</span></a></span></span><span> </span><span id="local-6989586621679576196"><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679576196"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span id="local-6989586621679576195"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576195"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="annot"><a href="GHC.Base.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679576194"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679576194"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679576196"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576195"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Monoid a =&gt; a -&gt; a -&gt; a
</span><a href="GHC.Base.html#mappend"><span class="hs-operator hs-var">`mappend`</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var">foldMap</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679576196"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679576194"><span class="hs-keyword hs-var">as</span></a></span><span>
</span><span id="line-748"></span><span>  </span><span id="local-6989586621679576189"><span class="annot"><span class="annottext">fold :: forall m. Monoid m =&gt; NonEmpty m -&gt; m
</span><a href="#local-6989586621679576189"><span class="hs-identifier hs-var hs-var hs-var hs-var">fold</span></a></span></span><span> </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span id="local-6989586621679576188"><span class="annot"><span class="annottext">m
</span><a href="#local-6989586621679576188"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="annot"><a href="GHC.Base.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679576187"><span class="annot"><span class="annottext">[m]
</span><a href="#local-6989586621679576187"><span class="hs-identifier hs-var">ms</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m
</span><a href="#local-6989586621679576188"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Monoid a =&gt; a -&gt; a -&gt; a
</span><a href="GHC.Base.html#mappend"><span class="hs-operator hs-var">`mappend`</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m. (Foldable t, Monoid m) =&gt; t m -&gt; m
</span><a href="Data.Foldable.html#fold"><span class="hs-identifier hs-var">fold</span></a></span><span> </span><span class="annot"><span class="annottext">[m]
</span><a href="#local-6989586621679576187"><span class="hs-identifier hs-var">ms</span></a></span><span>
</span><span id="line-749"></span><span>  </span><span id="local-6989586621679576186"><span class="annot"><span class="annottext">toList :: forall a. NonEmpty a -&gt; [a]
</span><a href="#local-6989586621679576186"><span class="hs-identifier hs-var hs-var hs-var hs-var">toList</span></a></span></span><span> </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span id="local-6989586621679576185"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576185"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="annot"><a href="GHC.Base.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679576184"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679576184"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576185"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#%3A"><span class="hs-glyph hs-var">:</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679576184"><span class="hs-keyword hs-var">as</span></a></span><span>
</span><span id="line-750"></span><span>
</span><span id="line-751"></span><span class="hs-comment">-- | @since 4.7.0.0</span><span>
</span><span id="line-752"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679576154"><span id="local-6989586621679576156"><span id="local-6989586621679576158"><span id="local-6989586621679576160"><span id="local-6989586621679576162"><span id="local-6989586621679576166"><span id="local-6989586621679576168"><span id="local-6989586621679576170"><span id="local-6989586621679576172"><span id="local-6989586621679576174"><span id="local-6989586621679576176"><span id="local-6989586621679576179"><span id="local-6989586621679576182"><span id="local-6989586621679577605"><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Either.html#Either"><span class="hs-identifier hs-type">Either</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577605"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-753"></span><span>    </span><span id="local-6989586621679576151"><span class="annot"><span class="annottext">foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Either a a -&gt; m
</span><a href="#local-6989586621679576151"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Either.html#Left"><span class="hs-identifier hs-type">Left</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Monoid a =&gt; a
</span><a href="GHC.Base.html#mempty"><span class="hs-identifier hs-var">mempty</span></a></span><span>
</span><span id="line-754"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var">foldMap</span></a></span><span> </span><span id="local-6989586621679576150"><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679576150"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Either.html#Right"><span class="hs-identifier hs-type">Right</span></a></span><span> </span><span id="local-6989586621679576149"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576149"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679576150"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576149"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-755"></span><span>
</span><span id="line-756"></span><span>    </span><span id="local-6989586621679576148"><span class="annot"><span class="annottext">foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Either a a -&gt; b
</span><a href="#local-6989586621679576148"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679576147"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576147"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Either.html#Left"><span class="hs-identifier hs-type">Left</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576147"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-757"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span id="local-6989586621679576146"><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576146"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679576145"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576145"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Either.html#Right"><span class="hs-identifier hs-type">Right</span></a></span><span> </span><span id="local-6989586621679576144"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576144"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576146"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576144"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576145"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-758"></span><span>
</span><span id="line-759"></span><span>    </span><span id="local-6989586621679576143"><span class="annot"><span class="annottext">length :: forall a. Either a a -&gt; Int
</span><a href="#local-6989586621679576143"><span class="hs-identifier hs-var hs-var hs-var hs-var">length</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Either.html#Left"><span class="hs-identifier hs-type">Left</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-760"></span><span>    </span><span class="annot"><a href="Data.Foldable.html#length"><span class="hs-identifier hs-var">length</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Either.html#Right"><span class="hs-identifier hs-type">Right</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-761"></span><span>
</span><span id="line-762"></span><span>    </span><span id="local-6989586621679576142"><span class="annot"><span class="annottext">null :: forall a. Either a a -&gt; Bool
</span><a href="#local-6989586621679576142"><span class="hs-identifier hs-var hs-var hs-var hs-var">null</span></a></span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a a. Either a a -&gt; Bool
</span><a href="Data.Either.html#isLeft"><span class="hs-identifier hs-var">isLeft</span></a></span><span>
</span><span id="line-763"></span><span>
</span><span id="line-764"></span><span class="hs-comment">-- | @since 4.15</span><span>
</span><span id="line-765"></span><span id="local-6989586621679576106"><span id="local-6989586621679576108"><span id="local-6989586621679576110"><span id="local-6989586621679576112"><span id="local-6989586621679576114"><span id="local-6989586621679576116"><span id="local-6989586621679576118"><span id="local-6989586621679576120"><span id="local-6989586621679576122"><span id="local-6989586621679576124"><span id="local-6989586621679576126"><span id="local-6989586621679576128"><span id="local-6989586621679576130"><span id="local-6989586621679576132"><span id="local-6989586621679576134"><span id="local-6989586621679576137"><span id="local-6989586621679576139"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Tuple.html#Solo"><span class="hs-identifier hs-type">Solo</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-766"></span><span>
</span><span id="line-767"></span><span class="hs-comment">-- | @since 4.7.0.0</span><span>
</span><span id="line-768"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679576076"><span id="local-6989586621679576078"><span id="local-6989586621679576080"><span id="local-6989586621679576082"><span id="local-6989586621679576084"><span id="local-6989586621679576088"><span id="local-6989586621679576090"><span id="local-6989586621679576092"><span id="local-6989586621679576094"><span id="local-6989586621679576096"><span id="local-6989586621679576098"><span id="local-6989586621679576101"><span id="local-6989586621679576104"><span id="local-6989586621679577598"><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679577598"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-769"></span><span>    </span><span id="local-6989586621679576074"><span class="annot"><span class="annottext">foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; (a, a) -&gt; m
</span><a href="#local-6989586621679576074"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap</span></a></span></span><span> </span><span id="local-6989586621679576073"><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679576073"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679576072"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576072"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679576073"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576072"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-770"></span><span>
</span><span id="line-771"></span><span>    </span><span id="local-6989586621679576071"><span class="annot"><span class="annottext">foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; (a, a) -&gt; b
</span><a href="#local-6989586621679576071"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr</span></a></span></span><span> </span><span id="local-6989586621679576070"><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576070"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679576069"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576069"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679576068"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576068"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679576070"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679576068"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679576069"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-772"></span><span>    </span><span id="local-6989586621679576067"><span class="annot"><span class="annottext">length :: forall a. (a, a) -&gt; Int
</span><a href="#local-6989586621679576067"><span class="hs-identifier hs-var hs-var hs-var hs-var">length</span></a></span></span><span> </span><span class="annot"><span class="annottext">(a, a)
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-773"></span><span>    </span><span id="local-6989586621679576066"><span class="annot"><span class="annottext">null :: forall a. (a, a) -&gt; Bool
</span><a href="#local-6989586621679576066"><span class="hs-identifier hs-var hs-var hs-var hs-var">null</span></a></span></span><span> </span><span class="annot"><span class="annottext">(a, a)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-774"></span><span>
</span><span id="line-775"></span><span class="hs-comment">-- | @since 4.8.0.0</span><span>
</span><span id="line-776"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679576041"><span id="local-6989586621679576043"><span id="local-6989586621679576045"><span id="local-6989586621679576047"><span id="local-6989586621679576049"><span id="local-6989586621679576060"><span id="local-6989586621679576062"><span id="local-6989586621679576064"><span id="local-6989586621679577591"><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Arr.html#Array"><span class="hs-identifier hs-type">Array</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577591"><span class="hs-identifier hs-type">i</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-777"></span><span>    </span><span id="local-6989586621679576040"><span class="annot"><span class="annottext">foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Array i a -&gt; b
</span><a href="#local-6989586621679576040"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b i. (a -&gt; b -&gt; b) -&gt; b -&gt; Array i a -&gt; b
</span><a href="GHC.Arr.html#foldrElems"><span class="hs-identifier hs-var">foldrElems</span></a></span><span>
</span><span id="line-778"></span><span>    </span><span id="local-6989586621679576039"><span class="annot"><span class="annottext">foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Array i a -&gt; b
</span><a href="#local-6989586621679576039"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a i. (b -&gt; a -&gt; b) -&gt; b -&gt; Array i a -&gt; b
</span><a href="GHC.Arr.html#foldlElems"><span class="hs-identifier hs-var">foldlElems</span></a></span><span>
</span><span id="line-779"></span><span>    </span><span id="local-6989586621679576038"><span class="annot"><span class="annottext">foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Array i a -&gt; b
</span><a href="#local-6989586621679576038"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a i. (b -&gt; a -&gt; b) -&gt; b -&gt; Array i a -&gt; b
</span><a href="GHC.Arr.html#foldlElems%27"><span class="hs-identifier hs-var">foldlElems'</span></a></span><span>
</span><span id="line-780"></span><span>    </span><span id="local-6989586621679576037"><span class="annot"><span class="annottext">foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Array i a -&gt; b
</span><a href="#local-6989586621679576037"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b i. (a -&gt; b -&gt; b) -&gt; b -&gt; Array i a -&gt; b
</span><a href="GHC.Arr.html#foldrElems%27"><span class="hs-identifier hs-var">foldrElems'</span></a></span><span>
</span><span id="line-781"></span><span>    </span><span id="local-6989586621679576036"><span class="annot"><span class="annottext">foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Array i a -&gt; a
</span><a href="#local-6989586621679576036"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a i. (a -&gt; a -&gt; a) -&gt; Array i a -&gt; a
</span><a href="GHC.Arr.html#foldl1Elems"><span class="hs-identifier hs-var">foldl1Elems</span></a></span><span>
</span><span id="line-782"></span><span>    </span><span id="local-6989586621679576035"><span class="annot"><span class="annottext">foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Array i a -&gt; a
</span><a href="#local-6989586621679576035"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a i. (a -&gt; a -&gt; a) -&gt; Array i a -&gt; a
</span><a href="GHC.Arr.html#foldr1Elems"><span class="hs-identifier hs-var">foldr1Elems</span></a></span><span>
</span><span id="line-783"></span><span>    </span><span id="local-6989586621679576034"><span class="annot"><span class="annottext">toList :: forall a. Array i a -&gt; [a]
</span><a href="#local-6989586621679576034"><span class="hs-identifier hs-var hs-var hs-var hs-var">toList</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i a. Array i a -&gt; [a]
</span><a href="GHC.Arr.html#elems"><span class="hs-identifier hs-var">elems</span></a></span><span>
</span><span id="line-784"></span><span>    </span><span id="local-6989586621679576033"><span class="annot"><span class="annottext">length :: forall a. Array i a -&gt; Int
</span><a href="#local-6989586621679576033"><span class="hs-identifier hs-var hs-var hs-var hs-var">length</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i a. Array i a -&gt; Int
</span><a href="GHC.Arr.html#numElements"><span class="hs-identifier hs-var">numElements</span></a></span><span>
</span><span id="line-785"></span><span>    </span><span id="local-6989586621679576029"><span class="annot"><span class="annottext">null :: forall a. Array i a -&gt; Bool
</span><a href="#local-6989586621679576029"><span class="hs-identifier hs-var hs-var hs-var hs-var">null</span></a></span></span><span> </span><span id="local-6989586621679576028"><span class="annot"><span class="annottext">Array i a
</span><a href="#local-6989586621679576028"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i a. Array i a -&gt; Int
</span><a href="GHC.Arr.html#numElements"><span class="hs-identifier hs-var">numElements</span></a></span><span> </span><span class="annot"><span class="annottext">Array i a
</span><a href="#local-6989586621679576028"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Classes.html#%3D%3D"><span class="hs-operator hs-var">==</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-786"></span><span>
</span><span id="line-787"></span><span class="hs-comment">-- | @since 4.7.0.0</span><span>
</span><span id="line-788"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679576007"><span id="local-6989586621679576009"><span id="local-6989586621679576014"><span id="local-6989586621679576018"><span id="local-6989586621679576021"><span id="local-6989586621679576024"><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="Data.Proxy.html#Proxy"><span class="hs-identifier hs-type">Proxy</span></a></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-789"></span><span>    </span><span id="local-6989586621679576002"><span class="annot"><span class="annottext">foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Proxy a -&gt; m
</span><a href="#local-6989586621679576002"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Proxy a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Monoid a =&gt; a
</span><a href="GHC.Base.html#mempty"><span class="hs-identifier hs-var">mempty</span></a></span><span>
</span><span id="line-790"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#foldMap"><span class="hs-pragma hs-type">foldMap</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-791"></span><span>    </span><span id="local-6989586621679575999"><span class="annot"><span class="annottext">fold :: forall m. Monoid m =&gt; Proxy m -&gt; m
</span><a href="#local-6989586621679575999"><span class="hs-identifier hs-var hs-var hs-var hs-var">fold</span></a></span></span><span> </span><span class="annot"><span class="annottext">Proxy m
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Monoid a =&gt; a
</span><a href="GHC.Base.html#mempty"><span class="hs-identifier hs-var">mempty</span></a></span><span>
</span><span id="line-792"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#fold"><span class="hs-pragma hs-type">fold</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-793"></span><span>    </span><span id="local-6989586621679575998"><span class="annot"><span class="annottext">foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Proxy a -&gt; b
</span><a href="#local-6989586621679575998"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679575997"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575997"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="annot"><span class="annottext">Proxy a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575997"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-794"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#foldr"><span class="hs-pragma hs-type">foldr</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-795"></span><span>    </span><span id="local-6989586621679575996"><span class="annot"><span class="annottext">foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Proxy a -&gt; b
</span><a href="#local-6989586621679575996"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl</span></a></span></span><span> </span><span class="annot"><span class="annottext">b -&gt; a -&gt; b
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679575995"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575995"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="annot"><span class="annottext">Proxy a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575995"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-796"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#foldl"><span class="hs-pragma hs-type">foldl</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-797"></span><span>    </span><span id="local-6989586621679575994"><span class="annot"><span class="annottext">foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Proxy a -&gt; a
</span><a href="#local-6989586621679575994"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl1</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Proxy a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [Char] -&gt; a
</span><a href="GHC.Err.html#errorWithoutStackTrace"><span class="hs-identifier hs-var">errorWithoutStackTrace</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;foldl1: Proxy&quot;</span></span><span>
</span><span id="line-798"></span><span>    </span><span id="local-6989586621679575993"><span class="annot"><span class="annottext">foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Proxy a -&gt; a
</span><a href="#local-6989586621679575993"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr1</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Proxy a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [Char] -&gt; a
</span><a href="GHC.Err.html#errorWithoutStackTrace"><span class="hs-identifier hs-var">errorWithoutStackTrace</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;foldr1: Proxy&quot;</span></span><span>
</span><span id="line-799"></span><span>    </span><span id="local-6989586621679575992"><span class="annot"><span class="annottext">length :: forall a. Proxy a -&gt; Int
</span><a href="#local-6989586621679575992"><span class="hs-identifier hs-var hs-var hs-var hs-var">length</span></a></span></span><span> </span><span class="annot"><span class="annottext">Proxy a
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-800"></span><span>    </span><span id="local-6989586621679575991"><span class="annot"><span class="annottext">null :: forall a. Proxy a -&gt; Bool
</span><a href="#local-6989586621679575991"><span class="hs-identifier hs-var hs-var hs-var hs-var">null</span></a></span></span><span> </span><span class="annot"><span class="annottext">Proxy a
</span><span class="hs-identifier">_</span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#True"><span class="hs-identifier hs-var">True</span></a></span><span>
</span><span id="line-801"></span><span>    </span><span id="local-6989586621679575989"><span class="annot"><span class="annottext">elem :: forall a. Eq a =&gt; a -&gt; Proxy a -&gt; Bool
</span><a href="#local-6989586621679575989"><span class="hs-identifier hs-var hs-var hs-var hs-var">elem</span></a></span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Proxy a
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-802"></span><span>    </span><span id="local-6989586621679575986"><span class="annot"><span class="annottext">sum :: forall a. Num a =&gt; Proxy a -&gt; a
</span><a href="#local-6989586621679575986"><span class="hs-identifier hs-var hs-var hs-var hs-var">sum</span></a></span></span><span> </span><span class="annot"><span class="annottext">Proxy a
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-number">0</span></span><span>
</span><span id="line-803"></span><span>    </span><span id="local-6989586621679575983"><span class="annot"><span class="annottext">product :: forall a. Num a =&gt; Proxy a -&gt; a
</span><a href="#local-6989586621679575983"><span class="hs-identifier hs-var hs-var hs-var hs-var">product</span></a></span></span><span> </span><span class="annot"><span class="annottext">Proxy a
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-number">1</span></span><span>
</span><span id="line-804"></span><span>
</span><span id="line-805"></span><span class="hs-comment">-- | @since 4.8.0.0</span><span>
</span><span id="line-806"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679575978"><span id="local-6989586621679575981"><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="Data.Semigroup.Internal.html#Dual"><span class="hs-identifier hs-type">Dual</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-807"></span><span>    </span><span id="local-6989586621679575961"><span class="annot"><span class="annottext">foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Dual a -&gt; m
</span><a href="#local-6989586621679575961"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap</span></a></span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">coerce :: forall a b. Coercible a b =&gt; a -&gt; b
</span><a href="../../ghc-prim-0.8.0/src/GHC-Prim.html#coerce"><span class="hs-identifier hs-type">coerce</span></a></span><span>
</span><span id="line-808"></span><span>
</span><span id="line-809"></span><span>    </span><span id="local-6989586621679575957"><span class="annot"><span class="annottext">elem :: forall a. Eq a =&gt; a -&gt; Dual a -&gt; Bool
</span><a href="#local-6989586621679575957"><span class="hs-identifier hs-var hs-var hs-var hs-var">elem</span></a></span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Dual a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getDual"><span class="hs-identifier hs-var">getDual</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Classes.html#%3D%3D"><span class="hs-operator hs-var">(==)</span></a></span><span>
</span><span id="line-810"></span><span>    </span><span id="local-6989586621679575955"><span class="annot"><span class="annottext">foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Dual a -&gt; b
</span><a href="#local-6989586621679575955"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl</span></a></span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">coerce :: forall a b. Coercible a b =&gt; a -&gt; b
</span><a href="../../ghc-prim-0.8.0/src/GHC-Prim.html#coerce"><span class="hs-identifier hs-type">coerce</span></a></span><span>
</span><span id="line-811"></span><span>    </span><span id="local-6989586621679575953"><span class="annot"><span class="annottext">foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Dual a -&gt; b
</span><a href="#local-6989586621679575953"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl'</span></a></span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">coerce :: forall a b. Coercible a b =&gt; a -&gt; b
</span><a href="../../ghc-prim-0.8.0/src/GHC-Prim.html#coerce"><span class="hs-identifier hs-type">coerce</span></a></span><span>
</span><span id="line-812"></span><span>    </span><span id="local-6989586621679575952"><span class="annot"><span class="annottext">foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Dual a -&gt; a
</span><a href="#local-6989586621679575952"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl1</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Dual a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getDual"><span class="hs-identifier hs-var">getDual</span></a></span><span>
</span><span id="line-813"></span><span>    </span><span id="local-6989586621679575951"><span class="annot"><span class="annottext">foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Dual a -&gt; b
</span><a href="#local-6989586621679575951"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr</span></a></span></span><span> </span><span id="local-6989586621679575950"><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679575950"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679575949"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575949"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Semigroup.Internal.html#Dual"><span class="hs-identifier hs-type">Dual</span></a></span><span> </span><span id="local-6989586621679575948"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575948"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679575950"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575948"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575949"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-814"></span><span>    </span><span id="local-6989586621679575946"><span class="annot"><span class="annottext">foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Dual a -&gt; b
</span><a href="#local-6989586621679575946"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr'</span></a></span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span>
</span><span id="line-815"></span><span>    </span><span id="local-6989586621679575945"><span class="annot"><span class="annottext">foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Dual a -&gt; a
</span><a href="#local-6989586621679575945"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr1</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Dual a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getDual"><span class="hs-identifier hs-var">getDual</span></a></span><span>
</span><span id="line-816"></span><span>    </span><span id="local-6989586621679575944"><span class="annot"><span class="annottext">length :: forall a. Dual a -&gt; Int
</span><a href="#local-6989586621679575944"><span class="hs-identifier hs-var hs-var hs-var hs-var">length</span></a></span></span><span> </span><span class="annot"><span class="annottext">Dual a
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-817"></span><span>    </span><span id="local-6989586621679575942"><span class="annot"><span class="annottext">maximum :: forall a. Ord a =&gt; Dual a -&gt; a
</span><a href="#local-6989586621679575942"><span class="hs-identifier hs-var hs-var hs-var hs-var">maximum</span></a></span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Dual a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getDual"><span class="hs-identifier hs-var">getDual</span></a></span><span>
</span><span id="line-818"></span><span>    </span><span id="local-6989586621679575940"><span class="annot"><span class="annottext">minimum :: forall a. Ord a =&gt; Dual a -&gt; a
</span><a href="#local-6989586621679575940"><span class="hs-identifier hs-var hs-var hs-var hs-var">minimum</span></a></span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Dual a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getDual"><span class="hs-identifier hs-var">getDual</span></a></span><span>
</span><span id="line-819"></span><span>    </span><span id="local-6989586621679575939"><span class="annot"><span class="annottext">null :: forall a. Dual a -&gt; Bool
</span><a href="#local-6989586621679575939"><span class="hs-identifier hs-var hs-var hs-var hs-var">null</span></a></span></span><span> </span><span class="annot"><span class="annottext">Dual a
</span><span class="hs-identifier">_</span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-820"></span><span>    </span><span id="local-6989586621679575937"><span class="annot"><span class="annottext">product :: forall a. Num a =&gt; Dual a -&gt; a
</span><a href="#local-6989586621679575937"><span class="hs-identifier hs-var hs-var hs-var hs-var">product</span></a></span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Dual a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getDual"><span class="hs-identifier hs-var">getDual</span></a></span><span>
</span><span id="line-821"></span><span>    </span><span id="local-6989586621679575935"><span class="annot"><span class="annottext">sum :: forall a. Num a =&gt; Dual a -&gt; a
</span><a href="#local-6989586621679575935"><span class="hs-identifier hs-var hs-var hs-var hs-var">sum</span></a></span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Dual a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getDual"><span class="hs-identifier hs-var">getDual</span></a></span><span>
</span><span id="line-822"></span><span>    </span><span id="local-6989586621679575934"><span class="annot"><span class="annottext">toList :: forall a. Dual a -&gt; [a]
</span><a href="#local-6989586621679575934"><span class="hs-identifier hs-var hs-var hs-var hs-var">toList</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Semigroup.Internal.html#Dual"><span class="hs-identifier hs-type">Dual</span></a></span><span> </span><span id="local-6989586621679575933"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575933"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575933"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-823"></span><span>
</span><span id="line-824"></span><span class="hs-comment">-- | @since 4.8.0.0</span><span>
</span><span id="line-825"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679575928"><span id="local-6989586621679575931"><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="Data.Semigroup.Internal.html#Sum"><span class="hs-identifier hs-type">Sum</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-826"></span><span>    </span><span id="local-6989586621679575911"><span class="annot"><span class="annottext">foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Sum a -&gt; m
</span><a href="#local-6989586621679575911"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap</span></a></span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">coerce :: forall a b. Coercible a b =&gt; a -&gt; b
</span><a href="../../ghc-prim-0.8.0/src/GHC-Prim.html#coerce"><span class="hs-identifier hs-type">coerce</span></a></span><span>
</span><span id="line-827"></span><span>
</span><span id="line-828"></span><span>    </span><span id="local-6989586621679575907"><span class="annot"><span class="annottext">elem :: forall a. Eq a =&gt; a -&gt; Sum a -&gt; Bool
</span><a href="#local-6989586621679575907"><span class="hs-identifier hs-var hs-var hs-var hs-var">elem</span></a></span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Sum a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getSum"><span class="hs-identifier hs-var">getSum</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Classes.html#%3D%3D"><span class="hs-operator hs-var">(==)</span></a></span><span>
</span><span id="line-829"></span><span>    </span><span id="local-6989586621679575905"><span class="annot"><span class="annottext">foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Sum a -&gt; b
</span><a href="#local-6989586621679575905"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl</span></a></span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">coerce :: forall a b. Coercible a b =&gt; a -&gt; b
</span><a href="../../ghc-prim-0.8.0/src/GHC-Prim.html#coerce"><span class="hs-identifier hs-type">coerce</span></a></span><span>
</span><span id="line-830"></span><span>    </span><span id="local-6989586621679575903"><span class="annot"><span class="annottext">foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Sum a -&gt; b
</span><a href="#local-6989586621679575903"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl'</span></a></span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">coerce :: forall a b. Coercible a b =&gt; a -&gt; b
</span><a href="../../ghc-prim-0.8.0/src/GHC-Prim.html#coerce"><span class="hs-identifier hs-type">coerce</span></a></span><span>
</span><span id="line-831"></span><span>    </span><span id="local-6989586621679575902"><span class="annot"><span class="annottext">foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Sum a -&gt; a
</span><a href="#local-6989586621679575902"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl1</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Sum a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getSum"><span class="hs-identifier hs-var">getSum</span></a></span><span>
</span><span id="line-832"></span><span>    </span><span id="local-6989586621679575901"><span class="annot"><span class="annottext">foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Sum a -&gt; b
</span><a href="#local-6989586621679575901"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr</span></a></span></span><span> </span><span id="local-6989586621679575900"><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679575900"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679575899"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575899"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Semigroup.Internal.html#Sum"><span class="hs-identifier hs-type">Sum</span></a></span><span> </span><span id="local-6989586621679575898"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575898"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679575900"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575898"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575899"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-833"></span><span>    </span><span id="local-6989586621679575896"><span class="annot"><span class="annottext">foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Sum a -&gt; b
</span><a href="#local-6989586621679575896"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr'</span></a></span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span>
</span><span id="line-834"></span><span>    </span><span id="local-6989586621679575895"><span class="annot"><span class="annottext">foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Sum a -&gt; a
</span><a href="#local-6989586621679575895"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr1</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Sum a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getSum"><span class="hs-identifier hs-var">getSum</span></a></span><span>
</span><span id="line-835"></span><span>    </span><span id="local-6989586621679575894"><span class="annot"><span class="annottext">length :: forall a. Sum a -&gt; Int
</span><a href="#local-6989586621679575894"><span class="hs-identifier hs-var hs-var hs-var hs-var">length</span></a></span></span><span> </span><span class="annot"><span class="annottext">Sum a
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-836"></span><span>    </span><span id="local-6989586621679575892"><span class="annot"><span class="annottext">maximum :: forall a. Ord a =&gt; Sum a -&gt; a
</span><a href="#local-6989586621679575892"><span class="hs-identifier hs-var hs-var hs-var hs-var">maximum</span></a></span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Sum a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getSum"><span class="hs-identifier hs-var">getSum</span></a></span><span>
</span><span id="line-837"></span><span>    </span><span id="local-6989586621679575890"><span class="annot"><span class="annottext">minimum :: forall a. Ord a =&gt; Sum a -&gt; a
</span><a href="#local-6989586621679575890"><span class="hs-identifier hs-var hs-var hs-var hs-var">minimum</span></a></span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Sum a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getSum"><span class="hs-identifier hs-var">getSum</span></a></span><span>
</span><span id="line-838"></span><span>    </span><span id="local-6989586621679575889"><span class="annot"><span class="annottext">null :: forall a. Sum a -&gt; Bool
</span><a href="#local-6989586621679575889"><span class="hs-identifier hs-var hs-var hs-var hs-var">null</span></a></span></span><span> </span><span class="annot"><span class="annottext">Sum a
</span><span class="hs-identifier">_</span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-839"></span><span>    </span><span id="local-6989586621679575887"><span class="annot"><span class="annottext">product :: forall a. Num a =&gt; Sum a -&gt; a
</span><a href="#local-6989586621679575887"><span class="hs-identifier hs-var hs-var hs-var hs-var">product</span></a></span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Sum a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getSum"><span class="hs-identifier hs-var">getSum</span></a></span><span>
</span><span id="line-840"></span><span>    </span><span id="local-6989586621679575885"><span class="annot"><span class="annottext">sum :: forall a. Num a =&gt; Sum a -&gt; a
</span><a href="#local-6989586621679575885"><span class="hs-identifier hs-var hs-var hs-var hs-var">sum</span></a></span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Sum a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getSum"><span class="hs-identifier hs-var">getSum</span></a></span><span>
</span><span id="line-841"></span><span>    </span><span id="local-6989586621679575884"><span class="annot"><span class="annottext">toList :: forall a. Sum a -&gt; [a]
</span><a href="#local-6989586621679575884"><span class="hs-identifier hs-var hs-var hs-var hs-var">toList</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Semigroup.Internal.html#Sum"><span class="hs-identifier hs-type">Sum</span></a></span><span> </span><span id="local-6989586621679575883"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575883"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575883"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-842"></span><span>
</span><span id="line-843"></span><span class="hs-comment">-- | @since 4.8.0.0</span><span>
</span><span id="line-844"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679575878"><span id="local-6989586621679575881"><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="Data.Semigroup.Internal.html#Product"><span class="hs-identifier hs-type">Product</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-845"></span><span>    </span><span id="local-6989586621679575861"><span class="annot"><span class="annottext">foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Product a -&gt; m
</span><a href="#local-6989586621679575861"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap</span></a></span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">coerce :: forall a b. Coercible a b =&gt; a -&gt; b
</span><a href="../../ghc-prim-0.8.0/src/GHC-Prim.html#coerce"><span class="hs-identifier hs-type">coerce</span></a></span><span>
</span><span id="line-846"></span><span>
</span><span id="line-847"></span><span>    </span><span id="local-6989586621679575857"><span class="annot"><span class="annottext">elem :: forall a. Eq a =&gt; a -&gt; Product a -&gt; Bool
</span><a href="#local-6989586621679575857"><span class="hs-identifier hs-var hs-var hs-var hs-var">elem</span></a></span></span><span>                  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Product a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getProduct"><span class="hs-identifier hs-var">getProduct</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Classes.html#%3D%3D"><span class="hs-operator hs-var">(==)</span></a></span><span>
</span><span id="line-848"></span><span>    </span><span id="local-6989586621679575855"><span class="annot"><span class="annottext">foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Product a -&gt; b
</span><a href="#local-6989586621679575855"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl</span></a></span></span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">coerce :: forall a b. Coercible a b =&gt; a -&gt; b
</span><a href="../../ghc-prim-0.8.0/src/GHC-Prim.html#coerce"><span class="hs-identifier hs-type">coerce</span></a></span><span>
</span><span id="line-849"></span><span>    </span><span id="local-6989586621679575853"><span class="annot"><span class="annottext">foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Product a -&gt; b
</span><a href="#local-6989586621679575853"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl'</span></a></span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">coerce :: forall a b. Coercible a b =&gt; a -&gt; b
</span><a href="../../ghc-prim-0.8.0/src/GHC-Prim.html#coerce"><span class="hs-identifier hs-type">coerce</span></a></span><span>
</span><span id="line-850"></span><span>    </span><span id="local-6989586621679575852"><span class="annot"><span class="annottext">foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Product a -&gt; a
</span><a href="#local-6989586621679575852"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl1</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Product a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getProduct"><span class="hs-identifier hs-var">getProduct</span></a></span><span>
</span><span id="line-851"></span><span>    </span><span id="local-6989586621679575851"><span class="annot"><span class="annottext">foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Product a -&gt; b
</span><a href="#local-6989586621679575851"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr</span></a></span></span><span> </span><span id="local-6989586621679575850"><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679575850"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679575849"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575849"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Semigroup.Internal.html#Product"><span class="hs-identifier hs-type">Product</span></a></span><span> </span><span id="local-6989586621679575848"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575848"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679575850"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575848"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575849"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-852"></span><span>    </span><span id="local-6989586621679575846"><span class="annot"><span class="annottext">foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Product a -&gt; b
</span><a href="#local-6989586621679575846"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr'</span></a></span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span>
</span><span id="line-853"></span><span>    </span><span id="local-6989586621679575845"><span class="annot"><span class="annottext">foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Product a -&gt; a
</span><a href="#local-6989586621679575845"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr1</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Product a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getProduct"><span class="hs-identifier hs-var">getProduct</span></a></span><span>
</span><span id="line-854"></span><span>    </span><span id="local-6989586621679575844"><span class="annot"><span class="annottext">length :: forall a. Product a -&gt; Int
</span><a href="#local-6989586621679575844"><span class="hs-identifier hs-var hs-var hs-var hs-var">length</span></a></span></span><span> </span><span class="annot"><span class="annottext">Product a
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-855"></span><span>    </span><span id="local-6989586621679575842"><span class="annot"><span class="annottext">maximum :: forall a. Ord a =&gt; Product a -&gt; a
</span><a href="#local-6989586621679575842"><span class="hs-identifier hs-var hs-var hs-var hs-var">maximum</span></a></span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Product a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getProduct"><span class="hs-identifier hs-var">getProduct</span></a></span><span>
</span><span id="line-856"></span><span>    </span><span id="local-6989586621679575840"><span class="annot"><span class="annottext">minimum :: forall a. Ord a =&gt; Product a -&gt; a
</span><a href="#local-6989586621679575840"><span class="hs-identifier hs-var hs-var hs-var hs-var">minimum</span></a></span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Product a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getProduct"><span class="hs-identifier hs-var">getProduct</span></a></span><span>
</span><span id="line-857"></span><span>    </span><span id="local-6989586621679575839"><span class="annot"><span class="annottext">null :: forall a. Product a -&gt; Bool
</span><a href="#local-6989586621679575839"><span class="hs-identifier hs-var hs-var hs-var hs-var">null</span></a></span></span><span> </span><span class="annot"><span class="annottext">Product a
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-858"></span><span>    </span><span id="local-6989586621679575837"><span class="annot"><span class="annottext">product :: forall a. Num a =&gt; Product a -&gt; a
</span><a href="#local-6989586621679575837"><span class="hs-identifier hs-var hs-var hs-var hs-var">product</span></a></span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Product a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getProduct"><span class="hs-identifier hs-var">getProduct</span></a></span><span>
</span><span id="line-859"></span><span>    </span><span id="local-6989586621679575835"><span class="annot"><span class="annottext">sum :: forall a. Num a =&gt; Product a -&gt; a
</span><a href="#local-6989586621679575835"><span class="hs-identifier hs-var hs-var hs-var hs-var">sum</span></a></span></span><span>                   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Product a -&gt; a
</span><a href="Data.Semigroup.Internal.html#getProduct"><span class="hs-identifier hs-var">getProduct</span></a></span><span>
</span><span id="line-860"></span><span>    </span><span id="local-6989586621679575834"><span class="annot"><span class="annottext">toList :: forall a. Product a -&gt; [a]
</span><a href="#local-6989586621679575834"><span class="hs-identifier hs-var hs-var hs-var hs-var">toList</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Semigroup.Internal.html#Product"><span class="hs-identifier hs-type">Product</span></a></span><span> </span><span id="local-6989586621679575833"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575833"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575833"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-861"></span><span>
</span><span id="line-862"></span><span class="hs-comment">-- | @since 4.8.0.0</span><span>
</span><span id="line-863"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679575800"><span id="local-6989586621679575802"><span id="local-6989586621679575804"><span id="local-6989586621679575806"><span id="local-6989586621679575808"><span id="local-6989586621679575810"><span id="local-6989586621679575812"><span id="local-6989586621679575814"><span id="local-6989586621679575816"><span id="local-6989586621679575818"><span id="local-6989586621679575820"><span id="local-6989586621679575822"><span id="local-6989586621679575824"><span id="local-6989586621679575826"><span id="local-6989586621679575828"><span id="local-6989586621679575831"><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="Data.Monoid.html#First"><span class="hs-identifier hs-type">First</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-864"></span><span>    </span><span id="local-6989586621679575796"><span class="annot"><span class="annottext">foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; First a -&gt; m
</span><a href="#local-6989586621679575796"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap</span></a></span></span><span> </span><span id="local-6989586621679575795"><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679575795"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var">foldMap</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679575795"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. First a -&gt; Maybe a
</span><a href="Data.Monoid.html#getFirst"><span class="hs-identifier hs-var">getFirst</span></a></span><span>
</span><span id="line-865"></span><span>
</span><span id="line-866"></span><span class="hs-comment">-- | @since 4.8.0.0</span><span>
</span><span id="line-867"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679575761"><span id="local-6989586621679575763"><span id="local-6989586621679575765"><span id="local-6989586621679575767"><span id="local-6989586621679575769"><span id="local-6989586621679575771"><span id="local-6989586621679575773"><span id="local-6989586621679575775"><span id="local-6989586621679575777"><span id="local-6989586621679575779"><span id="local-6989586621679575781"><span id="local-6989586621679575783"><span id="local-6989586621679575785"><span id="local-6989586621679575787"><span id="local-6989586621679575789"><span id="local-6989586621679575792"><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="Data.Monoid.html#Last"><span class="hs-identifier hs-type">Last</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-868"></span><span>    </span><span id="local-6989586621679575757"><span class="annot"><span class="annottext">foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Last a -&gt; m
</span><a href="#local-6989586621679575757"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap</span></a></span></span><span> </span><span id="local-6989586621679575756"><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679575756"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var">foldMap</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679575756"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Last a -&gt; Maybe a
</span><a href="Data.Monoid.html#getLast"><span class="hs-identifier hs-var">getLast</span></a></span><span>
</span><span id="line-869"></span><span>
</span><span id="line-870"></span><span class="hs-comment">-- | @since 4.12.0.0</span><span>
</span><span id="line-871"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679575722"><span id="local-6989586621679575724"><span id="local-6989586621679575726"><span id="local-6989586621679575728"><span id="local-6989586621679575730"><span id="local-6989586621679575732"><span id="local-6989586621679575734"><span id="local-6989586621679575736"><span id="local-6989586621679575738"><span id="local-6989586621679575740"><span id="local-6989586621679575742"><span id="local-6989586621679575744"><span id="local-6989586621679575746"><span id="local-6989586621679575748"><span id="local-6989586621679575750"><span id="local-6989586621679575753"><span id="local-6989586621679577505"><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577505"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Semigroup.Internal.html#Alt"><span class="hs-identifier hs-type">Alt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577505"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-872"></span><span>    </span><span id="local-6989586621679575718"><span class="annot"><span class="annottext">foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Alt f a -&gt; m
</span><a href="#local-6989586621679575718"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap</span></a></span></span><span> </span><span id="local-6989586621679575717"><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679575717"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var">foldMap</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679575717"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall {k} (f :: k -&gt; *) (a :: k). Alt f a -&gt; f a
</span><a href="Data.Semigroup.Internal.html#getAlt"><span class="hs-identifier hs-var">getAlt</span></a></span><span>
</span><span id="line-873"></span><span>
</span><span id="line-874"></span><span class="hs-comment">-- | @since 4.12.0.0</span><span>
</span><span id="line-875"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679575683"><span id="local-6989586621679575685"><span id="local-6989586621679575687"><span id="local-6989586621679575689"><span id="local-6989586621679575691"><span id="local-6989586621679575693"><span id="local-6989586621679575695"><span id="local-6989586621679575697"><span id="local-6989586621679575699"><span id="local-6989586621679575701"><span id="local-6989586621679575703"><span id="local-6989586621679575705"><span id="local-6989586621679575707"><span id="local-6989586621679575709"><span id="local-6989586621679575711"><span id="local-6989586621679575714"><span id="local-6989586621679577499"><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577499"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Monoid.html#Ap"><span class="hs-identifier hs-type">Ap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577499"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-876"></span><span>    </span><span id="local-6989586621679575679"><span class="annot"><span class="annottext">foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Ap f a -&gt; m
</span><a href="#local-6989586621679575679"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap</span></a></span></span><span> </span><span id="local-6989586621679575678"><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679575678"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var">foldMap</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><a href="#local-6989586621679575678"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall {k} (f :: k -&gt; *) (a :: k). Ap f a -&gt; f a
</span><a href="Data.Monoid.html#getAp"><span class="hs-identifier hs-var">getAp</span></a></span><span>
</span><span id="line-877"></span><span>
</span><span id="line-878"></span><span class="hs-comment">-- Instances for GHC.Generics</span><span>
</span><span id="line-879"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-880"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679575656"><span id="local-6989586621679575658"><span id="local-6989586621679575663"><span id="local-6989586621679575667"><span id="local-6989586621679575670"><span id="local-6989586621679575673"><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#U1"><span class="hs-identifier hs-type">U1</span></a></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-881"></span><span>    </span><span id="local-6989586621679575651"><span class="annot"><span class="annottext">foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; U1 a -&gt; m
</span><a href="#local-6989586621679575651"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldMap</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">U1 a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Monoid a =&gt; a
</span><a href="GHC.Base.html#mempty"><span class="hs-identifier hs-var">mempty</span></a></span><span>
</span><span id="line-882"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#foldMap"><span class="hs-pragma hs-type">foldMap</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-883"></span><span>    </span><span id="local-6989586621679575648"><span class="annot"><span class="annottext">fold :: forall m. Monoid m =&gt; U1 m -&gt; m
</span><a href="#local-6989586621679575648"><span class="hs-identifier hs-var hs-var hs-var hs-var">fold</span></a></span></span><span> </span><span class="annot"><span class="annottext">U1 m
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Monoid a =&gt; a
</span><a href="GHC.Base.html#mempty"><span class="hs-identifier hs-var">mempty</span></a></span><span>
</span><span id="line-884"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#fold"><span class="hs-pragma hs-type">fold</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-885"></span><span>    </span><span id="local-6989586621679575647"><span class="annot"><span class="annottext">foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; U1 a -&gt; b
</span><a href="#local-6989586621679575647"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679575646"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575646"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="annot"><span class="annottext">U1 a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575646"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-886"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#foldr"><span class="hs-pragma hs-type">foldr</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-887"></span><span>    </span><span id="local-6989586621679575645"><span class="annot"><span class="annottext">foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; U1 a -&gt; b
</span><a href="#local-6989586621679575645"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl</span></a></span></span><span> </span><span class="annot"><span class="annottext">b -&gt; a -&gt; b
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679575644"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575644"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="annot"><span class="annottext">U1 a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575644"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-888"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#foldl"><span class="hs-pragma hs-type">foldl</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-889"></span><span>    </span><span id="local-6989586621679575643"><span class="annot"><span class="annottext">foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; U1 a -&gt; a
</span><a href="#local-6989586621679575643"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldl1</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">U1 a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [Char] -&gt; a
</span><a href="GHC.Err.html#errorWithoutStackTrace"><span class="hs-identifier hs-var">errorWithoutStackTrace</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;foldl1: U1&quot;</span></span><span>
</span><span id="line-890"></span><span>    </span><span id="local-6989586621679575642"><span class="annot"><span class="annottext">foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; U1 a -&gt; a
</span><a href="#local-6989586621679575642"><span class="hs-identifier hs-var hs-var hs-var hs-var">foldr1</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">U1 a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [Char] -&gt; a
</span><a href="GHC.Err.html#errorWithoutStackTrace"><span class="hs-identifier hs-var">errorWithoutStackTrace</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;foldr1: U1&quot;</span></span><span>
</span><span id="line-891"></span><span>    </span><span id="local-6989586621679575641"><span class="annot"><span class="annottext">length :: forall a. U1 a -&gt; Int
</span><a href="#local-6989586621679575641"><span class="hs-identifier hs-var hs-var hs-var hs-var">length</span></a></span></span><span> </span><span class="annot"><span class="annottext">U1 a
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-892"></span><span>    </span><span id="local-6989586621679575640"><span class="annot"><span class="annottext">null :: forall a. U1 a -&gt; Bool
</span><a href="#local-6989586621679575640"><span class="hs-identifier hs-var hs-var hs-var hs-var">null</span></a></span></span><span> </span><span class="annot"><span class="annottext">U1 a
</span><span class="hs-identifier">_</span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#True"><span class="hs-identifier hs-var">True</span></a></span><span>
</span><span id="line-893"></span><span>    </span><span id="local-6989586621679575638"><span class="annot"><span class="annottext">elem :: forall a. Eq a =&gt; a -&gt; U1 a -&gt; Bool
</span><a href="#local-6989586621679575638"><span class="hs-identifier hs-var hs-var hs-var hs-var">elem</span></a></span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">U1 a
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#False"><span class="hs-identifier hs-var">False</span></a></span><span>
</span><span id="line-894"></span><span>    </span><span id="local-6989586621679575635"><span class="annot"><span class="annottext">sum :: forall a. Num a =&gt; U1 a -&gt; a
</span><a href="#local-6989586621679575635"><span class="hs-identifier hs-var hs-var hs-var hs-var">sum</span></a></span></span><span> </span><span class="annot"><span class="annottext">U1 a
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-number">0</span></span><span>
</span><span id="line-895"></span><span>    </span><span id="local-6989586621679575632"><span class="annot"><span class="annottext">product :: forall a. Num a =&gt; U1 a -&gt; a
</span><a href="#local-6989586621679575632"><span class="hs-identifier hs-var hs-var hs-var hs-var">product</span></a></span></span><span> </span><span class="annot"><span class="annottext">U1 a
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-number">1</span></span><span>
</span><span id="line-896"></span><span>
</span><span id="line-897"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-898"></span><span id="local-6989586621679575596"><span id="local-6989586621679575598"><span id="local-6989586621679575600"><span id="local-6989586621679575602"><span id="local-6989586621679575604"><span id="local-6989586621679575606"><span id="local-6989586621679575608"><span id="local-6989586621679575610"><span id="local-6989586621679575612"><span id="local-6989586621679575614"><span id="local-6989586621679575616"><span id="local-6989586621679575618"><span id="local-6989586621679575620"><span id="local-6989586621679575622"><span id="local-6989586621679575624"><span id="local-6989586621679575628"><span id="local-6989586621679575630"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#V1"><span class="hs-identifier hs-type">V1</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-899"></span><span>
</span><span id="line-900"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-901"></span><span id="local-6989586621679575561"><span id="local-6989586621679575563"><span id="local-6989586621679575565"><span id="local-6989586621679575567"><span id="local-6989586621679575569"><span id="local-6989586621679575571"><span id="local-6989586621679575573"><span id="local-6989586621679575575"><span id="local-6989586621679575577"><span id="local-6989586621679575579"><span id="local-6989586621679575581"><span id="local-6989586621679575583"><span id="local-6989586621679575585"><span id="local-6989586621679575587"><span id="local-6989586621679575589"><span id="local-6989586621679575592"><span id="local-6989586621679575594"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#Par1"><span class="hs-identifier hs-type">Par1</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-902"></span><span>
</span><span id="line-903"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-904"></span><span id="local-6989586621679575522"><span id="local-6989586621679575524"><span id="local-6989586621679575526"><span id="local-6989586621679575528"><span id="local-6989586621679575530"><span id="local-6989586621679575532"><span id="local-6989586621679575535"><span id="local-6989586621679575537"><span id="local-6989586621679575539"><span id="local-6989586621679575541"><span id="local-6989586621679575543"><span id="local-6989586621679575545"><span id="local-6989586621679575547"><span id="local-6989586621679575550"><span id="local-6989586621679575552"><span id="local-6989586621679575557"><span id="local-6989586621679575559"><span id="local-6989586621679577476"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577476"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Generics.html#Rec1"><span class="hs-identifier hs-type">Rec1</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577476"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-905"></span><span>
</span><span id="line-906"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-907"></span><span id="local-6989586621679575486"><span id="local-6989586621679575488"><span id="local-6989586621679575490"><span id="local-6989586621679575492"><span id="local-6989586621679575494"><span id="local-6989586621679575496"><span id="local-6989586621679575498"><span id="local-6989586621679575500"><span id="local-6989586621679575502"><span id="local-6989586621679575504"><span id="local-6989586621679575506"><span id="local-6989586621679575508"><span id="local-6989586621679575510"><span id="local-6989586621679575512"><span id="local-6989586621679575514"><span id="local-6989586621679575518"><span id="local-6989586621679575520"><span id="local-6989586621679577473"><span id="local-6989586621679577474"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Generics.html#K1"><span class="hs-identifier hs-type">K1</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577474"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577473"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-908"></span><span>
</span><span id="line-909"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-910"></span><span id="local-6989586621679575447"><span id="local-6989586621679575449"><span id="local-6989586621679575451"><span id="local-6989586621679575453"><span id="local-6989586621679575455"><span id="local-6989586621679575457"><span id="local-6989586621679575460"><span id="local-6989586621679575462"><span id="local-6989586621679575464"><span id="local-6989586621679575466"><span id="local-6989586621679575468"><span id="local-6989586621679575470"><span id="local-6989586621679575472"><span id="local-6989586621679575475"><span id="local-6989586621679575477"><span id="local-6989586621679575482"><span id="local-6989586621679575484"><span id="local-6989586621679577468"><span id="local-6989586621679577469"><span id="local-6989586621679577470"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577470"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Generics.html#M1"><span class="hs-identifier hs-type">M1</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577469"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577468"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577470"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-911"></span><span>
</span><span id="line-912"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-913"></span><span id="local-6989586621679575404"><span id="local-6989586621679575406"><span id="local-6989586621679575408"><span id="local-6989586621679575410"><span id="local-6989586621679575412"><span id="local-6989586621679575414"><span id="local-6989586621679575418"><span id="local-6989586621679575420"><span id="local-6989586621679575422"><span id="local-6989586621679575424"><span id="local-6989586621679575426"><span id="local-6989586621679575428"><span id="local-6989586621679575430"><span id="local-6989586621679575434"><span id="local-6989586621679575436"><span id="local-6989586621679575443"><span id="local-6989586621679575445"><span id="local-6989586621679577465"><span id="local-6989586621679577466"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577466"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577465"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577466"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#%3A%2B%3A"><span class="hs-operator hs-type">:+:</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577465"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-914"></span><span>
</span><span id="line-915"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-916"></span><span id="local-6989586621679575360"><span id="local-6989586621679575362"><span id="local-6989586621679575364"><span id="local-6989586621679575366"><span id="local-6989586621679575368"><span id="local-6989586621679575370"><span id="local-6989586621679575374"><span id="local-6989586621679575376"><span id="local-6989586621679575378"><span id="local-6989586621679575380"><span id="local-6989586621679575382"><span id="local-6989586621679575384"><span id="local-6989586621679575386"><span id="local-6989586621679575390"><span id="local-6989586621679575392"><span id="local-6989586621679575400"><span id="local-6989586621679575402"><span id="local-6989586621679577462"><span id="local-6989586621679577463"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577463"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577462"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577463"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#%3A%2A%3A"><span class="hs-operator hs-type">:*:</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577462"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-917"></span><span>
</span><span id="line-918"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-919"></span><span id="local-6989586621679575317"><span id="local-6989586621679575319"><span id="local-6989586621679575321"><span id="local-6989586621679575323"><span id="local-6989586621679575325"><span id="local-6989586621679575327"><span id="local-6989586621679575331"><span id="local-6989586621679575333"><span id="local-6989586621679575335"><span id="local-6989586621679575337"><span id="local-6989586621679575339"><span id="local-6989586621679575341"><span id="local-6989586621679575343"><span id="local-6989586621679575347"><span id="local-6989586621679575349"><span id="local-6989586621679575356"><span id="local-6989586621679575358"><span id="local-6989586621679577459"><span id="local-6989586621679577460"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577460"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577459"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577460"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#%3A.%3A"><span class="hs-operator hs-type">:.:</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577459"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-920"></span><span>
</span><span id="line-921"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-922"></span><span id="local-6989586621679575281"><span id="local-6989586621679575283"><span id="local-6989586621679575285"><span id="local-6989586621679575287"><span id="local-6989586621679575289"><span id="local-6989586621679575291"><span id="local-6989586621679575293"><span id="local-6989586621679575295"><span id="local-6989586621679575297"><span id="local-6989586621679575299"><span id="local-6989586621679575301"><span id="local-6989586621679575303"><span id="local-6989586621679575305"><span id="local-6989586621679575307"><span id="local-6989586621679575309"><span id="local-6989586621679575313"><span id="local-6989586621679575315"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#UAddr"><span class="hs-identifier hs-type">UAddr</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-923"></span><span>
</span><span id="line-924"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-925"></span><span id="local-6989586621679575245"><span id="local-6989586621679575247"><span id="local-6989586621679575249"><span id="local-6989586621679575251"><span id="local-6989586621679575253"><span id="local-6989586621679575255"><span id="local-6989586621679575257"><span id="local-6989586621679575259"><span id="local-6989586621679575261"><span id="local-6989586621679575263"><span id="local-6989586621679575265"><span id="local-6989586621679575267"><span id="local-6989586621679575269"><span id="local-6989586621679575271"><span id="local-6989586621679575273"><span id="local-6989586621679575277"><span id="local-6989586621679575279"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#UChar"><span class="hs-identifier hs-type">UChar</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-926"></span><span>
</span><span id="line-927"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-928"></span><span id="local-6989586621679575209"><span id="local-6989586621679575211"><span id="local-6989586621679575213"><span id="local-6989586621679575215"><span id="local-6989586621679575217"><span id="local-6989586621679575219"><span id="local-6989586621679575221"><span id="local-6989586621679575223"><span id="local-6989586621679575225"><span id="local-6989586621679575227"><span id="local-6989586621679575229"><span id="local-6989586621679575231"><span id="local-6989586621679575233"><span id="local-6989586621679575235"><span id="local-6989586621679575237"><span id="local-6989586621679575241"><span id="local-6989586621679575243"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#UDouble"><span class="hs-identifier hs-type">UDouble</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-929"></span><span>
</span><span id="line-930"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-931"></span><span id="local-6989586621679575173"><span id="local-6989586621679575175"><span id="local-6989586621679575177"><span id="local-6989586621679575179"><span id="local-6989586621679575181"><span id="local-6989586621679575183"><span id="local-6989586621679575185"><span id="local-6989586621679575187"><span id="local-6989586621679575189"><span id="local-6989586621679575191"><span id="local-6989586621679575193"><span id="local-6989586621679575195"><span id="local-6989586621679575197"><span id="local-6989586621679575199"><span id="local-6989586621679575201"><span id="local-6989586621679575205"><span id="local-6989586621679575207"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#UFloat"><span class="hs-identifier hs-type">UFloat</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-932"></span><span>
</span><span id="line-933"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-934"></span><span id="local-6989586621679575137"><span id="local-6989586621679575139"><span id="local-6989586621679575141"><span id="local-6989586621679575143"><span id="local-6989586621679575145"><span id="local-6989586621679575147"><span id="local-6989586621679575149"><span id="local-6989586621679575151"><span id="local-6989586621679575153"><span id="local-6989586621679575155"><span id="local-6989586621679575157"><span id="local-6989586621679575159"><span id="local-6989586621679575161"><span id="local-6989586621679575163"><span id="local-6989586621679575165"><span id="local-6989586621679575169"><span id="local-6989586621679575171"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#UInt"><span class="hs-identifier hs-type">UInt</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-935"></span><span>
</span><span id="line-936"></span><span class="hs-comment">-- | @since 4.9.0.0</span><span>
</span><span id="line-937"></span><span id="local-6989586621679575101"><span id="local-6989586621679575103"><span id="local-6989586621679575105"><span id="local-6989586621679575107"><span id="local-6989586621679575109"><span id="local-6989586621679575111"><span id="local-6989586621679575113"><span id="local-6989586621679575115"><span id="local-6989586621679575117"><span id="local-6989586621679575119"><span id="local-6989586621679575121"><span id="local-6989586621679575123"><span id="local-6989586621679575125"><span id="local-6989586621679575127"><span id="local-6989586621679575129"><span id="local-6989586621679575133"><span id="local-6989586621679575135"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#UWord"><span class="hs-identifier hs-type">UWord</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-938"></span><span>
</span><span id="line-939"></span><span class="hs-comment">-- Instances for Data.Ord</span><span>
</span><span id="line-940"></span><span class="hs-comment">-- | @since 4.12.0.0</span><span>
</span><span id="line-941"></span><span id="local-6989586621679575066"><span id="local-6989586621679575068"><span id="local-6989586621679575070"><span id="local-6989586621679575072"><span id="local-6989586621679575074"><span id="local-6989586621679575076"><span id="local-6989586621679575078"><span id="local-6989586621679575080"><span id="local-6989586621679575082"><span id="local-6989586621679575084"><span id="local-6989586621679575086"><span id="local-6989586621679575088"><span id="local-6989586621679575090"><span id="local-6989586621679575092"><span id="local-6989586621679575094"><span id="local-6989586621679575097"><span id="local-6989586621679575099"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="Data.Ord.html#Down"><span class="hs-identifier hs-type">Down</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-942"></span><span>
</span><span id="line-943"></span><span class="hs-comment">-- | Right-to-left monadic fold over the elements of a structure.</span><span>
</span><span id="line-944"></span><span class="hs-comment">--</span><span>
</span><span id="line-945"></span><span class="hs-comment">-- Given a structure @t@ with elements @(a, b, c, ..., x, y)@, the result of</span><span>
</span><span id="line-946"></span><span class="hs-comment">-- a fold with an operator function @f@ is equivalent to:</span><span>
</span><span id="line-947"></span><span class="hs-comment">--</span><span>
</span><span id="line-948"></span><span class="hs-comment">-- &gt; foldrM f z t = do</span><span>
</span><span id="line-949"></span><span class="hs-comment">-- &gt;     yy &lt;- f y z</span><span>
</span><span id="line-950"></span><span class="hs-comment">-- &gt;     xx &lt;- f x yy</span><span>
</span><span id="line-951"></span><span class="hs-comment">-- &gt;     ...</span><span>
</span><span id="line-952"></span><span class="hs-comment">-- &gt;     bb &lt;- f b cc</span><span>
</span><span id="line-953"></span><span class="hs-comment">-- &gt;     aa &lt;- f a bb</span><span>
</span><span id="line-954"></span><span class="hs-comment">-- &gt;     return aa -- Just @return z@ when the structure is empty</span><span>
</span><span id="line-955"></span><span class="hs-comment">--</span><span>
</span><span id="line-956"></span><span class="hs-comment">-- For a Monad @m@, given two functions @f1 :: a -&gt; m b@ and @f2 :: b -&gt; m c@,</span><span>
</span><span id="line-957"></span><span class="hs-comment">-- their Kleisli composition @(f1 &gt;=&gt; f2) :: a -&gt; m c@ is defined by:</span><span>
</span><span id="line-958"></span><span class="hs-comment">--</span><span>
</span><span id="line-959"></span><span class="hs-comment">-- &gt; (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2</span><span>
</span><span id="line-960"></span><span class="hs-comment">--</span><span>
</span><span id="line-961"></span><span class="hs-comment">-- Another way of thinking about @foldrM@ is that it amounts to an application</span><span>
</span><span id="line-962"></span><span class="hs-comment">-- to @z@ of a Kleisli composition:</span><span>
</span><span id="line-963"></span><span class="hs-comment">--</span><span>
</span><span id="line-964"></span><span class="hs-comment">-- &gt; foldrM f z t = f y &gt;=&gt; f x &gt;=&gt; ... &gt;=&gt; f b &gt;=&gt; f a $ z</span><span>
</span><span id="line-965"></span><span class="hs-comment">--</span><span>
</span><span id="line-966"></span><span class="hs-comment">-- The monadic effects of @foldrM@ are sequenced from right to left, and e.g.</span><span>
</span><span id="line-967"></span><span class="hs-comment">-- folds of infinite lists will diverge.</span><span>
</span><span id="line-968"></span><span class="hs-comment">--</span><span>
</span><span id="line-969"></span><span class="hs-comment">-- If at some step the bind operator @('&gt;&gt;=')@ short-circuits (as with, e.g.,</span><span>
</span><span id="line-970"></span><span class="hs-comment">-- 'mzero' in a 'MonadPlus'), the evaluated effects will be from a tail of the</span><span>
</span><span id="line-971"></span><span class="hs-comment">-- element sequence.  If you want to evaluate the monadic effects in</span><span>
</span><span id="line-972"></span><span class="hs-comment">-- left-to-right order, or perhaps be able to short-circuit after an initial</span><span>
</span><span id="line-973"></span><span class="hs-comment">-- sequence of elements, you'll need to use `foldlM` instead.</span><span>
</span><span id="line-974"></span><span class="hs-comment">--</span><span>
</span><span id="line-975"></span><span class="hs-comment">-- If the monadic effects don't short-circuit, the outermost application of</span><span>
</span><span id="line-976"></span><span class="hs-comment">-- @f@ is to the leftmost element @a@, so that, ignoring effects, the result</span><span>
</span><span id="line-977"></span><span class="hs-comment">-- looks like a right fold:</span><span>
</span><span id="line-978"></span><span class="hs-comment">--</span><span>
</span><span id="line-979"></span><span class="hs-comment">-- &gt; a `f` (b `f` (c `f` (... (x `f` (y `f` z))))).</span><span>
</span><span id="line-980"></span><span class="hs-comment">--</span><span>
</span><span id="line-981"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-982"></span><span class="hs-comment">--</span><span>
</span><span id="line-983"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-984"></span><span class="hs-comment">--</span><span>
</span><span id="line-985"></span><span class="hs-comment">-- &gt;&gt;&gt; let f i acc = do { print i ; return $ i : acc }</span><span>
</span><span id="line-986"></span><span class="hs-comment">-- &gt;&gt;&gt; foldrM f [] [0..3]</span><span>
</span><span id="line-987"></span><span class="hs-comment">-- 3</span><span>
</span><span id="line-988"></span><span class="hs-comment">-- 2</span><span>
</span><span id="line-989"></span><span class="hs-comment">-- 1</span><span>
</span><span id="line-990"></span><span class="hs-comment">-- 0</span><span>
</span><span id="line-991"></span><span class="hs-comment">-- [0,1,2,3]</span><span>
</span><span id="line-992"></span><span class="hs-comment">--</span><span>
</span><span id="line-993"></span><span id="local-6989586621679577448"><span id="local-6989586621679577449"><span id="local-6989586621679577450"><span id="local-6989586621679577451"><span class="annot"><a href="Data.Foldable.html#foldrM"><span class="hs-identifier hs-type">foldrM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577451"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577450"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577449"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577448"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577450"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577448"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577448"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577451"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577449"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577450"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577448"><span class="hs-identifier hs-type">b</span></a></span></span></span></span></span><span>
</span><span id="line-994"></span><span id="foldrM"><span class="annot"><span class="annottext">foldrM :: forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; b -&gt; m b) -&gt; b -&gt; t a -&gt; m b
</span><a href="Data.Foldable.html#foldrM"><span class="hs-identifier hs-var hs-var">foldrM</span></a></span></span><span> </span><span id="local-6989586621679575061"><span class="annot"><span class="annottext">a -&gt; b -&gt; m b
</span><a href="#local-6989586621679575061"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679575060"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575060"><span class="hs-identifier hs-var">z0</span></a></span></span><span> </span><span id="local-6989586621679575059"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679575059"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldl"><span class="hs-identifier hs-var">foldl</span></a></span><span> </span><span class="annot"><span class="annottext">forall {b}. (b -&gt; m b) -&gt; a -&gt; b -&gt; m b
</span><a href="#local-6989586621679575058"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="GHC.Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679575059"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575060"><span class="hs-identifier hs-var">z0</span></a></span><span>
</span><span id="line-995"></span><span>  </span><span class="hs-comment">-- See Note [List fusion and continuations in 'c']</span><span>
</span><span id="line-996"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679575058"><span class="annot"><span class="annottext">c :: (b -&gt; m b) -&gt; a -&gt; b -&gt; m b
</span><a href="#local-6989586621679575058"><span class="hs-identifier hs-var hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679575056"><span class="annot"><span class="annottext">b -&gt; m b
</span><a href="#local-6989586621679575056"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679575055"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575055"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679575054"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575054"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; m b
</span><a href="#local-6989586621679575061"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575055"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575054"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><a href="GHC.Base.html#%3E%3E%3D"><span class="hs-operator hs-var">&gt;&gt;=</span></a></span><span> </span><span class="annot"><span class="annottext">b -&gt; m b
</span><a href="#local-6989586621679575056"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-997"></span><span>        </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="#local-6989586621679575058"><span class="hs-pragma hs-type">c</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-998"></span><span>
</span><span id="line-999"></span><span class="hs-comment">-- | Left-to-right monadic fold over the elements of a structure.</span><span>
</span><span id="line-1000"></span><span class="hs-comment">--</span><span>
</span><span id="line-1001"></span><span class="hs-comment">-- Given a structure @t@ with elements @(a, b, ..., w, x, y)@, the result of</span><span>
</span><span id="line-1002"></span><span class="hs-comment">-- a fold with an operator function @f@ is equivalent to:</span><span>
</span><span id="line-1003"></span><span class="hs-comment">--</span><span>
</span><span id="line-1004"></span><span class="hs-comment">-- &gt; foldlM f z t = do</span><span>
</span><span id="line-1005"></span><span class="hs-comment">-- &gt;     aa &lt;- f z a</span><span>
</span><span id="line-1006"></span><span class="hs-comment">-- &gt;     bb &lt;- f aa b</span><span>
</span><span id="line-1007"></span><span class="hs-comment">-- &gt;     ...</span><span>
</span><span id="line-1008"></span><span class="hs-comment">-- &gt;     xx &lt;- f ww x</span><span>
</span><span id="line-1009"></span><span class="hs-comment">-- &gt;     yy &lt;- f xx y</span><span>
</span><span id="line-1010"></span><span class="hs-comment">-- &gt;     return yy -- Just @return z@ when the structure is empty</span><span>
</span><span id="line-1011"></span><span class="hs-comment">--</span><span>
</span><span id="line-1012"></span><span class="hs-comment">-- For a Monad @m@, given two functions @f1 :: a -&gt; m b@ and @f2 :: b -&gt; m c@,</span><span>
</span><span id="line-1013"></span><span class="hs-comment">-- their Kleisli composition @(f1 &gt;=&gt; f2) :: a -&gt; m c@ is defined by:</span><span>
</span><span id="line-1014"></span><span class="hs-comment">--</span><span>
</span><span id="line-1015"></span><span class="hs-comment">-- &gt; (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2</span><span>
</span><span id="line-1016"></span><span class="hs-comment">--</span><span>
</span><span id="line-1017"></span><span class="hs-comment">-- Another way of thinking about @foldlM@ is that it amounts to an application</span><span>
</span><span id="line-1018"></span><span class="hs-comment">-- to @z@ of a Kleisli composition:</span><span>
</span><span id="line-1019"></span><span class="hs-comment">--</span><span>
</span><span id="line-1020"></span><span class="hs-comment">-- &gt; foldlM f z t =</span><span>
</span><span id="line-1021"></span><span class="hs-comment">-- &gt;     flip f a &gt;=&gt; flip f b &gt;=&gt; ... &gt;=&gt; flip f x &gt;=&gt; flip f y $ z</span><span>
</span><span id="line-1022"></span><span class="hs-comment">--</span><span>
</span><span id="line-1023"></span><span class="hs-comment">-- The monadic effects of @foldlM@ are sequenced from left to right.</span><span>
</span><span id="line-1024"></span><span class="hs-comment">--</span><span>
</span><span id="line-1025"></span><span class="hs-comment">-- If at some step the bind operator @('&gt;&gt;=')@ short-circuits (as with, e.g.,</span><span>
</span><span id="line-1026"></span><span class="hs-comment">-- 'mzero' in a 'MonadPlus'), the evaluated effects will be from an initial</span><span>
</span><span id="line-1027"></span><span class="hs-comment">-- segment of the element sequence.  If you want to evaluate the monadic</span><span>
</span><span id="line-1028"></span><span class="hs-comment">-- effects in right-to-left order, or perhaps be able to short-circuit after</span><span>
</span><span id="line-1029"></span><span class="hs-comment">-- processing a tail of the sequence of elements, you'll need to use `foldrM`</span><span>
</span><span id="line-1030"></span><span class="hs-comment">-- instead.</span><span>
</span><span id="line-1031"></span><span class="hs-comment">--</span><span>
</span><span id="line-1032"></span><span class="hs-comment">-- If the monadic effects don't short-circuit, the outermost application of</span><span>
</span><span id="line-1033"></span><span class="hs-comment">-- @f@ is to the rightmost element @y@, so that, ignoring effects, the result</span><span>
</span><span id="line-1034"></span><span class="hs-comment">-- looks like a left fold:</span><span>
</span><span id="line-1035"></span><span class="hs-comment">--</span><span>
</span><span id="line-1036"></span><span class="hs-comment">-- &gt; ((((z `f` a) `f` b) ... `f` w) `f` x) `f` y</span><span>
</span><span id="line-1037"></span><span class="hs-comment">--</span><span>
</span><span id="line-1038"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1039"></span><span class="hs-comment">--</span><span>
</span><span id="line-1040"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1041"></span><span class="hs-comment">--</span><span>
</span><span id="line-1042"></span><span class="hs-comment">-- &gt;&gt;&gt; let f a e = do { print e ; return $ e : a }</span><span>
</span><span id="line-1043"></span><span class="hs-comment">-- &gt;&gt;&gt; foldlM f [] [0..3]</span><span>
</span><span id="line-1044"></span><span class="hs-comment">-- 0</span><span>
</span><span id="line-1045"></span><span class="hs-comment">-- 1</span><span>
</span><span id="line-1046"></span><span class="hs-comment">-- 2</span><span>
</span><span id="line-1047"></span><span class="hs-comment">-- 3</span><span>
</span><span id="line-1048"></span><span class="hs-comment">-- [3,2,1,0]</span><span>
</span><span id="line-1049"></span><span class="hs-comment">--</span><span>
</span><span id="line-1050"></span><span id="local-6989586621679577435"><span id="local-6989586621679577436"><span id="local-6989586621679577437"><span id="local-6989586621679577438"><span class="annot"><a href="Data.Foldable.html#foldlM"><span class="hs-identifier hs-type">foldlM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577438"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577437"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577436"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577435"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577437"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577436"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577436"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577438"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577435"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577437"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577436"><span class="hs-identifier hs-type">b</span></a></span></span></span></span></span><span>
</span><span id="line-1051"></span><span id="foldlM"><span class="annot"><span class="annottext">foldlM :: forall (t :: * -&gt; *) (m :: * -&gt; *) b a.
(Foldable t, Monad m) =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; t a -&gt; m b
</span><a href="Data.Foldable.html#foldlM"><span class="hs-identifier hs-var hs-var">foldlM</span></a></span></span><span> </span><span id="local-6989586621679575049"><span class="annot"><span class="annottext">b -&gt; a -&gt; m b
</span><a href="#local-6989586621679575049"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679575048"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575048"><span class="hs-identifier hs-var">z0</span></a></span></span><span> </span><span id="local-6989586621679575047"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679575047"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="annot"><span class="annottext">forall {b}. a -&gt; (b -&gt; m b) -&gt; b -&gt; m b
</span><a href="#local-6989586621679575046"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="GHC.Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679575047"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575048"><span class="hs-identifier hs-var">z0</span></a></span><span>
</span><span id="line-1052"></span><span>  </span><span class="hs-comment">-- See Note [List fusion and continuations in 'c']</span><span>
</span><span id="line-1053"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679575046"><span class="annot"><span class="annottext">c :: a -&gt; (b -&gt; m b) -&gt; b -&gt; m b
</span><a href="#local-6989586621679575046"><span class="hs-identifier hs-var hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679575044"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575044"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679575043"><span class="annot"><span class="annottext">b -&gt; m b
</span><a href="#local-6989586621679575043"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679575042"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575042"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b -&gt; a -&gt; m b
</span><a href="#local-6989586621679575049"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679575042"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575044"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><a href="GHC.Base.html#%3E%3E%3D"><span class="hs-operator hs-var">&gt;&gt;=</span></a></span><span> </span><span class="annot"><span class="annottext">b -&gt; m b
</span><a href="#local-6989586621679575043"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1054"></span><span>        </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="#local-6989586621679575046"><span class="hs-pragma hs-type">c</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1055"></span><span>
</span><span id="line-1056"></span><span class="hs-comment">-- | Map each element of a structure to an 'Applicative' action, evaluate these</span><span>
</span><span id="line-1057"></span><span class="hs-comment">-- actions from left to right, and ignore the results.  For a version that</span><span>
</span><span id="line-1058"></span><span class="hs-comment">-- doesn't ignore the results see 'Data.Traversable.traverse'.</span><span>
</span><span id="line-1059"></span><span class="hs-comment">--</span><span>
</span><span id="line-1060"></span><span class="hs-comment">-- 'traverse_' is just like 'mapM_', but generalised to 'Applicative' actions.</span><span>
</span><span id="line-1061"></span><span class="hs-comment">--</span><span>
</span><span id="line-1062"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1063"></span><span class="hs-comment">--</span><span>
</span><span id="line-1064"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1065"></span><span class="hs-comment">--</span><span>
</span><span id="line-1066"></span><span class="hs-comment">-- &gt;&gt;&gt; traverse_ print [&quot;Hello&quot;, &quot;world&quot;, &quot;!&quot;]</span><span>
</span><span id="line-1067"></span><span class="hs-comment">-- &quot;Hello&quot;</span><span>
</span><span id="line-1068"></span><span class="hs-comment">-- &quot;world&quot;</span><span>
</span><span id="line-1069"></span><span class="hs-comment">-- &quot;!&quot;</span><span>
</span><span id="line-1070"></span><span id="local-6989586621679577426"><span id="local-6989586621679577427"><span id="local-6989586621679577428"><span id="local-6989586621679577429"><span class="annot"><a href="Data.Foldable.html#traverse_"><span class="hs-identifier hs-type">traverse_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577429"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577428"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577427"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577428"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577426"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577429"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577427"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577428"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-1071"></span><span id="traverse_"><span class="annot"><span class="annottext">traverse_ :: forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Foldable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f ()
</span><a href="Data.Foldable.html#traverse_"><span class="hs-identifier hs-var hs-var">traverse_</span></a></span></span><span> </span><span id="local-6989586621679575037"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679575037"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="annot"><span class="annottext">forall {b}. a -&gt; f b -&gt; f b
</span><a href="#local-6989586621679575036"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1072"></span><span>  </span><span class="hs-comment">-- See Note [List fusion and continuations in 'c']</span><span>
</span><span id="line-1073"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679575036"><span class="annot"><span class="annottext">c :: a -&gt; f b -&gt; f b
</span><a href="#local-6989586621679575036"><span class="hs-identifier hs-var hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679575034"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575034"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679575033"><span class="annot"><span class="annottext">f b
</span><a href="#local-6989586621679575033"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679575037"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575034"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><a href="GHC.Base.html#%2A%3E"><span class="hs-operator hs-var">*&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">f b
</span><a href="#local-6989586621679575033"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1074"></span><span>        </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="#local-6989586621679575036"><span class="hs-pragma hs-type">c</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1075"></span><span>
</span><span id="line-1076"></span><span class="hs-comment">-- | 'for_' is 'traverse_' with its arguments flipped.  For a version</span><span>
</span><span id="line-1077"></span><span class="hs-comment">-- that doesn't ignore the results see 'Data.Traversable.for'.  This</span><span>
</span><span id="line-1078"></span><span class="hs-comment">-- is 'forM_' generalised to 'Applicative' actions.</span><span>
</span><span id="line-1079"></span><span class="hs-comment">--</span><span>
</span><span id="line-1080"></span><span class="hs-comment">-- 'for_' is just like 'forM_', but generalised to 'Applicative' actions.</span><span>
</span><span id="line-1081"></span><span class="hs-comment">--</span><span>
</span><span id="line-1082"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1083"></span><span class="hs-comment">--</span><span>
</span><span id="line-1084"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1085"></span><span class="hs-comment">--</span><span>
</span><span id="line-1086"></span><span class="hs-comment">-- &gt;&gt;&gt; for_ [1..4] print</span><span>
</span><span id="line-1087"></span><span class="hs-comment">-- 1</span><span>
</span><span id="line-1088"></span><span class="hs-comment">-- 2</span><span>
</span><span id="line-1089"></span><span class="hs-comment">-- 3</span><span>
</span><span id="line-1090"></span><span class="hs-comment">-- 4</span><span>
</span><span id="line-1091"></span><span id="local-6989586621679577413"><span id="local-6989586621679577414"><span id="local-6989586621679577415"><span id="local-6989586621679577416"><span class="annot"><a href="Data.Foldable.html#for_"><span class="hs-identifier hs-type">for_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577416"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577415"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577416"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577414"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577414"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577415"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577413"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577415"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-1092"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#for_"><span class="hs-pragma hs-type">for_</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1093"></span><span id="for_"><span class="annot"><span class="annottext">for_ :: forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Foldable t, Applicative f) =&gt;
t a -&gt; (a -&gt; f b) -&gt; f ()
</span><a href="Data.Foldable.html#for_"><span class="hs-identifier hs-var hs-var">for_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><a href="GHC.Base.html#flip"><span class="hs-identifier hs-var">flip</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Foldable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f ()
</span><a href="Data.Foldable.html#traverse_"><span class="hs-identifier hs-var">traverse_</span></a></span><span>
</span><span id="line-1094"></span><span>
</span><span id="line-1095"></span><span class="hs-comment">-- | Map each element of a structure to a monadic action, evaluate</span><span>
</span><span id="line-1096"></span><span class="hs-comment">-- these actions from left to right, and ignore the results.  For a</span><span>
</span><span id="line-1097"></span><span class="hs-comment">-- version that doesn't ignore the results see</span><span>
</span><span id="line-1098"></span><span class="hs-comment">-- 'Data.Traversable.mapM'.</span><span>
</span><span id="line-1099"></span><span class="hs-comment">--</span><span>
</span><span id="line-1100"></span><span class="hs-comment">-- 'mapM_' is just like 'traverse_', but specialised to monadic actions.</span><span>
</span><span id="line-1101"></span><span class="hs-comment">--</span><span>
</span><span id="line-1102"></span><span id="local-6989586621679577407"><span id="local-6989586621679577408"><span id="local-6989586621679577409"><span id="local-6989586621679577410"><span class="annot"><a href="Data.Foldable.html#mapM_"><span class="hs-identifier hs-type">mapM_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577410"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577409"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577408"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577409"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577407"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577410"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577408"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577409"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-1103"></span><span id="mapM_"><span class="annot"><span class="annottext">mapM_ :: forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><a href="Data.Foldable.html#mapM_"><span class="hs-identifier hs-var hs-var">mapM_</span></a></span></span><span> </span><span id="local-6989586621679575024"><span class="annot"><span class="annottext">a -&gt; m b
</span><a href="#local-6989586621679575024"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="annot"><span class="annottext">forall {b}. a -&gt; m b -&gt; m b
</span><a href="#local-6989586621679575023"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="GHC.Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1104"></span><span>  </span><span class="hs-comment">-- See Note [List fusion and continuations in 'c']</span><span>
</span><span id="line-1105"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679575023"><span class="annot"><span class="annottext">c :: a -&gt; m b -&gt; m b
</span><a href="#local-6989586621679575023"><span class="hs-identifier hs-var hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679575021"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575021"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679575020"><span class="annot"><span class="annottext">m b
</span><a href="#local-6989586621679575020"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; m b
</span><a href="#local-6989586621679575024"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679575021"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><a href="GHC.Base.html#%3E%3E"><span class="hs-operator hs-var">&gt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">m b
</span><a href="#local-6989586621679575020"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1106"></span><span>        </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="#local-6989586621679575023"><span class="hs-pragma hs-type">c</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1107"></span><span>
</span><span id="line-1108"></span><span class="hs-comment">-- | 'forM_' is 'mapM_' with its arguments flipped.  For a version that</span><span>
</span><span id="line-1109"></span><span class="hs-comment">-- doesn't ignore the results see 'Data.Traversable.forM'.</span><span>
</span><span id="line-1110"></span><span class="hs-comment">--</span><span>
</span><span id="line-1111"></span><span class="hs-comment">-- 'forM_' is just like 'for_', but specialised to monadic actions.</span><span>
</span><span id="line-1112"></span><span class="hs-comment">--</span><span>
</span><span id="line-1113"></span><span id="local-6989586621679577396"><span id="local-6989586621679577397"><span id="local-6989586621679577398"><span id="local-6989586621679577399"><span class="annot"><a href="Data.Foldable.html#forM_"><span class="hs-identifier hs-type">forM_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577399"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577398"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577399"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577397"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577397"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577398"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577396"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577398"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-1114"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#forM_"><span class="hs-pragma hs-type">forM_</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1115"></span><span id="forM_"><span class="annot"><span class="annottext">forM_ :: forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m ()
</span><a href="Data.Foldable.html#forM_"><span class="hs-identifier hs-var hs-var">forM_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><a href="GHC.Base.html#flip"><span class="hs-identifier hs-var">flip</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><a href="Data.Foldable.html#mapM_"><span class="hs-identifier hs-var">mapM_</span></a></span><span>
</span><span id="line-1116"></span><span>
</span><span id="line-1117"></span><span class="hs-comment">-- | Evaluate each action in the structure from left to right, and</span><span>
</span><span id="line-1118"></span><span class="hs-comment">-- ignore the results.  For a version that doesn't ignore the results</span><span>
</span><span id="line-1119"></span><span class="hs-comment">-- see 'Data.Traversable.sequenceA'.</span><span>
</span><span id="line-1120"></span><span class="hs-comment">--</span><span>
</span><span id="line-1121"></span><span class="hs-comment">-- 'sequenceA_' is just like 'sequence_', but generalised to 'Applicative'</span><span>
</span><span id="line-1122"></span><span class="hs-comment">-- actions.</span><span>
</span><span id="line-1123"></span><span class="hs-comment">--</span><span>
</span><span id="line-1124"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1125"></span><span class="hs-comment">--</span><span>
</span><span id="line-1126"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1127"></span><span class="hs-comment">--</span><span>
</span><span id="line-1128"></span><span class="hs-comment">-- &gt;&gt;&gt; sequenceA_ [print &quot;Hello&quot;, print &quot;world&quot;, print &quot;!&quot;]</span><span>
</span><span id="line-1129"></span><span class="hs-comment">-- &quot;Hello&quot;</span><span>
</span><span id="line-1130"></span><span class="hs-comment">-- &quot;world&quot;</span><span>
</span><span id="line-1131"></span><span class="hs-comment">-- &quot;!&quot;</span><span>
</span><span id="line-1132"></span><span id="local-6989586621679577391"><span id="local-6989586621679577392"><span id="local-6989586621679577393"><span class="annot"><a href="Data.Foldable.html#sequenceA_"><span class="hs-identifier hs-type">sequenceA_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577393"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577392"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577393"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577392"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577391"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577392"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-1133"></span><span id="sequenceA_"><span class="annot"><span class="annottext">sequenceA_ :: forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Foldable t, Applicative f) =&gt;
t (f a) -&gt; f ()
</span><a href="Data.Foldable.html#sequenceA_"><span class="hs-identifier hs-var hs-var">sequenceA_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="annot"><span class="annottext">forall {f :: * -&gt; *} {a} {b}. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><a href="#local-6989586621679575010"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1134"></span><span>  </span><span class="hs-comment">-- See Note [List fusion and continuations in 'c']</span><span>
</span><span id="line-1135"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679575010"><span class="annot"><span class="annottext">c :: f a -&gt; f b -&gt; f b
</span><a href="#local-6989586621679575010"><span class="hs-identifier hs-var hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679575007"><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679575007"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679575006"><span class="annot"><span class="annottext">f b
</span><a href="#local-6989586621679575006"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679575007"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><a href="GHC.Base.html#%2A%3E"><span class="hs-operator hs-var">*&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">f b
</span><a href="#local-6989586621679575006"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1136"></span><span>        </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="#local-6989586621679575010"><span class="hs-pragma hs-type">c</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1137"></span><span>
</span><span id="line-1138"></span><span class="hs-comment">-- | Evaluate each monadic action in the structure from left to right,</span><span>
</span><span id="line-1139"></span><span class="hs-comment">-- and ignore the results.  For a version that doesn't ignore the</span><span>
</span><span id="line-1140"></span><span class="hs-comment">-- results see 'Data.Traversable.sequence'.</span><span>
</span><span id="line-1141"></span><span class="hs-comment">--</span><span>
</span><span id="line-1142"></span><span class="hs-comment">-- 'sequence_' is just like 'sequenceA_', but specialised to monadic</span><span>
</span><span id="line-1143"></span><span class="hs-comment">-- actions.</span><span>
</span><span id="line-1144"></span><span class="hs-comment">--</span><span>
</span><span id="line-1145"></span><span id="local-6989586621679577383"><span id="local-6989586621679577384"><span id="local-6989586621679577385"><span class="annot"><a href="Data.Foldable.html#sequence_"><span class="hs-identifier hs-type">sequence_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577385"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577384"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577385"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577384"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577383"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577384"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-1146"></span><span id="sequence_"><span class="annot"><span class="annottext">sequence_ :: forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Foldable t, Monad m) =&gt;
t (m a) -&gt; m ()
</span><a href="Data.Foldable.html#sequence_"><span class="hs-identifier hs-var hs-var">sequence_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="annot"><span class="annottext">forall {m :: * -&gt; *} {a} {b}. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><a href="#local-6989586621679575000"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="GHC.Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1147"></span><span>  </span><span class="hs-comment">-- See Note [List fusion and continuations in 'c']</span><span>
</span><span id="line-1148"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679575000"><span class="annot"><span class="annottext">c :: m a -&gt; m b -&gt; m b
</span><a href="#local-6989586621679575000"><span class="hs-identifier hs-var hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679574997"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679574997"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679574996"><span class="annot"><span class="annottext">m b
</span><a href="#local-6989586621679574996"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679574997"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><a href="GHC.Base.html#%3E%3E"><span class="hs-operator hs-var">&gt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">m b
</span><a href="#local-6989586621679574996"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1149"></span><span>        </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="#local-6989586621679575000"><span class="hs-pragma hs-type">c</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1150"></span><span>
</span><span id="line-1151"></span><span class="hs-comment">-- | The sum of a collection of actions, generalizing 'concat'.</span><span>
</span><span id="line-1152"></span><span class="hs-comment">--</span><span>
</span><span id="line-1153"></span><span class="hs-comment">-- 'asum' is just like 'msum', but generalised to 'Alternative'.</span><span>
</span><span id="line-1154"></span><span class="hs-comment">--</span><span>
</span><span id="line-1155"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1156"></span><span class="hs-comment">--</span><span>
</span><span id="line-1157"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1158"></span><span class="hs-comment">--</span><span>
</span><span id="line-1159"></span><span class="hs-comment">-- &gt;&gt;&gt; asum [Just &quot;Hello&quot;, Nothing, Just &quot;World&quot;]</span><span>
</span><span id="line-1160"></span><span class="hs-comment">-- Just &quot;Hello&quot;</span><span>
</span><span id="line-1161"></span><span id="local-6989586621679577374"><span id="local-6989586621679577376"><span id="local-6989586621679577377"><span class="annot"><a href="Data.Foldable.html#asum"><span class="hs-identifier hs-type">asum</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577377"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#Alternative"><span class="hs-identifier hs-type">Alternative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577376"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577377"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577376"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577374"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577376"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577374"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-1162"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#asum"><span class="hs-pragma hs-type">asum</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1163"></span><span id="asum"><span class="annot"><span class="annottext">asum :: forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Foldable t, Alternative f) =&gt;
t (f a) -&gt; f a
</span><a href="Data.Foldable.html#asum"><span class="hs-identifier hs-var hs-var">asum</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><a href="GHC.Base.html#%3C%7C%3E"><span class="hs-operator hs-var">(&lt;|&gt;)</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Alternative f =&gt; f a
</span><a href="GHC.Base.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span>
</span><span id="line-1164"></span><span>
</span><span id="line-1165"></span><span class="hs-comment">-- | The sum of a collection of actions, generalizing 'concat'.</span><span>
</span><span id="line-1166"></span><span class="hs-comment">--</span><span>
</span><span id="line-1167"></span><span class="hs-comment">-- 'msum' is just like 'asum', but specialised to 'MonadPlus'.</span><span>
</span><span id="line-1168"></span><span class="hs-comment">--</span><span>
</span><span id="line-1169"></span><span id="local-6989586621679577365"><span id="local-6989586621679577367"><span id="local-6989586621679577368"><span class="annot"><a href="Data.Foldable.html#msum"><span class="hs-identifier hs-type">msum</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577368"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#MonadPlus"><span class="hs-identifier hs-type">MonadPlus</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577367"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577368"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577367"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577365"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577367"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577365"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-1170"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#msum"><span class="hs-pragma hs-type">msum</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1171"></span><span id="msum"><span class="annot"><span class="annottext">msum :: forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Foldable t, MonadPlus m) =&gt;
t (m a) -&gt; m a
</span><a href="Data.Foldable.html#msum"><span class="hs-identifier hs-var hs-var">msum</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Foldable t, Alternative f) =&gt;
t (f a) -&gt; f a
</span><a href="Data.Foldable.html#asum"><span class="hs-identifier hs-var">asum</span></a></span><span>
</span><span id="line-1172"></span><span>
</span><span id="line-1173"></span><span class="hs-comment">-- | The concatenation of all the elements of a container of lists.</span><span>
</span><span id="line-1174"></span><span class="hs-comment">--</span><span>
</span><span id="line-1175"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1176"></span><span class="hs-comment">--</span><span>
</span><span id="line-1177"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1178"></span><span class="hs-comment">--</span><span>
</span><span id="line-1179"></span><span class="hs-comment">-- &gt;&gt;&gt; concat (Just [1, 2, 3])</span><span>
</span><span id="line-1180"></span><span class="hs-comment">-- [1,2,3]</span><span>
</span><span id="line-1181"></span><span class="hs-comment">--</span><span>
</span><span id="line-1182"></span><span class="hs-comment">-- &gt;&gt;&gt; concat (Left 42)</span><span>
</span><span id="line-1183"></span><span class="hs-comment">-- []</span><span>
</span><span id="line-1184"></span><span class="hs-comment">--</span><span>
</span><span id="line-1185"></span><span class="hs-comment">-- &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]</span><span>
</span><span id="line-1186"></span><span class="hs-comment">-- [1,2,3,4,5,6]</span><span>
</span><span id="line-1187"></span><span id="local-6989586621679577360"><span id="local-6989586621679577361"><span class="annot"><a href="Data.Foldable.html#concat"><span class="hs-identifier hs-type">concat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577361"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577361"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679577360"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679577360"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span>
</span><span id="line-1188"></span><span id="concat"><span class="annot"><span class="annottext">concat :: forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><a href="Data.Foldable.html#concat"><span class="hs-identifier hs-var hs-var">concat</span></a></span></span><span> </span><span id="local-6989586621679574981"><span class="annot"><span class="annottext">t [a]
</span><a href="#local-6989586621679574981"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. (forall b. (a -&gt; b -&gt; b) -&gt; b -&gt; b) -&gt; [a]
</span><a href="GHC.Base.html#build"><span class="hs-identifier hs-var">build</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679574978"><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679574978"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679574977"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679574977"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679574976"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679574976"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679574975"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679574975"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; b
</span><a href="#local-6989586621679574978"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679574975"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679574976"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679574977"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t [a]
</span><a href="#local-6989586621679574981"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1189"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#concat"><span class="hs-pragma hs-type">concat</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1190"></span><span>
</span><span id="line-1191"></span><span class="hs-comment">-- | Map a function over all the elements of a container and concatenate</span><span>
</span><span id="line-1192"></span><span class="hs-comment">-- the resulting lists.</span><span>
</span><span id="line-1193"></span><span class="hs-comment">--</span><span>
</span><span id="line-1194"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1195"></span><span class="hs-comment">--</span><span>
</span><span id="line-1196"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1197"></span><span class="hs-comment">--</span><span>
</span><span id="line-1198"></span><span class="hs-comment">-- &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]</span><span>
</span><span id="line-1199"></span><span class="hs-comment">-- [1,2,3,10,11,12,100,101,102,1000,1001,1002]</span><span>
</span><span id="line-1200"></span><span class="hs-comment">--</span><span>
</span><span id="line-1201"></span><span class="hs-comment">-- &gt;&gt;&gt; concatMap (take 3) (Just [1..])</span><span>
</span><span id="line-1202"></span><span class="hs-comment">-- [1,2,3]</span><span>
</span><span id="line-1203"></span><span id="local-6989586621679577354"><span id="local-6989586621679577355"><span id="local-6989586621679577356"><span class="annot"><a href="Data.Foldable.html#concatMap"><span class="hs-identifier hs-type">concatMap</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577356"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577355"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679577354"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577356"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577355"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679577354"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-1204"></span><span id="concatMap"><span class="annot"><span class="annottext">concatMap :: forall (t :: * -&gt; *) a b. Foldable t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]
</span><a href="Data.Foldable.html#concatMap"><span class="hs-identifier hs-var hs-var">concatMap</span></a></span></span><span> </span><span id="local-6989586621679574973"><span class="annot"><span class="annottext">a -&gt; [b]
</span><a href="#local-6989586621679574973"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679574972"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679574972"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. (forall b. (a -&gt; b -&gt; b) -&gt; b -&gt; b) -&gt; [a]
</span><a href="GHC.Base.html#build"><span class="hs-identifier hs-var">build</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679574969"><span class="annot"><span class="annottext">b -&gt; b -&gt; b
</span><a href="#local-6989586621679574969"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679574968"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679574968"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679574967"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574967"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679574966"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679574966"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="annot"><span class="annottext">b -&gt; b -&gt; b
</span><a href="#local-6989586621679574969"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679574966"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; [b]
</span><a href="#local-6989586621679574973"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574967"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679574968"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679574972"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1205"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Foldable.html#concatMap"><span class="hs-pragma hs-type">concatMap</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1206"></span><span>
</span><span id="line-1207"></span><span class="hs-comment">-- These use foldr rather than foldMap to avoid repeated concatenation.</span><span>
</span><span id="line-1208"></span><span>
</span><span id="line-1209"></span><span class="hs-comment">-- | 'and' returns the conjunction of a container of Bools.  For the</span><span>
</span><span id="line-1210"></span><span class="hs-comment">-- result to be 'True', the container must be finite; 'False', however,</span><span>
</span><span id="line-1211"></span><span class="hs-comment">-- results from a 'False' value finitely far from the left end.</span><span>
</span><span id="line-1212"></span><span class="hs-comment">--</span><span>
</span><span id="line-1213"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1214"></span><span class="hs-comment">--</span><span>
</span><span id="line-1215"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1216"></span><span class="hs-comment">--</span><span>
</span><span id="line-1217"></span><span class="hs-comment">-- &gt;&gt;&gt; and []</span><span>
</span><span id="line-1218"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-1219"></span><span class="hs-comment">--</span><span>
</span><span id="line-1220"></span><span class="hs-comment">-- &gt;&gt;&gt; and [True]</span><span>
</span><span id="line-1221"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-1222"></span><span class="hs-comment">--</span><span>
</span><span id="line-1223"></span><span class="hs-comment">-- &gt;&gt;&gt; and [False]</span><span>
</span><span id="line-1224"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-1225"></span><span class="hs-comment">--</span><span>
</span><span id="line-1226"></span><span class="hs-comment">-- &gt;&gt;&gt; and [True, True, False]</span><span>
</span><span id="line-1227"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-1228"></span><span class="hs-comment">--</span><span>
</span><span id="line-1229"></span><span class="hs-comment">-- &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...</span><span>
</span><span id="line-1230"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-1231"></span><span class="hs-comment">--</span><span>
</span><span id="line-1232"></span><span class="hs-comment">-- &gt;&gt;&gt; and (repeat True)</span><span>
</span><span id="line-1233"></span><span class="hs-comment">-- * Hangs forever *</span><span>
</span><span id="line-1234"></span><span id="local-6989586621679577349"><span class="annot"><a href="Data.Foldable.html#and"><span class="hs-identifier hs-type">and</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577349"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577349"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span></span><span>
</span><span id="line-1235"></span><span id="and"><span class="annot"><span class="annottext">and :: forall (t :: * -&gt; *). Foldable t =&gt; t Bool -&gt; Bool
</span><a href="Data.Foldable.html#and"><span class="hs-identifier hs-var hs-var">and</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">All -&gt; Bool
</span><a href="Data.Semigroup.Internal.html#getAll"><span class="hs-identifier hs-var">getAll</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var">foldMap</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; All
</span><a href="Data.Semigroup.Internal.html#All"><span class="hs-identifier hs-var">All</span></a></span><span>
</span><span id="line-1236"></span><span>
</span><span id="line-1237"></span><span class="hs-comment">-- | 'or' returns the disjunction of a container of Bools.  For the</span><span>
</span><span id="line-1238"></span><span class="hs-comment">-- result to be 'False', the container must be finite; 'True', however,</span><span>
</span><span id="line-1239"></span><span class="hs-comment">-- results from a 'True' value finitely far from the left end.</span><span>
</span><span id="line-1240"></span><span class="hs-comment">--</span><span>
</span><span id="line-1241"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1242"></span><span class="hs-comment">--</span><span>
</span><span id="line-1243"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1244"></span><span class="hs-comment">--</span><span>
</span><span id="line-1245"></span><span class="hs-comment">-- &gt;&gt;&gt; or []</span><span>
</span><span id="line-1246"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-1247"></span><span class="hs-comment">--</span><span>
</span><span id="line-1248"></span><span class="hs-comment">-- &gt;&gt;&gt; or [True]</span><span>
</span><span id="line-1249"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-1250"></span><span class="hs-comment">--</span><span>
</span><span id="line-1251"></span><span class="hs-comment">-- &gt;&gt;&gt; or [False]</span><span>
</span><span id="line-1252"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-1253"></span><span class="hs-comment">--</span><span>
</span><span id="line-1254"></span><span class="hs-comment">-- &gt;&gt;&gt; or [True, True, False]</span><span>
</span><span id="line-1255"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-1256"></span><span class="hs-comment">--</span><span>
</span><span id="line-1257"></span><span class="hs-comment">-- &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...</span><span>
</span><span id="line-1258"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-1259"></span><span class="hs-comment">--</span><span>
</span><span id="line-1260"></span><span class="hs-comment">-- &gt;&gt;&gt; or (repeat False)</span><span>
</span><span id="line-1261"></span><span class="hs-comment">-- * Hangs forever *</span><span>
</span><span id="line-1262"></span><span id="local-6989586621679574958"><span class="annot"><a href="Data.Foldable.html#or"><span class="hs-identifier hs-type">or</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679574958"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679574958"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span></span><span>
</span><span id="line-1263"></span><span id="or"><span class="annot"><span class="annottext">or :: forall (t :: * -&gt; *). Foldable t =&gt; t Bool -&gt; Bool
</span><a href="Data.Foldable.html#or"><span class="hs-identifier hs-var hs-var">or</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Any -&gt; Bool
</span><a href="Data.Semigroup.Internal.html#getAny"><span class="hs-identifier hs-var">getAny</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var">foldMap</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Any
</span><a href="Data.Semigroup.Internal.html#Any"><span class="hs-identifier hs-var">Any</span></a></span><span>
</span><span id="line-1264"></span><span>
</span><span id="line-1265"></span><span class="hs-comment">-- | Determines whether any element of the structure satisfies the predicate.</span><span>
</span><span id="line-1266"></span><span class="hs-comment">--</span><span>
</span><span id="line-1267"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1268"></span><span class="hs-comment">--</span><span>
</span><span id="line-1269"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1270"></span><span class="hs-comment">--</span><span>
</span><span id="line-1271"></span><span class="hs-comment">-- &gt;&gt;&gt; any (&gt; 3) []</span><span>
</span><span id="line-1272"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-1273"></span><span class="hs-comment">--</span><span>
</span><span id="line-1274"></span><span class="hs-comment">-- &gt;&gt;&gt; any (&gt; 3) [1,2]</span><span>
</span><span id="line-1275"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-1276"></span><span class="hs-comment">--</span><span>
</span><span id="line-1277"></span><span class="hs-comment">-- &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]</span><span>
</span><span id="line-1278"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-1279"></span><span class="hs-comment">--</span><span>
</span><span id="line-1280"></span><span class="hs-comment">-- &gt;&gt;&gt; any (&gt; 3) [1..]</span><span>
</span><span id="line-1281"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-1282"></span><span class="hs-comment">--</span><span>
</span><span id="line-1283"></span><span class="hs-comment">-- &gt;&gt;&gt; any (&gt; 3) [0, -1..]</span><span>
</span><span id="line-1284"></span><span class="hs-comment">-- * Hangs forever *</span><span>
</span><span id="line-1285"></span><span id="local-6989586621679577659"><span id="local-6989586621679577660"><span class="annot"><a href="Data.Foldable.html#any"><span class="hs-identifier hs-type">any</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577660"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577659"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577660"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577659"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span></span></span><span>
</span><span id="line-1286"></span><span id="any"><span class="annot"><span class="annottext">any :: forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><a href="Data.Foldable.html#any"><span class="hs-identifier hs-var hs-var">any</span></a></span></span><span> </span><span id="local-6989586621679574945"><span class="annot"><span class="annottext">a -&gt; Bool
</span><a href="#local-6989586621679574945"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Any -&gt; Bool
</span><a href="Data.Semigroup.Internal.html#getAny"><span class="hs-identifier hs-var">getAny</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var">foldMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Any
</span><a href="Data.Semigroup.Internal.html#Any"><span class="hs-identifier hs-var">Any</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; Bool
</span><a href="#local-6989586621679574945"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1287"></span><span>
</span><span id="line-1288"></span><span class="hs-comment">-- | Determines whether all elements of the structure satisfy the predicate.</span><span>
</span><span id="line-1289"></span><span class="hs-comment">--</span><span>
</span><span id="line-1290"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1291"></span><span class="hs-comment">--</span><span>
</span><span id="line-1292"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1293"></span><span class="hs-comment">--</span><span>
</span><span id="line-1294"></span><span class="hs-comment">-- &gt;&gt;&gt; all (&gt; 3) []</span><span>
</span><span id="line-1295"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-1296"></span><span class="hs-comment">--</span><span>
</span><span id="line-1297"></span><span class="hs-comment">-- &gt;&gt;&gt; all (&gt; 3) [1,2]</span><span>
</span><span id="line-1298"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-1299"></span><span class="hs-comment">--</span><span>
</span><span id="line-1300"></span><span class="hs-comment">-- &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]</span><span>
</span><span id="line-1301"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-1302"></span><span class="hs-comment">--</span><span>
</span><span id="line-1303"></span><span class="hs-comment">-- &gt;&gt;&gt; all (&gt; 3) [1..]</span><span>
</span><span id="line-1304"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-1305"></span><span class="hs-comment">--</span><span>
</span><span id="line-1306"></span><span class="hs-comment">-- &gt;&gt;&gt; all (&gt; 3) [4..]</span><span>
</span><span id="line-1307"></span><span class="hs-comment">-- * Hangs forever *</span><span>
</span><span id="line-1308"></span><span id="local-6989586621679574943"><span id="local-6989586621679574944"><span class="annot"><a href="Data.Foldable.html#all"><span class="hs-identifier hs-type">all</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679574944"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679574943"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679574944"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679574943"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span></span></span><span>
</span><span id="line-1309"></span><span id="all"><span class="annot"><span class="annottext">all :: forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><a href="Data.Foldable.html#all"><span class="hs-identifier hs-var hs-var">all</span></a></span></span><span> </span><span id="local-6989586621679574937"><span class="annot"><span class="annottext">a -&gt; Bool
</span><a href="#local-6989586621679574937"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">All -&gt; Bool
</span><a href="Data.Semigroup.Internal.html#getAll"><span class="hs-identifier hs-var">getAll</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var">foldMap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; All
</span><a href="Data.Semigroup.Internal.html#All"><span class="hs-identifier hs-var">All</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; Bool
</span><a href="#local-6989586621679574937"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1310"></span><span>
</span><span id="line-1311"></span><span class="hs-comment">-- | The largest element of a non-empty structure with respect to the</span><span>
</span><span id="line-1312"></span><span class="hs-comment">-- given comparison function.</span><span>
</span><span id="line-1313"></span><span class="hs-comment">--</span><span>
</span><span id="line-1314"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1315"></span><span class="hs-comment">--</span><span>
</span><span id="line-1316"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1317"></span><span class="hs-comment">--</span><span>
</span><span id="line-1318"></span><span class="hs-comment">-- &gt;&gt;&gt; maximumBy (compare `on` length) [&quot;Hello&quot;, &quot;World&quot;, &quot;!&quot;, &quot;Longest&quot;, &quot;bar&quot;]</span><span>
</span><span id="line-1319"></span><span class="hs-comment">-- &quot;Longest&quot;</span><span>
</span><span id="line-1320"></span><span class="hs-comment">--</span><span>
</span><span id="line-1321"></span><span class="hs-comment">-- WARNING: This function is partial for possibly-empty structures like lists.</span><span>
</span><span id="line-1322"></span><span>
</span><span id="line-1323"></span><span class="hs-comment">-- See Note [maximumBy/minimumBy space usage]</span><span>
</span><span id="line-1324"></span><span id="local-6989586621679577339"><span id="local-6989586621679577340"><span class="annot"><a href="Data.Foldable.html#maximumBy"><span class="hs-identifier hs-type">maximumBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577340"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577339"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577339"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Ordering"><span class="hs-identifier hs-type">Ordering</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577340"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577339"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577339"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-1325"></span><span id="maximumBy"><span class="annot"><span class="annottext">maximumBy :: forall (t :: * -&gt; *) a.
Foldable t =&gt;
(a -&gt; a -&gt; Ordering) -&gt; t a -&gt; a
</span><a href="Data.Foldable.html#maximumBy"><span class="hs-identifier hs-var hs-var">maximumBy</span></a></span></span><span> </span><span id="local-6989586621679574934"><span class="annot"><span class="annottext">a -&gt; a -&gt; Ordering
</span><a href="#local-6989586621679574934"><span class="hs-identifier hs-var">cmp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a -&gt; a
</span><a href="Data.Maybe.html#fromMaybe"><span class="hs-identifier hs-var">fromMaybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. [Char] -&gt; a
</span><a href="GHC.Err.html#errorWithoutStackTrace"><span class="hs-identifier hs-var">errorWithoutStackTrace</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;maximumBy: empty structure&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1326"></span><span>  </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldl%27"><span class="hs-identifier hs-var">foldl'</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe a -&gt; a -&gt; Maybe a
</span><a href="#local-6989586621679574933"><span class="hs-identifier hs-var">max'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><a href="GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-1327"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1328"></span><span>    </span><span id="local-6989586621679574933"><span class="annot"><span class="annottext">max' :: Maybe a -&gt; a -&gt; Maybe a
</span><a href="#local-6989586621679574933"><span class="hs-identifier hs-var hs-var">max'</span></a></span></span><span> </span><span id="local-6989586621679574932"><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679574932"><span class="hs-identifier hs-var">mx</span></a></span></span><span> </span><span id="local-6989586621679574931"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574931"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679574932"><span class="hs-identifier hs-var">mx</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1329"></span><span>      </span><span class="annot"><span class="annottext">Maybe a
</span><a href="GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574931"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-1330"></span><span>      </span><span class="annot"><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679574930"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574930"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; Ordering
</span><a href="#local-6989586621679574934"><span class="hs-identifier hs-var">cmp</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574930"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574931"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1331"></span><span>        </span><span class="annot"><span class="annottext">Ordering
</span><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#GT"><span class="hs-identifier hs-var">GT</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574930"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1332"></span><span>        </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574931"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-1333"></span><span class="hs-pragma">{-# INLINEABLE</span><span> </span><span class="annot"><a href="Data.Foldable.html#maximumBy"><span class="hs-pragma hs-type">maximumBy</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1334"></span><span>
</span><span id="line-1335"></span><span class="hs-comment">-- | The least element of a non-empty structure with respect to the</span><span>
</span><span id="line-1336"></span><span class="hs-comment">-- given comparison function.</span><span>
</span><span id="line-1337"></span><span class="hs-comment">--</span><span>
</span><span id="line-1338"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1339"></span><span class="hs-comment">--</span><span>
</span><span id="line-1340"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1341"></span><span class="hs-comment">--</span><span>
</span><span id="line-1342"></span><span class="hs-comment">-- &gt;&gt;&gt; minimumBy (compare `on` length) [&quot;Hello&quot;, &quot;World&quot;, &quot;!&quot;, &quot;Longest&quot;, &quot;bar&quot;]</span><span>
</span><span id="line-1343"></span><span class="hs-comment">-- &quot;!&quot;</span><span>
</span><span id="line-1344"></span><span class="hs-comment">--</span><span>
</span><span id="line-1345"></span><span class="hs-comment">-- WARNING: This function is partial for possibly-empty structures like lists.</span><span>
</span><span id="line-1346"></span><span>
</span><span id="line-1347"></span><span class="hs-comment">-- See Note [maximumBy/minimumBy space usage]</span><span>
</span><span id="line-1348"></span><span id="local-6989586621679574928"><span id="local-6989586621679574929"><span class="annot"><a href="Data.Foldable.html#minimumBy"><span class="hs-identifier hs-type">minimumBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679574929"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679574928"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679574928"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Ordering"><span class="hs-identifier hs-type">Ordering</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679574929"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679574928"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679574928"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-1349"></span><span id="minimumBy"><span class="annot"><span class="annottext">minimumBy :: forall (t :: * -&gt; *) a.
Foldable t =&gt;
(a -&gt; a -&gt; Ordering) -&gt; t a -&gt; a
</span><a href="Data.Foldable.html#minimumBy"><span class="hs-identifier hs-var hs-var">minimumBy</span></a></span></span><span> </span><span id="local-6989586621679574925"><span class="annot"><span class="annottext">a -&gt; a -&gt; Ordering
</span><a href="#local-6989586621679574925"><span class="hs-identifier hs-var">cmp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a -&gt; a
</span><a href="Data.Maybe.html#fromMaybe"><span class="hs-identifier hs-var">fromMaybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. [Char] -&gt; a
</span><a href="GHC.Err.html#errorWithoutStackTrace"><span class="hs-identifier hs-var">errorWithoutStackTrace</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;minimumBy: empty structure&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1350"></span><span>  </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="Data.Foldable.html#foldl%27"><span class="hs-identifier hs-var">foldl'</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe a -&gt; a -&gt; Maybe a
</span><a href="#local-6989586621679574924"><span class="hs-identifier hs-var">min'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><a href="GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-1351"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1352"></span><span>    </span><span id="local-6989586621679574924"><span class="annot"><span class="annottext">min' :: Maybe a -&gt; a -&gt; Maybe a
</span><a href="#local-6989586621679574924"><span class="hs-identifier hs-var hs-var">min'</span></a></span></span><span> </span><span id="local-6989586621679574923"><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679574923"><span class="hs-identifier hs-var">mx</span></a></span></span><span> </span><span id="local-6989586621679574922"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574922"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679574923"><span class="hs-identifier hs-var">mx</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1353"></span><span>      </span><span class="annot"><span class="annottext">Maybe a
</span><a href="GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574922"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-1354"></span><span>      </span><span class="annot"><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679574921"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574921"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; Ordering
</span><a href="#local-6989586621679574925"><span class="hs-identifier hs-var">cmp</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574921"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574922"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1355"></span><span>        </span><span class="annot"><span class="annottext">Ordering
</span><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#GT"><span class="hs-identifier hs-var">GT</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574922"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-1356"></span><span>        </span><span class="annot"><span class="annottext">Ordering
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574921"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1357"></span><span class="hs-pragma">{-# INLINEABLE</span><span> </span><span class="annot"><a href="Data.Foldable.html#minimumBy"><span class="hs-pragma hs-type">minimumBy</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1358"></span><span>
</span><span id="line-1359"></span><span class="hs-comment">-- | 'notElem' is the negation of 'elem'.</span><span>
</span><span id="line-1360"></span><span class="hs-comment">--</span><span>
</span><span id="line-1361"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1362"></span><span class="hs-comment">--</span><span>
</span><span id="line-1363"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1364"></span><span class="hs-comment">--</span><span>
</span><span id="line-1365"></span><span class="hs-comment">-- &gt;&gt;&gt; 3 `notElem` []</span><span>
</span><span id="line-1366"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-1367"></span><span class="hs-comment">--</span><span>
</span><span id="line-1368"></span><span class="hs-comment">-- &gt;&gt;&gt; 3 `notElem` [1,2]</span><span>
</span><span id="line-1369"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-1370"></span><span class="hs-comment">--</span><span>
</span><span id="line-1371"></span><span class="hs-comment">-- &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]</span><span>
</span><span id="line-1372"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-1373"></span><span class="hs-comment">--</span><span>
</span><span id="line-1374"></span><span class="hs-comment">-- For infinite structures, 'notElem' terminates if the value exists at a</span><span>
</span><span id="line-1375"></span><span class="hs-comment">-- finite distance from the left side of the structure:</span><span>
</span><span id="line-1376"></span><span class="hs-comment">--</span><span>
</span><span id="line-1377"></span><span class="hs-comment">-- &gt;&gt;&gt; 3 `notElem` [1..]</span><span>
</span><span id="line-1378"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-1379"></span><span class="hs-comment">--</span><span>
</span><span id="line-1380"></span><span class="hs-comment">-- &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])</span><span>
</span><span id="line-1381"></span><span class="hs-comment">-- * Hangs forever *</span><span>
</span><span id="line-1382"></span><span id="local-6989586621679577333"><span id="local-6989586621679577334"><span class="annot"><a href="Data.Foldable.html#notElem"><span class="hs-identifier hs-type">notElem</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577334"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Classes.html#Eq"><span class="hs-identifier hs-type">Eq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577333"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577333"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577334"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577333"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span></span></span><span>
</span><span id="line-1383"></span><span id="notElem"><span class="annot"><span class="annottext">notElem :: forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><a href="Data.Foldable.html#notElem"><span class="hs-identifier hs-var hs-var">notElem</span></a></span></span><span> </span><span id="local-6989586621679574916"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574916"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><a href="../../ghc-prim-0.8.0/src/GHC-Classes.html#not"><span class="hs-identifier hs-var">not</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><a href="Data.Foldable.html#elem"><span class="hs-identifier hs-var">elem</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574916"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1384"></span><span>
</span><span id="line-1385"></span><span class="hs-comment">-- | The 'find' function takes a predicate and a structure and returns</span><span>
</span><span id="line-1386"></span><span class="hs-comment">-- the leftmost element of the structure matching the predicate, or</span><span>
</span><span id="line-1387"></span><span class="hs-comment">-- 'Nothing' if there is no such element.</span><span>
</span><span id="line-1388"></span><span class="hs-comment">--</span><span>
</span><span id="line-1389"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-1390"></span><span class="hs-comment">--</span><span>
</span><span id="line-1391"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-1392"></span><span class="hs-comment">--</span><span>
</span><span id="line-1393"></span><span class="hs-comment">-- &gt;&gt;&gt; find (&gt; 42) [0, 5..]</span><span>
</span><span id="line-1394"></span><span class="hs-comment">-- Just 45</span><span>
</span><span id="line-1395"></span><span class="hs-comment">--</span><span>
</span><span id="line-1396"></span><span class="hs-comment">-- &gt;&gt;&gt; find (&gt; 12) [1..7]</span><span>
</span><span id="line-1397"></span><span class="hs-comment">-- Nothing</span><span>
</span><span id="line-1398"></span><span id="local-6989586621679577329"><span id="local-6989586621679577330"><span class="annot"><a href="Data.Foldable.html#find"><span class="hs-identifier hs-type">find</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577330"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679577329"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.8.0/src/GHC-Types.html#Bool"><span class="hs-identifier hs-type">Bool</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679577330"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577329"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679577329"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-1399"></span><span id="find"><span class="annot"><span class="annottext">find :: forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Maybe a
</span><a href="Data.Foldable.html#find"><span class="hs-identifier hs-var hs-var">find</span></a></span></span><span> </span><span id="local-6989586621679574910"><span class="annot"><span class="annottext">a -&gt; Bool
</span><a href="#local-6989586621679574910"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. First a -&gt; Maybe a
</span><a href="Data.Monoid.html#getFirst"><span class="hs-identifier hs-var">getFirst</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Foldable.html#foldMap"><span class="hs-identifier hs-var">foldMap</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679574909"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574909"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; First a
</span><a href="Data.Monoid.html#First"><span class="hs-identifier hs-var">First</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">a -&gt; Bool
</span><a href="#local-6989586621679574910"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574909"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679574909"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><a href="GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1400"></span><span>
</span><span id="line-1401"></span><span class="hs-comment">{-
Note [List fusion and continuations in 'c']
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Suppose we define
  mapM_ f = foldr ((&gt;&gt;) . f) (return ())
(this is the way it used to be).

Now suppose we want to optimise the call

  mapM_ &lt;big&gt; (build g)
    where
  g c n = ...(c x1 y1)...(c x2 y2)....n...

GHC used to proceed like this:

  mapM_ &lt;big&gt; (build g)

  = { Definition of mapM_ }
    foldr ((&gt;&gt;) . &lt;big&gt;) (return ()) (build g)

  = { foldr/build rule }
    g ((&gt;&gt;) . &lt;big&gt;) (return ())

  = { Inline g }
    let c = (&gt;&gt;) . &lt;big&gt;
        n = return ()
    in ...(c x1 y1)...(c x2 y2)....n...

The trouble is that `c`, being big, will not be inlined.  And that can
be absolutely terrible for performance, as we saw in #8763.

It's much better to define

  mapM_ f = foldr c (return ())
    where
      c x k = f x &gt;&gt; k
      {-# INLINE c #-}

Now we get
  mapM_ &lt;big&gt; (build g)

  = { inline mapM_ }
    foldr c (return ()) (build g)
      where c x k = f x &gt;&gt; k
            {-# INLINE c #-}
            f = &lt;big&gt;

Notice that `f` does not inline into the RHS of `c`,
because the INLINE pragma stops it; see
Note [Simplifying inside stable unfoldings] in GHC.Core.Opt.Simplify.Utils.
Continuing:

  = { foldr/build rule }
    g c (return ())
      where ...
         c x k = f x &gt;&gt; k
         {-# INLINE c #-}
            f = &lt;big&gt;

  = { inline g }
    ...(c x1 y1)...(c x2 y2)....n...
      where c x k = f x &gt;&gt; k
            {-# INLINE c #-}
            f = &lt;big&gt;
            n = return ()

      Now, crucially, `c` does inline

  = { inline c }
    ...(f x1 &gt;&gt; y1)...(f x2 &gt;&gt; y2)....n...
      where f = &lt;big&gt;
            n = return ()

And all is well!  The key thing is that the fragment
`(f x1 &gt;&gt; y1)` is inlined into the body of the builder
`g`.
-}</span><span>
</span><span id="line-1478"></span><span>
</span><span id="line-1479"></span><span class="hs-comment">{-
Note [maximumBy/minimumBy space usage]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When the type signatures of maximumBy and minimumBy were generalized to work
over any Foldable instance (instead of just lists), they were defined using
foldr1.  This was problematic for space usage, as the semantics of maximumBy
and minimumBy essentially require that they examine every element of the
data structure.  Using foldr1 to examine every element results in space usage
proportional to the size of the data structure.  For the common case of lists,
this could be particularly bad (see #10830).

For the common case of lists, switching the implementations of maximumBy and
minimumBy to foldl1 solves the issue, assuming GHC's strictness analysis can then
make these functions only use O(1) stack space.  As of base 4.16, we have
switched to employing foldl' over foldl1, not relying on GHC's optimiser.  See
https://gitlab.haskell.org/ghc/ghc/-/issues/17867 for more context.
-}</span><span>
</span><span id="line-1496"></span><span>
</span><span id="line-1497"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-1498"></span><span>
</span><span id="line-1499"></span><span class="hs-comment">-- $overview</span><span>
</span><span id="line-1500"></span><span class="hs-comment">--</span><span>
</span><span id="line-1501"></span><span class="hs-comment">-- #overview#</span><span>
</span><span id="line-1502"></span><span class="hs-comment">-- The Foldable class generalises some common &quot;Data.List&quot; functions to</span><span>
</span><span id="line-1503"></span><span class="hs-comment">-- structures that can be reduced to a summary value one element at a time.</span><span>
</span><span id="line-1504"></span><span class="hs-comment">--</span><span>
</span><span id="line-1505"></span><span class="hs-comment">-- == Left and right folds</span><span>
</span><span id="line-1506"></span><span class="hs-comment">--</span><span>
</span><span id="line-1507"></span><span class="hs-comment">-- #leftright#</span><span>
</span><span id="line-1508"></span><span class="hs-comment">-- The contribution of each element to the final result is combined with an</span><span>
</span><span id="line-1509"></span><span class="hs-comment">-- accumulator via a suitable /operator/.  The operator may be explicitly</span><span>
</span><span id="line-1510"></span><span class="hs-comment">-- provided by the caller as with `foldr` or may be implicit as in `length`.</span><span>
</span><span id="line-1511"></span><span class="hs-comment">-- In the case of `foldMap`, the caller provides a function mapping each</span><span>
</span><span id="line-1512"></span><span class="hs-comment">-- element into a suitable 'Monoid', which makes it possible to merge the</span><span>
</span><span id="line-1513"></span><span class="hs-comment">-- per-element contributions via that monoid's `mappend` function.</span><span>
</span><span id="line-1514"></span><span class="hs-comment">--</span><span>
</span><span id="line-1515"></span><span class="hs-comment">-- A key distinction is between left-associative and right-associative</span><span>
</span><span id="line-1516"></span><span class="hs-comment">-- folds:</span><span>
</span><span id="line-1517"></span><span class="hs-comment">--</span><span>
</span><span id="line-1518"></span><span class="hs-comment">-- * In left-associative folds the accumulator is a partial fold over the</span><span>
</span><span id="line-1519"></span><span class="hs-comment">--   elements that __precede__ the current element, and is passed to the</span><span>
</span><span id="line-1520"></span><span class="hs-comment">--   operator as its first (left) argument.  The outermost application of the</span><span>
</span><span id="line-1521"></span><span class="hs-comment">--   operator merges the contribution of the last element of the structure with</span><span>
</span><span id="line-1522"></span><span class="hs-comment">--   the contributions of all its predecessors.</span><span>
</span><span id="line-1523"></span><span class="hs-comment">--</span><span>
</span><span id="line-1524"></span><span class="hs-comment">-- * In right-associative folds the accumulator is a partial fold over the</span><span>
</span><span id="line-1525"></span><span class="hs-comment">--   elements that __follow__ the current element, and is passed to the</span><span>
</span><span id="line-1526"></span><span class="hs-comment">--   operator as its second (right) argument.  The outermost application of</span><span>
</span><span id="line-1527"></span><span class="hs-comment">--   the operator merges the contribution of the first element of the structure</span><span>
</span><span id="line-1528"></span><span class="hs-comment">--   with the contributions of all its successors.</span><span>
</span><span id="line-1529"></span><span class="hs-comment">--</span><span>
</span><span id="line-1530"></span><span class="hs-comment">-- These two types of folds are typified by the left-associative strict</span><span>
</span><span id="line-1531"></span><span class="hs-comment">-- 'foldl'' and the right-associative lazy `foldr`.</span><span>
</span><span id="line-1532"></span><span class="hs-comment">--</span><span>
</span><span id="line-1533"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1534"></span><span class="hs-comment">-- 'foldl'' :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</span><span>
</span><span id="line-1535"></span><span class="hs-comment">-- `foldr`  :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span><span>
</span><span id="line-1536"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1537"></span><span class="hs-comment">--</span><span>
</span><span id="line-1538"></span><span class="hs-comment">-- Example usage:</span><span>
</span><span id="line-1539"></span><span class="hs-comment">--</span><span>
</span><span id="line-1540"></span><span class="hs-comment">-- &gt;&gt;&gt; foldl' (+) 0 [1..100]</span><span>
</span><span id="line-1541"></span><span class="hs-comment">-- 5050</span><span>
</span><span id="line-1542"></span><span class="hs-comment">-- &gt;&gt;&gt; foldr (&amp;&amp;) True (repeat False)</span><span>
</span><span id="line-1543"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-1544"></span><span class="hs-comment">--</span><span>
</span><span id="line-1545"></span><span class="hs-comment">-- The first argument of both is an explicit /operator/ that merges the</span><span>
</span><span id="line-1546"></span><span class="hs-comment">-- contribution of an element of the structure with a partial fold over,</span><span>
</span><span id="line-1547"></span><span class="hs-comment">-- respectively, either the preceding or following elements of the structure.</span><span>
</span><span id="line-1548"></span><span class="hs-comment">--</span><span>
</span><span id="line-1549"></span><span class="hs-comment">-- The second argument of both is an initial accumulator value @z@ of type</span><span>
</span><span id="line-1550"></span><span class="hs-comment">-- @b@.  This is the result of the fold when the structure is empty.</span><span>
</span><span id="line-1551"></span><span class="hs-comment">-- When the structure is non-empty, this is the accumulator value merged with</span><span>
</span><span id="line-1552"></span><span class="hs-comment">-- the first element in left-associative folds, or with the last element in</span><span>
</span><span id="line-1553"></span><span class="hs-comment">-- right-associative folds.</span><span>
</span><span id="line-1554"></span><span class="hs-comment">--</span><span>
</span><span id="line-1555"></span><span class="hs-comment">-- The third and final argument is a @Foldable@ structure containing elements</span><span>
</span><span id="line-1556"></span><span class="hs-comment">-- @(a, b, c, &amp;#x2026;)@.</span><span>
</span><span id="line-1557"></span><span class="hs-comment">--</span><span>
</span><span id="line-1558"></span><span class="hs-comment">-- * __'foldl''__ takes an operator argument of the form:</span><span>
</span><span id="line-1559"></span><span class="hs-comment">--</span><span>
</span><span id="line-1560"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1561"></span><span class="hs-comment">--     f :: b -- accumulated fold of the initial elements</span><span>
</span><span id="line-1562"></span><span class="hs-comment">--       -&gt; a -- current element</span><span>
</span><span id="line-1563"></span><span class="hs-comment">--       -&gt; b -- updated fold, inclusive of current element</span><span>
</span><span id="line-1564"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1565"></span><span class="hs-comment">--</span><span>
</span><span id="line-1566"></span><span class="hs-comment">--     If the structure's last element is @y@, the result of the fold is:</span><span>
</span><span id="line-1567"></span><span class="hs-comment">--</span><span>
</span><span id="line-1568"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1569"></span><span class="hs-comment">--     g y . &amp;#x2026; . g c . g b . g a $ z</span><span>
</span><span id="line-1570"></span><span class="hs-comment">--       where g element !acc = f acc element</span><span>
</span><span id="line-1571"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1572"></span><span class="hs-comment">--</span><span>
</span><span id="line-1573"></span><span class="hs-comment">--     Since 'foldl'' is strict in the accumulator, this is always</span><span>
</span><span id="line-1574"></span><span class="hs-comment">--     a [strict](#strict) reduction with no opportunity for early return or</span><span>
</span><span id="line-1575"></span><span class="hs-comment">--     intermediate results.  The structure must be finite, since no result is</span><span>
</span><span id="line-1576"></span><span class="hs-comment">--     returned until the last element is processed.  The advantage of</span><span>
</span><span id="line-1577"></span><span class="hs-comment">--     strictness is space efficiency: the final result can be computed without</span><span>
</span><span id="line-1578"></span><span class="hs-comment">--     storing a potentially deep stack of lazy intermediate results.</span><span>
</span><span id="line-1579"></span><span class="hs-comment">--</span><span>
</span><span id="line-1580"></span><span class="hs-comment">-- * __`foldr`__ takes an operator argument of the form:</span><span>
</span><span id="line-1581"></span><span class="hs-comment">--</span><span>
</span><span id="line-1582"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1583"></span><span class="hs-comment">--     f :: a -- current element</span><span>
</span><span id="line-1584"></span><span class="hs-comment">--       -&gt; b -- accumulated fold of the remaining elements</span><span>
</span><span id="line-1585"></span><span class="hs-comment">--       -&gt; b -- updated fold, inclusive of current element</span><span>
</span><span id="line-1586"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1587"></span><span class="hs-comment">--</span><span>
</span><span id="line-1588"></span><span class="hs-comment">--     the result of the fold is:</span><span>
</span><span id="line-1589"></span><span class="hs-comment">--</span><span>
</span><span id="line-1590"></span><span class="hs-comment">--     @f a . f b . f c . &amp;#x2026; $ z@</span><span>
</span><span id="line-1591"></span><span class="hs-comment">--</span><span>
</span><span id="line-1592"></span><span class="hs-comment">--     If each call of @f@ on the current element @e@, (referenced as @(f e)@</span><span>
</span><span id="line-1593"></span><span class="hs-comment">--     below) returns a structure in which its second argument is captured in a</span><span>
</span><span id="line-1594"></span><span class="hs-comment">--     lazily-evaluated component, then the fold of the remaining elements is</span><span>
</span><span id="line-1595"></span><span class="hs-comment">--     available to the caller of `foldr` as a pending computation (thunk) that</span><span>
</span><span id="line-1596"></span><span class="hs-comment">--     is computed only when that component is evaluated.</span><span>
</span><span id="line-1597"></span><span class="hs-comment">--</span><span>
</span><span id="line-1598"></span><span class="hs-comment">--     Alternatively, if any of the @(f e)@ ignore their second argument, the</span><span>
</span><span id="line-1599"></span><span class="hs-comment">--     fold stops there, with the remaining elements unused.  As a result,</span><span>
</span><span id="line-1600"></span><span class="hs-comment">--     `foldr` is well suited to define both [corecursive](#corec)</span><span>
</span><span id="line-1601"></span><span class="hs-comment">--     and [short-circuit](#short) reductions.</span><span>
</span><span id="line-1602"></span><span class="hs-comment">--</span><span>
</span><span id="line-1603"></span><span class="hs-comment">--     When the operator is always strict in its second argument, 'foldl'' is</span><span>
</span><span id="line-1604"></span><span class="hs-comment">--     generally a better choice than `foldr`.  When `foldr` is called with a</span><span>
</span><span id="line-1605"></span><span class="hs-comment">--     strict operator, evaluation cannot begin until the last element is</span><span>
</span><span id="line-1606"></span><span class="hs-comment">--     reached, by which point a deep stack of pending function applications</span><span>
</span><span id="line-1607"></span><span class="hs-comment">--     may have been built up in memory.</span><span>
</span><span id="line-1608"></span><span class="hs-comment">--</span><span>
</span><span id="line-1609"></span><span>
</span><span id="line-1610"></span><span class="hs-comment">-- $chirality</span><span>
</span><span id="line-1611"></span><span class="hs-comment">--</span><span>
</span><span id="line-1612"></span><span class="hs-comment">-- #chirality#</span><span>
</span><span id="line-1613"></span><span class="hs-comment">-- Foldable structures are generally expected to be efficiently iterable from</span><span>
</span><span id="line-1614"></span><span class="hs-comment">-- left to right. Right-to-left iteration may be substantially more costly, or</span><span>
</span><span id="line-1615"></span><span class="hs-comment">-- even impossible (as with, for example, infinite lists).  The text in the</span><span>
</span><span id="line-1616"></span><span class="hs-comment">-- sections that follow that suggests performance differences between</span><span>
</span><span id="line-1617"></span><span class="hs-comment">-- left-associative and right-associative folds assumes /left-handed/</span><span>
</span><span id="line-1618"></span><span class="hs-comment">-- structures in which left-to-right iteration is cheaper than right-to-left</span><span>
</span><span id="line-1619"></span><span class="hs-comment">-- iteration.</span><span>
</span><span id="line-1620"></span><span class="hs-comment">--</span><span>
</span><span id="line-1621"></span><span class="hs-comment">-- In finite structures for which right-to-left sequencing no less efficient</span><span>
</span><span id="line-1622"></span><span class="hs-comment">-- than left-to-right sequencing, there is no inherent performance distinction</span><span>
</span><span id="line-1623"></span><span class="hs-comment">-- between left-associative and right-associative folds.  If the structure's</span><span>
</span><span id="line-1624"></span><span class="hs-comment">-- @Foldable@ instance takes advantage of this symmetry to also make strict</span><span>
</span><span id="line-1625"></span><span class="hs-comment">-- right folds space-efficient and lazy left folds corecursive, one need only</span><span>
</span><span id="line-1626"></span><span class="hs-comment">-- take care to choose either a strict or lazy method for the task at hand.</span><span>
</span><span id="line-1627"></span><span class="hs-comment">--</span><span>
</span><span id="line-1628"></span><span class="hs-comment">-- Foldable instances for symmetric structures should strive to provide equally</span><span>
</span><span id="line-1629"></span><span class="hs-comment">-- performant left-associative and right-associative interfaces. The main</span><span>
</span><span id="line-1630"></span><span class="hs-comment">-- limitations are:</span><span>
</span><span id="line-1631"></span><span class="hs-comment">--</span><span>
</span><span id="line-1632"></span><span class="hs-comment">-- * The lazy 'fold', 'foldMap' and 'toList' methods have no right-associative</span><span>
</span><span id="line-1633"></span><span class="hs-comment">--   counterparts.</span><span>
</span><span id="line-1634"></span><span class="hs-comment">-- * The strict 'foldMap'' method has no left-associative counterpart.</span><span>
</span><span id="line-1635"></span><span class="hs-comment">--</span><span>
</span><span id="line-1636"></span><span class="hs-comment">-- Thus, for some foldable structures 'foldr'' is just as efficient as 'foldl''</span><span>
</span><span id="line-1637"></span><span class="hs-comment">-- for strict reduction, and 'foldl' may be just as appropriate for corecursive</span><span>
</span><span id="line-1638"></span><span class="hs-comment">-- folds as 'foldr'.</span><span>
</span><span id="line-1639"></span><span class="hs-comment">--</span><span>
</span><span id="line-1640"></span><span class="hs-comment">-- Finally, in some less common structures (e.g. /snoc/ lists) right to left</span><span>
</span><span id="line-1641"></span><span class="hs-comment">-- iterations are cheaper than left to right.  Such structures are poor</span><span>
</span><span id="line-1642"></span><span class="hs-comment">-- candidates for a @Foldable@ instance, and are perhaps best handled via their</span><span>
</span><span id="line-1643"></span><span class="hs-comment">-- type-specific interfaces.  If nevertheless a @Foldable@ instance is</span><span>
</span><span id="line-1644"></span><span class="hs-comment">-- provided, the material in the sections that follow applies to these also, by</span><span>
</span><span id="line-1645"></span><span class="hs-comment">-- replacing each method with one with the opposite associativity (when</span><span>
</span><span id="line-1646"></span><span class="hs-comment">-- available) and switching the order of arguments in the fold's /operator/.</span><span>
</span><span id="line-1647"></span><span class="hs-comment">--</span><span>
</span><span id="line-1648"></span><span class="hs-comment">-- You may need to pay careful attention to strictness of the fold's /operator/</span><span>
</span><span id="line-1649"></span><span class="hs-comment">-- when its strictness is different between its first and second argument.</span><span>
</span><span id="line-1650"></span><span class="hs-comment">-- For example, while @('+')@ is expected to be commutative and strict in both</span><span>
</span><span id="line-1651"></span><span class="hs-comment">-- arguments, the list concatenation operator @('++')@ is not commutative and</span><span>
</span><span id="line-1652"></span><span class="hs-comment">-- is only strict in the initial constructor of its first argument.  The fold:</span><span>
</span><span id="line-1653"></span><span class="hs-comment">--</span><span>
</span><span id="line-1654"></span><span class="hs-comment">-- &gt; myconcat xs = foldr (\a b -&gt; a ++ b) [] xs</span><span>
</span><span id="line-1655"></span><span class="hs-comment">--</span><span>
</span><span id="line-1656"></span><span class="hs-comment">-- is substantially cheaper (linear in the length of the consumed portion of</span><span>
</span><span id="line-1657"></span><span class="hs-comment">-- the final list, thus e.g. constant time/space for just the first element)</span><span>
</span><span id="line-1658"></span><span class="hs-comment">-- than:</span><span>
</span><span id="line-1659"></span><span class="hs-comment">--</span><span>
</span><span id="line-1660"></span><span class="hs-comment">-- &gt; revconcat xs = foldr (\a b -&gt; b ++ a) [] xs</span><span>
</span><span id="line-1661"></span><span class="hs-comment">--</span><span>
</span><span id="line-1662"></span><span class="hs-comment">-- In which the total cost scales up with both the number of lists combined and</span><span>
</span><span id="line-1663"></span><span class="hs-comment">-- the number of elements ultimately consumed.  A more efficient way to combine</span><span>
</span><span id="line-1664"></span><span class="hs-comment">-- lists in reverse order, is to use:</span><span>
</span><span id="line-1665"></span><span class="hs-comment">--</span><span>
</span><span id="line-1666"></span><span class="hs-comment">-- &gt; revconcat = foldr (++) [] . reverse</span><span>
</span><span id="line-1667"></span><span>
</span><span id="line-1668"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-1669"></span><span>
</span><span id="line-1670"></span><span class="hs-comment">-- $reduction</span><span>
</span><span id="line-1671"></span><span class="hs-comment">--</span><span>
</span><span id="line-1672"></span><span class="hs-comment">-- As observed in the [above description](#leftright) of left and right folds,</span><span>
</span><span id="line-1673"></span><span class="hs-comment">-- there are three general ways in which a structure can be reduced to a</span><span>
</span><span id="line-1674"></span><span class="hs-comment">-- summary value:</span><span>
</span><span id="line-1675"></span><span class="hs-comment">--</span><span>
</span><span id="line-1676"></span><span class="hs-comment">-- * __Recursive__ reduction, which is strict in all the elements of the</span><span>
</span><span id="line-1677"></span><span class="hs-comment">--   structure.  This produces a single final result only after processing the</span><span>
</span><span id="line-1678"></span><span class="hs-comment">--   entire input structure, and so the input must be finite.</span><span>
</span><span id="line-1679"></span><span class="hs-comment">--</span><span>
</span><span id="line-1680"></span><span class="hs-comment">-- * __Corecursion__, which yields intermediate results as it encounters</span><span>
</span><span id="line-1681"></span><span class="hs-comment">--   additional input elements.  Lazy processing of the remaining elements</span><span>
</span><span id="line-1682"></span><span class="hs-comment">--   makes the intermediate results available even before the rest of the</span><span>
</span><span id="line-1683"></span><span class="hs-comment">--   input is processed.  The input may be unbounded, and the caller can</span><span>
</span><span id="line-1684"></span><span class="hs-comment">--   stop processing intermediate results early.</span><span>
</span><span id="line-1685"></span><span class="hs-comment">--</span><span>
</span><span id="line-1686"></span><span class="hs-comment">-- * __Short-circuit__ reduction, which examines some initial sequence of the</span><span>
</span><span id="line-1687"></span><span class="hs-comment">--   input elements, but stops once a termination condition is met, returning a</span><span>
</span><span id="line-1688"></span><span class="hs-comment">--   final result based only on the elements considered up to that point.  The</span><span>
</span><span id="line-1689"></span><span class="hs-comment">--   remaining elements are not considered.  The input should generally be</span><span>
</span><span id="line-1690"></span><span class="hs-comment">--   finite, because the termination condition might otherwise never be met.</span><span>
</span><span id="line-1691"></span><span class="hs-comment">--</span><span>
</span><span id="line-1692"></span><span class="hs-comment">-- Whether a fold is recursive, corecursive or short-circuiting can depend on</span><span>
</span><span id="line-1693"></span><span class="hs-comment">-- both the method chosen to perform the fold and on the operator passed to</span><span>
</span><span id="line-1694"></span><span class="hs-comment">-- that method (which may be implicit, as with the `mappend` method of a monoid</span><span>
</span><span id="line-1695"></span><span class="hs-comment">-- instance).</span><span>
</span><span id="line-1696"></span><span class="hs-comment">--</span><span>
</span><span id="line-1697"></span><span class="hs-comment">-- There are also hybrid cases, where the method and/or operator are not well</span><span>
</span><span id="line-1698"></span><span class="hs-comment">-- suited to the task at hand, resulting in a fold that fails to yield</span><span>
</span><span id="line-1699"></span><span class="hs-comment">-- incremental results until the entire input is processed, or fails to</span><span>
</span><span id="line-1700"></span><span class="hs-comment">-- strictly evaluate results as it goes, deferring all the work to the</span><span>
</span><span id="line-1701"></span><span class="hs-comment">-- evaluation of a large final thunk.  Such cases should be avoided, either by</span><span>
</span><span id="line-1702"></span><span class="hs-comment">-- selecting a more appropriate @Foldable@ method, or by tailoring the operator</span><span>
</span><span id="line-1703"></span><span class="hs-comment">-- to the chosen method.</span><span>
</span><span id="line-1704"></span><span class="hs-comment">--</span><span>
</span><span id="line-1705"></span><span class="hs-comment">-- The distinction between these types of folds is critical, both in deciding</span><span>
</span><span id="line-1706"></span><span class="hs-comment">-- which @Foldable@ method to use to perform the reduction efficiently, and in</span><span>
</span><span id="line-1707"></span><span class="hs-comment">-- writing @Foldable@ instances for new structures.  Below is a more detailed</span><span>
</span><span id="line-1708"></span><span class="hs-comment">-- overview of each type.</span><span>
</span><span id="line-1709"></span><span>
</span><span id="line-1710"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-1711"></span><span>
</span><span id="line-1712"></span><span class="hs-comment">-- $strict</span><span>
</span><span id="line-1713"></span><span class="hs-comment">-- #strict#</span><span>
</span><span id="line-1714"></span><span class="hs-comment">--</span><span>
</span><span id="line-1715"></span><span class="hs-comment">-- Common examples of strict recursive reduction are the various /aggregate/</span><span>
</span><span id="line-1716"></span><span class="hs-comment">-- functions, like 'sum', 'product', 'length', as well as more complex</span><span>
</span><span id="line-1717"></span><span class="hs-comment">-- summaries such as frequency counts.  These functions return only a single</span><span>
</span><span id="line-1718"></span><span class="hs-comment">-- value after processing the entire input structure.  In such cases, lazy</span><span>
</span><span id="line-1719"></span><span class="hs-comment">-- processing of the tail of the input structure is generally not only</span><span>
</span><span id="line-1720"></span><span class="hs-comment">-- unnecessary, but also inefficient.  Thus, these and similar folds should be</span><span>
</span><span id="line-1721"></span><span class="hs-comment">-- implemented in terms of strict left-associative @Foldable@ methods (typically</span><span>
</span><span id="line-1722"></span><span class="hs-comment">-- 'foldl'') to perform an efficient reduction in constant space.</span><span>
</span><span id="line-1723"></span><span class="hs-comment">--</span><span>
</span><span id="line-1724"></span><span class="hs-comment">-- Conversely, an implementation of @Foldable@ for a new structure should</span><span>
</span><span id="line-1725"></span><span class="hs-comment">-- ensure that 'foldl'' actually performs a strict left-associative reduction.</span><span>
</span><span id="line-1726"></span><span class="hs-comment">--</span><span>
</span><span id="line-1727"></span><span class="hs-comment">-- The 'foldMap'' method is a special case of 'foldl'', in which the initial</span><span>
</span><span id="line-1728"></span><span class="hs-comment">-- accumulator is `mempty` and the operator is @mappend . f@, where @f@ maps</span><span>
</span><span id="line-1729"></span><span class="hs-comment">-- each input element into the 'Monoid' in question.  Therefore, 'foldMap'' is</span><span>
</span><span id="line-1730"></span><span class="hs-comment">-- an appropriate choice under essentially the same conditions as 'foldl'', and</span><span>
</span><span id="line-1731"></span><span class="hs-comment">-- its implementation for a given @Foldable@ structure should also be a strict</span><span>
</span><span id="line-1732"></span><span class="hs-comment">-- left-associative reduction.</span><span>
</span><span id="line-1733"></span><span class="hs-comment">--</span><span>
</span><span id="line-1734"></span><span class="hs-comment">-- While the examples below are not necessarily the most optimal definitions of</span><span>
</span><span id="line-1735"></span><span class="hs-comment">-- the intended functions, they are all cases in which 'foldMap'' is far more</span><span>
</span><span id="line-1736"></span><span class="hs-comment">-- appropriate (as well as more efficient) than the lazy `foldMap`.</span><span>
</span><span id="line-1737"></span><span class="hs-comment">--</span><span>
</span><span id="line-1738"></span><span class="hs-comment">-- &gt; length  = getSum     . foldMap' (const (Sum 1))</span><span>
</span><span id="line-1739"></span><span class="hs-comment">-- &gt; sum     = getSum     . foldMap' Sum</span><span>
</span><span id="line-1740"></span><span class="hs-comment">-- &gt; product = getProduct . foldMap' Product</span><span>
</span><span id="line-1741"></span><span class="hs-comment">--</span><span>
</span><span id="line-1742"></span><span class="hs-comment">-- [ The actual default definitions employ coercions to optimise out</span><span>
</span><span id="line-1743"></span><span class="hs-comment">--   'getSum' and 'getProduct'. ]</span><span>
</span><span id="line-1744"></span><span>
</span><span id="line-1745"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-1746"></span><span>
</span><span id="line-1747"></span><span class="hs-comment">-- $strictlist</span><span>
</span><span id="line-1748"></span><span class="hs-comment">--</span><span>
</span><span id="line-1749"></span><span class="hs-comment">-- The full list of strict recursive functions in this module is:</span><span>
</span><span id="line-1750"></span><span class="hs-comment">--</span><span>
</span><span id="line-1751"></span><span class="hs-comment">-- * Provided the operator is strict in its left argument:</span><span>
</span><span id="line-1752"></span><span class="hs-comment">--</span><span>
</span><span id="line-1753"></span><span class="hs-comment">--     @'foldl'' :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b@</span><span>
</span><span id="line-1754"></span><span class="hs-comment">--</span><span>
</span><span id="line-1755"></span><span class="hs-comment">-- * Provided `mappend` is strict in its left argument:</span><span>
</span><span id="line-1756"></span><span class="hs-comment">--</span><span>
</span><span id="line-1757"></span><span class="hs-comment">--     @'foldMap'' :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m@</span><span>
</span><span id="line-1758"></span><span class="hs-comment">--</span><span>
</span><span id="line-1759"></span><span class="hs-comment">-- * Provided the instance is correctly defined:</span><span>
</span><span id="line-1760"></span><span class="hs-comment">--</span><span>
</span><span id="line-1761"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1762"></span><span class="hs-comment">--     `length`    :: Foldable t =&gt; t a -&gt; Int</span><span>
</span><span id="line-1763"></span><span class="hs-comment">--     `sum`       :: (Foldable t, Num a) =&gt; t a -&gt; a</span><span>
</span><span id="line-1764"></span><span class="hs-comment">--     `product`   :: (Foldable t, Num a) =&gt; t a -&gt; a</span><span>
</span><span id="line-1765"></span><span class="hs-comment">--     `maximum`   :: (Foldable t, Ord a) =&gt; t a -&gt; a</span><span>
</span><span id="line-1766"></span><span class="hs-comment">--     `minimum`   :: (Foldable t, Ord a) =&gt; t a -&gt; a</span><span>
</span><span id="line-1767"></span><span class="hs-comment">--     `maximumBy` :: Foldable t =&gt; (a -&gt; a -&gt; Ordering) -&gt; t a -&gt; a</span><span>
</span><span id="line-1768"></span><span class="hs-comment">--     `minimumBy` :: Foldable t =&gt; (a -&gt; a -&gt; Ordering) -&gt; t a -&gt; a</span><span>
</span><span id="line-1769"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1770"></span><span>
</span><span id="line-1771"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-1772"></span><span>
</span><span id="line-1773"></span><span class="hs-comment">-- $lazy</span><span>
</span><span id="line-1774"></span><span class="hs-comment">--</span><span>
</span><span id="line-1775"></span><span class="hs-comment">-- #corec#</span><span>
</span><span id="line-1776"></span><span class="hs-comment">-- Common examples of lazy corecursive reduction are functions that map and</span><span>
</span><span id="line-1777"></span><span class="hs-comment">-- flatten a structure to a lazy stream of result values, i.e.  an iterator</span><span>
</span><span id="line-1778"></span><span class="hs-comment">-- over the transformed input elements.  In such cases, it is important to</span><span>
</span><span id="line-1779"></span><span class="hs-comment">-- choose a @Foldable@ method that is lazy in the tail of the structure, such</span><span>
</span><span id="line-1780"></span><span class="hs-comment">-- as `foldr` (or `foldMap`, if the result @Monoid@ has a lazy `mappend` as</span><span>
</span><span id="line-1781"></span><span class="hs-comment">-- with e.g. ByteString Builders).</span><span>
</span><span id="line-1782"></span><span class="hs-comment">--</span><span>
</span><span id="line-1783"></span><span class="hs-comment">-- Conversely, an implementation of `foldr` for a structure that can</span><span>
</span><span id="line-1784"></span><span class="hs-comment">-- accommodate a large (and possibly unbounded) number of elements is expected</span><span>
</span><span id="line-1785"></span><span class="hs-comment">-- to be lazy in the tail of the input, allowing operators that are lazy in the</span><span>
</span><span id="line-1786"></span><span class="hs-comment">-- accumulator to yield intermediate results incrementally.  Such folds are</span><span>
</span><span id="line-1787"></span><span class="hs-comment">-- right-associative, with the tail of the stream returned as a lazily</span><span>
</span><span id="line-1788"></span><span class="hs-comment">-- evaluated component of the result (an element of a tuple or some other</span><span>
</span><span id="line-1789"></span><span class="hs-comment">-- non-strict constructor, e.g. the @(:)@ constructor for lists).</span><span>
</span><span id="line-1790"></span><span class="hs-comment">--</span><span>
</span><span id="line-1791"></span><span class="hs-comment">-- The @toList@ function below lazily transforms a @Foldable@ structure to a</span><span>
</span><span id="line-1792"></span><span class="hs-comment">-- List.  Note that this transformation may be lossy, e.g.  for a keyed</span><span>
</span><span id="line-1793"></span><span class="hs-comment">-- container (@Map@, @HashMap@, &amp;#x2026;) the output stream holds only the</span><span>
</span><span id="line-1794"></span><span class="hs-comment">-- values, not the keys.  Lossless transformations to\/from lists of @(key,</span><span>
</span><span id="line-1795"></span><span class="hs-comment">-- value)@ pairs are typically available in the modules for the specific</span><span>
</span><span id="line-1796"></span><span class="hs-comment">-- container types.</span><span>
</span><span id="line-1797"></span><span class="hs-comment">--</span><span>
</span><span id="line-1798"></span><span class="hs-comment">-- &gt; toList = foldr (:) []</span><span>
</span><span id="line-1799"></span><span class="hs-comment">--</span><span>
</span><span id="line-1800"></span><span class="hs-comment">-- A more complex example is concatenation of a list of lists expressed as a</span><span>
</span><span id="line-1801"></span><span class="hs-comment">-- nested right fold (bypassing @('++')@).  We can check that the definition is</span><span>
</span><span id="line-1802"></span><span class="hs-comment">-- indeed lazy by folding an infinite list of lists, and taking an initial</span><span>
</span><span id="line-1803"></span><span class="hs-comment">-- segment.</span><span>
</span><span id="line-1804"></span><span class="hs-comment">--</span><span>
</span><span id="line-1805"></span><span class="hs-comment">-- &gt;&gt;&gt; myconcat = foldr (\x z -&gt; foldr (:) z x) []</span><span>
</span><span id="line-1806"></span><span class="hs-comment">-- &gt;&gt;&gt; take 15 $ myconcat $ map (\i -&gt; [0..i]) [0..]</span><span>
</span><span id="line-1807"></span><span class="hs-comment">-- [0,0,1,0,1,2,0,1,2,3,0,1,2,3,4]</span><span>
</span><span id="line-1808"></span><span class="hs-comment">--</span><span>
</span><span id="line-1809"></span><span class="hs-comment">-- Of course in this case another way to achieve the same result is via a</span><span>
</span><span id="line-1810"></span><span class="hs-comment">-- list comprehension:</span><span>
</span><span id="line-1811"></span><span class="hs-comment">--</span><span>
</span><span id="line-1812"></span><span class="hs-comment">-- &gt; myconcat xss = [x | xs &lt;- xss, x &lt;- xs]</span><span>
</span><span id="line-1813"></span><span>
</span><span id="line-1814"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-1815"></span><span>
</span><span id="line-1816"></span><span class="hs-comment">-- $lazylist</span><span>
</span><span id="line-1817"></span><span class="hs-comment">--</span><span>
</span><span id="line-1818"></span><span class="hs-comment">-- The full list of lazy corecursive functions in this module is:</span><span>
</span><span id="line-1819"></span><span class="hs-comment">--</span><span>
</span><span id="line-1820"></span><span class="hs-comment">-- * Provided the reduction function is lazy in its second argument,</span><span>
</span><span id="line-1821"></span><span class="hs-comment">--   (otherwise best to use a strict recursive reduction):</span><span>
</span><span id="line-1822"></span><span class="hs-comment">--</span><span>
</span><span id="line-1823"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1824"></span><span class="hs-comment">--     `foldr`  :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span><span>
</span><span id="line-1825"></span><span class="hs-comment">--     `foldr1` :: Foldable t =&gt; (a -&gt; a -&gt; a) -&gt; t a -&gt; a</span><span>
</span><span id="line-1826"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1827"></span><span class="hs-comment">--</span><span>
</span><span id="line-1828"></span><span class="hs-comment">-- * Provided the 'Monoid' `mappend` is lazy in its second argument</span><span>
</span><span id="line-1829"></span><span class="hs-comment">--   (otherwise best to use a strict recursive reduction):</span><span>
</span><span id="line-1830"></span><span class="hs-comment">--</span><span>
</span><span id="line-1831"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1832"></span><span class="hs-comment">--     `fold`    :: Foldable t =&gt; Monoid m =&gt; t m -&gt; m</span><span>
</span><span id="line-1833"></span><span class="hs-comment">--     `foldMap` :: Foldable t =&gt; Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m</span><span>
</span><span id="line-1834"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1835"></span><span class="hs-comment">--</span><span>
</span><span id="line-1836"></span><span class="hs-comment">-- * Provided the instance is correctly defined:</span><span>
</span><span id="line-1837"></span><span class="hs-comment">--</span><span>
</span><span id="line-1838"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1839"></span><span class="hs-comment">--     `toList`    :: Foldable t =&gt; t a -&gt; [a]</span><span>
</span><span id="line-1840"></span><span class="hs-comment">--     `concat`    :: Foldable t =&gt; t [a] -&gt; [a]</span><span>
</span><span id="line-1841"></span><span class="hs-comment">--     `concatMap` :: Foldable t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]</span><span>
</span><span id="line-1842"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1843"></span><span>
</span><span id="line-1844"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-1845"></span><span>
</span><span id="line-1846"></span><span class="hs-comment">-- $shortcircuit</span><span>
</span><span id="line-1847"></span><span class="hs-comment">--</span><span>
</span><span id="line-1848"></span><span class="hs-comment">-- #short#</span><span>
</span><span id="line-1849"></span><span class="hs-comment">-- Examples of short-circuit reduction include various boolean predicates that</span><span>
</span><span id="line-1850"></span><span class="hs-comment">-- test whether some or all the elements of a structure satisfy a given</span><span>
</span><span id="line-1851"></span><span class="hs-comment">-- condition.  Because these don't necessarily consume the entire list, they</span><span>
</span><span id="line-1852"></span><span class="hs-comment">-- typically employ `foldr` with an operator that is conditionally strict in</span><span>
</span><span id="line-1853"></span><span class="hs-comment">-- its second argument.  Once the termination condition is met the second</span><span>
</span><span id="line-1854"></span><span class="hs-comment">-- argument (tail of the input structure) is ignored.  No result is returned</span><span>
</span><span id="line-1855"></span><span class="hs-comment">-- until that happens.</span><span>
</span><span id="line-1856"></span><span class="hs-comment">--</span><span>
</span><span id="line-1857"></span><span class="hs-comment">-- The key distinguishing feature of these folds is /conditional/ strictness</span><span>
</span><span id="line-1858"></span><span class="hs-comment">-- in the second argument, it is sometimes evaluated and sometimes not.</span><span>
</span><span id="line-1859"></span><span class="hs-comment">--</span><span>
</span><span id="line-1860"></span><span class="hs-comment">-- The simplest (degenerate case) of these is 'null', which determines whether</span><span>
</span><span id="line-1861"></span><span class="hs-comment">-- a structure is empty or not.  This only needs to look at the first element,</span><span>
</span><span id="line-1862"></span><span class="hs-comment">-- and only to the extent of whether it exists or not, and not its value.  In</span><span>
</span><span id="line-1863"></span><span class="hs-comment">-- this case termination is guaranteed, and infinite input structures are fine.</span><span>
</span><span id="line-1864"></span><span class="hs-comment">-- Its default definition is of course in terms of the lazy 'foldr':</span><span>
</span><span id="line-1865"></span><span class="hs-comment">--</span><span>
</span><span id="line-1866"></span><span class="hs-comment">-- &gt; null = foldr (\_ _ -&gt; False) True</span><span>
</span><span id="line-1867"></span><span class="hs-comment">--</span><span>
</span><span id="line-1868"></span><span class="hs-comment">-- A more general example is `any`, which applies a predicate to each input</span><span>
</span><span id="line-1869"></span><span class="hs-comment">-- element in turn until it finds the first one for which the predicate is</span><span>
</span><span id="line-1870"></span><span class="hs-comment">-- true, at which point it returns success.  If, in an infinite input stream</span><span>
</span><span id="line-1871"></span><span class="hs-comment">-- the predicate is false for all the elements, `any` will not terminate,</span><span>
</span><span id="line-1872"></span><span class="hs-comment">-- but since it runs in constant space, it typically won't run out of memory,</span><span>
</span><span id="line-1873"></span><span class="hs-comment">-- it'll just loop forever.</span><span>
</span><span id="line-1874"></span><span>
</span><span id="line-1875"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-1876"></span><span>
</span><span id="line-1877"></span><span class="hs-comment">-- $shortlist</span><span>
</span><span id="line-1878"></span><span class="hs-comment">--</span><span>
</span><span id="line-1879"></span><span class="hs-comment">-- The full list of short-circuit folds in this module is:</span><span>
</span><span id="line-1880"></span><span class="hs-comment">--</span><span>
</span><span id="line-1881"></span><span class="hs-comment">-- * Boolean predicate folds.</span><span>
</span><span id="line-1882"></span><span class="hs-comment">--   These functions examine elements strictly until a condition is met,</span><span>
</span><span id="line-1883"></span><span class="hs-comment">--   but then return a result ignoring the rest (lazy in the tail).  These</span><span>
</span><span id="line-1884"></span><span class="hs-comment">--   may loop forever given an unbounded input where no elements satisfy the</span><span>
</span><span id="line-1885"></span><span class="hs-comment">--   termination condition.</span><span>
</span><span id="line-1886"></span><span class="hs-comment">--</span><span>
</span><span id="line-1887"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1888"></span><span class="hs-comment">--     `null`    :: Foldable t =&gt; t a -&gt; Bool</span><span>
</span><span id="line-1889"></span><span class="hs-comment">--     `elem`    :: Foldable t =&gt; Eq a =&gt; a -&gt; t a -&gt; Bool</span><span>
</span><span id="line-1890"></span><span class="hs-comment">--     `notElem` :: (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool</span><span>
</span><span id="line-1891"></span><span class="hs-comment">--     `and`     :: Foldable t =&gt; t Bool -&gt; Bool</span><span>
</span><span id="line-1892"></span><span class="hs-comment">--     `or`      :: Foldable t =&gt; t Bool -&gt; Bool</span><span>
</span><span id="line-1893"></span><span class="hs-comment">--     `find`    :: Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Maybe a</span><span>
</span><span id="line-1894"></span><span class="hs-comment">--     `any`     :: Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool</span><span>
</span><span id="line-1895"></span><span class="hs-comment">--     `all`     :: Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool</span><span>
</span><span id="line-1896"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1897"></span><span class="hs-comment">--</span><span>
</span><span id="line-1898"></span><span class="hs-comment">-- * Many instances of @('&lt;|&gt;')@ (e.g. the 'Maybe' instance) are conditionally</span><span>
</span><span id="line-1899"></span><span class="hs-comment">--   lazy, and use or don't use their second argument depending on the value</span><span>
</span><span id="line-1900"></span><span class="hs-comment">--   of the first.  These are used with the folds below, which terminate as</span><span>
</span><span id="line-1901"></span><span class="hs-comment">--   early as possible, but otherwise generally keep going.  Some instances</span><span>
</span><span id="line-1902"></span><span class="hs-comment">--   (e.g. for List) are always strict, but the result is lazy in the tail</span><span>
</span><span id="line-1903"></span><span class="hs-comment">--   of the output, so that `asum` for a list of lists is in fact corecursive.</span><span>
</span><span id="line-1904"></span><span class="hs-comment">--   These folds are defined in terms of `foldr`.</span><span>
</span><span id="line-1905"></span><span class="hs-comment">--</span><span>
</span><span id="line-1906"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1907"></span><span class="hs-comment">--     `asum` :: (Foldable t, Alternative f) =&gt; t (f a) -&gt; f a</span><span>
</span><span id="line-1908"></span><span class="hs-comment">--     `msum` :: (Foldable t, MonadPlus m) =&gt; t (m a) -&gt; m a</span><span>
</span><span id="line-1909"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1910"></span><span class="hs-comment">--</span><span>
</span><span id="line-1911"></span><span class="hs-comment">-- * Likewise, the @('*&gt;')@ operator in some `Applicative` functors, and @('&gt;&gt;')@</span><span>
</span><span id="line-1912"></span><span class="hs-comment">--   in some monads are conditionally lazy and can /short-circuit/ a chain of</span><span>
</span><span id="line-1913"></span><span class="hs-comment">--   computations.  The below folds will terminate as early as possible, but</span><span>
</span><span id="line-1914"></span><span class="hs-comment">--   even infinite loops can be productive here, when evaluated solely for</span><span>
</span><span id="line-1915"></span><span class="hs-comment">--   their stream of IO side-effects.  See &quot;Data.Traversable#effectful&quot;</span><span>
</span><span id="line-1916"></span><span class="hs-comment">--   for discussion of related functions.</span><span>
</span><span id="line-1917"></span><span class="hs-comment">--</span><span>
</span><span id="line-1918"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1919"></span><span class="hs-comment">--     `traverse_`  :: (Foldable t, Applicative f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f ()</span><span>
</span><span id="line-1920"></span><span class="hs-comment">--     `for_`       :: (Foldable t, Applicative f) =&gt; t a -&gt; (a -&gt; f b) -&gt; f ()</span><span>
</span><span id="line-1921"></span><span class="hs-comment">--     `sequenceA_` :: (Foldable t, Applicative f) =&gt; t (f a) -&gt; f ()</span><span>
</span><span id="line-1922"></span><span class="hs-comment">--     `mapM_`      :: (Foldable t, Monad m) =&gt; (a -&gt; m b) -&gt; t a -&gt; m ()</span><span>
</span><span id="line-1923"></span><span class="hs-comment">--     `forM_`      :: (Foldable t, Monad m) =&gt; t a -&gt; (a -&gt; m b) -&gt; m ()</span><span>
</span><span id="line-1924"></span><span class="hs-comment">--     `sequence_`  :: (Foldable t, Monad m) =&gt; t (m a) -&gt; m ()</span><span>
</span><span id="line-1925"></span><span class="hs-comment">--     @</span><span>
</span><span id="line-1926"></span><span class="hs-comment">--</span><span>
</span><span id="line-1927"></span><span class="hs-comment">-- * Finally, there's one more special case, `foldlM`:</span><span>
</span><span id="line-1928"></span><span class="hs-comment">--</span><span>
</span><span id="line-1929"></span><span class="hs-comment">--     @`foldlM` :: (Foldable t, Monad m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; t a -&gt; m b@</span><span>
</span><span id="line-1930"></span><span class="hs-comment">--</span><span>
</span><span id="line-1931"></span><span class="hs-comment">--     The sequencing of monadic effects proceeds from left to right.  If at</span><span>
</span><span id="line-1932"></span><span class="hs-comment">--     some step the bind operator @('&gt;&gt;=')@ short-circuits (as with, e.g.,</span><span>
</span><span id="line-1933"></span><span class="hs-comment">--     'mzero' with a 'MonadPlus', or an exception with a 'MonadThrow', etc.),</span><span>
</span><span id="line-1934"></span><span class="hs-comment">--     then the evaluated effects will be from an initial portion of the</span><span>
</span><span id="line-1935"></span><span class="hs-comment">--     element sequence.</span><span>
</span><span id="line-1936"></span><span class="hs-comment">--</span><span>
</span><span id="line-1937"></span><span class="hs-comment">--     &gt;&gt;&gt; :set -XBangPatterns</span><span>
</span><span id="line-1938"></span><span class="hs-comment">--     &gt;&gt;&gt; import Control.Monad</span><span>
</span><span id="line-1939"></span><span class="hs-comment">--     &gt;&gt;&gt; import Control.Monad.Trans.Class</span><span>
</span><span id="line-1940"></span><span class="hs-comment">--     &gt;&gt;&gt; import Control.Monad.Trans.Maybe</span><span>
</span><span id="line-1941"></span><span class="hs-comment">--     &gt;&gt;&gt; import Data.Foldable</span><span>
</span><span id="line-1942"></span><span class="hs-comment">--     &gt;&gt;&gt; let f !_ e = when (e &gt; 3) mzero &gt;&gt; lift (print e)</span><span>
</span><span id="line-1943"></span><span class="hs-comment">--     &gt;&gt;&gt; runMaybeT $ foldlM f () [0..]</span><span>
</span><span id="line-1944"></span><span class="hs-comment">--     0</span><span>
</span><span id="line-1945"></span><span class="hs-comment">--     1</span><span>
</span><span id="line-1946"></span><span class="hs-comment">--     2</span><span>
</span><span id="line-1947"></span><span class="hs-comment">--     3</span><span>
</span><span id="line-1948"></span><span class="hs-comment">--     Nothing</span><span>
</span><span id="line-1949"></span><span class="hs-comment">--</span><span>
</span><span id="line-1950"></span><span class="hs-comment">--     Contrast this with `foldrM`, which sequences monadic effects from right</span><span>
</span><span id="line-1951"></span><span class="hs-comment">--     to left, and therefore diverges when folding an unbounded input</span><span>
</span><span id="line-1952"></span><span class="hs-comment">--     structure without ever having the opportunity to short-circuit.</span><span>
</span><span id="line-1953"></span><span class="hs-comment">--</span><span>
</span><span id="line-1954"></span><span class="hs-comment">--     &gt;&gt;&gt; let f e _ = when (e &gt; 3) mzero &gt;&gt; lift (print e)</span><span>
</span><span id="line-1955"></span><span class="hs-comment">--     &gt;&gt;&gt; runMaybeT $ foldrM f () [0..]</span><span>
</span><span id="line-1956"></span><span class="hs-comment">--     ...hangs...</span><span>
</span><span id="line-1957"></span><span class="hs-comment">--</span><span>
</span><span id="line-1958"></span><span class="hs-comment">--     When the structure is finite `foldrM` performs the monadic effects from</span><span>
</span><span id="line-1959"></span><span class="hs-comment">--     right to left, possibly short-circuiting after processing a tail portion</span><span>
</span><span id="line-1960"></span><span class="hs-comment">--     of the element sequence.</span><span>
</span><span id="line-1961"></span><span class="hs-comment">--</span><span>
</span><span id="line-1962"></span><span class="hs-comment">--     &gt;&gt;&gt; let f e _ = when (e &lt; 3) mzero &gt;&gt; lift (print e)</span><span>
</span><span id="line-1963"></span><span class="hs-comment">--     &gt;&gt;&gt; runMaybeT $ foldrM f () [0..5]</span><span>
</span><span id="line-1964"></span><span class="hs-comment">--     5</span><span>
</span><span id="line-1965"></span><span class="hs-comment">--     4</span><span>
</span><span id="line-1966"></span><span class="hs-comment">--     3</span><span>
</span><span id="line-1967"></span><span class="hs-comment">--     Nothing</span><span>
</span><span id="line-1968"></span><span>
</span><span id="line-1969"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-1970"></span><span>
</span><span id="line-1971"></span><span class="hs-comment">-- $hybrid</span><span>
</span><span id="line-1972"></span><span class="hs-comment">--</span><span>
</span><span id="line-1973"></span><span class="hs-comment">-- The below folds, are neither strict reductions that produce a final answer</span><span>
</span><span id="line-1974"></span><span class="hs-comment">-- in constant space, nor lazy corecursions, and so have limited applicability.</span><span>
</span><span id="line-1975"></span><span class="hs-comment">-- They do have specialised uses, but are best avoided when in doubt.</span><span>
</span><span id="line-1976"></span><span class="hs-comment">--</span><span>
</span><span id="line-1977"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1978"></span><span class="hs-comment">-- 'foldr'' :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span><span>
</span><span id="line-1979"></span><span class="hs-comment">-- 'foldl'  :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</span><span>
</span><span id="line-1980"></span><span class="hs-comment">-- 'foldl1' :: Foldable t =&gt; (a -&gt; a -&gt; a) -&gt; t a -&gt; a</span><span>
</span><span id="line-1981"></span><span class="hs-comment">-- 'foldrM' :: (Foldable t, Monad m) =&gt; (a -&gt; b -&gt; m b) -&gt; b -&gt; t a -&gt; m b</span><span>
</span><span id="line-1982"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1983"></span><span class="hs-comment">--</span><span>
</span><span id="line-1984"></span><span class="hs-comment">-- The lazy left-folds (used corecursively) and 'foldrM' (used to sequence</span><span>
</span><span id="line-1985"></span><span class="hs-comment">-- actions right-to-left) can be performant in structures whose @Foldable@</span><span>
</span><span id="line-1986"></span><span class="hs-comment">-- instances take advantage of efficient right-to-left iteration to compute</span><span>
</span><span id="line-1987"></span><span class="hs-comment">-- lazy left folds outside-in from the rightmost element.</span><span>
</span><span id="line-1988"></span><span class="hs-comment">--</span><span>
</span><span id="line-1989"></span><span class="hs-comment">-- The strict 'foldr'' is the least likely to be useful, structures that</span><span>
</span><span id="line-1990"></span><span class="hs-comment">-- support efficient sequencing /only/ right-to-left are not common.</span><span>
</span><span id="line-1991"></span><span>
</span><span id="line-1992"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-1993"></span><span>
</span><span id="line-1994"></span><span class="hs-comment">-- $instances</span><span>
</span><span id="line-1995"></span><span class="hs-comment">--</span><span>
</span><span id="line-1996"></span><span class="hs-comment">-- #instances#</span><span>
</span><span id="line-1997"></span><span class="hs-comment">-- For many structures reasonably efficient @Foldable@ instances can be derived</span><span>
</span><span id="line-1998"></span><span class="hs-comment">-- automatically, by enabling the @DeriveFoldable@ GHC extension.  When this</span><span>
</span><span id="line-1999"></span><span class="hs-comment">-- works, it is generally not necessary to define a custom instance by hand.</span><span>
</span><span id="line-2000"></span><span class="hs-comment">-- Though in some cases one may be able to get slightly faster hand-tuned code,</span><span>
</span><span id="line-2001"></span><span class="hs-comment">-- care is required to avoid producing slower code, or code that is not</span><span>
</span><span id="line-2002"></span><span class="hs-comment">-- sufficiently lazy, strict or /lawful/.</span><span>
</span><span id="line-2003"></span><span class="hs-comment">--</span><span>
</span><span id="line-2004"></span><span class="hs-comment">-- The hand-crafted instances can get away with only defining one of 'foldr' or</span><span>
</span><span id="line-2005"></span><span class="hs-comment">-- 'foldMap'.  All the other methods have default definitions in terms of one</span><span>
</span><span id="line-2006"></span><span class="hs-comment">-- of these.  The default definitions have the expected strictness and the</span><span>
</span><span id="line-2007"></span><span class="hs-comment">-- expected asymptotic runtime and space costs, modulo small constant factors.</span><span>
</span><span id="line-2008"></span><span class="hs-comment">-- If you choose to hand-tune, benchmarking is advised to see whether you're</span><span>
</span><span id="line-2009"></span><span class="hs-comment">-- doing better than the default derived implementations, plus careful tests to</span><span>
</span><span id="line-2010"></span><span class="hs-comment">-- ensure that the custom methods are correct.</span><span>
</span><span id="line-2011"></span><span class="hs-comment">--</span><span>
</span><span id="line-2012"></span><span class="hs-comment">-- Below we construct a @Foldable@ instance for a data type representing a</span><span>
</span><span id="line-2013"></span><span class="hs-comment">-- (finite) binary tree with depth-first traversal.</span><span>
</span><span id="line-2014"></span><span class="hs-comment">--</span><span>
</span><span id="line-2015"></span><span class="hs-comment">-- &gt; data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)</span><span>
</span><span id="line-2016"></span><span class="hs-comment">--</span><span>
</span><span id="line-2017"></span><span class="hs-comment">-- a suitable instance would be:</span><span>
</span><span id="line-2018"></span><span class="hs-comment">--</span><span>
</span><span id="line-2019"></span><span class="hs-comment">-- &gt; instance Foldable Tree where</span><span>
</span><span id="line-2020"></span><span class="hs-comment">-- &gt;    foldr f z Empty = z</span><span>
</span><span id="line-2021"></span><span class="hs-comment">-- &gt;    foldr f z (Leaf x) = f x z</span><span>
</span><span id="line-2022"></span><span class="hs-comment">-- &gt;    foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l</span><span>
</span><span id="line-2023"></span><span class="hs-comment">--</span><span>
</span><span id="line-2024"></span><span class="hs-comment">-- The 'Node' case is a right fold of the left subtree whose initial</span><span>
</span><span id="line-2025"></span><span class="hs-comment">-- value is a right fold of the rest of the tree.</span><span>
</span><span id="line-2026"></span><span class="hs-comment">--</span><span>
</span><span id="line-2027"></span><span class="hs-comment">-- For example, when @f@ is @(':')@, all three cases return an immediate value,</span><span>
</span><span id="line-2028"></span><span class="hs-comment">-- respectively @z@ or a /cons cell/ holding @x@ or @l@, with the remainder the</span><span>
</span><span id="line-2029"></span><span class="hs-comment">-- structure, if any, encapsulated in a lazy thunk.  This meets the expected</span><span>
</span><span id="line-2030"></span><span class="hs-comment">-- efficient [corecursive](#corec) behaviour of 'foldr'.</span><span>
</span><span id="line-2031"></span><span class="hs-comment">--</span><span>
</span><span id="line-2032"></span><span class="hs-comment">-- Alternatively, one could define @foldMap@:</span><span>
</span><span id="line-2033"></span><span class="hs-comment">--</span><span>
</span><span id="line-2034"></span><span class="hs-comment">-- &gt; instance Foldable Tree where</span><span>
</span><span id="line-2035"></span><span class="hs-comment">-- &gt;    foldMap f Empty = mempty</span><span>
</span><span id="line-2036"></span><span class="hs-comment">-- &gt;    foldMap f (Leaf x) = f x</span><span>
</span><span id="line-2037"></span><span class="hs-comment">-- &gt;    foldMap f (Node l k r) = foldMap f l &lt;&gt; f k &lt;&gt; foldMap f r</span><span>
</span><span id="line-2038"></span><span class="hs-comment">--</span><span>
</span><span id="line-2039"></span><span class="hs-comment">-- And indeed some efficiency may be gained by directly defining both,</span><span>
</span><span id="line-2040"></span><span class="hs-comment">-- avoiding some indirection in the default definitions that express</span><span>
</span><span id="line-2041"></span><span class="hs-comment">-- one in terms of the other.  If you implement just one, likely 'foldr'</span><span>
</span><span id="line-2042"></span><span class="hs-comment">-- is the better choice.</span><span>
</span><span id="line-2043"></span><span class="hs-comment">--</span><span>
</span><span id="line-2044"></span><span class="hs-comment">-- A binary tree typically (when balanced, or randomly biased) provides equally</span><span>
</span><span id="line-2045"></span><span class="hs-comment">-- efficient access to its left and right subtrees.  This makes it possible to</span><span>
</span><span id="line-2046"></span><span class="hs-comment">-- define a `foldl` optimised for [corecursive](#corec) folds with operators</span><span>
</span><span id="line-2047"></span><span class="hs-comment">-- that are lazy in their first (left) argument.</span><span>
</span><span id="line-2048"></span><span class="hs-comment">--</span><span>
</span><span id="line-2049"></span><span class="hs-comment">-- &gt; instance Foldable Tree where</span><span>
</span><span id="line-2050"></span><span class="hs-comment">-- &gt;    foldr f z Empty = z</span><span>
</span><span id="line-2051"></span><span class="hs-comment">-- &gt;    foldr f z (Leaf x) = f x z</span><span>
</span><span id="line-2052"></span><span class="hs-comment">-- &gt;    foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l</span><span>
</span><span id="line-2053"></span><span class="hs-comment">-- &gt;    --</span><span>
</span><span id="line-2054"></span><span class="hs-comment">-- &gt;    foldMap f Empty = mempty</span><span>
</span><span id="line-2055"></span><span class="hs-comment">-- &gt;    foldMap f (Leaf x) = f x</span><span>
</span><span id="line-2056"></span><span class="hs-comment">-- &gt;    foldMap f (Node l k r) = foldMap f l &lt;&gt; f k &lt;&gt; foldMap f r</span><span>
</span><span id="line-2057"></span><span class="hs-comment">-- &gt;    --</span><span>
</span><span id="line-2058"></span><span class="hs-comment">-- &gt;    foldl f z Empty = z</span><span>
</span><span id="line-2059"></span><span class="hs-comment">-- &gt;    foldl f z (Leaf x) = f z x</span><span>
</span><span id="line-2060"></span><span class="hs-comment">-- &gt;    foldl f z (Node l k r) = foldl f (f (foldl f z l) k) r</span><span>
</span><span id="line-2061"></span><span class="hs-comment">--</span><span>
</span><span id="line-2062"></span><span class="hs-comment">-- Now left-to-right and right-to-left iteration over the structure</span><span>
</span><span id="line-2063"></span><span class="hs-comment">-- elements are equally efficient (note the mirror-order output when</span><span>
</span><span id="line-2064"></span><span class="hs-comment">-- using `foldl`):</span><span>
</span><span id="line-2065"></span><span class="hs-comment">--</span><span>
</span><span id="line-2066"></span><span class="hs-comment">-- &gt;&gt;&gt; foldr (\e acc -&gt; e : acc) [] (Node (Leaf 1) 2 (Leaf 3))</span><span>
</span><span id="line-2067"></span><span class="hs-comment">-- [1,2,3]</span><span>
</span><span id="line-2068"></span><span class="hs-comment">-- &gt;&gt;&gt; foldl (\acc e -&gt; e : acc) [] (Node (Leaf 1) 2 (Leaf 3))</span><span>
</span><span id="line-2069"></span><span class="hs-comment">-- [3,2,1]</span><span>
</span><span id="line-2070"></span><span class="hs-comment">--</span><span>
</span><span id="line-2071"></span><span class="hs-comment">-- We can carry this further, and define more non-default methods...</span><span>
</span><span id="line-2072"></span><span class="hs-comment">--</span><span>
</span><span id="line-2073"></span><span class="hs-comment">-- The structure definition actually admits trees that are unbounded on either</span><span>
</span><span id="line-2074"></span><span class="hs-comment">-- or both sides.  The only fold that can plausibly terminate for a tree</span><span>
</span><span id="line-2075"></span><span class="hs-comment">-- unbounded on both left and right is `null`, when defined as shown below.</span><span>
</span><span id="line-2076"></span><span class="hs-comment">-- The default definition in terms of `foldr` diverges if the tree is unbounded</span><span>
</span><span id="line-2077"></span><span class="hs-comment">-- on the left.  Here we define a variant that avoids travelling down the tree</span><span>
</span><span id="line-2078"></span><span class="hs-comment">-- to find the leftmost element and just examines the root node.</span><span>
</span><span id="line-2079"></span><span class="hs-comment">--</span><span>
</span><span id="line-2080"></span><span class="hs-comment">-- &gt;    null Empty = True</span><span>
</span><span id="line-2081"></span><span class="hs-comment">-- &gt;    null _     = False</span><span>
</span><span id="line-2082"></span><span class="hs-comment">--</span><span>
</span><span id="line-2083"></span><span class="hs-comment">-- This is a sound choice also for finite trees.</span><span>
</span><span id="line-2084"></span><span class="hs-comment">--</span><span>
</span><span id="line-2085"></span><span class="hs-comment">-- In practice, unbounded trees are quite uncommon, and can barely be said to</span><span>
</span><span id="line-2086"></span><span class="hs-comment">-- be @Foldable@.  They would typically employ breadth first traversal, and</span><span>
</span><span id="line-2087"></span><span class="hs-comment">-- would support only corecursive and short-circuit folds (diverge under strict</span><span>
</span><span id="line-2088"></span><span class="hs-comment">-- reduction).</span><span>
</span><span id="line-2089"></span><span class="hs-comment">--</span><span>
</span><span id="line-2090"></span><span class="hs-comment">-- Returning to simpler instances, defined just in terms of `foldr`, it is</span><span>
</span><span id="line-2091"></span><span class="hs-comment">-- somewhat surprising that a fairly efficient /default/ implementation of the</span><span>
</span><span id="line-2092"></span><span class="hs-comment">-- strict 'foldl'' is defined in terms of lazy `foldr` when only the latter is</span><span>
</span><span id="line-2093"></span><span class="hs-comment">-- explicitly provided by the instance.  It may be instructive to take a look</span><span>
</span><span id="line-2094"></span><span class="hs-comment">-- at how this works.</span><span>
</span><span id="line-2095"></span><span>
</span><span id="line-2096"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-2097"></span><span>
</span><span id="line-2098"></span><span class="hs-comment">-- $strictlazy</span><span>
</span><span id="line-2099"></span><span class="hs-comment">--</span><span>
</span><span id="line-2100"></span><span class="hs-comment">-- #strictlazy#</span><span>
</span><span id="line-2101"></span><span class="hs-comment">--</span><span>
</span><span id="line-2102"></span><span class="hs-comment">-- Sometimes, it is useful for the result of applying 'foldr' to be a</span><span>
</span><span id="line-2103"></span><span class="hs-comment">-- /function/.  This is done by mapping the structure elements to functions</span><span>
</span><span id="line-2104"></span><span class="hs-comment">-- with the same argument and result types.  The per-element functions are then</span><span>
</span><span id="line-2105"></span><span class="hs-comment">-- composed to give the final result.</span><span>
</span><span id="line-2106"></span><span class="hs-comment">--</span><span>
</span><span id="line-2107"></span><span class="hs-comment">-- For example, we can /flip/ the strict left fold 'foldl'' by writing:</span><span>
</span><span id="line-2108"></span><span class="hs-comment">--</span><span>
</span><span id="line-2109"></span><span class="hs-comment">-- &gt; foldl' f z xs = flippedFoldl' f xs z</span><span>
</span><span id="line-2110"></span><span class="hs-comment">--</span><span>
</span><span id="line-2111"></span><span class="hs-comment">-- with the function 'flippedFoldl'' defined as below, with 'seq' used to</span><span>
</span><span id="line-2112"></span><span class="hs-comment">-- ensure the strictness in the accumulator:</span><span>
</span><span id="line-2113"></span><span class="hs-comment">--</span><span>
</span><span id="line-2114"></span><span class="hs-comment">-- &gt; flippedFoldl' f [] z = z</span><span>
</span><span id="line-2115"></span><span class="hs-comment">-- &gt; flippedFoldl' f (x : xs) z = z `seq` flippedFoldl' f xs (f z x)</span><span>
</span><span id="line-2116"></span><span class="hs-comment">--</span><span>
</span><span id="line-2117"></span><span class="hs-comment">-- Rewriting to use lambdas, this is:</span><span>
</span><span id="line-2118"></span><span class="hs-comment">--</span><span>
</span><span id="line-2119"></span><span class="hs-comment">-- &gt; flippedFoldl' f [] = \ b -&gt; b</span><span>
</span><span id="line-2120"></span><span class="hs-comment">-- &gt; flippedFoldl' f (x : xs) = \ b -&gt; b `seq` r (f b x)</span><span>
</span><span id="line-2121"></span><span class="hs-comment">-- &gt;     where r = flippedFoldl' f xs</span><span>
</span><span id="line-2122"></span><span class="hs-comment">--</span><span>
</span><span id="line-2123"></span><span class="hs-comment">-- The above has the form of a right fold, enabling a rewrite to:</span><span>
</span><span id="line-2124"></span><span class="hs-comment">--</span><span>
</span><span id="line-2125"></span><span class="hs-comment">-- &gt; flippedFoldl' f = \ xs -&gt; foldr f' id xs</span><span>
</span><span id="line-2126"></span><span class="hs-comment">-- &gt;     where f' x r = \ b -&gt; b `seq` r (f b x)</span><span>
</span><span id="line-2127"></span><span class="hs-comment">--</span><span>
</span><span id="line-2128"></span><span class="hs-comment">-- We can now unflip this to get 'foldl'':</span><span>
</span><span id="line-2129"></span><span class="hs-comment">--</span><span>
</span><span id="line-2130"></span><span class="hs-comment">-- &gt; foldl' f z = \ xs -&gt; foldr f' id xs z</span><span>
</span><span id="line-2131"></span><span class="hs-comment">-- &gt;           -- \ xs -&gt; flippedFoldl' f xs z</span><span>
</span><span id="line-2132"></span><span class="hs-comment">-- &gt;   where f' x r = \ b -&gt; b `seq` r (f b x)</span><span>
</span><span id="line-2133"></span><span class="hs-comment">--</span><span>
</span><span id="line-2134"></span><span class="hs-comment">-- The function __@foldr f' id xs@__ applied to @z@ is built corecursively, and</span><span>
</span><span id="line-2135"></span><span class="hs-comment">-- its terms are applied to an eagerly evaluated accumulator before further</span><span>
</span><span id="line-2136"></span><span class="hs-comment">-- terms are applied to the result.  As required, this runs in constant space,</span><span>
</span><span id="line-2137"></span><span class="hs-comment">-- and can be optimised to an efficient loop.</span><span>
</span><span id="line-2138"></span><span class="hs-comment">--</span><span>
</span><span id="line-2139"></span><span class="hs-comment">-- (The actual definition of 'foldl'' labels the lambdas in the definition of</span><span>
</span><span id="line-2140"></span><span class="hs-comment">-- __@f'@__ above as /oneShot/, which enables further optimisations).</span><span>
</span><span id="line-2141"></span><span>
</span><span id="line-2142"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-2143"></span><span>
</span><span id="line-2144"></span><span class="hs-comment">-- $generative</span><span>
</span><span id="line-2145"></span><span class="hs-comment">--</span><span>
</span><span id="line-2146"></span><span class="hs-comment">-- #generative#</span><span>
</span><span id="line-2147"></span><span class="hs-comment">-- So far, we have not discussed /generative recursion/.  Unlike recursive</span><span>
</span><span id="line-2148"></span><span class="hs-comment">-- reduction or corecursion, instead of processing a sequence of elements</span><span>
</span><span id="line-2149"></span><span class="hs-comment">-- already in memory, generative recursion involves producing a possibly</span><span>
</span><span id="line-2150"></span><span class="hs-comment">-- unbounded sequence of values from an initial seed value.  The canonical</span><span>
</span><span id="line-2151"></span><span class="hs-comment">-- example of this is 'Data.List.unfoldr' for Lists, with variants available</span><span>
</span><span id="line-2152"></span><span class="hs-comment">-- for Vectors and various other structures.</span><span>
</span><span id="line-2153"></span><span class="hs-comment">--</span><span>
</span><span id="line-2154"></span><span class="hs-comment">-- A key issue with lists, when used generatively as /iterators/, rather than as</span><span>
</span><span id="line-2155"></span><span class="hs-comment">-- poor-man's containers (see [[1\]](#uselistsnot)), is that such iterators</span><span>
</span><span id="line-2156"></span><span class="hs-comment">-- tend to consume memory when used more than once.  A single traversal of a</span><span>
</span><span id="line-2157"></span><span class="hs-comment">-- list-as-iterator will run in constant space, but as soon as the list is</span><span>
</span><span id="line-2158"></span><span class="hs-comment">-- retained for reuse, its entire element sequence is stored in memory, and the</span><span>
</span><span id="line-2159"></span><span class="hs-comment">-- second traversal reads the copy, rather than regenerates the elements.  It</span><span>
</span><span id="line-2160"></span><span class="hs-comment">-- is sometimes better to recompute the elements rather than memoise the list.</span><span>
</span><span id="line-2161"></span><span class="hs-comment">--</span><span>
</span><span id="line-2162"></span><span class="hs-comment">-- Memoisation happens because the built-in Haskell list __@[]@__ is</span><span>
</span><span id="line-2163"></span><span class="hs-comment">-- represented as __data__, either empty or a /cons-cell/ holding the first</span><span>
</span><span id="line-2164"></span><span class="hs-comment">-- element and the tail of the list.  The @Foldable@ class enables a variant</span><span>
</span><span id="line-2165"></span><span class="hs-comment">-- representation of iterators as /functions/, which take an operator and a</span><span>
</span><span id="line-2166"></span><span class="hs-comment">-- starting accumulator and output a summary result.</span><span>
</span><span id="line-2167"></span><span class="hs-comment">--</span><span>
</span><span id="line-2168"></span><span class="hs-comment">-- The [@fmlist@](https://hackage.haskell.org/package/fmlist) package takes</span><span>
</span><span id="line-2169"></span><span class="hs-comment">-- this approach, by representing a list via its `foldMap` action.</span><span>
</span><span id="line-2170"></span><span class="hs-comment">--</span><span>
</span><span id="line-2171"></span><span class="hs-comment">-- Below we implement an analogous data structure using a representation</span><span>
</span><span id="line-2172"></span><span class="hs-comment">-- based on `foldr`.  This is an example of /Church encoding/</span><span>
</span><span id="line-2173"></span><span class="hs-comment">-- (named after Alonzo Church, inventor of the lambda calculus).</span><span>
</span><span id="line-2174"></span><span class="hs-comment">--</span><span>
</span><span id="line-2175"></span><span class="hs-comment">-- &gt; {-# LANGUAGE RankNTypes #-}</span><span>
</span><span id="line-2176"></span><span class="hs-comment">-- &gt; newtype FRList a = FR { unFR :: forall b. (a -&gt; b -&gt; b) -&gt; b -&gt; b }</span><span>
</span><span id="line-2177"></span><span class="hs-comment">--</span><span>
</span><span id="line-2178"></span><span class="hs-comment">-- The __@unFR@__ field of this type is essentially its `foldr` method</span><span>
</span><span id="line-2179"></span><span class="hs-comment">-- with the list as its first rather than last argument.  Thus we</span><span>
</span><span id="line-2180"></span><span class="hs-comment">-- immediately get a @Foldable@ instance (and a 'toList' function</span><span>
</span><span id="line-2181"></span><span class="hs-comment">-- mapping an __@FRList@__ to a regular list).</span><span>
</span><span id="line-2182"></span><span class="hs-comment">--</span><span>
</span><span id="line-2183"></span><span class="hs-comment">-- &gt; instance Foldable FRList where</span><span>
</span><span id="line-2184"></span><span class="hs-comment">-- &gt;     foldr f z l = unFR l f z</span><span>
</span><span id="line-2185"></span><span class="hs-comment">-- &gt;     -- With older versions of @base@, also define sum, product, ...</span><span>
</span><span id="line-2186"></span><span class="hs-comment">-- &gt;     -- to ensure use of the strict 'foldl''.</span><span>
</span><span id="line-2187"></span><span class="hs-comment">-- &gt;     -- sum = foldl' (+) 0</span><span>
</span><span id="line-2188"></span><span class="hs-comment">-- &gt;     -- ...</span><span>
</span><span id="line-2189"></span><span class="hs-comment">--</span><span>
</span><span id="line-2190"></span><span class="hs-comment">-- We can convert a regular list to an __@FRList@__ with:</span><span>
</span><span id="line-2191"></span><span class="hs-comment">--</span><span>
</span><span id="line-2192"></span><span class="hs-comment">-- &gt; fromList :: [a] -&gt; FRList a</span><span>
</span><span id="line-2193"></span><span class="hs-comment">-- &gt; fromList as = FRList $ \ f z -&gt; foldr f z as</span><span>
</span><span id="line-2194"></span><span class="hs-comment">--</span><span>
</span><span id="line-2195"></span><span class="hs-comment">-- However, reuse of an __@FRList@__ obtained in this way will typically</span><span>
</span><span id="line-2196"></span><span class="hs-comment">-- memoise the underlying element sequence.  Instead, we can define</span><span>
</span><span id="line-2197"></span><span class="hs-comment">-- __@FRList@__ terms directly:</span><span>
</span><span id="line-2198"></span><span class="hs-comment">--</span><span>
</span><span id="line-2199"></span><span class="hs-comment">-- &gt; -- | Immediately return the initial accumulator</span><span>
</span><span id="line-2200"></span><span class="hs-comment">-- &gt; nil :: FRList a</span><span>
</span><span id="line-2201"></span><span class="hs-comment">-- &gt; nil = FRList $ \ _ z -&gt; z</span><span>
</span><span id="line-2202"></span><span class="hs-comment">-- &gt; {-# INLINE nil #-}</span><span>
</span><span id="line-2203"></span><span class="hs-comment">--</span><span>
</span><span id="line-2204"></span><span class="hs-comment">-- &gt; -- | Fold the tail to use as an accumulator with the new initial element</span><span>
</span><span id="line-2205"></span><span class="hs-comment">-- &gt; cons :: a -&gt; FRList a -&gt; FRList a</span><span>
</span><span id="line-2206"></span><span class="hs-comment">-- &gt; cons a l = FRList $ \ f z -&gt; f a (unFR l f z)</span><span>
</span><span id="line-2207"></span><span class="hs-comment">-- &gt; {-# INLINE cons #-}</span><span>
</span><span id="line-2208"></span><span class="hs-comment">--</span><span>
</span><span id="line-2209"></span><span class="hs-comment">-- More crucially, we can also directly define the key building block for</span><span>
</span><span id="line-2210"></span><span class="hs-comment">-- generative recursion:</span><span>
</span><span id="line-2211"></span><span class="hs-comment">--</span><span>
</span><span id="line-2212"></span><span class="hs-comment">-- &gt; -- | Generative recursion, dual to `foldr`.</span><span>
</span><span id="line-2213"></span><span class="hs-comment">-- &gt; unfoldr :: (s -&gt; Maybe (a, s)) -&gt; s -&gt; FRList a</span><span>
</span><span id="line-2214"></span><span class="hs-comment">-- &gt; unfoldr g s0 = FR generate</span><span>
</span><span id="line-2215"></span><span class="hs-comment">-- &gt;   where generate f z = loop s0</span><span>
</span><span id="line-2216"></span><span class="hs-comment">-- &gt;           where loop s | Just (a, t) &lt;- g s = f a (loop t)</span><span>
</span><span id="line-2217"></span><span class="hs-comment">-- &gt;                        | otherwise = z</span><span>
</span><span id="line-2218"></span><span class="hs-comment">-- &gt; {-# INLINE unfoldr #-}</span><span>
</span><span id="line-2219"></span><span class="hs-comment">--</span><span>
</span><span id="line-2220"></span><span class="hs-comment">-- Which can, for example, be specialised to number ranges:</span><span>
</span><span id="line-2221"></span><span class="hs-comment">--</span><span>
</span><span id="line-2222"></span><span class="hs-comment">-- &gt; -- | Generate a range of consecutive integral values.</span><span>
</span><span id="line-2223"></span><span class="hs-comment">-- &gt; range :: (Ord a, Integral a) =&gt; a -&gt; a -&gt; FRList a</span><span>
</span><span id="line-2224"></span><span class="hs-comment">-- &gt; range lo hi =</span><span>
</span><span id="line-2225"></span><span class="hs-comment">-- &gt;     unfoldr (\s -&gt; if s &gt; hi then Nothing else Just (s, s+1)) lo</span><span>
</span><span id="line-2226"></span><span class="hs-comment">-- &gt; {-# INLINE range #-}</span><span>
</span><span id="line-2227"></span><span class="hs-comment">--</span><span>
</span><span id="line-2228"></span><span class="hs-comment">-- The program below, when compiled with optimisation:</span><span>
</span><span id="line-2229"></span><span class="hs-comment">--</span><span>
</span><span id="line-2230"></span><span class="hs-comment">-- &gt; main :: IO ()</span><span>
</span><span id="line-2231"></span><span class="hs-comment">-- &gt; main = do</span><span>
</span><span id="line-2232"></span><span class="hs-comment">-- &gt;     let r :: FRList Int</span><span>
</span><span id="line-2233"></span><span class="hs-comment">-- &gt;         r = range 1 10000000</span><span>
</span><span id="line-2234"></span><span class="hs-comment">-- &gt;      in print (sum r, length r)</span><span>
</span><span id="line-2235"></span><span class="hs-comment">--</span><span>
</span><span id="line-2236"></span><span class="hs-comment">-- produces the expected output with no noticeable garbage-collection, despite</span><span>
</span><span id="line-2237"></span><span class="hs-comment">-- reuse of the __@FRList@__ term __@r@__.</span><span>
</span><span id="line-2238"></span><span class="hs-comment">--</span><span>
</span><span id="line-2239"></span><span class="hs-comment">-- &gt; (50000005000000,10000000)</span><span>
</span><span id="line-2240"></span><span class="hs-comment">-- &gt;     52,120 bytes allocated in the heap</span><span>
</span><span id="line-2241"></span><span class="hs-comment">-- &gt;      3,320 bytes copied during GC</span><span>
</span><span id="line-2242"></span><span class="hs-comment">-- &gt;     44,376 bytes maximum residency (1 sample(s))</span><span>
</span><span id="line-2243"></span><span class="hs-comment">-- &gt;     25,256 bytes maximum slop</span><span>
</span><span id="line-2244"></span><span class="hs-comment">-- &gt;          3 MiB total memory in use (0 MB lost due to fragmentation)</span><span>
</span><span id="line-2245"></span><span class="hs-comment">--</span><span>
</span><span id="line-2246"></span><span class="hs-comment">-- The Weak Head Normal Form of an __@FRList@__ is a lambda abstraction not a</span><span>
</span><span id="line-2247"></span><span class="hs-comment">-- data value, and reuse does not lead to memoisation.  Reuse of the iterator</span><span>
</span><span id="line-2248"></span><span class="hs-comment">-- above is somewhat contrived, when computing multiple folds over a common</span><span>
</span><span id="line-2249"></span><span class="hs-comment">-- list, you should generally traverse a  list only [once](#multipass).  The</span><span>
</span><span id="line-2250"></span><span class="hs-comment">-- goal is to demonstrate that the separate computations of the 'sum' and</span><span>
</span><span id="line-2251"></span><span class="hs-comment">-- 'length' run efficiently in constant space, despite reuse.  This would not</span><span>
</span><span id="line-2252"></span><span class="hs-comment">-- be the case with the list @[1..10000000]@.</span><span>
</span><span id="line-2253"></span><span class="hs-comment">--</span><span>
</span><span id="line-2254"></span><span class="hs-comment">-- This is, however, an artificially simple reduction.  More typically, there</span><span>
</span><span id="line-2255"></span><span class="hs-comment">-- are likely to be some allocations in the inner loop, but the temporary</span><span>
</span><span id="line-2256"></span><span class="hs-comment">-- storage used will be garbage-collected as needed, and overall memory</span><span>
</span><span id="line-2257"></span><span class="hs-comment">-- utilisation will remain modest and will not scale with the size of the list.</span><span>
</span><span id="line-2258"></span><span class="hs-comment">--</span><span>
</span><span id="line-2259"></span><span class="hs-comment">-- If we go back to built-in lists (i.e. __@[]@__), but avoid reuse by</span><span>
</span><span id="line-2260"></span><span class="hs-comment">-- performing reduction in a single pass, as below:</span><span>
</span><span id="line-2261"></span><span class="hs-comment">--</span><span>
</span><span id="line-2262"></span><span class="hs-comment">-- &gt; data PairS a b = P !a !b -- We define a strict pair datatype</span><span>
</span><span id="line-2263"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-2264"></span><span class="hs-comment">-- &gt; main :: IO ()</span><span>
</span><span id="line-2265"></span><span class="hs-comment">-- &gt; main = do</span><span>
</span><span id="line-2266"></span><span class="hs-comment">-- &gt;     let l :: [Int]</span><span>
</span><span id="line-2267"></span><span class="hs-comment">-- &gt;         l = [1..10000000]</span><span>
</span><span id="line-2268"></span><span class="hs-comment">-- &gt;      in print $ average l</span><span>
</span><span id="line-2269"></span><span class="hs-comment">-- &gt;   where</span><span>
</span><span id="line-2270"></span><span class="hs-comment">-- &gt;     sumlen :: PairS Int Int -&gt; Int -&gt; PairS Int Int</span><span>
</span><span id="line-2271"></span><span class="hs-comment">-- &gt;     sumlen (P s l) a = P (s + a) (l + 1)</span><span>
</span><span id="line-2272"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-2273"></span><span class="hs-comment">-- &gt;     average is =</span><span>
</span><span id="line-2274"></span><span class="hs-comment">-- &gt;         let (P s l) = foldl' sumlen (P 0 0) is</span><span>
</span><span id="line-2275"></span><span class="hs-comment">-- &gt;          in (fromIntegral s :: Double) / fromIntegral l</span><span>
</span><span id="line-2276"></span><span class="hs-comment">--</span><span>
</span><span id="line-2277"></span><span class="hs-comment">-- the result is again obtained in constant space:</span><span>
</span><span id="line-2278"></span><span class="hs-comment">--</span><span>
</span><span id="line-2279"></span><span class="hs-comment">-- &gt; 5000000.5</span><span>
</span><span id="line-2280"></span><span class="hs-comment">-- &gt;          102,176 bytes allocated in the heap</span><span>
</span><span id="line-2281"></span><span class="hs-comment">-- &gt;            3,320 bytes copied during GC</span><span>
</span><span id="line-2282"></span><span class="hs-comment">-- &gt;           44,376 bytes maximum residency (1 sample(s))</span><span>
</span><span id="line-2283"></span><span class="hs-comment">-- &gt;           25,256 bytes maximum slop</span><span>
</span><span id="line-2284"></span><span class="hs-comment">-- &gt;                3 MiB total memory in use (0 MB lost due to fragmentation)</span><span>
</span><span id="line-2285"></span><span class="hs-comment">--</span><span>
</span><span id="line-2286"></span><span class="hs-comment">-- (and, in fact, faster than with __@FRList@__ by a small factor).</span><span>
</span><span id="line-2287"></span><span class="hs-comment">--</span><span>
</span><span id="line-2288"></span><span class="hs-comment">-- The __@[]@__ list structure works as an efficient iterator when used</span><span>
</span><span id="line-2289"></span><span class="hs-comment">-- just once.  When space-leaks via list reuse are not a concern, and/or</span><span>
</span><span id="line-2290"></span><span class="hs-comment">-- memoisation is actually desirable, the regular list implementation is</span><span>
</span><span id="line-2291"></span><span class="hs-comment">-- likely to be faster.  This is not a suggestion to replace all your uses of</span><span>
</span><span id="line-2292"></span><span class="hs-comment">-- __@[]@__ with a generative alternative.</span><span>
</span><span id="line-2293"></span><span class="hs-comment">--</span><span>
</span><span id="line-2294"></span><span class="hs-comment">-- The __@FRList@__ type could be further extended with instances of 'Functor',</span><span>
</span><span id="line-2295"></span><span class="hs-comment">-- 'Applicative', 'Monad', 'Alternative', etc., and could then provide a</span><span>
</span><span id="line-2296"></span><span class="hs-comment">-- fully-featured list type, optimised for reuse without space-leaks.  If,</span><span>
</span><span id="line-2297"></span><span class="hs-comment">-- however, all that's required is space-efficient, re-use friendly iteration,</span><span>
</span><span id="line-2298"></span><span class="hs-comment">-- less is perhaps more, and just @Foldable@ may be sufficient.</span><span>
</span><span id="line-2299"></span><span>
</span><span id="line-2300"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-2301"></span><span>
</span><span id="line-2302"></span><span class="hs-comment">-- $multipass</span><span>
</span><span id="line-2303"></span><span class="hs-comment">--</span><span>
</span><span id="line-2304"></span><span class="hs-comment">-- #multipass#</span><span>
</span><span id="line-2305"></span><span class="hs-comment">-- In applications where you want to compute a composite function of a</span><span>
</span><span id="line-2306"></span><span class="hs-comment">-- structure, which requires more than one aggregate as an input, it is</span><span>
</span><span id="line-2307"></span><span class="hs-comment">-- generally best to compute all the aggregates in a single pass, rather</span><span>
</span><span id="line-2308"></span><span class="hs-comment">-- than to traverse the same structure repeatedly.</span><span>
</span><span id="line-2309"></span><span class="hs-comment">--</span><span>
</span><span id="line-2310"></span><span class="hs-comment">-- The [@foldl@](http://hackage.haskell.org/package/foldl) package implements a</span><span>
</span><span id="line-2311"></span><span class="hs-comment">-- robust general framework for dealing with this situation.  If you choose to</span><span>
</span><span id="line-2312"></span><span class="hs-comment">-- to do it yourself, with a bit of care, the simplest cases are not difficult</span><span>
</span><span id="line-2313"></span><span class="hs-comment">-- to handle directly.  You just need to accumulate the individual aggregates</span><span>
</span><span id="line-2314"></span><span class="hs-comment">-- as __strict__ components of a single data type, and then apply a final</span><span>
</span><span id="line-2315"></span><span class="hs-comment">-- transformation to it to extract the composite result.  For example,</span><span>
</span><span id="line-2316"></span><span class="hs-comment">-- computing an average requires computing both the 'sum' and the 'length' of a</span><span>
</span><span id="line-2317"></span><span class="hs-comment">-- (non-empty) structure and dividing the sum by the length:</span><span>
</span><span id="line-2318"></span><span class="hs-comment">--</span><span>
</span><span id="line-2319"></span><span class="hs-comment">-- &gt; import Data.Foldable (foldl')</span><span>
</span><span id="line-2320"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-2321"></span><span class="hs-comment">-- &gt; data PairS a b = P !a !b -- We define a strict pair datatype</span><span>
</span><span id="line-2322"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-2323"></span><span class="hs-comment">-- &gt; -- | Compute sum and length in a single pass, then reduce to the average.</span><span>
</span><span id="line-2324"></span><span class="hs-comment">-- &gt; average :: (Foldable f, Fractional a) =&gt; f a -&gt; a</span><span>
</span><span id="line-2325"></span><span class="hs-comment">-- &gt; average xs =</span><span>
</span><span id="line-2326"></span><span class="hs-comment">-- &gt;     let sumlen (P s l) a = P (s + a) (l + 1 :: Int)</span><span>
</span><span id="line-2327"></span><span class="hs-comment">-- &gt;         (P s l) = foldl' sumlen (P 0 0) xs</span><span>
</span><span id="line-2328"></span><span class="hs-comment">-- &gt;      in s / fromIntegral l</span><span>
</span><span id="line-2329"></span><span class="hs-comment">--</span><span>
</span><span id="line-2330"></span><span class="hs-comment">-- The above example is somewhat contrived, some structures keep track of their</span><span>
</span><span id="line-2331"></span><span class="hs-comment">-- length internally, and can return it in \(\mathcal{O}(1)\) time, so this</span><span>
</span><span id="line-2332"></span><span class="hs-comment">-- particular recipe for averages is not always the most efficient.  In</span><span>
</span><span id="line-2333"></span><span class="hs-comment">-- general, composite aggregate functions of large structures benefit from</span><span>
</span><span id="line-2334"></span><span class="hs-comment">-- single-pass reduction.  This is especially the case when reuse of a list and</span><span>
</span><span id="line-2335"></span><span class="hs-comment">-- memoisation of its elements is thereby avoided,</span><span>
</span><span id="line-2336"></span><span>
</span><span id="line-2337"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-2338"></span><span>
</span><span id="line-2339"></span><span class="hs-comment">-- $laws</span><span>
</span><span id="line-2340"></span><span class="hs-comment">-- #laws#</span><span>
</span><span id="line-2341"></span><span class="hs-comment">--</span><span>
</span><span id="line-2342"></span><span class="hs-comment">-- The type constructor 'Endo' from &quot;Data.Monoid&quot;, associates with each type</span><span>
</span><span id="line-2343"></span><span class="hs-comment">-- __@b@__ the __@newtype@__-encapsulated type of functions mapping __@b@__ to</span><span>
</span><span id="line-2344"></span><span class="hs-comment">-- itself.  Functions from a type to itself are called /endomorphisms/, hence</span><span>
</span><span id="line-2345"></span><span class="hs-comment">-- the name /Endo/.  The type __@Endo b@__ is a 'Monoid' under function</span><span>
</span><span id="line-2346"></span><span class="hs-comment">-- composition:</span><span>
</span><span id="line-2347"></span><span class="hs-comment">--</span><span>
</span><span id="line-2348"></span><span class="hs-comment">-- &gt; newtype Endo b = Endo { appEndo :: b -&gt; b }</span><span>
</span><span id="line-2349"></span><span class="hs-comment">-- &gt; instance Semigroup Endo b where</span><span>
</span><span id="line-2350"></span><span class="hs-comment">-- &gt;     Endo f &lt;&gt; Endo g = Endo (f . g)</span><span>
</span><span id="line-2351"></span><span class="hs-comment">-- &gt; instance Monoid Endo b where</span><span>
</span><span id="line-2352"></span><span class="hs-comment">-- &gt;     mempty = Endo id</span><span>
</span><span id="line-2353"></span><span class="hs-comment">--</span><span>
</span><span id="line-2354"></span><span class="hs-comment">-- For every 'Monoid' m, we also have a 'Dual' monoid __@Dual m@__ which</span><span>
</span><span id="line-2355"></span><span class="hs-comment">-- combines elements in the opposite order:</span><span>
</span><span id="line-2356"></span><span class="hs-comment">--</span><span>
</span><span id="line-2357"></span><span class="hs-comment">-- &gt; newtype Dual m = Dual { getDual :: m }</span><span>
</span><span id="line-2358"></span><span class="hs-comment">-- &gt; instance Semigroup m =&gt; Semigroup Dual m where</span><span>
</span><span id="line-2359"></span><span class="hs-comment">-- &gt;     Dual a &lt;&gt; Dual b = Dual (b &lt;&gt; a)</span><span>
</span><span id="line-2360"></span><span class="hs-comment">-- &gt; instance Monoid m =&gt; Monoid Dual m where</span><span>
</span><span id="line-2361"></span><span class="hs-comment">-- &gt;     mempty = Dual mempty</span><span>
</span><span id="line-2362"></span><span class="hs-comment">--</span><span>
</span><span id="line-2363"></span><span class="hs-comment">-- With the above preliminaries out of the way, 'Foldable' instances are</span><span>
</span><span id="line-2364"></span><span class="hs-comment">-- expected to satisfy the following laws:</span><span>
</span><span id="line-2365"></span><span class="hs-comment">--</span><span>
</span><span id="line-2366"></span><span class="hs-comment">-- The 'foldr' method must be equivalent in value and strictness to replacing</span><span>
</span><span id="line-2367"></span><span class="hs-comment">-- each element __@a@__ of a 'Foldable' structure with __@Endo (f a)@__,</span><span>
</span><span id="line-2368"></span><span class="hs-comment">-- composing these via 'foldMap' and applying the result to the base case</span><span>
</span><span id="line-2369"></span><span class="hs-comment">-- __@z@__:</span><span>
</span><span id="line-2370"></span><span class="hs-comment">--</span><span>
</span><span id="line-2371"></span><span class="hs-comment">-- &gt; foldr f z t = appEndo (foldMap (Endo . f) t ) z</span><span>
</span><span id="line-2372"></span><span class="hs-comment">--</span><span>
</span><span id="line-2373"></span><span class="hs-comment">-- Likewise, the 'foldl' method must be equivalent in value and strictness</span><span>
</span><span id="line-2374"></span><span class="hs-comment">-- to composing the functions __@flip f a@__ in reverse order and applying</span><span>
</span><span id="line-2375"></span><span class="hs-comment">-- the result to the base case:</span><span>
</span><span id="line-2376"></span><span class="hs-comment">--</span><span>
</span><span id="line-2377"></span><span class="hs-comment">-- &gt; foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z</span><span>
</span><span id="line-2378"></span><span class="hs-comment">--</span><span>
</span><span id="line-2379"></span><span class="hs-comment">-- When the elements of the structure are taken from a 'Monoid', the</span><span>
</span><span id="line-2380"></span><span class="hs-comment">-- definition of 'fold' must agree with __@foldMap id@__:</span><span>
</span><span id="line-2381"></span><span class="hs-comment">--</span><span>
</span><span id="line-2382"></span><span class="hs-comment">-- &gt; fold = foldMap id</span><span>
</span><span id="line-2383"></span><span class="hs-comment">--</span><span>
</span><span id="line-2384"></span><span class="hs-comment">-- The 'length' method must agree with a 'foldMap' mapping each element to</span><span>
</span><span id="line-2385"></span><span class="hs-comment">-- __@Sum 1@__ (The 'Sum' type abstracts numbers as a monoid under addition).</span><span>
</span><span id="line-2386"></span><span class="hs-comment">--</span><span>
</span><span id="line-2387"></span><span class="hs-comment">-- &gt; length = getSum . foldMap (Sum . const 1)</span><span>
</span><span id="line-2388"></span><span class="hs-comment">--</span><span>
</span><span id="line-2389"></span><span class="hs-comment">-- @sum@, @product@, @maximum@, and @minimum@ should all be essentially</span><span>
</span><span id="line-2390"></span><span class="hs-comment">-- equivalent to @foldMap@ forms, such as</span><span>
</span><span id="line-2391"></span><span class="hs-comment">--</span><span>
</span><span id="line-2392"></span><span class="hs-comment">-- &gt; sum     = getSum     . foldMap' Sum</span><span>
</span><span id="line-2393"></span><span class="hs-comment">-- &gt; product = getProduct . foldMap' Product</span><span>
</span><span id="line-2394"></span><span class="hs-comment">--</span><span>
</span><span id="line-2395"></span><span class="hs-comment">-- but are generally more efficient when defined more directly as:</span><span>
</span><span id="line-2396"></span><span class="hs-comment">--</span><span>
</span><span id="line-2397"></span><span class="hs-comment">-- &gt; sum = foldl' (+) 0</span><span>
</span><span id="line-2398"></span><span class="hs-comment">-- &gt; product = foldl' (*) 1</span><span>
</span><span id="line-2399"></span><span class="hs-comment">--</span><span>
</span><span id="line-2400"></span><span class="hs-comment">-- If the 'Foldable' structure has a 'Functor' instance, then for every</span><span>
</span><span id="line-2401"></span><span class="hs-comment">-- function __@f@__ mapping the elements into a 'Monoid', it should satisfy:</span><span>
</span><span id="line-2402"></span><span class="hs-comment">--</span><span>
</span><span id="line-2403"></span><span class="hs-comment">-- &gt; foldMap f = fold . fmap f</span><span>
</span><span id="line-2404"></span><span class="hs-comment">--</span><span>
</span><span id="line-2405"></span><span class="hs-comment">-- which implies that</span><span>
</span><span id="line-2406"></span><span class="hs-comment">--</span><span>
</span><span id="line-2407"></span><span class="hs-comment">-- &gt; foldMap f . fmap g = foldMap (f . g)</span><span>
</span><span id="line-2408"></span><span class="hs-comment">--</span><span>
</span><span id="line-2409"></span><span>
</span><span id="line-2410"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-2411"></span><span>
</span><span id="line-2412"></span><span class="hs-comment">-- $notes</span><span>
</span><span id="line-2413"></span><span class="hs-comment">--</span><span>
</span><span id="line-2414"></span><span class="hs-comment">-- #notes#</span><span>
</span><span id="line-2415"></span><span class="hs-comment">-- Since 'Foldable' does not have 'Functor' as a superclass, it is possible to</span><span>
</span><span id="line-2416"></span><span class="hs-comment">-- define 'Foldable' instances for structures that constrain their element</span><span>
</span><span id="line-2417"></span><span class="hs-comment">-- types.  Therefore, __@Set@__ can be 'Foldable', even though sets keep their</span><span>
</span><span id="line-2418"></span><span class="hs-comment">-- elements in ascending order.  This requires the elements to be comparable,</span><span>
</span><span id="line-2419"></span><span class="hs-comment">-- which precludes defining a 'Functor' instance for @Set@.</span><span>
</span><span id="line-2420"></span><span class="hs-comment">--</span><span>
</span><span id="line-2421"></span><span class="hs-comment">-- The 'Foldable' class makes it possible to use idioms familiar from the @List@</span><span>
</span><span id="line-2422"></span><span class="hs-comment">-- type with container structures that are better suited to the task at hand.</span><span>
</span><span id="line-2423"></span><span class="hs-comment">-- This supports use of more appropriate 'Foldable' data types, such as @Seq@,</span><span>
</span><span id="line-2424"></span><span class="hs-comment">-- @Set@, @NonEmpty@, etc., without requiring new idioms (see</span><span>
</span><span id="line-2425"></span><span class="hs-comment">-- [[1\]](#uselistsnot) for when not to use lists).</span><span>
</span><span id="line-2426"></span><span class="hs-comment">--</span><span>
</span><span id="line-2427"></span><span class="hs-comment">-- The more general methods of the 'Foldable' class are now exported by the</span><span>
</span><span id="line-2428"></span><span class="hs-comment">-- &quot;Prelude&quot; in place of the original List-specific methods (see the</span><span>
</span><span id="line-2429"></span><span class="hs-comment">-- [FTP Proposal](https://wiki.haskell.org/Foldable_Traversable_In_Prelude)).</span><span>
</span><span id="line-2430"></span><span class="hs-comment">-- The List-specific variants are for now still available in &quot;GHC.OldList&quot;, but</span><span>
</span><span id="line-2431"></span><span class="hs-comment">-- that module is intended only as a transitional aid, and may be removed in</span><span>
</span><span id="line-2432"></span><span class="hs-comment">-- the future.</span><span>
</span><span id="line-2433"></span><span class="hs-comment">--</span><span>
</span><span id="line-2434"></span><span class="hs-comment">-- Surprises can arise from the @Foldable@ instance of the 2-tuple @(a,)@ which</span><span>
</span><span id="line-2435"></span><span class="hs-comment">-- now behaves as a 1-element @Foldable@ container in its second slot.  In</span><span>
</span><span id="line-2436"></span><span class="hs-comment">-- contexts where a specific monomorphic type is expected, and you want to be</span><span>
</span><span id="line-2437"></span><span class="hs-comment">-- able to rely on type errors to guide refactoring, it may make sense to</span><span>
</span><span id="line-2438"></span><span class="hs-comment">-- define and use less-polymorphic variants of some of the @Foldable@ methods.</span><span>
</span><span id="line-2439"></span><span class="hs-comment">--</span><span>
</span><span id="line-2440"></span><span class="hs-comment">-- Below are two examples showing a definition of a reusable less-polymorphic</span><span>
</span><span id="line-2441"></span><span class="hs-comment">-- 'sum' and a one-off in-line specialisation of 'length':</span><span>
</span><span id="line-2442"></span><span class="hs-comment">--</span><span>
</span><span id="line-2443"></span><span class="hs-comment">-- &gt; {-# LANGUAGE TypeApplications #-}</span><span>
</span><span id="line-2444"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-2445"></span><span class="hs-comment">-- &gt; mySum :: Num a =&gt; [a] -&gt; a</span><span>
</span><span id="line-2446"></span><span class="hs-comment">-- &gt; mySum = sum</span><span>
</span><span id="line-2447"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-2448"></span><span class="hs-comment">-- &gt; type SlowVector a = [a]</span><span>
</span><span id="line-2449"></span><span class="hs-comment">-- &gt; slowLength :: SlowVector -&gt; Int</span><span>
</span><span id="line-2450"></span><span class="hs-comment">-- &gt; slowLength v = length @[] v</span><span>
</span><span id="line-2451"></span><span class="hs-comment">--</span><span>
</span><span id="line-2452"></span><span class="hs-comment">-- In both cases, if the data type to which the function is applied changes</span><span>
</span><span id="line-2453"></span><span class="hs-comment">-- to something other than a list, the call-site will no longer compile until</span><span>
</span><span id="line-2454"></span><span class="hs-comment">-- appropriate changes are made.</span><span>
</span><span id="line-2455"></span><span>
</span><span id="line-2456"></span><span class="hs-comment">-- $linear</span><span>
</span><span id="line-2457"></span><span class="hs-comment">--</span><span>
</span><span id="line-2458"></span><span class="hs-comment">-- It is perhaps worth noting that since the __`elem`__ function in the</span><span>
</span><span id="line-2459"></span><span class="hs-comment">-- Foldable class carries only an __`Eq`__ constraint on the element type,</span><span>
</span><span id="line-2460"></span><span class="hs-comment">-- search for the presence or absence of an element in the structure generally</span><span>
</span><span id="line-2461"></span><span class="hs-comment">-- takes \(\mathcal{O}(n)\) time, even for ordered structures like __@Set@__</span><span>
</span><span id="line-2462"></span><span class="hs-comment">-- that are potentially capable of performing the search faster.  (The @member@</span><span>
</span><span id="line-2463"></span><span class="hs-comment">-- function of the @Set@ module carries an `Ord` constraint, and can perform</span><span>
</span><span id="line-2464"></span><span class="hs-comment">-- the search in \(\mathcal{O}(log\ n)\) time).</span><span>
</span><span id="line-2465"></span><span class="hs-comment">--</span><span>
</span><span id="line-2466"></span><span class="hs-comment">-- An alternative to Foldable's __`elem`__ method is required in order to</span><span>
</span><span id="line-2467"></span><span class="hs-comment">-- abstract potentially faster than linear search over general container</span><span>
</span><span id="line-2468"></span><span class="hs-comment">-- structures.  This can be achieved by defining an additional type class (e.g.</span><span>
</span><span id="line-2469"></span><span class="hs-comment">-- @HasMember@ below).  Instances of such a type class (that are also</span><span>
</span><span id="line-2470"></span><span class="hs-comment">-- `Foldable') can employ the `elem` linear search as a last resort, when</span><span>
</span><span id="line-2471"></span><span class="hs-comment">-- faster search is not supported.</span><span>
</span><span id="line-2472"></span><span class="hs-comment">--</span><span>
</span><span id="line-2473"></span><span class="hs-comment">-- &gt; {-# LANGUAGE FlexibleInstances, MultiParamTypeClasses #-}</span><span>
</span><span id="line-2474"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-2475"></span><span class="hs-comment">-- &gt; import qualified Data.Set as Set</span><span>
</span><span id="line-2476"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-2477"></span><span class="hs-comment">-- &gt; class Eq a =&gt; HasMember t a where</span><span>
</span><span id="line-2478"></span><span class="hs-comment">-- &gt;     member :: a -&gt; t a -&gt; Bool</span><span>
</span><span id="line-2479"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-2480"></span><span class="hs-comment">-- &gt; instance Eq a =&gt; HasMember [] a where</span><span>
</span><span id="line-2481"></span><span class="hs-comment">-- &gt;     member = elem</span><span>
</span><span id="line-2482"></span><span class="hs-comment">-- &gt; [...]</span><span>
</span><span id="line-2483"></span><span class="hs-comment">-- &gt; instance Ord a =&gt; HasMember Set.Set a where</span><span>
</span><span id="line-2484"></span><span class="hs-comment">-- &gt;     member = Set.member</span><span>
</span><span id="line-2485"></span><span class="hs-comment">--</span><span>
</span><span id="line-2486"></span><span class="hs-comment">-- The above suggests that 'elem' may be a misfit in the 'Foldable' class.</span><span>
</span><span id="line-2487"></span><span class="hs-comment">-- Alternative design ideas are solicited on GHC's bug tracker via issue</span><span>
</span><span id="line-2488"></span><span class="hs-comment">-- [\#20421](https://gitlab.haskell.org/ghc/ghc/-/issues/20421).</span><span>
</span><span id="line-2489"></span><span class="hs-comment">--</span><span>
</span><span id="line-2490"></span><span class="hs-comment">-- Note that some structure-specific optimisations may of course be possible</span><span>
</span><span id="line-2491"></span><span class="hs-comment">-- directly in the corresponding @Foldable@ instance, e.g. with @Set@ the size</span><span>
</span><span id="line-2492"></span><span class="hs-comment">-- of the set is known in advance, without iterating to count the elements, and</span><span>
</span><span id="line-2493"></span><span class="hs-comment">-- its `length` instance takes advantage of this to return the size directly.</span><span>
</span><span id="line-2494"></span><span>
</span><span id="line-2495"></span><span class="hs-comment">--------------</span><span>
</span><span id="line-2496"></span><span>
</span><span id="line-2497"></span><span class="hs-comment">-- $also</span><span>
</span><span id="line-2498"></span><span class="hs-comment">--</span><span>
</span><span id="line-2499"></span><span class="hs-comment">--  * [1] #uselistsnot# \&quot;When You Should Use Lists in Haskell (Mostly, You Should Not)\&quot;,</span><span>
</span><span id="line-2500"></span><span class="hs-comment">--    by Johannes Waldmann,</span><span>
</span><span id="line-2501"></span><span class="hs-comment">--    in arxiv.org, Programming Languages (cs.PL), at</span><span>
</span><span id="line-2502"></span><span class="hs-comment">--    &lt;https://arxiv.org/abs/1808.08329&gt;.</span><span>
</span><span id="line-2503"></span><span class="hs-comment">--</span><span>
</span><span id="line-2504"></span><span class="hs-comment">--  * [2] \&quot;The Essence of the Iterator Pattern\&quot;,</span><span>
</span><span id="line-2505"></span><span class="hs-comment">--    by Jeremy Gibbons and Bruno Oliveira,</span><span>
</span><span id="line-2506"></span><span class="hs-comment">--    in /Mathematically-Structured Functional Programming/, 2006, online at</span><span>
</span><span id="line-2507"></span><span class="hs-comment">--    &lt;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&gt;.</span><span>
</span><span id="line-2508"></span><span class="hs-comment">--</span><span>
</span><span id="line-2509"></span><span class="hs-comment">--  * [3] \&quot;A tutorial on the universality and expressiveness of fold\&quot;,</span><span>
</span><span id="line-2510"></span><span class="hs-comment">--    by Graham Hutton, J\. Functional Programming 9 (4): 355&#8211;372, July 1999,</span><span>
</span><span id="line-2511"></span><span class="hs-comment">--    online at &lt;http://www.cs.nott.ac.uk/~pszgmh/fold.pdf&gt;.</span><span>
</span><span id="line-2512"></span></pre></body></html>