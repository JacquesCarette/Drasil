-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Theory SubPackage
--   
--   Please see the README on GitHub at
--   <a>https://github.com/JacquesCarette/Drasil#readme</a>
@package drasil-theory
@version 0.1.0.0


-- | Defining all the classes which represent knowledge-about-theories.
module Theory.Drasil.Classes

-- | Members of this class may have inputs.
class HasInputs c

-- | Provides a <tt>Lens</tt> that holds a <a>DefinedQuantityDict</a> and
--   maybe constraints.
inputs :: HasInputs c => Lens' c [(DefinedQuantityDict, Maybe (RealInterval Expr Expr))]

-- | Members of this class may have outputs.
class HasOutput c

-- | Provides a <a>Getter</a> that holds a <a>DefinedQuantityDict</a> for
--   output.
output :: HasOutput c => Getter c DefinedQuantityDict

-- | Provides a <a>Getter</a> that holds constraints on the output.
out_constraints :: HasOutput c => Getter c [RealInterval Expr Expr]


-- | For deriving equations in examples.
module Theory.Drasil.Components.Derivation

-- | Derivations are an ordered list of sentences and expressions. They are
--   rendered in order as paragraphs and equation blocks to display the
--   derivation.
data Derivation
Derivation :: Sentence -> [Sentence] -> Derivation

-- | A class that might have a <a>Derivation</a>.
class MayHaveDerivation c

-- | Provides a <tt>Lens</tt> to a possible derivation.
derivations :: MayHaveDerivation c => Lens' c (Maybe Derivation)

-- | Smart constructor for creating a <a>Derivation</a>.
mkDeriv :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but prepends "Detailed derivation of" to
--   the header.
mkDerivName :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but without a header <a>Sentence</a>.
mkDerivNoHeader :: [Sentence] -> Derivation


-- | Defines types used in models and theories.
module Theory.Drasil.ConstraintSet

-- | <a>ConstraintSet</a>s are sets of invariants that always hold for
--   underlying domains.
data ConstraintSet e

-- | Smart constructor for building ConstraintSets
mkConstraintSet :: ConceptChunk -> NonEmpty e -> ConstraintSet e
instance Drasil.Database.UID.HasUID (Theory.Drasil.ConstraintSet.ConstraintSet e)
instance Language.Drasil.Chunk.NamedIdea.NamedIdea (Theory.Drasil.ConstraintSet.ConstraintSet e)
instance Language.Drasil.Chunk.NamedIdea.Idea (Theory.Drasil.ConstraintSet.ConstraintSet e)
instance Language.Drasil.Classes.Definition (Theory.Drasil.ConstraintSet.ConstraintSet e)
instance Language.Drasil.Classes.ConceptDomain (Theory.Drasil.ConstraintSet.ConstraintSet e)
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.ExprClasses.Express (Theory.Drasil.ConstraintSet.ConstraintSet e)
instance Language.Drasil.WellTyped.RequiresChecking (Theory.Drasil.ConstraintSet.ConstraintSet Language.Drasil.Expr.Lang.Expr) Language.Drasil.Expr.Lang.Expr Language.Drasil.Space.Space


-- | Defines types and functions for Data Definitions.
module Theory.Drasil.DataDefinition

-- | A data definition is a <a>QDefinition</a> that may have additional
--   notes: the scope, any references (as <a>DecRef</a>s), maybe a
--   derivation, a label (<a>ShortName</a>), a reference address, and other
--   notes (<a>Sentence</a>s).
data DataDefinition
ddQD :: Lens' SimpleQDef a -> Lens' ModelQDef a -> Lens' DataDefinition a

-- | Smart constructor for data definitions.
ddE :: SimpleQDef -> [DecRef] -> Maybe Derivation -> String -> [Sentence] -> DataDefinition

-- | Smart constructor for data definitions.
ddME :: ModelQDef -> [DecRef] -> Maybe Derivation -> String -> [Sentence] -> DataDefinition

-- | Smart constructor for data definitions with no references.
ddENoRefs :: SimpleQDef -> Maybe Derivation -> String -> [Sentence] -> DataDefinition

-- | Smart constructor for data definitions with no references.
ddMENoRefs :: ModelQDef -> Maybe Derivation -> String -> [Sentence] -> DataDefinition

-- | Extracts the 'QDefinition e' from a <a>DataDefinition</a>.
qdFromDD :: DataDefinition -> Either SimpleQDef ModelQDef
qdEFromDD :: DataDefinition -> Maybe SimpleQDef
instance Drasil.Database.Chunk.HasChunkRefs Theory.Drasil.DataDefinition.DataDefinition
instance Drasil.Database.UID.HasUID Theory.Drasil.DataDefinition.DataDefinition
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Theory.Drasil.DataDefinition.DataDefinition
instance Language.Drasil.Chunk.NamedIdea.Idea Theory.Drasil.DataDefinition.DataDefinition
instance Language.Drasil.Chunk.DefinedQuantity.DefinesQuantity Theory.Drasil.DataDefinition.DataDefinition
instance Theory.Drasil.Classes.HasOutput Theory.Drasil.DataDefinition.DataDefinition
instance Language.Drasil.ExprClasses.Express Theory.Drasil.DataDefinition.DataDefinition
instance Language.Drasil.DecoratedReference.HasDecRef Theory.Drasil.DataDefinition.DataDefinition
instance GHC.Classes.Eq Theory.Drasil.DataDefinition.DataDefinition
instance Theory.Drasil.Components.Derivation.MayHaveDerivation Theory.Drasil.DataDefinition.DataDefinition
instance Language.Drasil.Classes.HasAdditionalNotes Theory.Drasil.DataDefinition.DataDefinition
instance Language.Drasil.ShortName.HasShortName Theory.Drasil.DataDefinition.DataDefinition
instance Language.Drasil.Label.Type.HasRefAddress Theory.Drasil.DataDefinition.DataDefinition
instance Language.Drasil.Classes.ConceptDomain Theory.Drasil.DataDefinition.DataDefinition
instance Language.Drasil.Classes.CommonIdea Theory.Drasil.DataDefinition.DataDefinition
instance Language.Drasil.Label.Type.Referable Theory.Drasil.DataDefinition.DataDefinition
instance Language.Drasil.WellTyped.RequiresChecking Theory.Drasil.DataDefinition.DataDefinition Language.Drasil.Expr.Lang.Expr Language.Drasil.Space.Space

module Theory.Drasil.DifferentialModel

-- | Describe the structural content of a system of linear ODEs with six
--   necessary fields
data DifferentialModel
SystemOfLinearODEs :: UnitalChunk -> ConstrConcept -> [[Expr]] -> [Unknown] -> [Expr] -> ConceptChunk -> DifferentialModel

-- | independent variable, often time
[_indepVar] :: DifferentialModel -> UnitalChunk

-- | dependent variable
[_depVar] :: DifferentialModel -> ConstrConcept

-- | coefficients matrix
[_coefficients] :: DifferentialModel -> [[Expr]]

-- | unknowns column vector (orders)
[_unknowns] :: DifferentialModel -> [Unknown]

-- | constant column vector
[_dmConstants] :: DifferentialModel -> [Expr]

-- | meta data
[_dmconc] :: DifferentialModel -> ConceptChunk

-- | Acceptable format for ODE solvers, represent the structure of X' = AX
--   + B X' is a column vector of first-order unknowns
data ODESolverFormat
X' :: [[Expr]] -> [Integer] -> [Expr] -> ODESolverFormat

-- | represent A, the coefficient matrix with identity matrix
[coeffVects] :: ODESolverFormat -> [[Expr]]

-- | combing with the dependent variable. it represents X, the unknown
--   column vector after reduce the highest order.
[unknownVect] :: ODESolverFormat -> [Integer]

-- | represent B, the constant column vector with identity matrix
[constantVect] :: ODESolverFormat -> [Expr]

-- | Information for solving an initial value problem
data InitialValueProblem
IVP :: Expr -> Expr -> [Expr] -> InitialValueProblem

-- | initial time
[initTime] :: InitialValueProblem -> Expr

-- | end time
[finalTime] :: InitialValueProblem -> Expr

-- | initial values
[initValues] :: InitialValueProblem -> [Expr]

-- | Operation connect the dependent variable and the order
($^^) :: ConstrConcept -> Integer -> Unknown

-- | Operation represent multiple
($**) :: Expr -> Unknown -> Term

-- | Operation represent plus (collection Terms)
($++) :: [Term] -> Term -> LHS

-- | Construct an ODESolverFormat for solving the ODE.
makeAODESolverFormat :: DifferentialModel -> ODESolverFormat
makeAIVP :: Expr -> Expr -> [Expr] -> InitialValueProblem

-- | Create a <a>DifferentialModel</a> by giving a independent variable, a
--   dependent variable a canonical matrix form, and conceptChuck.
makeASystemDE :: UnitalChunk -> ConstrConcept -> [[Expr]] -> [Unknown] -> [Expr] -> String -> NP -> Sentence -> DifferentialModel

-- | Create a <a>DifferentialModel</a> by the input language
makeASingleDE :: UnitalChunk -> ConstrConcept -> LHS -> Expr -> String -> NP -> Sentence -> DifferentialModel

-- | Form well-formatted ODE equations which the ODE solvers can solve.
formEquations :: [[Expr]] -> [Unknown] -> [Expr] -> ConstrConcept -> [Expr]
instance Language.Drasil.WellTyped.RequiresChecking Theory.Drasil.DifferentialModel.DifferentialModel Language.Drasil.Expr.Lang.Expr Language.Drasil.Space.Space
instance Drasil.Database.UID.HasUID Theory.Drasil.DifferentialModel.DifferentialModel
instance GHC.Classes.Eq Theory.Drasil.DifferentialModel.DifferentialModel
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Theory.Drasil.DifferentialModel.DifferentialModel
instance Language.Drasil.Chunk.NamedIdea.Idea Theory.Drasil.DifferentialModel.DifferentialModel
instance Language.Drasil.Classes.Definition Theory.Drasil.DifferentialModel.DifferentialModel
instance Language.Drasil.Classes.ConceptDomain Theory.Drasil.DifferentialModel.DifferentialModel
instance Language.Drasil.ExprClasses.Express Theory.Drasil.DifferentialModel.DifferentialModel


-- | Defines types and functions for creating mult-definitions.
module Theory.Drasil.MultiDefn

-- | <a>MultiDefn</a>s are QDefinition factories, used for showing one or
--   more ways we can define a QDefinition.
data MultiDefn e

-- | <a>DefiningExpr</a> are the data that make up a (quantity) definition,
--   namely the description, the defining (rhs) expression and the context
--   domain(s). These are meant to be <tt>alternate</tt> but equivalent
--   definitions for a single concept.
data DefiningExpr e

-- | Smart constructor for MultiDefns, does nothing special at the moment.
--   First argument is the <a>Space</a> to become a <a>UID</a>.
mkMultiDefn :: String -> DefinedQuantityDict -> Sentence -> NonEmpty (DefiningExpr e) -> MultiDefn e

-- | Smart constructor for <a>MultiDefn</a>s defining <a>UID</a>s using
--   that of the <a>DefinedQuantityDict</a>.
mkMultiDefnForQuant :: DefinedQuantityDict -> Sentence -> NonEmpty (DefiningExpr e) -> MultiDefn e

-- | Smart constructor for <a>DefiningExpr</a>s.
mkDefiningExpr :: String -> [UID] -> Sentence -> e -> DefiningExpr e

-- | Convert <a>MultiDefn</a>s into <a>QDefinition</a>s via a specific
--   <a>DefiningExpr</a>.
multiDefnGenQD :: MultiDefn e -> DefiningExpr e -> QDefinition e

-- | Convert <a>MultiDefn</a>s into <a>QDefinition</a>s via a specific
--   <a>DefiningExpr</a> (by <a>UID</a>).
multiDefnGenQDByUID :: MultiDefn e -> UID -> QDefinition e
instance Drasil.Database.UID.HasUID (Theory.Drasil.MultiDefn.MultiDefn e)
instance Language.Drasil.Symbol.HasSymbol (Theory.Drasil.MultiDefn.MultiDefn e)
instance Language.Drasil.Chunk.NamedIdea.NamedIdea (Theory.Drasil.MultiDefn.MultiDefn e)
instance Language.Drasil.Chunk.NamedIdea.Idea (Theory.Drasil.MultiDefn.MultiDefn e)
instance Language.Drasil.Space.HasSpace (Theory.Drasil.MultiDefn.MultiDefn e)
instance Language.Drasil.Classes.Definition (Theory.Drasil.MultiDefn.MultiDefn e)
instance Language.Drasil.Classes.Quantity (Theory.Drasil.MultiDefn.MultiDefn e)
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit (Theory.Drasil.MultiDefn.MultiDefn e)
instance Language.Drasil.Classes.ConceptDomain (Theory.Drasil.MultiDefn.MultiDefn e)
instance Language.Drasil.WellTyped.RequiresChecking (Theory.Drasil.MultiDefn.MultiDefn Language.Drasil.Expr.Lang.Expr) Language.Drasil.Expr.Lang.Expr Language.Drasil.Space.Space
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.ExprClasses.Express (Theory.Drasil.MultiDefn.MultiDefn e)
instance GHC.Classes.Eq (Theory.Drasil.MultiDefn.DefiningExpr e)
instance Drasil.Database.UID.HasUID (Theory.Drasil.MultiDefn.DefiningExpr e)
instance Language.Drasil.Classes.ConceptDomain (Theory.Drasil.MultiDefn.DefiningExpr e)
instance Language.Drasil.Classes.Definition (Theory.Drasil.MultiDefn.DefiningExpr e)


-- | Defines types and functions for creating models.
module Theory.Drasil.ModelKinds

-- | <a>ModelKinds</a> carrier, used to carry commonly overwritten
--   information from the IMs<i>TMs</i>GDs.
data ModelKind e
MK :: ModelKinds e -> UID -> NP -> ModelKind e
[_mk] :: ModelKind e -> ModelKinds e
[_mkUID] :: ModelKind e -> UID
[_mkTerm] :: ModelKind e -> NP

-- | Models can be of different kinds:
--   
--   <ul>
--   <li><a>NewDEModel</a>s represent differential equations as
--   <a>DifferentialModel</a>s</li>
--   <li><a>DEModel</a>s represent differential equations as
--   <a>RelationConcept</a>s</li>
--   <li><tt>EquationalConstraint</tt>s represent invariants that will hold
--   in a system of equations.</li>
--   <li><a>EquationalModel</a>s represent quantities that are calculated
--   via a single definition/<a>QDefinition</a>.</li>
--   <li><a>EquationalRealm</a>s represent MultiDefns; quantities that may
--   be calculated using any one of many <a>DefiningExpr</a>s (e.g., 'x = A
--   = ... = Z')</li>
--   <li><tt>FunctionalModel</tt>s represent quantity-resulting function
--   definitions.</li>
--   <li><a>OthModel</a>s are placeholders for models. No new
--   <a>OthModel</a>s should be created, they should be using one of the
--   other kinds.</li>
--   </ul>
data ModelKinds e
[NewDEModel] :: DifferentialModel -> ModelKinds e
[DEModel] :: RelationConcept -> ModelKinds e
[EquationalConstraints] :: ConstraintSet e -> ModelKinds e
[EquationalModel] :: QDefinition e -> ModelKinds e
[EquationalRealm] :: MultiDefn e -> ModelKinds e
[OthModel] :: RelationConcept -> ModelKinds e

-- | Smart constructor for <a>NewDEModel</a>s
newDEModel :: String -> NP -> DifferentialModel -> ModelKind e

-- | Smart constructor for <a>DEModel</a>s
deModel :: String -> NP -> RelationConcept -> ModelKind e

-- | Smart constructor for <a>EquationalConstraints</a>
equationalConstraints :: String -> NP -> ConstraintSet e -> ModelKind e

-- | Smart constructor for <a>EquationalModel</a>s
equationalModel :: String -> NP -> QDefinition e -> ModelKind e

-- | Smart constructor for <a>EquationalRealm</a>s
equationalRealm :: String -> NP -> MultiDefn e -> ModelKind e

-- | Smart constructor for <a>OthModel</a>s
othModel :: String -> NP -> RelationConcept -> ModelKind Expr

-- | Smart constructor for <a>NewDEModel</a>s, deriving UID+Term from the
--   <a>DifferentialModel</a>
newDEModel' :: DifferentialModel -> ModelKind e

-- | Smart constructor for <a>DEModel</a>s, deriving UID+Term from the
--   <a>RelationConcept</a>
deModel' :: RelationConcept -> ModelKind e

-- | Smart constructor for <a>EquationalConstraints</a>, deriving UID+Term
--   from the <a>ConstraintSet</a>
equationalConstraints' :: ConstraintSet e -> ModelKind e

-- | Smart constructor for <a>EquationalModel</a>s, deriving UID+Term from
--   the <a>QDefinition</a>
equationalModel' :: QDefinition e -> ModelKind e

-- | Smart constructor for <a>EquationalRealm</a>s, deriving UID+Term from
--   the <a>MultiDefn</a>
equationalRealm' :: MultiDefn e -> ModelKind e

-- | Smart constructor for <a>OthModel</a>s, deriving UID+Term from the
--   <a>RelationConcept</a>
othModel' :: RelationConcept -> ModelKind e

-- | Smart constructor for <a>EquationalModel</a>s, deriving Term from the
--   <a>QDefinition</a>
equationalModelU :: String -> QDefinition e -> ModelKind e

-- | Smart constructor for <a>EquationalModel</a>s, deriving UID from the
--   <a>QDefinition</a>
equationalModelN :: NP -> QDefinition e -> ModelKind e

-- | Smart constructor for <a>EquationalRealm</a>s
equationalRealmU :: String -> MultiDefn e -> ModelKind e

-- | Smart constructor for <a>EquationalRealm</a>s, deriving UID from the
--   <a>MultiDefn</a>
equationalRealmN :: NP -> MultiDefn e -> ModelKind e

-- | Map into internal representations of ModelKinds
setMk :: ModelKinds e -> Setter' DifferentialModel a -> Setter' RelationConcept a -> Setter' (ConstraintSet e) a -> Setter' (QDefinition e) a -> Setter' (MultiDefn e) a -> a -> ModelKinds e

-- | Retrieve internal data from ModelKinds
elimMk :: Getter DifferentialModel a -> Getter RelationConcept a -> Getter (ConstraintSet e) a -> Getter (QDefinition e) a -> Getter (MultiDefn e) a -> ModelKinds e -> a

-- | Make a <tt>Lens</tt> for <a>ModelKinds</a>.
lensMk :: forall e a. Lens' DifferentialModel a -> Lens' RelationConcept a -> Lens' (ConstraintSet e) a -> Lens' (QDefinition e) a -> Lens' (MultiDefn e) a -> Lens' (ModelKinds e) a

-- | Make a <a>Getter</a> for <a>ModelKinds</a>.
getterMk :: forall e a. Getter DifferentialModel a -> Getter RelationConcept a -> Getter (ConstraintSet e) a -> Getter (QDefinition e) a -> Getter (MultiDefn e) a -> Getter (ModelKinds e) a

-- | Extract a list of <a>QDefinition</a>s from a list of
--   <a>ModelKinds</a>.
getEqModQds :: [ModelKind e] -> [QDefinition e]
instance Drasil.Database.UID.HasUID (Theory.Drasil.ModelKinds.ModelKinds e)
instance Language.Drasil.Chunk.NamedIdea.NamedIdea (Theory.Drasil.ModelKinds.ModelKinds e)
instance Language.Drasil.Chunk.NamedIdea.Idea (Theory.Drasil.ModelKinds.ModelKinds e)
instance Language.Drasil.Classes.Definition (Theory.Drasil.ModelKinds.ModelKinds e)
instance Language.Drasil.Classes.ConceptDomain (Theory.Drasil.ModelKinds.ModelKinds e)
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.ExprClasses.Express (Theory.Drasil.ModelKinds.ModelKinds e)
instance Language.Drasil.WellTyped.RequiresChecking (Theory.Drasil.ModelKinds.ModelKinds Language.Drasil.Expr.Lang.Expr) Language.Drasil.Expr.Lang.Expr Language.Drasil.Space.Space
instance Drasil.Database.UID.HasUID (Theory.Drasil.ModelKinds.ModelKind e)
instance Language.Drasil.Chunk.NamedIdea.NamedIdea (Theory.Drasil.ModelKinds.ModelKind e)
instance Language.Drasil.Chunk.NamedIdea.Idea (Theory.Drasil.ModelKinds.ModelKind e)
instance Language.Drasil.Classes.Definition (Theory.Drasil.ModelKinds.ModelKind e)
instance Language.Drasil.Classes.ConceptDomain (Theory.Drasil.ModelKinds.ModelKind e)
instance Language.Drasil.ExprClasses.Express e => Language.Drasil.ExprClasses.Express (Theory.Drasil.ModelKinds.ModelKind e)
instance Language.Drasil.WellTyped.RequiresChecking (Theory.Drasil.ModelKinds.ModelKind Language.Drasil.Expr.Lang.Expr) Language.Drasil.Expr.Lang.Expr Language.Drasil.Space.Space


-- | Defines types and functions for Instance Models.
module Theory.Drasil.InstanceModel

-- | An instance model is a ModelKind that may have specific inputs,
--   outputs, and output constraints. It also has attributes like
--   references, derivation, labels (<a>ShortName</a>), reference address,
--   and notes.
data InstanceModel

-- | Smart constructor for instance models with everything defined.
im :: ModelKind Expr -> Inputs -> Output -> OutputConstraints -> [DecRef] -> Maybe Derivation -> String -> [Sentence] -> InstanceModel

-- | Smart constructor for instance models with a custom term, and no
--   derivation.
imNoDeriv :: ModelKind Expr -> Inputs -> Output -> OutputConstraints -> [DecRef] -> String -> [Sentence] -> InstanceModel

-- | Smart constructor for instance models with a custom term, and no
--   references.
imNoRefs :: ModelKind Expr -> Inputs -> Output -> OutputConstraints -> Maybe Derivation -> String -> [Sentence] -> InstanceModel

-- | Smart constructor for instance models with a custom term, and no
--   derivations or references.
imNoDerivNoRefs :: ModelKind Expr -> Inputs -> Output -> OutputConstraints -> String -> [Sentence] -> InstanceModel

-- | Grab all related <a>QDefinition</a>s from a list of instance models.
getEqModQdsFromIm :: [InstanceModel] -> [SimpleQDef]

-- | For building a quantity with no constraint.
qwUC :: (Quantity q, MayHaveUnit q, Concept q) => q -> Input

-- | For building a quantity with a constraint.
qwC :: (Quantity q, MayHaveUnit q, Concept q) => q -> RealInterval Expr Expr -> Input
instance Drasil.Database.Chunk.HasChunkRefs Theory.Drasil.InstanceModel.InstanceModel
instance Drasil.Database.UID.HasUID Theory.Drasil.InstanceModel.InstanceModel
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Theory.Drasil.InstanceModel.InstanceModel
instance Language.Drasil.Chunk.NamedIdea.Idea Theory.Drasil.InstanceModel.InstanceModel
instance Language.Drasil.Classes.Definition Theory.Drasil.InstanceModel.InstanceModel
instance Language.Drasil.Classes.ConceptDomain Theory.Drasil.InstanceModel.InstanceModel
instance Language.Drasil.ExprClasses.Express Theory.Drasil.InstanceModel.InstanceModel
instance Theory.Drasil.Components.Derivation.MayHaveDerivation Theory.Drasil.InstanceModel.InstanceModel
instance Language.Drasil.DecoratedReference.HasDecRef Theory.Drasil.InstanceModel.InstanceModel
instance Language.Drasil.ShortName.HasShortName Theory.Drasil.InstanceModel.InstanceModel
instance Language.Drasil.Label.Type.HasRefAddress Theory.Drasil.InstanceModel.InstanceModel
instance Language.Drasil.Classes.HasAdditionalNotes Theory.Drasil.InstanceModel.InstanceModel
instance Language.Drasil.Classes.CommonIdea Theory.Drasil.InstanceModel.InstanceModel
instance Language.Drasil.Label.Type.Referable Theory.Drasil.InstanceModel.InstanceModel
instance Language.Drasil.Chunk.DefinedQuantity.DefinesQuantity Theory.Drasil.InstanceModel.InstanceModel
instance Theory.Drasil.Classes.HasInputs Theory.Drasil.InstanceModel.InstanceModel
instance Theory.Drasil.Classes.HasOutput Theory.Drasil.InstanceModel.InstanceModel
instance Language.Drasil.WellTyped.RequiresChecking Theory.Drasil.InstanceModel.InstanceModel Language.Drasil.Expr.Lang.Expr Language.Drasil.Space.Space


-- | Defines types and functions for General Definitions.
module Theory.Drasil.GenDefn

-- | A general definition is a <a>ModelKind</a> that may have units, a
--   derivation, references (as <a>DecRef</a>s), a shortname, a reference
--   address, and notes.
data GenDefn

-- | Smart constructor for general definitions.
gd :: IsUnit u => ModelKind ModelExpr -> Maybe u -> Maybe Derivation -> [DecRef] -> String -> [Sentence] -> GenDefn

-- | Smart constructor for general definitions with no references.
gdNoRefs :: IsUnit u => ModelKind ModelExpr -> Maybe u -> Maybe Derivation -> String -> [Sentence] -> GenDefn

-- | Grab all related <tt>QDefinitions</tt> from a list of general
--   definitions.
getEqModQdsFromGd :: [GenDefn] -> [ModelQDef]
instance Drasil.Database.Chunk.HasChunkRefs Theory.Drasil.GenDefn.GenDefn
instance Drasil.Database.UID.HasUID Theory.Drasil.GenDefn.GenDefn
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Theory.Drasil.GenDefn.GenDefn
instance Language.Drasil.Chunk.NamedIdea.Idea Theory.Drasil.GenDefn.GenDefn
instance Language.Drasil.Classes.Definition Theory.Drasil.GenDefn.GenDefn
instance Language.Drasil.Classes.ConceptDomain Theory.Drasil.GenDefn.GenDefn
instance Language.Drasil.ExprClasses.Express Theory.Drasil.GenDefn.GenDefn
instance Theory.Drasil.Components.Derivation.MayHaveDerivation Theory.Drasil.GenDefn.GenDefn
instance Language.Drasil.DecoratedReference.HasDecRef Theory.Drasil.GenDefn.GenDefn
instance Language.Drasil.ShortName.HasShortName Theory.Drasil.GenDefn.GenDefn
instance Language.Drasil.Label.Type.HasRefAddress Theory.Drasil.GenDefn.GenDefn
instance Language.Drasil.Classes.HasAdditionalNotes Theory.Drasil.GenDefn.GenDefn
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Theory.Drasil.GenDefn.GenDefn
instance Language.Drasil.Classes.CommonIdea Theory.Drasil.GenDefn.GenDefn
instance Language.Drasil.Label.Type.Referable Theory.Drasil.GenDefn.GenDefn


-- | Defines types and functions for Theoretical Models.
module Theory.Drasil.Theory

-- | Theories are the basis for building models with context, spaces,
--   quantities, operations, invariants, etc.
class Theory t
valid_context :: Theory t => Lens' t [TheoryModel]
spaces :: Theory t => Lens' t [SpaceDefn]
quantities :: Theory t => Lens' t [DefinedQuantityDict]
operations :: Theory t => Lens' t [ConceptChunk]
defined_quant :: Theory t => Lens' t [ModelQDef]
invariants :: Theory t => Lens' t [ModelExpr]
defined_fun :: Theory t => Lens' t [ModelQDef]

-- | A TheoryModel is a collection of:
--   
--   <ul>
--   <li>tUid - a UID,</li>
--   <li>con - a ConceptChunk,</li>
--   <li>vctx - definition context (<a>TheoryModel</a>s),</li>
--   <li>spc - type definitions (<a>SpaceDefn</a>s),</li>
--   <li>quan - quantities (<a>DefinedQuantityDict</a>s),</li>
--   <li>ops - operations (<a>ConceptChunk</a>s),</li>
--   <li>defq - definitions (<a>QDefinition</a>s),</li>
--   <li>invs - invariants (<a>ModelExpr</a>s),</li>
--   <li>dfun - defined functions (<a>QDefinition</a>s),</li>
--   <li>ref - accompanying references (<a>DecRef</a>s),</li>
--   <li>lb - a label (<a>SpaceDefn</a>),</li>
--   <li>ra - reference address (<a>SpaceDefn</a>),</li>
--   <li>notes - additional notes (<a>Sentence</a>s).</li>
--   </ul>
--   
--   Right now, neither the definition context (vctx) nor the spaces (spc)
--   are ever defined.
data TheoryModel

-- | Constructor for theory models. Must have a source. Uses the shortname
--   of the reference address.
tm :: (Quantity q, MayHaveUnit q, Concept q, Concept c) => ModelKind ModelExpr -> [q] -> [c] -> [ModelQDef] -> [ModelExpr] -> [ModelQDef] -> [DecRef] -> String -> [Sentence] -> TheoryModel

-- | Constructor for theory models. Uses the shortname of the reference
--   address.
tmNoRefs :: (Quantity q, MayHaveUnit q, Concept q, Concept c) => ModelKind ModelExpr -> [q] -> [c] -> [ModelQDef] -> [ModelExpr] -> [ModelQDef] -> String -> [Sentence] -> TheoryModel
instance Drasil.Database.Chunk.HasChunkRefs Theory.Drasil.Theory.TheoryModel
instance Drasil.Database.UID.HasUID Theory.Drasil.Theory.TheoryModel
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Theory.Drasil.Theory.TheoryModel
instance Language.Drasil.Chunk.NamedIdea.Idea Theory.Drasil.Theory.TheoryModel
instance Language.Drasil.Classes.Definition Theory.Drasil.Theory.TheoryModel
instance Language.Drasil.DecoratedReference.HasDecRef Theory.Drasil.Theory.TheoryModel
instance Language.Drasil.Classes.ConceptDomain Theory.Drasil.Theory.TheoryModel
instance Language.Drasil.Classes.HasAdditionalNotes Theory.Drasil.Theory.TheoryModel
instance Theory.Drasil.Theory.Theory Theory.Drasil.Theory.TheoryModel
instance Language.Drasil.ShortName.HasShortName Theory.Drasil.Theory.TheoryModel
instance Language.Drasil.Label.Type.HasRefAddress Theory.Drasil.Theory.TheoryModel
instance Language.Drasil.Classes.CommonIdea Theory.Drasil.Theory.TheoryModel
instance Language.Drasil.Label.Type.Referable Theory.Drasil.Theory.TheoryModel


-- | Re-export many things to simplify external use.
module Theory.Drasil

-- | Members of this class may have inputs.
class HasInputs c

-- | Provides a <tt>Lens</tt> that holds a <a>DefinedQuantityDict</a> and
--   maybe constraints.
inputs :: HasInputs c => Lens' c [(DefinedQuantityDict, Maybe (RealInterval Expr Expr))]

-- | Members of this class may have outputs.
class HasOutput c

-- | Provides a <a>Getter</a> that holds a <a>DefinedQuantityDict</a> for
--   output.
output :: HasOutput c => Getter c DefinedQuantityDict

-- | Provides a <a>Getter</a> that holds constraints on the output.
out_constraints :: HasOutput c => Getter c [RealInterval Expr Expr]

-- | <a>ConstraintSet</a>s are sets of invariants that always hold for
--   underlying domains.
data ConstraintSet e

-- | Smart constructor for building ConstraintSets
mkConstraintSet :: ConceptChunk -> NonEmpty e -> ConstraintSet e

-- | Derivations are an ordered list of sentences and expressions. They are
--   rendered in order as paragraphs and equation blocks to display the
--   derivation.
data Derivation
Derivation :: Sentence -> [Sentence] -> Derivation

-- | Smart constructor for creating a <a>Derivation</a>.
mkDeriv :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but prepends "Detailed derivation of" to
--   the header.
mkDerivName :: Sentence -> [Sentence] -> Derivation

-- | Similar to <a>mkDeriv</a>, but without a header <a>Sentence</a>.
mkDerivNoHeader :: [Sentence] -> Derivation

-- | A class that might have a <a>Derivation</a>.
class MayHaveDerivation c

-- | Provides a <tt>Lens</tt> to a possible derivation.
derivations :: MayHaveDerivation c => Lens' c (Maybe Derivation)

-- | A data definition is a <a>QDefinition</a> that may have additional
--   notes: the scope, any references (as <a>DecRef</a>s), maybe a
--   derivation, a label (<a>ShortName</a>), a reference address, and other
--   notes (<a>Sentence</a>s).
data DataDefinition

-- | Smart constructor for data definitions.
ddE :: SimpleQDef -> [DecRef] -> Maybe Derivation -> String -> [Sentence] -> DataDefinition

-- | Smart constructor for data definitions with no references.
ddENoRefs :: SimpleQDef -> Maybe Derivation -> String -> [Sentence] -> DataDefinition

-- | Smart constructor for data definitions.
ddME :: ModelQDef -> [DecRef] -> Maybe Derivation -> String -> [Sentence] -> DataDefinition

-- | Smart constructor for data definitions with no references.
ddMENoRefs :: ModelQDef -> Maybe Derivation -> String -> [Sentence] -> DataDefinition

-- | Extracts the 'QDefinition e' from a <a>DataDefinition</a>.
qdFromDD :: DataDefinition -> Either SimpleQDef ModelQDef
qdEFromDD :: DataDefinition -> Maybe SimpleQDef

-- | A general definition is a <a>ModelKind</a> that may have units, a
--   derivation, references (as <a>DecRef</a>s), a shortname, a reference
--   address, and notes.
data GenDefn

-- | Smart constructor for general definitions.
gd :: IsUnit u => ModelKind ModelExpr -> Maybe u -> Maybe Derivation -> [DecRef] -> String -> [Sentence] -> GenDefn

-- | Smart constructor for general definitions with no references.
gdNoRefs :: IsUnit u => ModelKind ModelExpr -> Maybe u -> Maybe Derivation -> String -> [Sentence] -> GenDefn

-- | Grab all related <tt>QDefinitions</tt> from a list of general
--   definitions.
getEqModQdsFromGd :: [GenDefn] -> [ModelQDef]

-- | <a>MultiDefn</a>s are QDefinition factories, used for showing one or
--   more ways we can define a QDefinition.
data MultiDefn e

-- | <a>DefiningExpr</a> are the data that make up a (quantity) definition,
--   namely the description, the defining (rhs) expression and the context
--   domain(s). These are meant to be <tt>alternate</tt> but equivalent
--   definitions for a single concept.
data DefiningExpr e

-- | Smart constructor for MultiDefns, does nothing special at the moment.
--   First argument is the <a>Space</a> to become a <a>UID</a>.
mkMultiDefn :: String -> DefinedQuantityDict -> Sentence -> NonEmpty (DefiningExpr e) -> MultiDefn e

-- | Smart constructor for <a>MultiDefn</a>s defining <a>UID</a>s using
--   that of the <a>DefinedQuantityDict</a>.
mkMultiDefnForQuant :: DefinedQuantityDict -> Sentence -> NonEmpty (DefiningExpr e) -> MultiDefn e

-- | Smart constructor for <a>DefiningExpr</a>s.
mkDefiningExpr :: String -> [UID] -> Sentence -> e -> DefiningExpr e

-- | Convert <a>MultiDefn</a>s into <a>QDefinition</a>s via a specific
--   <a>DefiningExpr</a>.
multiDefnGenQD :: MultiDefn e -> DefiningExpr e -> QDefinition e

-- | Convert <a>MultiDefn</a>s into <a>QDefinition</a>s via a specific
--   <a>DefiningExpr</a> (by <a>UID</a>).
multiDefnGenQDByUID :: MultiDefn e -> UID -> QDefinition e

-- | <a>ModelKinds</a> carrier, used to carry commonly overwritten
--   information from the IMs<i>TMs</i>GDs.
data ModelKind e

-- | Smart constructor for <a>NewDEModel</a>s
newDEModel :: String -> NP -> DifferentialModel -> ModelKind e

-- | Smart constructor for <a>DEModel</a>s
deModel :: String -> NP -> RelationConcept -> ModelKind e

-- | Smart constructor for <a>EquationalConstraints</a>
equationalConstraints :: String -> NP -> ConstraintSet e -> ModelKind e

-- | Smart constructor for <a>EquationalModel</a>s
equationalModel :: String -> NP -> QDefinition e -> ModelKind e

-- | Smart constructor for <a>EquationalRealm</a>s
equationalRealm :: String -> NP -> MultiDefn e -> ModelKind e

-- | Smart constructor for <a>OthModel</a>s
othModel :: String -> NP -> RelationConcept -> ModelKind Expr

-- | Smart constructor for <a>NewDEModel</a>s, deriving UID+Term from the
--   <a>DifferentialModel</a>
newDEModel' :: DifferentialModel -> ModelKind e

-- | Smart constructor for <a>DEModel</a>s, deriving UID+Term from the
--   <a>RelationConcept</a>
deModel' :: RelationConcept -> ModelKind e

-- | Smart constructor for <a>EquationalConstraints</a>, deriving UID+Term
--   from the <a>ConstraintSet</a>
equationalConstraints' :: ConstraintSet e -> ModelKind e

-- | Smart constructor for <a>EquationalModel</a>s, deriving UID+Term from
--   the <a>QDefinition</a>
equationalModel' :: QDefinition e -> ModelKind e

-- | Smart constructor for <a>EquationalRealm</a>s, deriving UID+Term from
--   the <a>MultiDefn</a>
equationalRealm' :: MultiDefn e -> ModelKind e

-- | Smart constructor for <a>OthModel</a>s, deriving UID+Term from the
--   <a>RelationConcept</a>
othModel' :: RelationConcept -> ModelKind e

-- | Smart constructor for <a>EquationalModel</a>s, deriving Term from the
--   <a>QDefinition</a>
equationalModelU :: String -> QDefinition e -> ModelKind e

-- | Smart constructor for <a>EquationalModel</a>s, deriving UID from the
--   <a>QDefinition</a>
equationalModelN :: NP -> QDefinition e -> ModelKind e

-- | Smart constructor for <a>EquationalRealm</a>s
equationalRealmU :: String -> MultiDefn e -> ModelKind e

-- | Smart constructor for <a>EquationalRealm</a>s, deriving UID from the
--   <a>MultiDefn</a>
equationalRealmN :: NP -> MultiDefn e -> ModelKind e

-- | An instance model is a ModelKind that may have specific inputs,
--   outputs, and output constraints. It also has attributes like
--   references, derivation, labels (<a>ShortName</a>), reference address,
--   and notes.
data InstanceModel

-- | Smart constructor for instance models with everything defined.
im :: ModelKind Expr -> Inputs -> Output -> OutputConstraints -> [DecRef] -> Maybe Derivation -> String -> [Sentence] -> InstanceModel

-- | Smart constructor for instance models with a custom term, and no
--   derivation.
imNoDeriv :: ModelKind Expr -> Inputs -> Output -> OutputConstraints -> [DecRef] -> String -> [Sentence] -> InstanceModel

-- | Smart constructor for instance models with a custom term, and no
--   references.
imNoRefs :: ModelKind Expr -> Inputs -> Output -> OutputConstraints -> Maybe Derivation -> String -> [Sentence] -> InstanceModel

-- | Smart constructor for instance models with a custom term, and no
--   derivations or references.
imNoDerivNoRefs :: ModelKind Expr -> Inputs -> Output -> OutputConstraints -> String -> [Sentence] -> InstanceModel

-- | For building a quantity with no constraint.
qwUC :: (Quantity q, MayHaveUnit q, Concept q) => q -> Input

-- | For building a quantity with a constraint.
qwC :: (Quantity q, MayHaveUnit q, Concept q) => q -> RealInterval Expr Expr -> Input

-- | Grab all related <a>QDefinition</a>s from a list of instance models.
getEqModQdsFromIm :: [InstanceModel] -> [SimpleQDef]

-- | Theories are the basis for building models with context, spaces,
--   quantities, operations, invariants, etc.
class Theory t
valid_context :: Theory t => Lens' t [TheoryModel]
spaces :: Theory t => Lens' t [SpaceDefn]
quantities :: Theory t => Lens' t [DefinedQuantityDict]
operations :: Theory t => Lens' t [ConceptChunk]
defined_quant :: Theory t => Lens' t [ModelQDef]
invariants :: Theory t => Lens' t [ModelExpr]
defined_fun :: Theory t => Lens' t [ModelQDef]

-- | A TheoryModel is a collection of:
--   
--   <ul>
--   <li>tUid - a UID,</li>
--   <li>con - a ConceptChunk,</li>
--   <li>vctx - definition context (<a>TheoryModel</a>s),</li>
--   <li>spc - type definitions (<a>SpaceDefn</a>s),</li>
--   <li>quan - quantities (<a>DefinedQuantityDict</a>s),</li>
--   <li>ops - operations (<a>ConceptChunk</a>s),</li>
--   <li>defq - definitions (<a>QDefinition</a>s),</li>
--   <li>invs - invariants (<a>ModelExpr</a>s),</li>
--   <li>dfun - defined functions (<a>QDefinition</a>s),</li>
--   <li>ref - accompanying references (<a>DecRef</a>s),</li>
--   <li>lb - a label (<a>SpaceDefn</a>),</li>
--   <li>ra - reference address (<a>SpaceDefn</a>),</li>
--   <li>notes - additional notes (<a>Sentence</a>s).</li>
--   </ul>
--   
--   Right now, neither the definition context (vctx) nor the spaces (spc)
--   are ever defined.
data TheoryModel

-- | Constructor for theory models. Must have a source. Uses the shortname
--   of the reference address.
tm :: (Quantity q, MayHaveUnit q, Concept q, Concept c) => ModelKind ModelExpr -> [q] -> [c] -> [ModelQDef] -> [ModelExpr] -> [ModelQDef] -> [DecRef] -> String -> [Sentence] -> TheoryModel

-- | Constructor for theory models. Uses the shortname of the reference
--   address.
tmNoRefs :: (Quantity q, MayHaveUnit q, Concept q, Concept c) => ModelKind ModelExpr -> [q] -> [c] -> [ModelQDef] -> [ModelExpr] -> [ModelQDef] -> String -> [Sentence] -> TheoryModel

-- | Describe the structural content of a system of linear ODEs with six
--   necessary fields
data DifferentialModel
SystemOfLinearODEs :: UnitalChunk -> ConstrConcept -> [[Expr]] -> [Unknown] -> [Expr] -> ConceptChunk -> DifferentialModel

-- | independent variable, often time
[_indepVar] :: DifferentialModel -> UnitalChunk

-- | dependent variable
[_depVar] :: DifferentialModel -> ConstrConcept

-- | coefficients matrix
[_coefficients] :: DifferentialModel -> [[Expr]]

-- | unknowns column vector (orders)
[_unknowns] :: DifferentialModel -> [Unknown]

-- | constant column vector
[_dmConstants] :: DifferentialModel -> [Expr]

-- | meta data
[_dmconc] :: DifferentialModel -> ConceptChunk

-- | Acceptable format for ODE solvers, represent the structure of X' = AX
--   + B X' is a column vector of first-order unknowns
data ODESolverFormat
X' :: [[Expr]] -> [Integer] -> [Expr] -> ODESolverFormat

-- | represent A, the coefficient matrix with identity matrix
[coeffVects] :: ODESolverFormat -> [[Expr]]

-- | combing with the dependent variable. it represents X, the unknown
--   column vector after reduce the highest order.
[unknownVect] :: ODESolverFormat -> [Integer]

-- | represent B, the constant column vector with identity matrix
[constantVect] :: ODESolverFormat -> [Expr]

-- | Information for solving an initial value problem
data InitialValueProblem
IVP :: Expr -> Expr -> [Expr] -> InitialValueProblem

-- | initial time
[initTime] :: InitialValueProblem -> Expr

-- | end time
[finalTime] :: InitialValueProblem -> Expr

-- | initial values
[initValues] :: InitialValueProblem -> [Expr]

-- | Operation connect the dependent variable and the order
($^^) :: ConstrConcept -> Integer -> Unknown

-- | Operation represent multiple
($**) :: Expr -> Unknown -> Term

-- | Operation represent plus (collection Terms)
($++) :: [Term] -> Term -> LHS

-- | Construct an ODESolverFormat for solving the ODE.
makeAODESolverFormat :: DifferentialModel -> ODESolverFormat
makeAIVP :: Expr -> Expr -> [Expr] -> InitialValueProblem

-- | Create a <a>DifferentialModel</a> by giving a independent variable, a
--   dependent variable a canonical matrix form, and conceptChuck.
makeASystemDE :: UnitalChunk -> ConstrConcept -> [[Expr]] -> [Unknown] -> [Expr] -> String -> NP -> Sentence -> DifferentialModel

-- | Create a <a>DifferentialModel</a> by the input language
makeASingleDE :: UnitalChunk -> ConstrConcept -> LHS -> Expr -> String -> NP -> Sentence -> DifferentialModel

-- | Form well-formatted ODE equations which the ODE solvers can solve.
formEquations :: [[Expr]] -> [Unknown] -> [Expr] -> ConstrConcept -> [Expr]
