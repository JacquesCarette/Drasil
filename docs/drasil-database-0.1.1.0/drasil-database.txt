-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Database SubPackage
--   
--   Please see the README on GitHub at
--   <a>https://github.com/JacquesCarette/Drasil#readme</a>
@package drasil-database
@version 0.1.1.0


-- | Re-export database types and functions to simplify external use.
module Database.Drasil

-- | Drasil's knowledge database.
data ChunkDB

-- | An empty <a>ChunkDB</a>.
empty :: ChunkDB

-- | Create a <a>ChunkDB</a> from a list of chunks. This will insert all
--   chunks into the database from the list, from left to right.
fromList :: IsChunk a => [a] -> ChunkDB

-- | Query the <a>ChunkDB</a> for all registered chunks (by their
--   <a>UID</a>s).
registered :: ChunkDB -> [UID]

-- | Enumerate all types registered in the <a>ChunkDB</a>.
typesRegistered :: ChunkDB -> [TypeRep]

-- | Get the number of chunks registered in the <a>ChunkDB</a>.
size :: ChunkDB -> Int

-- | Check if a <a>UID</a> is registered in the <a>ChunkDB</a>.
isRegistered :: UID -> ChunkDB -> Bool

-- | Filter the <a>ChunkDB</a> for chunks that are not needed by any other
--   chunks. These are the only chunks that can safely be removed from the
--   database, though we do not include this functionality.
findUnused :: ChunkDB -> [UID]

-- | Find a chunk by its <a>UID</a> in the <a>ChunkDB</a>.
find :: Typeable a => UID -> ChunkDB -> Maybe a

-- | Find a chunk by its <a>UID</a> in the <a>ChunkDB</a>, throwing a hard
--   error if it is not found.
findOrErr :: forall a. Typeable a => UID -> ChunkDB -> a

-- | Find all chunks of a specific type in the <a>ChunkDB</a>.
findAll :: forall a. IsChunk a => ChunkDB -> [a]

-- | Find all chunks of a specific type in the <a>ChunkDB</a>, returning
--   their <a>UID</a>s rather than the chunks themselves.
findAll' :: TypeRep -> ChunkDB -> [UID]

-- | Find all chunks that depend on a specific one.
dependants :: UID -> ChunkDB -> Maybe [UID]

-- | Find all chunks that depend on a specific one, throwing a hard error
--   if the dependency chunk is not found.
dependantsOrErr :: UID -> ChunkDB -> [UID]

-- | Find the type of a chunk by its <a>UID</a>.
findTypeOf :: UID -> ChunkDB -> Maybe TypeRep

-- | Insert a chunk into the <a>ChunkDB</a> if it is sensibly to do so
--   (i.e., does not depend on itself and is not a <a>ChunkDB</a>). We
--   temporarily allow chunks to overwrite other ones, but we warn when
--   this happens.
insert :: IsChunk a => a -> ChunkDB -> ChunkDB

-- | Insert a list of chunks into a <a>ChunkDB</a>.
insertAll :: IsChunk a => [a] -> ChunkDB -> ChunkDB

-- | An ordered map based on <a>Strict</a> for looking up chunks by their
--   <a>UID</a>s.
type UMap a = Map UID (a, Int)

-- | Create a <a>UMap</a> from a list of chunks. Assumes that the leftmost
--   chunk in the list has index 0, increasing by 1 each step to the right.
idMap :: HasUID a => [a] -> UMap a
refTable :: ChunkDB -> UMap Reference

-- | Find a <a>Reference</a> by its <a>UID</a>, throwing an error if it is
--   not found.
refFind :: UID -> ChunkDB -> Reference
labelledcontentTable :: ChunkDB -> UMap LabelledContent

-- | Find a <a>LabelledContent</a> by its <a>UID</a>, throwing an error if
--   it is not found.
labelledcontentFind :: UID -> ChunkDB -> LabelledContent
refbyTable :: ChunkDB -> Map UID [UID]

-- | Find what chunks reference a given <a>UID</a>.
refbyLookup :: UID -> Map UID [UID] -> [UID]
traceTable :: ChunkDB -> Map UID [UID]

-- | Query a chunk for to what chunks it refers to.
traceLookup :: UID -> Map UID [UID] -> [UID]
type ChunkType = String

-- | A dumped representation of a <a>ChunkDB</a>, mapping chunk types
--   (<a>String</a>s) to lists of <a>UID</a>s.
type DumpedChunkDB = Map ChunkType [UID]
dumpChunkDB :: ChunkDB -> DumpedChunkDB

-- | <a>UID</a> references that contain information about the type of data
--   the <a>UID</a> refers to, useful for type-safe dereferencing.
data () => TypedUIDRef typ

-- | Create a <a>TypedUIDRef</a> to a chunk.
mkRef :: IsChunk t => t -> TypedUIDRef t

-- | Find a chunk by its typed UID reference.
typedFind :: IsChunk t => TypedUIDRef t -> ChunkDB -> Maybe t

-- | Find a chunk by its typed UID reference, erroring if not found.
typedFindOrErr :: IsChunk t => TypedUIDRef t -> ChunkDB -> t
