-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for code and document generation for scientific software - Build System SubPackage
--   
--   Please see the README on GitHub at
--   <a>https://github.com/JacquesCarette/Drasil#readme</a>
@package drasil-code-base
@version 0.1.9.0

module Language.Drasil.Code.Expr.Convert

-- | Render an algebraic expression into our code expression language.
expr :: Expr -> CodeExpr

-- | Convert <tt>RealInterval</tt> <tt>Expr</tt> <tt>Expr</tt>s into
--   <tt>RealInterval</tt> <a>CodeExpr</a> <a>CodeExpr</a>s.
realInterval :: RealInterval Expr Expr -> RealInterval CodeExpr CodeExpr

-- | Convert constrained expressions (<tt>ConstraintE</tt>) into
--   <tt>Constraint''CodeExpr</tt>s.
constraint :: ConstraintE -> Constraint CodeExpr
class CanGenCode e
toCodeExpr :: CanGenCode e => e -> CodeExpr
instance Language.Drasil.Code.Expr.Convert.CanGenCode Language.Drasil.Literal.Lang.Literal
instance Language.Drasil.Code.Expr.Convert.CanGenCode Language.Drasil.Expr.Lang.Expr


-- | Defines chunk types for use in code generation.
module Language.Drasil.Chunk.CodeBase

-- | A <a>CodeIdea</a> must include some code and its name.
class CodeIdea c

-- | Name of the idea.
codeName :: CodeIdea c => c -> String

-- | Code chunk associated with the idea.
codeChunk :: CodeIdea c => c -> CodeChunk

-- | A <a>DefiningCodeExpr</a> must have it's underlying chunk defined in
--   the CodeExpr language.
class CodeIdea c => DefiningCodeExpr c
codeExpr :: DefiningCodeExpr c => Lens' c CodeExpr

-- | Convert the program name to an abbreviated <a>String</a> without any
--   special characters.
programName :: CommonIdea c => c -> String

-- | Used when a function name needs to be distinguishable from a variable
--   name.
funcPrefix :: String

-- | Details if a piece of code is meant to be a variable or a function.
data VarOrFunc
Var :: VarOrFunc
Func :: VarOrFunc

-- | Basic chunk representation in the code generation context. Contains a
--   QuantityDict and the kind of code (variable or function).
data CodeChunk
CodeC :: QuantityDict -> VarOrFunc -> CodeChunk
[_qc] :: CodeChunk -> QuantityDict
[kind] :: CodeChunk -> VarOrFunc
qc :: Lens' CodeChunk QuantityDict

-- | Chunk representing a variable. The <tt>obv</tt> field represents the
--   object containing this variable, if it is an object field.
data CodeVarChunk
CodeVC :: CodeChunk -> Maybe CodeChunk -> CodeVarChunk
[_ccv] :: CodeVarChunk -> CodeChunk
[_obv] :: CodeVarChunk -> Maybe CodeChunk
obv :: Lens' CodeVarChunk (Maybe CodeChunk)
ccv :: Lens' CodeVarChunk CodeChunk

-- | Chunk representing a function.
newtype CodeFuncChunk
CodeFC :: CodeChunk -> CodeFuncChunk
[_ccf] :: CodeFuncChunk -> CodeChunk
ccf :: Iso' CodeFuncChunk CodeChunk

-- | Construct a <a>CodeVarChunk</a> from a <a>Quantity</a>.
quantvar :: (Quantity c, MayHaveUnit c) => c -> CodeVarChunk

-- | Construct a <a>CodeFuncChunk</a> from a <a>Quantity</a>.
quantfunc :: (Quantity c, MayHaveUnit c) => c -> CodeFuncChunk

-- | Get a list of <a>CodeChunk</a>s from an equation.
codevars :: CodeExpr -> ChunkDB -> [CodeVarChunk]

-- | Get a list of <a>CodeChunk</a>s from an equation (no functions).
codevars' :: CodeExpr -> ChunkDB -> [CodeVarChunk]

-- | Make a <a>CodeVarChunk</a> from a <a>UID</a> in the <a>ChunkDB</a>.
varResolve :: ChunkDB -> UID -> CodeVarChunk

-- | Make a <a>CodeFuncChunk</a> from a <a>UID</a> in the <a>ChunkDB</a>.
funcResolve :: ChunkDB -> UID -> CodeFuncChunk
listToArray :: CodeVarChunk -> CodeVarChunk
instance Language.Drasil.UID.HasUID Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.Space.HasSpace Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.Symbol.HasSymbol Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.Classes.Callable Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.CodeBase.CodeFuncChunk
instance Language.Drasil.UID.HasUID Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance Language.Drasil.Space.HasSpace Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance Language.Drasil.Symbol.HasSymbol Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.CodeBase.CodeVarChunk
instance Language.Drasil.UID.HasUID Language.Drasil.Chunk.CodeBase.CodeChunk
instance Language.Drasil.Chunk.NamedIdea.NamedIdea Language.Drasil.Chunk.CodeBase.CodeChunk
instance Language.Drasil.Chunk.NamedIdea.Idea Language.Drasil.Chunk.CodeBase.CodeChunk
instance Language.Drasil.Space.HasSpace Language.Drasil.Chunk.CodeBase.CodeChunk
instance Language.Drasil.Symbol.HasSymbol Language.Drasil.Chunk.CodeBase.CodeChunk
instance Language.Drasil.Classes.Quantity Language.Drasil.Chunk.CodeBase.CodeChunk
instance GHC.Classes.Eq Language.Drasil.Chunk.CodeBase.CodeChunk
instance Language.Drasil.Chunk.UnitDefn.MayHaveUnit Language.Drasil.Chunk.CodeBase.CodeChunk


-- | Re-exporting modules
module Language.Drasil.Code.Expr.Development

-- | Expression language where all terms also denote a term in GOOL (i.e.
--   translation is total and meaning preserving).
data CodeExpr

-- | Brings literals into the expression language.
[Lit] :: Literal -> CodeExpr

-- | Takes an associative arithmetic operator with a list of expressions.
[AssocA] :: AssocArithOper -> [CodeExpr] -> CodeExpr

-- | Takes an associative boolean operator with a list of expressions.
[AssocB] :: AssocBoolOper -> [CodeExpr] -> CodeExpr

-- | C stands for <a>Chunk</a>, for referring to a chunk in an expression.
--   Implicitly assumes that the chunk has a symbol.
[C] :: UID -> CodeExpr

-- | A function call accepts a list of parameters and a list of named
--   parameters. For example
--   
--   <ul>
--   <li>F(x) is (FCall F [x] []).</li>
--   <li>F(x,y) would be (FCall F [x,y]).</li>
--   <li>F(x,n=y) would be (FCall F [x] [(n,y)]).</li>
--   </ul>
[FCall] :: UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Actor creation given <a>UID</a>, parameters, and named parameters.
[New] :: UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Message an actor:
--   
--   <ul>
--   <li>1st <a>UID</a> is the actor,</li>
--   <li>2nd <a>UID</a> is the method.</li>
--   </ul>
[Message] :: UID -> UID -> [CodeExpr] -> [(UID, CodeExpr)] -> CodeExpr

-- | Access a field of an actor:
--   
--   <ul>
--   <li>1st <a>UID</a> is the actor,</li>
--   <li>2nd <a>UID</a> is the field.</li>
--   </ul>
[Field] :: UID -> UID -> CodeExpr

-- | For multi-case expressions, each pair represents one case.
[Case] :: Completeness -> [(CodeExpr, CodeExpr)] -> CodeExpr

-- | Represents a matrix of expressions.
[Matrix] :: [[CodeExpr]] -> CodeExpr

-- | Unary operation for most functions (eg. sin, cos, log, etc.).
[UnaryOp] :: UFunc -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Bool -&gt; Bool</tt> operations.
[UnaryOpB] :: UFuncB -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Vector -&gt; Vector</tt> operations.
[UnaryOpVV] :: UFuncVV -> CodeExpr -> CodeExpr

-- | Unary operation for <tt>Vector -&gt; Number</tt> operations.
[UnaryOpVN] :: UFuncVN -> CodeExpr -> CodeExpr

-- | Binary operator for arithmetic between expressions (fractional, power,
--   and subtraction).
[ArithBinaryOp] :: ArithBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for boolean operators (implies, iff).
[BoolBinaryOp] :: BoolBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for equality between expressions.
[EqBinaryOp] :: EqBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for indexing two expressions.
[LABinaryOp] :: LABinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for ordering expressions (less than, greater than,
--   etc.).
[OrdBinaryOp] :: OrdBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Vector</tt> operations
--   (cross product).
[VVVBinaryOp] :: VVVBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Binary operator for <tt>Vector x Vector -&gt; Number</tt> operations
--   (dot product).
[VVNBinaryOp] :: VVNBinOp -> CodeExpr -> CodeExpr -> CodeExpr

-- | Operators are generalized arithmetic operators over a
--   <a>DomainDesc</a> of an <a>Expr</a>. Could be called BigOp. ex:
--   Summation is represented via <tt>Add</tt> over a discrete domain.
[Operator] :: AssocArithOper -> DiscreteDomainDesc CodeExpr CodeExpr -> CodeExpr -> CodeExpr

-- | The expression is an element of a space. IsIn :: Expr -&gt; Space
--   -&gt; Expr | A different kind of <tt>IsIn</tt>. A <a>UID</a> is an
--   element of an interval.
[RealI] :: UID -> RealInterval CodeExpr CodeExpr -> CodeExpr

-- | Arithmetic operators (fractional, power, and subtraction).
data ArithBinOp
Frac :: ArithBinOp
Pow :: ArithBinOp
Subt :: ArithBinOp

-- | Equality operators (equal or not equal).
data EqBinOp
Eq :: EqBinOp
NEq :: EqBinOp

-- | Conditional and Biconditional operators (Expressions can imply one
--   another, or exist if and only if another expression exists).
data BoolBinOp
Impl :: BoolBinOp
Iff :: BoolBinOp

-- | Index operator.
data LABinOp
Index :: LABinOp

-- | Ordered binary operators (less than, greater than, less than or equal
--   to, greater than or equal to).
data OrdBinOp
Lt :: OrdBinOp
Gt :: OrdBinOp
LEq :: OrdBinOp
GEq :: OrdBinOp

-- | <tt>Vector x Vector -&gt; Vector</tt> binary operations (cross
--   product).
data VVVBinOp
Cross :: VVVBinOp

-- | <tt>Vector x Vector -&gt; Number</tt> binary operations (dot product).
data VVNBinOp
Dot :: VVNBinOp

-- | Associative operators (adding and multiplication). Also specifies
--   whether it is for integers or for real numbers.
data AssocArithOper
AddI :: AssocArithOper
AddRe :: AssocArithOper
MulI :: AssocArithOper
MulRe :: AssocArithOper

-- | Associative boolean operators (and, or).
data AssocBoolOper
And :: AssocBoolOper
Or :: AssocBoolOper

-- | Unary functions (abs, log, ln, sin, etc.).
data UFunc
Abs :: UFunc
Log :: UFunc
Ln :: UFunc
Sin :: UFunc
Cos :: UFunc
Tan :: UFunc
Sec :: UFunc
Csc :: UFunc
Cot :: UFunc
Arcsin :: UFunc
Arccos :: UFunc
Arctan :: UFunc
Exp :: UFunc
Sqrt :: UFunc
Neg :: UFunc

-- | <tt>Bool -&gt; Bool</tt> operators.
data UFuncB
Not :: UFuncB

-- | <tt>Vector -&gt; Vector</tt> operators.
data UFuncVV
NegV :: UFuncVV

-- | <tt>Vector -&gt; Number</tt> operators.
data UFuncVN
Norm :: UFuncVN
Dim :: UFuncVN

-- | Get dependencies from an equation.
eDep :: CodeExpr -> [UID]

-- | Get dependencies from an equation, without functions.
eDep' :: CodeExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names (similar to <a>eNames</a>).
eNamesRI :: RealInterval CodeExpr CodeExpr -> [UID]

-- | Generic traversal of everything that could come from an interval to
--   names without functions (similar to <a>eNames'</a>).
eNamesRI' :: RealInterval CodeExpr CodeExpr -> [UID]

-- | eprec - <a>Expression</a> precedence.
eprec :: CodeExpr -> Int

-- | precA - precedence for arithmetic-related Binary-Associative
--   (Commutative) operators.
precA :: AssocArithOper -> Int

-- | precB - precedence for boolean-related Binary-Associative
--   (Commutative) operators.
precB :: AssocBoolOper -> Int

-- | Render an algebraic expression into our code expression language.
expr :: Expr -> CodeExpr

-- | Convert <tt>RealInterval</tt> <tt>Expr</tt> <tt>Expr</tt>s into
--   <tt>RealInterval</tt> <a>CodeExpr</a> <a>CodeExpr</a>s.
realInterval :: RealInterval Expr Expr -> RealInterval CodeExpr CodeExpr

-- | Convert constrained expressions (<tt>ConstraintE</tt>) into
--   <tt>Constraint''CodeExpr</tt>s.
constraint :: ConstraintE -> Constraint CodeExpr


-- | Re-export CodeExpr constructors.
module Language.Drasil.CodeExpr

-- | Expression language where all terms also denote a term in GOOL (i.e.
--   translation is total and meaning preserving).
data CodeExpr
class CodeExprC r

-- | Constructs a CodeExpr for actor creation (constructor call)
new :: (CodeExprC r, Callable f, HasUID f, CodeIdea f) => f -> [r] -> r

-- | Constructs a CodeExpr for actor creation (constructor call) that uses
--   named arguments
newWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr for actor messaging (method call)
message :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c) => c -> f -> [r] -> r

-- | Constructs a CodeExpr for actor messaging (method call) that uses
--   named arguments
msgWithNamedArgs :: (CodeExprC r, Callable f, HasUID f, CodeIdea f, HasUID c, HasSpace c, CodeIdea c, HasUID a, IsArgumentName a) => c -> f -> [r] -> [(a, r)] -> r

-- | Constructs a CodeExpr representing the field of an actor
field :: CodeExprC r => CodeVarChunk -> CodeVarChunk -> r
class ExprC r
lit :: ExprC r => Literal -> r
($=) :: ExprC r => r -> r -> r
($!=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($<=) :: ExprC r => r -> r -> r

-- | Smart constructor for ordering two equations.
($>=) :: ExprC r => r -> r -> r

-- | Smart constructor for the dot product of two equations.
($.) :: ExprC r => r -> r -> r

-- | Add two expressions (Integers).
addI :: ExprC r => r -> r -> r

-- | Add two expressions (Real numbers).
addRe :: ExprC r => r -> r -> r

-- | Multiply two expressions (Integers).
mulI :: ExprC r => r -> r -> r

-- | Multiply two expressions (Real numbers).
mulRe :: ExprC r => r -> r -> r
($-) :: ExprC r => r -> r -> r
($/) :: ExprC r => r -> r -> r
($^) :: ExprC r => r -> r -> r
($=>) :: ExprC r => r -> r -> r
($<=>) :: ExprC r => r -> r -> r
($&&) :: ExprC r => r -> r -> r
($||) :: ExprC r => r -> r -> r

-- | Smart constructor for taking the absolute value of an expression.
abs_ :: ExprC r => r -> r

-- | Smart constructor for negating an expression.
neg :: ExprC r => r -> r

-- | Smart constructor to take the log of an expression.
log :: ExprC r => r -> r

-- | Smart constructor to take the ln of an expression.
ln :: ExprC r => r -> r

-- | Smart constructor to take the square root of an expression.
sqrt :: ExprC r => r -> r

-- | Smart constructor to apply sin to an expression.
sin :: ExprC r => r -> r

-- | Smart constructor to apply cos to an expression.
cos :: ExprC r => r -> r

-- | Smart constructor to apply tan to an expression.
tan :: ExprC r => r -> r

-- | Smart constructor to apply sec to an expression.
sec :: ExprC r => r -> r

-- | Smart constructor to apply csc to an expression.
csc :: ExprC r => r -> r

-- | Smart constructor to apply cot to an expression.
cot :: ExprC r => r -> r

-- | Smart constructor to apply arcsin to an expression.
arcsin :: ExprC r => r -> r

-- | Smart constructor to apply arccos to an expression.
arccos :: ExprC r => r -> r

-- | Smart constructor to apply arctan to an expression.
arctan :: ExprC r => r -> r

-- | Smart constructor for the exponential (base e) function.
exp :: ExprC r => r -> r

-- | Smart constructor for calculating the dimension of a vector.
dim :: ExprC r => r -> r

-- | Smart constructor for calculating the normal form of a vector.
norm :: ExprC r => r -> r

-- | Smart constructor for negating vectors.
negVec :: ExprC r => r -> r

-- | Smart constructor for applying logical negation to an expression.
not_ :: ExprC r => r -> r

-- | Smart constructor for indexing.
idx :: ExprC r => r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defint :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defsum :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for the summation, product, and integral functions
--   over an interval.
defprod :: ExprC r => Symbol -> r -> r -> r -> r

-- | Smart constructor for 'real interval' membership.
realInterval :: (ExprC r, HasUID c) => c -> RealInterval r r -> r

-- | Euclidean function : takes a vector and returns the sqrt of the
--   sum-of-squares.
euclidean :: ExprC r => [r] -> r

-- | Smart constructor to cross product two expressions.
cross :: ExprC r => r -> r -> r

-- | Smart constructor for case statements with a complete set of cases.
completeCase :: ExprC r => [(r, r)] -> r

-- | Smart constructor for case statements with an incomplete set of cases.
incompleteCase :: ExprC r => [(r, r)] -> r

-- | Create a matrix. TODO: Re-work later.
matrix :: ExprC r => [[r]] -> r

-- | Create a two-by-two matrix from four given values. For example:
--   
--   <pre>
--   &gt;&gt;&gt; m2x2 1 2 3 4
--   [ [1,2],
--     [3,4] ]
--   </pre>
m2x2 :: ExprC r => r -> r -> r -> r -> r

-- | Create a 2D vector (a matrix with two rows, one column). First
--   argument is placed above the second.
vec2D :: ExprC r => r -> r -> r

-- | Creates a diagonal two-by-two matrix. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dgnl2x2 1 2
--   [ [1, 0],
--     [0, 2] ]
--   </pre>
dgnl2x2 :: ExprC r => r -> r -> r

-- | Applies a given function with a list of parameters.
apply :: (ExprC r, HasUID f, HasSymbol f) => f -> [r] -> r

-- | Similar to <a>apply</a>, but takes a relation to apply to
--   <a>FCall</a>.
applyWithNamedArgs :: (ExprC r, HasUID f, HasSymbol f, HasUID a, IsArgumentName a) => f -> [r] -> [(a, r)] -> r

-- | Create an <a>Expr</a> from a <a>Symbol</a>ic Chunk.
sy :: (ExprC r, HasUID c, HasSymbol c) => c -> r
infixr 4 $=
infixl 7 $/
infixr 8 $^
infixr 9 $&&
infixr 9 $||
class LiteralC r
int :: LiteralC r => Integer -> r
str :: LiteralC r => String -> r
dbl :: LiteralC r => Double -> r
exactDbl :: LiteralC r => Integer -> r
perc :: LiteralC r => Integer -> Integer -> r

-- | Render an algebraic expression into our code expression language.
expr :: Expr -> CodeExpr
